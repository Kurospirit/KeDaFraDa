F Sharp

F♯ est un langage de programmation fonctionnel, impératif et orienté objet pour la plate-forme .NET. F♯ est développé par Microsoft Research dont le noyau est dérivé du langage OCaml (avec lequel il est fortement compatible). Ces deux langages de programmation font partie de la famille des langages ML.
C'est un langage qui a été conçu spécifiquement pour la plate-forme .NET et est donc fortement orienté-objet. Depuis novembre 2010, Microsoft a mis à la disposition de tous les bibliothèques core et son compilateur F♯, sous la licence Apache 2.
Présentation.
F♯ est un langage fortement typé utilisant l'inférence de types. Ce mécanisme délègue le typage des variables et des fonctions au compilateur. Néanmoins, le langage permet au développeur d'indiquer explicitement le type à la déclaration. Intégré à l'écosystème .NET, F♯ supporte les types primitifs de la plate-forme ainsi que ses objets. De plus il étend le système de type et permet de faire la distinction entre les types dits immuables et ceux dits modifiables. Les objets sont considérés comme des types modifiables (en place), et sont utilisés pour la mise en place du modèle de programmation objet au sein du langage. Les types immuables sont utilisés principalement lorsque l'on programme de manière fonctionnelle ; la modification d'un type immuable crée une nouvelle instance sans pour autant écraser l'ancienne.
Comme tous les langages dérivé de ML, F♯ utilise par défaut le mécanisme de l'évaluation stricte. Cependant il peut, à l'instar de Haskell, mettre en œuvre l'évaluation paresseuse des expressions grâce à l'utilisation du mot-clé codice_1. Pour la programmation fonctionnelle, il fournit plusieurs constructions et un ensemble de types immuables : les n-uplets, des enregistrements, des types sommes et des listes.
Un n-uplet représente une collection de n valeurs, n ≥ 0. La valeur correspond à l'arité du n-uplet. Le type unit représente le n-uplet vide et dont l'unique valeur possible est (). Ce type est utilisé pour typer des fonctions qui ne prennent pas en entrée de valeur et/ou n'en renvoient pas. Le 3-uplet (ou triplet) est représenté par codice_2, où A, B, et C peuvent être de n'importe quel type. Un n-uplet peut être utilisé pour stocker des valeurs uniquement lorsque le nombre de valeurs est connu au moment du codage et reste constant tout au long de l'exécution.
Un enregistrement est une version spécialisée des n-uplets où les champs sont nommés, comme dans . Les enregistrements peuvent être créés de la façon suivante : codice_3. Le mot-clé codice_4 est utilisé pour créer une copie de l'enregistrement : codice_5 crée un nouvel enregistrement à partir d'un précédent enregistrement nommé r et dont il change la valeur du champ Nom.
Le type liste est une liste chainée qui peut se représenter soit à l'aide de la notation codice_6 (composé à l'aide de l'opérateur codice_7, l'équivalent de l'opérateur cons des langages Lisp/Scheme), soit dans une notation abrégée : codice_8. Une liste vide est notée codice_9.
La dernière sorte de type algébrique de données, les types sommes (qui sont, fonctionnellement, des équivalents typés des unions du langage C) peuvent être définis comme une somme de n'importe lequel des types immuables évoqués précédemment. Par exemple,
peut contenir des valeurs instanciées soit par codice_10 soit par codice_11. Le type des valeurs retournées par les constructeurs peut lui aussi être défini.
Exemples.
Voici le traditionnel hello world :
Cet autre exemple traditionnel chez les langages fonctionnels a pour objectif de montrer la concision que l'on peut obtenir avec ce type de langages :
Cette variante, avec un accumulateur, met en œuvre la récursion terminale, une optimisation commune parmi les langages fonctionnels :