Forth (langage)

Forth est un langage de programmation , inventé par Charles H. Moore dans les années 1960.
Historique.
En 1958, un jeune informaticien nommé Charles Moore, chargé de calculer des trajectoires de satellites, entreprend, pour faciliter son travail quotidien, la construction d'une boîte à outils sous la forme d'un interpréteur de commandes. D'année en année, cet interpréteur est amélioré et rendu indépendant de la machine hôte. En 1968, il prend le nom de Forth, et en 1970, il est suffisamment mûr pour faire l'objet d'une première publication comme « Langage pour calcul interactif ».
1971 voit la première application d'envergure : Moore utilise Forth pour développer le logiciel de pilotage du radio-télescope de Kitt Peak (Arizona) sur deux mini-ordinateurs 16-bits. Il y est bientôt rejoint par Elizabeth Rather, qui devient le deuxième programmeur Forth. Par ses performances et sa souplesse d'emploi, l'application intéresse rapidement d'autres observatoires, et en 1976, Forth est adopté comme standard par l'Union internationale d'astronomie.
Après une première modernisation du logiciel de Kitt Peak en 1973, Moore et Rather fondent Forth,Inc., pour promouvoir le langage et ses applications. En 1976, une première version exécutable sur microprocesseurs 8-bits est disponible sous le nom de MicroFORTH.
En 1978 est créée une association, le "Forth Interest Group" (FIG), pour promouvoir une version « domaine public » du langage sur un maximum de processeurs, et publier la revue "Forth Dimensions". Le FIG-FORTH, légèrement différent du MicroFORTH, contribuera grandement à la diffusion du langage.
Le besoin de standardisation d'un langage que chacun peut modifier à sa guise devient manifeste. Une première tentative (FORTH77) aboutit au premier standard largement diffusé, FORTH79. Ce standard évolue quatre ans plus tard en FORTH83, mais des incompatibilités entre les deux versions engendrent des problèmes de portabilité, et sont à l'origine d'un clivage dans la communauté des programmeurs FORTH.
Dénomination.
Son nom est une contraction de l'anglais "fourth", qui signifie « quatrième » : c'était à l'origine un langage pour les machines de quatrième génération machines dotées de lecteurs de disquettes ; mais, à l'époque, la machine IBM utilisée ne permettait que des noms de cinq lettres (ce qui suggère qu'il s'agissait d'un IBM 1130). Forth utilisait des concepts novateurs pour l'époque : multiprogrammation et cache-disque notamment.
Principes.
Forth repose sur l'utilisation explicite de piles, alors que les autres langages utilisent des piles invisibles au programmeur.
Pile de données.
Une des importantes caractéristiques du langage est l'utilisation d'une pile de données pour passer des arguments entre les mots, qui sont les constituants d'un programme Forth. 
Un simple exemple : l'expression codice_1 sera traduite par la suite codice_2, dans la notation polonaise inversée.
Cette suite de mots agit sur la pile de données, son effet est
À partir des mots prédéfinis du langage, comme +, *, DUP (qui duplique l'élément en sommet de pile), SWAP (qui échange les
deux éléments du sommets), etc. le programmeur construit le vocabulaire de son application en définissant ses propres mots, qu'il réutilise ensuite :
Une conséquence importante de l'utilisation d'une pile est la quasi-suppression des noms de variables locales, qui deviennent inutiles.
Pile de retour.
Comme dans la quasi-totalité des langages, Forth utilise une pile pour stocker les adresses de retour des sous-programmes en cours d'exécution. L'originalité ici est de mettre cette pile à la disposition du programmeur, principalement pour un stockage temporaire de données, au moyen de deux opérateurs permettant les transferts pile de données - pile de retour.
Sous-programmes.
Un mot Forth est l'équivalent des sous-programmes, fonctions ou procédures dans les autres langages. Cependant, Moore décrit les mots plus comme des abréviations que comme des fonctions à la C. Le mot d'ordre en Forth est la factorisation, c'est-à-dire le découpage de l'application en petits mots dont la définition tient sur une ligne ou deux.
Les « mots » de Forth sont « compilés », c'est-à-dire convertis en une forme exécutable et ajoutés au dictionnaire des mots. La forme exécutable diffère suivant le compilateur/interpréteur utilisé : génération directe de code machine ou "bytecode" par exemple (il existe de nombreuses variantes intermédiaires).
Autres caractéristiques.
Il n'y a pas d'instruction GOTO. La syntaxe particulière de l'instruction IF...ELSE...THEN permet de résoudre de façon élégante le problème des "n+1/2 itérations" qui, en programmation structurée, aboutit à l'introduction d'une variable booléenne supplémentaire si l'on veut absolument éviter le GOTO.
Il n'y a pas d'opérateur d'affectation "=". Les variables ne sont pas des données, mais des pointeurs vers des zones de mémoire allouées explicitement par le programmeur, qui contiennent les données. Le transfert des données se fait par les deux opérateurs @ (fetch) et ! (store), qui correspondent aux instructions LDA (Load Accumulator) et STA (Store Accumulator) d'un assembleur, la pile jouant ici le rôle de l'accumulateur.
L'invocation de toto pousse l'adresse de la variable toto sur la pile. @ remplace cette adresse par la valeur contenue dans toto, à savoir 3.
A son tour, l'invocation de titi pousse l'adresse de titi sur la pile, qui contient à ce moment les deux valeurs 3 et adr(titi). Enfin, ! écrit 3 en mémoire à l'adresse titi, et laisse la pile vide.
Mise en œuvre.
Le mélange interprétation/compilation, associé à des techniques de compilation efficaces et à la possibilité offerte par nombre de systèmes de définir aussi de nouvelles primitives en assembleur, fait de Forth l'un des langages interprétés les plus rapides et les plus compacts.
Très proche du matériel, le Forth est un langage que l'on peut qualifier de « bas niveau », mais qui dispose de ressources qui lui permettent de se rapprocher du « haut niveau ». Le langage est en effet basé sur un petit nombre de primitives suffisamment élémentaires pour être implémentées directement « dans le silicium » (c'est-à-dire être les instructions d'un processeur matériel ; les primitives de Forth sont donc bel et bien un « langage assembleur » pour ces processeurs. Il existe quelques exemples de processeurs Forth).
Dans le même temps, le langage permet de définir des mots qui ont une action sur la compilation ; on peut ainsi définir de nouvelles structures de contrôle (par exemple la structure switch/case peut s'écrire à partir de la structure if/then/else). Cette caractéristique fait de Forth un langage extensible.
C'est ainsi qu'à partir de quelques primitives écrites en langage machine, on peut construire un interpréteur en ligne de commande, un assembleur, un compilateur, un éditeur de source. La compacité est extrême : sur une machine 8 bits, 7 kilooctets suffisent pour avoir un interpréteur en ligne de commande, dont 700 octets seulement de code machine, le reste étant constitué de tables de pointeurs. En ajoutant environ 5 ko, on dispose de l'éditeur, d'un assembleur, et d'un système rudimentaire de stockage sur disquettes, le tout fonctionnant sans système d'exploitation avec quelques kilooctets de mémoire vive, et tenant sur une simple disquette (source intégrale incluse) ; autrement dit un micro-environnement de développement capable de s'autocompiler à partir de son propre source depuis une plateforme disposant de ressources modestes comme les applications embarquées.
Un des aspects de Forth est de tenter de trouver un juste milieu entre la langue naturelle du programmeur et la « langue » artificielle du processeur, contrairement aux autres langages qui prennent nettement le parti du programmeur au détriment du processeur. Ce compromis donne au langage son aspect exotique et déroutant de prime abord, et requiert sans conteste une certaine capacité d'adaptation de la part du programmeur.
Le langage Forth a fait l'objet d'une normalisation officielle, l'ANS-FORTH, fondée sur les standards officieux précédents Forth-79 et Forth-84. La plupart des Forth commerciaux suivent cette norme. De par l'extrême facilité d'implémentation d'un interpréteur pour ce langage, il existe un nombre incalculable de systèmes Forth de domaine public, qui sont soit alignés sur le standard ANS-Forth (comme gforth de GNU), soit sont des dialectes plus ou moins éloignés de Forth (notamment ColorForth de Charles Moore), et ce pour à peu près toutes les plateformes, du Intel 8051 à Windows, en passant évidemment par Linux.
Utilisations.
Forth a été utilisé principalement dans des systèmes embarqués et des contrôleurs, en raison de leur caractère compact et de la facilité d'utiliser des mots définis en assembleur dans des programmes de plus haut niveau. Parmi les applications les plus prestigieuses, on relèvera sa présence sur quelques missions de la NASA.
Les ROM Open Firmware des produits d'Apple et de Sun, ainsi qu'une partie du boot de FreeBSD, étaient jusqu'à récemment écrites en Forth, permettant la portabilité du code de bas niveau entre les processeurs.
L'augmentation de performance des micro-contrôleurs permettant désormais la programmation des applications de ce type en langage C, désormais érigé en assembleur universel, l'utilisation de Forth régresse sur son terrain de prédilection. Plus généralement, la tendance étant à ce que le programmeur devienne une ressource interchangeable (ce qui permet déjà l'externalisation de certains développements) au détriment de l'expérience et de la compétence, l'utilisation de Forth ne peut que décliner.
Bien que la mort de Forth ait été annoncée maintes et maintes fois, et que d'aucuns le qualifieraient de moribond, de nouveaux programmeurs de divers horizons curieux et attirés par ses performances et ses conceptions remarquables s'y intéressent régulièrement et s'en inspirent ; la survie de quelques sociétés prestataires de services qui basent leur offre sur Forth et réalisent des développements pour des projets de pointe (gestion de trafic aérien par exemple), laissent à penser que Forth n'est pas une langue morte.
Voir aussi.
Bibliographie.
Historiquement, une des premières bibles Forth (techniquement Fig-forth) fut le livre de Kevin McCabe publié en 1983, traduit en français et publié en France en 1985.
Léo Brodie a écrit deux ouvrages considérés unanimement comme des références par la communauté Forth, qui les a mis en ligne. Le premier est un cours sur le langage, le second un précis de programmation et de style, traitant de sujets tels que l'architecture d'un programme, les différentes étapes du processus de programmation, la programmation ascendante et descendante, la factorisation, le choix des noms, etc.
Un ouvrage décrivant le fonctionnement interne et l'implémentation en liste chaînée sur processeur Z80 d'un langage très voisin de Forth :