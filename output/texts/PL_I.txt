PL/I

Le PL/I ou PL/1 (Programming Language number 1) est un langage de programmation développé par IBM dans les débuts des années 1970. 
Son objectif était d'être universel et de pouvoir remplacer indifféremment les langages à destination scientifique, tels que FORTRAN et ALGOL, et le langage COBOL, plus adapté aux problèmes de comptabilité et de gestion. Il permettait même l'accès à des fonctions autrefois réservées à la programmation système, comme la gestion de zones dynamiques de mémoire allouées à la demande (et non simplement à l'entrée dans un bloc), de pointeurs, et le travail par programme directement dans les tampons d'entrée-sortie. Ses capacités de points d'entrée génériques dans les procédures offraient une possibilité qui se retrouvera avec C++.
Ce langage est défini par les normes ECMA-50 (1976), ANSI X3.53-1976, AFNOR NF Z 65-500 et ISO 6160:1979. Il fut utilisé comme langage de programmation système dans le projet Multics. 
Son objectif était de devenir le langage privilégié de programmation des ordinateurs universels IBM 360 et 370. Les noms de PL/1 à PL/100 furent déposés par IBM par précaution, mais cela empêcha ce langage d'être proposé sous ce nom par d'autres constructeurs, nuisant ainsi à son succès.
Sa syntaxe ajoutait aux idées de FORTRAN certaines idées de COBOL (structures, calcul en mode décimal), et d'ALGOL (structure de blocs imbriqués). Toutefois, les programmeurs de ces deux langages ne communiquaient guère entre eux à l'époque, et chacun jugeait inutile et encombrant ce qui avait été inclus pour l'autre — et vice versa. Son compilateur nécessitait également des machines importantes, et ne comportait au départ ni optimiseur, ni compilateur incrémental (le "PL/I Optimizing compiler" et le "PL/I Checkout compiler" ne viendront que plus tard).
Ce langage avait beaucoup des caractéristiques de ce qui sera plus tard le C, et même déjà certaines du C++. IBM déposa les noms PL/1 à PL/100 pour éviter de perdre le contrôle des spécifications du langage. Un effet non prévu de cette décision fut de dissuader la concurrence de nommer « PL/I » ses propres implémentations, qui prirent des noms voisins : « SL/1 », « CPL/1 », « PL/M », « PL/C »... Devant la multitude de ces appellations, la crainte d'une balkanisation du langage (et des frais de migration associés en cas de changement de constructeur) dissuada les équipes informatiques d'y migrer. Le lancement du langage, malgré ses qualités (gestion simple du "multitasking", récursivité, structures de blocs, facilités de "debugging" et de profilage, allocation dynamique dans des pools de mémoire eux-mêmes dynamiques (AREA), procédures génériques analogues aux "templates" de C++) ne rencontra donc pas le vif succès attendu. Ses puissantes possibilité de débogage, en particulier "(CHECK):" et "ON CHECK(...) ... furent néanmoins remarquées.
Défauts.
La recherche d'universalité du langage, en lui donnant une apparence complexe, a joué contre lui. Les programmeurs Fortran n'avaient guère l'usage des "structures" ni du format décimal inspirés du COBOL et ceux de Cobol ne voyaient pas l'intérêt de calculer en nombres complexes.
Les instructions FORMAT et le GOTO calculé du Fortran combinées aux curiosités du Cobol avec ses PICTURE et son tri de fichier intégré ont fait du PL/I un langage certes complet mais plus complexe à apprendre
Et maintenant ?
Il est comme langage RAD, . 
Cela permet de se faire des outils très rapides, et aussi simplement qu'en REXX. 
Mais pour utiliser ce type de langage, il est nécessaire que les développeurs aient une bonne discipline en programmation, alors que pour le Cobol, par exemple, le compilateur « tente » d'éviter ces problématiques qui nécessitent autant de discipline (déclaratives, "closures", ..).
Conclusion.
PL/I permettait de confiner à des zones prédéfinies et allouées à la demande ("AREA") la manipulation des pointeurs et des adresses, faisant ainsi bénéficier le programmeur de la protection mémoire matérielle du système. Il disposait de puissantes possibilités intégrées de débogage. Ces possibilités natives du langage sont assurées dans d'autres aujourd'hui par des bibliothèques (Electric Fence...), ou des frameworks (Valgrind...). Ses autres innovations se retrouvent aujourd'hui, parfois dans le corps des langages et compilateurs (appels génériques de procédure, conversions automatiques de type, profilage, structures chaînées), plus souvent dans des bibliothèques optionnelles.