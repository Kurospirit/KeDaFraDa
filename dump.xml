<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.8/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.8/ http://www.mediawiki.org/xml/export-0.8.xsd" version="0.8" xml:lang="fr">
  <siteinfo>
    <sitename>Wikipédia</sitename>
    <base>http://fr.wikipedia.org/wiki/Wikip%C3%A9dia:Accueil_principal</base>
    <generator>MediaWiki 1.23wmf16</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Média</namespace>
      <namespace key="-1" case="first-letter">Spécial</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Discussion</namespace>
      <namespace key="2" case="first-letter">Utilisateur</namespace>
      <namespace key="3" case="first-letter">Discussion utilisateur</namespace>
      <namespace key="4" case="first-letter">Wikipédia</namespace>
      <namespace key="5" case="first-letter">Discussion Wikipédia</namespace>
      <namespace key="6" case="first-letter">Fichier</namespace>
      <namespace key="7" case="first-letter">Discussion fichier</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">Discussion MediaWiki</namespace>
      <namespace key="10" case="first-letter">Modèle</namespace>
      <namespace key="11" case="first-letter">Discussion modèle</namespace>
      <namespace key="12" case="first-letter">Aide</namespace>
      <namespace key="13" case="first-letter">Discussion aide</namespace>
      <namespace key="14" case="first-letter">Catégorie</namespace>
      <namespace key="15" case="first-letter">Discussion catégorie</namespace>
      <namespace key="100" case="first-letter">Portail</namespace>
      <namespace key="101" case="first-letter">Discussion Portail</namespace>
      <namespace key="102" case="first-letter">Projet</namespace>
      <namespace key="103" case="first-letter">Discussion Projet</namespace>
      <namespace key="104" case="first-letter">Référence</namespace>
      <namespace key="105" case="first-letter">Discussion Référence</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Discussion module</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>M4 (langage)</title>
    <ns>0</ns>
    <id>122944</id>
    <revision>
      <id>93508131</id>
      <parentid>89804714</parentid>
      <timestamp>2013-05-27T13:02:41Z</timestamp>
      <contributor>
        <username>Yvand</username>
        <id>928947</id>
      </contributor>
      <minor/>
      <comment>Ajout lien sur autoconf</comment>
      <text xml:space="preserve" bytes="1702">{{voir homonymes|M4}}
'''M4''' est un [[Langage de programmation|langage]] de traitement de [[macro]]s.

Un processeur de macros est un outil de remplacement de texte. Sa principale utilisation est de réutiliser des canevas de texte, typiquement dans les applications de programmation mais aussi dans les éditeurs de texte. Parmi les usages les plus courants, l’[[GNU M4|implémentation GNU de M4]] est utilisée dans [[GNU]] [[Autoconf|autoconf]], ou encore dans [[Sendmail]] pour générer le fichier de configuration &lt;tt&gt;sendmail.cf&lt;/tt&gt;.

À l’époque où l’[[Langage_Assembleur|assembleur]] était une étape importante du développement logiciel, les programmeurs remarquèrent que la plupart de leurs programmes était de la répétition de texte. Des moyens simples de réutiliser ces textes furent donc inventés. Ils découvrirent rapidement que cela permettait non seulement de réutiliser des pans entiers de texte, mais aussi de substituer des valeurs différentes en fonction de paramètres. Cela définit la portée des processeurs de macro.

M4 offre les possibilités suivantes :
* remplacement de texte ;
* substitution de paramètre ;
* inclusion de fichier ;
* manipulation de chaînes de caractères ;
* évaluation conditionnelle ;
* expressions arithmétiques ;
* interfaçage avec le système ;
* diagnostics pour le programmeur.

À la différence des processeurs de macros précédents, M4 n’a pas été ciblé pour un langage informatique ou humain particulier. Historiquement, il a toutefois été développé pour supporter le dialecte ratfor du [[Fortran]].

== Articles connexes ==
* [[GNU M4]]

{{Portail|Informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>qolwj369ksrtfxjl6xjhafg6kun9zvt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Advanced Boolean Expression Language</title>
    <ns>0</ns>
    <id>140890</id>
    <revision>
      <id>89847313</id>
      <parentid>79624547</parentid>
      <timestamp>2013-03-12T19:02:03Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 7 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q379390]]</comment>
      <text xml:space="preserve" bytes="471">{{ébauche|informatique|électronique}}
'''ABEL''', [[acronyme]] de '''Advanced Boolean Expression Language''', est un langage de programmation informatique utilisé dans le domaine de l'[[électronique]], pour notamment la programmation des [[Circuit logique programmable|PLD]]. Il a été créé en [[1983]] par Data I/O Corporation, à Redmond, Washington.

{{Portail|programmation informatique|électricité et électronique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>bo9edisfkl6ddyz4lwazpkkjs0gt030</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Logo (langage)</title>
    <ns>0</ns>
    <id>1736</id>
    <revision>
      <id>101747171</id>
      <parentid>101586699</parentid>
      <timestamp>2014-03-03T11:05:16Z</timestamp>
      <contributor>
        <username>ScoopBot</username>
        <id>1749652</id>
      </contributor>
      <minor/>
      <comment>Mise en forme / Correction(s) non-cosmétique(s)</comment>
      <text xml:space="preserve" bytes="95107">{{Infobox Langage de programmation
| nom                    = Logo
| logo                   = Remi turtlegrafik.png
| paradigme              = [[Programmation procédurale]], [[Réflexion (informatique)|Réflexion]], [[Programmation orientée objet]]
| année                  = 1967
| auteur                 = [[Wally Feurzeig]], [[Seymour Papert]]
| développeurs           = Wally Feurzeig, Seymour Papert
| typage                 = [[Typage statique|Statique]]
| implémentations        = [[UCBLogo]], autres...
| dialectes              = [[Starlogo]]
| influencé par          = [[Lisp (langage)|Lisp]]
| a influencé            = [[Smalltalk]], [[Etoys (langage)|Etoys]], [[Scratch (langage)|Scratch]], [[NetLogo]], [[KTurtle]], [[REBOL]]
| système d'exploitation = [[Windows]], [[Linux]], [[Mac OS]]
|licence                 = 
| site web               = 
}}
{{Voir homonymes|Logo (homonymie)}}

'''Logo''' est à la fois une philosophie de l’éducation et une famille de langages de programmation en constante évolution qui aident à la mettre en pratique&lt;ref&gt;Harold Abelson, ''Apple Logo'', 1982&lt;/ref&gt;.

Le projet est né à la fin des années soixante de la rencontre entre le courant [[Intelligence artificielle#Cognitivisme|cognitiviste en intelligence artificielle]] et des théories sur l’apprentissage issues de travaux de [[Jean Piaget]] et de ses conceptions en matière d’éducation. Ces deux volets sont respectivement représentés par ses promoteurs, [[Marvin Minsky]] et [[Seymour Papert]] — qui sera le moteur du projet —, au sein du Computer Science and Artificial Intelligence Laboratory (Laboratoire d'intelligence artificielle et d'informatique) du [[MIT]].

L‘appellation, inspirée du grec [[Logos]] « parole, discours, intelligence », recouvre, donc, deux concepts étroitement liés quoique distincts : un mode d’apprentissage inspiré des travaux de [[Jean Piaget]] sur le développement cognitif de l’enfant et un type d’environnement informatique, à partir d'un langage adapté du LISP spécialement conçu dans une démarche de [[pédagogie active]] inspirée des travaux de celui-ci. Il s'inscrit en réaction à une introduction de l'ordinateur dans l'éducation inspirée de l'[[Pédagogie#Enseignement programmé (Skinner, 1958)|enseignement programmé]].

Sur le plan informatique, '''Logo''' est un langage de [[programmation orientée objet]] [[Réflexion (informatique)|réflexif]]. Plus lisible que le [[Lisp]], il en est une adaptation, ce qui lui a valu le surnom de « Lisp sans parenthèses ». Essentiellement connu pour la fameuse tortue graphique, mais est également capable de manipuler des listes, des fichiers et des entrées/sorties, … ce qui en fait un langage adapté à l'approche des concepts de l'[[algorithmique]], ce dont on pourra trouver un exemple dans les ouvrages ''Computer Science Logo Style'' de Brian Harvey, professeur à l'[[Université de Berkeley]].
 
Bien que langage complet de haut niveau, Logo a été paradoxalement victime de sa tortue - pourtant présente en [[Pascal (langage)|Pascal]] - qui l'a cantonnée à une image faussement puérile, ses fonctionnalités de base étaient supérieures aux divers [[BASIC]] des [[années 1980]]. Il était, à l'époque, un bon marchepied vers la [[programmation structurée]] et [[programmation modulaire|modulaire]] et connaît toujours des développements dans le cadre de recherches en  [[intelligence artificielle]].
[[Fichier:Logo Example Ex3.jpg|thumb|Exemple d'écran de MSWLogo]]

== Philosophie du projet ==

Logo propose une approche de l’utilisation de l’informatique délibérément [[Constructivisme (psychologie)|constructiviste]]. C’est l’apprenant, enfant ou adulte expérimenté, qui est le principal acteur de son apprentissage, et l’ordinateur n’est présent que pour lui permettre de construire des réalités dans des environnements divers : les [[Micromonde]]s, à l’aide d’un langage informatique spécialement conçu à cet effet (la géométrie Tortue en est un exemple).

Il n’est nullement question ici de [[simulation informatique]]. « C’est en créant qu’on apprend », telle est la thèse piagétienne que Papert défendra dans la poursuite du projet Logo.
 
L’objectif va, en effet, au-delà de l’acquisition de concepts qui seraient présents à ces micromondes.
 
Piaget distingue quatre stades dans le développement individuel dont les apprentissages sont acquis par l’interaction entre l’enfant et son environnement. Il note, toutefois, que, faute de trouver un environnement adéquat – qui n’existe pas -, celui-ci n’atteint pas toujours le dernier stade, celui des opérations formelles. Il émet d’ailleurs cette constatation que nombre d’adultes n'y sont, en réalité, jamais arrivés.
 
{{Article connexe|Jean Piaget#Les différents stades de l'évolution individuelle{{!}}Jean Piaget}}

Et c’est ici que l’ordinateur entre en jeu. Papert y voit l’opportunité de créer des environnements propices au développement de ces facultés logiques, à condition qu’il soit correctement adapté à cette fin. Ce sera le cas grâce au langage informatique Logo proprement dit.

L’environnement Logo se veut, donc, imprégné de la pensée de Piaget : il offre à l’apprenant - quel que soit son niveau ou son âge - la possibilité de se représenter et de décrire les phénomènes ainsi que le déroulement de sa démarche entreprise : saisie des moyens utilisés, justification de leur choix et/ou ajustements en cours de tâche. L’objectif poursuivi est d’amener, in fine, l’apprenant à dégager lui-même les caractéristiques de ses actions et de ses propres processus cognitifs. En un mot, qu’il apprenne comment il apprend.

Dans son ouvrage&lt;ref&gt;''Mindstorms: Children, Computers, and Powerful Ideas'', 1980 {{ISBN|978-0-465-04674-4}} Traduction française : &quot;''Jaillissement de l'esprit. Ordinateurs et apprentissage''&quot;, Flammarion, 1981, réédité en 1999 {{ISBN|978-2-08-081210-0}}&lt;/ref&gt;, Papert va même plus loin : l’environnement de Logo pourrait amener l’enfant à adopter de lui-même un mode de pensée procédural, mode de pensée qu’il décrit comment étant plus efficace que tout autre.

Encore faut-il une porte d’entrée qui soit à la portée de cet enfant. Ce sera le rôle de la tortue graphique, un robot dont l’enfant pourra commander les déplacements en s’appuyant sur la connaissance de la manière dont lui-même se déplace. Paradoxalement, le langage été victime de cette tortue qui l'a cantonnée à une image puérile ainsi également d'un succès commercial qui a fait se multiplier des versions incomplètes, non conformes aux exigences [[programmation fonctionnelle|fonctionnelles]] sur lesquelles insiste pourtant son propre concepteur, et parfois limitées à cette tortue graphique. Or, celle-ci n'est pas l'apanage de Logo : elle existe également dans Pascal 7.0.
 
Dans le développement du projet, l’intelligence artificielle contribuera à différents titres comme celui d’offrir un milieu propice à la recherche fondamentale, avec le [[Lisp]] un substrat au développement du langage informatique proprement dit, un premier robot d’expérimentation : la tortue de sol, le développement de la géométrie tortue, … sans oublier l’infrastructure informatique, une ressource rare et chère à l’époque. Il inspire également la notion d'[[émergence]] pour comprendre ce que peut pourrait entraîner l'usage de Logo dans d'apprentissage.

== Histoire ==

Un projet tel que celui porté par Logo relève d’un long processus au cours duquel, tant sous l’influence de l’évolution de la pensée de ses concepteurs – Papert en premier – que des rapides progrès dans le domaine du matériel informatique. Bien que projet et langage informatique vont évaluer de pair, il y a néanmoins parfois lieu d’effectuer une distinction dans l’évocation de leur histoire respective.

=== La période d’incubation : (1966 à 1980) : une tortue à petits pas ===

En tant que langage informatique proprement dit, Logo a été créé chez Bolt Beranek et Newman (BBN). Le concept initial émergea d’intenses discussions en 1966 entre Seymour Papert, Dan Bobrow et {{lien|trad=Wally Feurzeig|fr=Wallace Feurzeig}}. Papert conçut les spécificités fonctionnelles essentielles du nouveau langage et Bobrow contribua à son concept et en réalisa sa première implémentation. Par la suite, contribuèrent également à son développement Richard Grant, Cynthia Solomon, Frank Frazier et Paul Wexelblat&lt;ref&gt;{{pdf}}{{lien web|url=http://logoplus.pagesperso-orange.fr/private/Origine%20du%20langage%20LOGO.pdf|titre=Origine du langage LOGO}}&lt;/ref&gt;.

Il succédait à une première tentative de créer un langage de programmation conçu pour les enfants, TELCOMP, basé sur le FORTRAN. À ce stade, le projet restait très orienté vers l’apprentissage des mathématiques et une familiarisation avec l’algorithmique, tout en insistant pour qu'il soit accessible aux jeunes élèves sans grande préparation. La première version de LOGO fut, d'ailleurs, une version pilote testée en 1967 avec des étudiants en mathématique de grades 5 et 6 à l’école Hanscom Field School de Lincoln, Massachusetts, sous la responsabilité de l’U.S. Office of Naval Research.

À l'issue des quatre années de recherche nécessaires aux chercheurs du BBN, il a reçu de nombreuses interfaces de simulation différentes, dont la tortue graphique, qui apparut cependant relativement tard par rapport à la première version du Logo.

Les premiers utilisateurs en milieu scolaire, eux, l'ont testée à Muzzy Jr High, Lexington, Massachusetts. La première version est sortie, sur un PDP-1, en Lisp. Il était alors appelé Ghost, et était destiné à la résolution de problèmes de base : les bugs pouvaient être mis en valeur immédiatement grâce à la tortue. Le langage n'était pas particulièrement puissant, et la conception avait plutôt été axée sur la simplicité d'utilisation pour des débutants en informatique (qui devaient alors utiliser un Teletype). La possibilité de fournir un commentaire détaillé des erreurs était également déterminante.

En 1970, Seymour Papert fonda le laboratoire LOGO au M.I.T.  L’année suivante vit apparaître les premières expérimentations avec les tortues LOGO (de sol ou d'écran), considérées à tort par beaucoup pour être essentielles au projet LOGO alors qu’elles n’en représentent qu’un sous-ensemble. Plusieurs implémentations sur différents matériels et des expériences pédagogiques suivirent au cours de la décade des années 1970 au M.I.T. mais aussi ailleurs comme à l’Université d’Edimbourgh&lt;ref&gt;[http://www.inf.ed.ac.uk/about/AIhistory.htm Jim Howe] l&lt;/ref&gt; ou à celle de Tasmanie, en Australie (c’est, d’ailleurs, par cette dernière que se diffusa la première tortue graphique sur Apple II sous le nom de Tasmania Logo).

Cette phase de réflexion et d'expérimentation est marquée par des recherches ponctuelles au sein d’écoles voisines (dont la Brookline Public Schools) et donnèrent lieu à des publications à diffusion restreinte (« ''papers'' »), les Logo Memos, relatant les enseignements tirés de ces expériences.

=== Apogée et désillusion  (1980 à 1990) : du lièvre à la tortue ===

LOGO va quitter le laboratoire et connaître sa période faste au début des années 1980. Deux facteurs vont contribuer à cet engouement :
* l’arrivée des micro-ordinateurs qui vont à la fois rendre les ressources informatiques plus accessibles et, en les individualisant, donner l’impression à ses utilisateurs de pouvoir s’approprier une informatique jusque là aux mains de spécialistes officiant dans des grandes salles interdites et climatisées. De par son approche de l’informatique, LOGO va pouvoir s’inscrire dans ce mouvement ; 
* la sortie de l’ouvrage de Papert en 1980 qui va séduire  dans un premier temps le monde de l’éducation en lui offrant une alternative à l’enseignement programmé en informatique distribuée qui inquiète les enseignants qui y voient à la fois une concurrence technologique et une perte de liberté dans le choix des méthodes pédagogiques.

L’horizon de la tortue s’élargit, en effet, avec l’apparition des micro-ordinateurs. Fin des années 1970, le MIT Logo Group s’attelle à développer des versions de Logo pour le Texas Instruments [[TI-99/4A]]&lt;ref name=&quot;Solomon&quot;&gt;vidéos sur le site de [http://logothings.wikispaces.com/ Cynthia Solomon]&lt;/ref&gt; et [[Apple II]], tous deux sortis en 1977. Si la base du langage est commune, les interfaces graphiques sont différentes eu égard aux spécificités des deux machines : du fait de son interface de type « jeux vidéo », la version pour le TI 99/4A privilégie les projets orientés vers le mouvement (les dyna-turtles ou lutins), tandis que celle pour l’Apple II donne la préférence au graphique tortue bien connu et à la manipulation de mots et de listes - bien moins connue.

En 1980 est lancé un projet pilote à la Lamplighter School de Dallas où 50 TI 99/4A sont mis à la disposition des 450 élèves. Dans la foulée est lancé un autre projet à New York avec 12 TI 99/4A auxquels s’ajouteront un peu plus tard quelques Apple II. De ces deux projets naîtront des produits commercialisés par la société Terrapin Softwares (qui commercialise également des tortues de sols depuis 1977) : le TILOGO sur le TI 99/4A et le Terrapin Logo, devenu par la suite Logo PLUS, sur Apple II.

En 1980, une nouvelle entreprise est formée, la Logo Computer System Inc. (LCSI) qui va regrouper sous l’égide et la présidence de Papert nombre de chercheurs, enseignants, développeurs et autres programmeurs embarqués dans l’aventure qu’a été le développement du projet. Dans les années qui suivent, LCSI implémentera sur la plupart des nouveaux micro-ordinateurs le langage avec ses caractéristiques fonctionnelles réclamées par son initiateur. Ainsi naquirent APPLE LOGO, Commodore LOGO, Atari LOGO, ensuite IBM LOGO, et enfin, Mac LOGO, tous construits sur les mêmes fondements, mais enrichis en fonction de l’évolution technique des matériels. Des versions pour une douzaine de langues furent développées, chose en soi très facile puisque l’architecture permettait de redéfinir aisément les primitives du langage (de même qu’il est toujours possible de « doubler » une primitive par une procédure construite avec celle-ci). En réalité, la vraie difficulté dans les traductions a résidé dans le choix des termes qui doivent être tirés du langage naturel et ne revêtir aucune ambiguïté. C’est ainsi, par exemple que Papert, après avoir longtemps hésité, donna sa préférence à la traduction canadienne DROITE ou GAUCHE plutôt qu’aux TOURNEDROITE ou TOURNEGAUCHE devenus usuels par la suite sous l’influence française. Petit détail amusant, c’est pourtant au [[Centre mondial informatique et ressource humaine]] que Papert, qui en était devenu le directeur scientifique, mettra la dernière main à la version française du Apple Logo.

Le plus digne successeur de cette série est certainement le UCBLogo développé par Brian Harvey&lt;ref&gt;[http://www.eecs.berkeley.edu/~bh/ Brian Harvey]&lt;/ref&gt; qui ne cessera d’enrichir le langage informatique dans le strict respect du métalangage, tout en indiquant explicitement comment changer ou traduire les primitives et les messages.

D’une manière ou une autre, les nombreuses versions de Logo s’inspireront avec plus ou moins de rigueur des versions LCSI, y compris un Logo de qualité discutable pour les ordinateurs [[MSX]] qui domineront de plus en plus le marché de l’éducation, sauf aux États-Unis où Apple reste le favori. Une domination renforcée par l’échec du lancement du PC Junior d’IBM qui pouvait supporter un Logo de qualité et le choix politique en France de privilégier Thomson MO5 dans le [[Plan informatique pour tous]]. Les développeurs se tourneront alors vers ce matériel en ajoutant, par exemple, les tortues dynamiques développées sur le TI 99/4A, le tout fonctionnant avec des cartouches à insérer.

À la même période, va se manifester un certain intérêt pour utiliser Logo en tant que langage de programmation proprement dit comme ce sera le cas avec le MacLogo de LCSI et Object Logo de Coral Software, une autre version pour le MacIntosh qui comprenait notamment un [[compilateur]] et même un [[débuggeur]]. Mais Logo ne parvint jamais à intéresser les programmeurs professionnels, sans doute à cause de l'étiquette « pour enfant » qui lui collait à la peau.

En 1985, LCSI lance Logowriter qui, outre une interface simplifiée et plus intuitive, comprend un traitement de texte et réintroduit les « lutins » (sprite), des tortues qui peuvent prendre des formes et des couleurs différentes.

Parallèlement, {{lien|Mitchel Resnick}} et Steve Ocko vont développer LEGO Logo une interface entre Logo et des moteurs, lumières et autres détecteurs utilisables dans des montages avec les fameuses briques [[Lego]]. Cette idée d’utiliser des robots n’était pas neuve mais recueillit néanmoins un succès commercial.

Alors que LCSI marque le pas avec Logowriter, Terrapin Softwares et Harvard Associates, les premiers pour Macintosh, les seconds pour DOS et ensuite Windows, vont continuer à développer des versions qui, bien que bénéficiant des progrès du matériel, se cantonneront à la géométrie Tortue et à la manipulation de mots et de listes.

Par contre, même si les initiatives d'introduction de Logo se multiplient durant cette décennie, il faut bien reconnaître que le volet « projet d'apprentissage » du projet marque le pas dans un monde de l'éducation qui se révélera très vite frileux (cf supra).

Les expériences s'arrêtent souvent à une ou deux semaines, c'est-à-dire le temps de découvrir et de s'amuser avec la tortue graphique comme telle que celle menée par l'[[INRP]] en France&lt;ref&gt;BOSSUET, Gérard. L’ordinateur à l’école (l’éducateur). Paris: Presses Universitaires de France (PUF), 1982. 234 pg&lt;/ref&gt;, sauf dans des ateliers privés ou des écoles privilégiées par un projet pédagogique qui favorise une approche active de la part de l'apprenant.

Ce n'est d'ailleurs pas un hasard si Logo reçoit un accueil privilégié en Argentine où l'éducation est fortement imprégnée de la pensée piagétienne.

=== Après 1990, de Logo au constructionnisme ; les métamorphoses de la tortue ===

Au début des années 1990, Logo est considéré comme un produit vieillot et obsolète en Amérique du Nord. Logowriter n’a plus guère évolué depuis sa sortie. Quant au Logo classique, il n’a pas intégré les apports de la rapide évolution des ressources informatiques. En Europe, l’engouement des premiers temps a fait long feu après l’échec des plans informatique visant à introduire les nouvelles technologies de l’information dans l’enseignement. À l’exception de la Grande-Bretagne qui l’utilise comme un [[outil pédagogique]] sans rapport avec le projet d’apprentissage sous-jacent, son usage est devenu anecdotique dès le milieu des années 1980 dans un contexte pédagogique largement défavorable à sa philosophie.
 
Ce n’est pas nécessairement le cas partout. Par exemple, un ambitieux programme est lancé au Costa Rica&lt;ref&gt;[http://webcache.googleusercontent.com/search?q=cache:JbaBIjwDbT4J:www.innovemosdoc.cl/nuevas_tecnologias/programa/programa_nacional.doc+%22+La+incorporación+de+la+informática+al+sistema+educativo+y+la+experiencia+de+Costa+Rica%22&amp;cd=1&amp;hl=fr&amp;ct=clnk&amp;gl=be]&lt;/ref&gt; par une « ancienne du MIT», Clotilde Fonseca, qui va faire école dans une douzaine de pays d’Amérique Latine. Au Japon, Logowriter va également faire son chemin au début des années 1990.

Un regain d’intérêt se manifestera vers le milieu de la décennie où l’on verra s’effacer Logo, tel qu’il était défini au début des années 1980, au profit du développement de nouveaux produits et d’un nouveau concept : le {{lien|Constructionism (learning theory)|fr=constructionisme}}.
 
En fait, si le nom de Logo va peu à peu disparaître, les idées qui en formaient le substrat, subsistent dans les grandes lignes. Même si elles intègrent de nouvelles fonctionnalités, les conceptions à la base du langage informatique restent les mêmes : un langage « naturel » avec des mots « de tous les jours », que l’on peut combiner et enrichir de nouveaux mots ;

Par contre, le projet éducatif, lui, s’est affiné. D’abord plutôt vague sur son option pédagogique dans sa description du « facilitateur » en milieu Logo, Papert opte résolument pour une pédagogie active, en insistant sur l’importance de créer des choses - « making things - lorsqu’on apprend ainsi que sur celle de la verbalisation dans la construction de nouvelles connaissances.

Plus tard, Resnick, le concepteur des nouveaux micromondes, va encore compléter le concept en y ajoutant une dimension de travail de groupe&lt;ref&gt;[http://llk.media.mit.edu/papers/Distrib-Construc.html]&lt;/ref&gt;.

Sur le plan informatique, MicroWorlds Logo va ajouter dès 1993 de nouvelles fonctions à l’environnement Logo en se basant sur l’interface MacIntosh : de nouveaux outils de dessins, un éditeur de formes, un générateur de musique et la possibilité d’importer des images ou des sons. De même, il prend en charge les tâches multiples  de sorte que des objets peuvent être animés ou créer de manière indépendantes : la tortue n’est plus toute seule.

Au MIT, une brique programmable apparaît dans le cadre de Lego Logo qui rend inutile une liaison avec un ordinateur.

Par ailleurs, Brian Harvey va continuer à enrichir le langage de base sur le plan purement informatique UCBLogo&lt;ref&gt;[http://www.cs.berkeley.edu/~bh/logo.html%20 UCBLogo]&lt;/ref&gt;, dans sa version distribuée librement, comprend 344 primitives.

À l’autre extrémité, dans le domaine de la recherche, avec, Mitchel Resnick va développer avec {{lien|StarLogo}} des environnements où des milliers de « tortues » peuvent interagir.

Plus récemment, le même Resnick proposera avec [[Scratch (langage)|Scratch]] un nouveau projet de type Logo intégrant une implémentation visuelle et dynamique du langage de programmation [[Smalltalk]] basé sur [[Squeak]]. [[Squeak]] est l'héritier du Logo dans l'approche qu'il propose de l'interaction informatique-éducation. Il s'inscrit dans les cadres théoriques de la psychologie du développement et des idées de gens comme [[James Baldwin (psychologue)|Baldwin]], [[Jean Piaget|Piaget]] ou [[Lev Vygotski|Vygotski]].

== Implémentations ==
[[Fichier:LogoRecursiveSpiral.jpg|thumb|Exemple de spirale récursive en MSWLogo]]
Il existe plus de 130 [[Mise en œuvre|implémentations]] du Logo, aux caractéristiques variées.

Et, faut-il le dire, de qualités variables tant au niveau informatique que par rapport au projet éducatif. Certains ne sont, d'ailleurs pas des [[langages informatiques]], même simplifiés, mais seulement des [[programmes informatiques]].

Ainsi, Papert s'insurgera contre les versions simplifiées comme le « Logo instantané » où les instructions sont facilitées par des touches fonctions, celles limitées au graphisme Tortue ou encore celles où la tortue ne tourne que par des multiples de 10 ou de 30° : ''Comment peut-on découvrir à quoi ressemble un angle à 45 degrés quand il peut tourner la tortue seulement dans les multiples de 10 ou 30 degrés à chaque fois ?''&lt;ref&gt;Papert Seymour, &quot;Misconceptions about Logo&quot;,Creative Computing, vol 10, N° 11 / Novembre1984, p. 229 (traduction libre)&lt;/ref&gt;

=== Berkeley Logo ===
{{Article détaillé|UCBLogo}}
[[UCBLogo]] est l'implémentation la plus populaire, un [[logiciel libre]] réalisé par [[Brian Harvey]] de l'[[université de Californie à Berkeley]].
Il existe plusieurs implémentations de'' UCBLogo'', parmi lesquelles ''MSWLogo'', une version pour MS Windows très utilisée dans les écoles britanniques.

=== Autres implémentations libres ===
* ''ELICA''&lt;ref&gt;{{en}} [http://www.elica.net/ ELICA]&lt;/ref&gt;, une mise en œuvre [[Programmation orientée objet|orientée objet]] réalisée par ''Pavel Boytchev''.
* ''StarLogo''&lt;ref&gt;{{en}} [http://education.mit.edu/starlogo/ StarLogo]&lt;/ref&gt;, une implémentation du [[Massachusetts Institute of Technology|MIT]] par un dialecte de mise en concurrence utilisé pour la modélisation de systèmes décentralisés. Il s'agit d'une évolution du langage permettant de faire évoluer des ''agents'' en parallèle représentés par des milliers de tortues de mer. Outre ''StarLogo'', il en existe deux autres avec  ''NetLogo''&lt;ref&gt;{{en}} [http://ccl.northwestern.edu/netlogo/  NetLogo réalisé par ''Uri Wilensky'']&lt;/ref&gt; et ''Logoplus Multi-Gfx''&lt;ref&gt;[http://perso.orange.fr/logoplus Logoplus Multi-Gfx], un compilateur LOGO libre pour Windows.&lt;/ref&gt;. Toutes ces versions permettent d'expérimenter des théories concernant les [[phénomènes émergents]], ce qui est particulièrement intéressant en [[science sociale|sciences sociales]], en [[biologie]], en [[physique]], ainsi que dans de nombreuses autres sciences. Même si ces langages se concentrent sur l'interaction d'un grand nombre d'[[agent]]s indépendants, il parviennent à conserver la philosophie du Logo.
* ''Scratch''&lt;ref&gt;{{en}} [http://scratch.mit.edu/ Scratch au sein du MIT]&lt;/ref&gt;, un environnement expérimental de programmation réalisé par [[glisser-déposer]] de ''tortues''.
* Sous [[KDE]] il existe [http://edu.kde.org/kturtle/ KTurtle].
* ''LIOGO''&lt;ref&gt;{{en}} [http://liogo.sourceforge.net/ LIOGO], un compilateur Logo pour [[Microsoft .NET|.NET]] et [[Mono (informatique)|Mono]].&lt;/ref&gt;.
* ''Logo3d''&lt;ref&gt;{{en}} [http://sourceforge.net/projects/logo3d/ Logo3d], logiciel libre distribué selon les termes de la [[licence ISC]].&lt;/ref&gt;, une implémentation à l'origine développé au [[MIT]] par [[Seymour Papert]] puis maintenue sur la plateforme [[SourceForge.net]].

=== Implémentations propriétaires ===
* ''Imagine''&lt;ref&gt;{{en}} [http://www.logo.com/imagine/ Imagine]&lt;/ref&gt; de l'[[université Comenius]], une mise en œuvre [[Programmation orientée objet|orientée objet]] une collaboration d'agents en [[parallélisme (informatique)|parallèle]] sur [[internet]].
* [http://comlogo.input.sk/ Comenius Logo], une autre mise en œuvre disponible en hollandais, allemand, tchèque, etc.
* Apple Logo, Atari Logo, IBM Logo, NSX Logo et plusieurs autres versions ont été produites par &quot;Logo Computer Systems Inc.&quot;, soit une douzaine de plateformes et environ 18 langues parlées: grec, hébreux, arabe, italien, espagnol, etc. Logo Computer Systems Inc. est une société fondée par [[Seymour Papert]] afin de poursuivre ses développements Logo avec une version du langage de programmation basée sur un environnement entièrement graphique.
* LogoWriter  aussi été produit par Logo Computer Systems Inc. pour les plateformes Apple, IBM et NSX.
*''{{Lien|fr=MicroWorlds|lang=en|trad=MicroWorlds|texte=MicroWorlds}}''&lt;ref&gt;{{en}} [http://www.microworlds.com/ Microworlds]&lt;/ref&gt; de la société ''Logo Computer Systems Inc.''
* ''Terrapin Logo''&lt;ref&gt;{{en}} [http://www.terrapinlogo.com/ Terrapin Logo]&lt;/ref&gt;.

* Logo S.O.L.I. était une version française de Logo produite par Logo Computer Systems Inc. (S.O.L.I. signifie Systèmes d'Ordinateur Logo Inc.) largement utilisée dans les [[École primaire en France|écoles primaires]] dans les [[années 1980]] par le biais des [[Thomson MO5|MO5]] et des [[Thomson TO7/70|TO7/70]]{{refnec}}.
* Lego/Logo était un système de contrôle de moteurs et capteurs Lego, beaucoup utilisée dans les écoles dans les années 1990{{refnec}}.

D'autres implémentations ont ou ont eu une importance qui mérite d'être signalée : le P_Logo, des éditions Profil ; le jLogo&lt;ref&gt;{{en}} [http://guillot.emmanuel.free.fr/jLogo/ jLogo], autre version en Java de Logo&lt;/ref&gt; et le [[Xlogo|XLogo]], basées sur des interpréteurs écrit en [[Java (langage)|Java]].

Il n'existe aucune norme de Logo, mais uniquement une tradition. Ainsi, on constate des différences importantes entre les différentes évolutions du Logo. Les exemples de code donnés ci-dessous sont censés fonctionner dans la plupart des dialectes du Logo.

== Logo, langage informatique ==

=== Aperçu du Métalangage ===

LOGO fait partie de la famille des [[Programmation orientée objet|langages de programmation orientée objet]]. Ses règles de syntaxe sont réduites au minimum et le vocabulaire se rapproche le plus possible du langage &quot;naturel&quot;, des mots de tous les jours. C'est évident pour les commandes de la tortue graphique, mais également pour le traitement de mots ou de listes. Par exemple, il comprend des termes comme  SAUFPREMIER, PREMIER, … aujourd'hui largement utilisés dans les [[bases de données]].

À l'origine n'existe que 2 types d'objets : les '''MOTS''' et les '''LISTES'''.

Les ''MOTS'' sont des chaînes de caractères.  Formellement, les nombres ne sont que des mots particuliers reconnus et évalués automatiquement par leur valeur. 
Les ''LISTES'' sont des suites ordonnées d'objets.

Un mot est signalé par un guillemet, une liste par des crochets. Si un mot n'est pas précédé d'un guillemet, il est interprété comme une procédure (voir ci-dessous).

Ces objets peuvent servir d'entrées  - ''d'ARGUMENTS'' - à des '''OPÉRATIONS''' ou des '''COMMANDES'''.

Une '''OPÉRATION''' sert à créer un nouvel objet à partir des objets entrant (formellement des ARGUMENTS), qu'elle ''retourne'' à une autre opération ou à une COMMANDE.
Une '''COMMANDE''' dit ce qu'il (l'ordinateur ou le robot) doit faire de cet objet.

Une ligne de programmation est et ne peut être que formulée qu'en termes d''''INSTRUCTION'''.
Une instruction se compose impérativement d'une -  et d'une seule - COMMANDE, suivie d'un objet, d'une ou de plusieurs OPÉRATIONS qui retournent l'objet qu'elles créent à l'éventuelle opération qui la précède, ou à la commande.

C'est pourquoi taper simplement 5 + 5 (ou, plus formellement, SOMME 5 5) entraîne un message d'erreur du type &quot;''Ne sait que faire avec 10''&quot;, puisqu l'instruction est incomplète du fait de l'absence de commande. De même ECRIS ''tout seul'' fera apparaître une message &quot;Pas assez d'entrée pour…&quot; puisque, cette fois-ci l'instruction est incomplète du fait de l'absence d'objet.

Par contre, dans l'instruction  ECRIS 5 + 5 affiche 10, l'opération d'addition sur des mots directement évalués comme des nombres retournant son résultat  à la commande d'affichage,
De même, dans le [[micromonde]] &quot;Tortue&quot;, AVANCE 5 + 5, fera se mouvoir le robot tortue de 10 pas.
Par contre, ECRIS [5 + 5] produira un affichage du texte 5 + 5 puisqu'il s'agit d'afficher le contenu d'une liste signalée par les […].

Un groupe d'instructions peut toutefois être écrit sur une même ligne. Sera, donc, licite :

&lt;code&gt;AVANCE SOMME [5 5] DROITE 360/10&lt;/code&gt;

La seule exception à la règle de commande unique réside dans l'emploi de la primitive REPETE qui accepte comme entrée une liste d'instructions.

&lt;code&gt;REPETE 360 [AV 1 TD 1]&lt;/code&gt; (formule du cercle en géométrie LOGO).

Soit une instruction qui commande de répéter 360 fois, deux instructions

Les mots prédéfinis dans le langage sont appelés '''''PRIMITIVES''''' du langage.

Ce langage de base peut s'enrichir de '''PROCÉDURES''' créées par l'utilisateur. Une fois définie, ces procédures vont faire partie intégrante du langage et obéissent aux mêmes règles d'écriture. Leurs définitions sont écrites et corrigée dans l'éditeur ''ED'' ou, dans certaines versions, définies directement à l'aide de la commande &quot;POUR&quot;, suivie du nom de la procédure (ce qui facilite le passage de la commande directe vers la programmation)

Une procédure comprend trois partie : son nom, les commandes et opérations que son activation déclenchera et le mot FIN. Elle peut être définie comme nécessitant une ou plusieurs entrées qui, sont, en réalité des variables pouvant stocker localement des objets. Dans ce cas, leur utilisation exigera impérativement l'introduction d'objets. Taper un mot qui n'est pas une procédure ou une primitive sera signalé comme une erreur &quot;ne sait comment…&quot;

LOGO se présente comme un langage évolutif : les &quot;primitives&quot; ne sont, en réalité que des procédures ''build in''.

Dès lors, en toute logique, une procédure doit pouvoir comprendre des procédures, ''y compris elle-même''', ce qui confère à LOGO la puissance d'un [[langage récursif]].

&lt;code&gt;POUR RECURSION
:RECURSION
FIN&lt;/code&gt;

est donc licite et crée une boucle sans fin.

De même, une procédure peut être construite de manière à nécessiter un ou plusieurs arguments.

&lt;code&gt;POUR CERCLE :LONGUEUR
:REPETE [AV : LONGUEUR DR 1]
FIN&lt;/code&gt;

crée une procédure qui permet de dessiner des cercles de taille variable : par exemple CERCLE 0,5 ou CERCLE 1 ,
mais, toujours, à partir d’un point de la circonférence (ici situé à 180°) puisque la tortue dessine le contour d’un objet graphique et part, dès lors, d’un point sur ce contour.

''PS : rien n’est plus difficile que de dessiner un cercle à partir de son centre : par exemple, au point d’origine (0,0) de la tortue, au centre de l’écran, pour ne rien dire du dessin de cercles concentriques !''

Toujours aussi logiquement, une procédure peut être une opération en utilisant la primitive RETOURNE.
Ainsi si on définit la procédure suivante :

&lt;code&gt;POUR MULTIPLICATION :X :Y
:RETOURNE PRODUIT [:X :Y]
FIN&lt;/code&gt;
 
&lt;code&gt;ECRIS MULTIPLICATION 5 6&lt;/code&gt; affichera
30

''Force est de reconnaître qu'en réalité, peu de versions de Logo intègrent ces aspects.''

L''''interprétation''' se fait de la gauche vers la droite. Par exemple,
 
ECRIS SOMME 7 PRODUIT 5 2

17

est interprété par Logo de la manière suivante :

# La commande ECRIS nécessite une entrée
# Le mot rencontré est une opération nécessitant deux entrées
# la première entrée est un nombre, soit un mot directement évalué par sa valeur ; pas de problème
# le seconde entrée est une opération qui nécessite également deux entrées
# ces deux entrées sont bien présentes et sont reconnus comme des nombres
# l'instruction est donc complète et, dès lors, exécutée.

Les '''variables''' ne doivent pas être déclarées au préalable. Elles ne nécessitent aucune notation particulière et peuvent être nommée par n'importe quel mot, même par le nom d’une procédure existante, et il est d’ailleurs chaudement recommandé de choisir des termes explicites. Leur contenu étant un objet, il peut être un MOT ou une LISTE.

Par défaut, les variables sont globales.  Dans des versions complètes, elles peuvent éventuellement être déclarées comme locales. Lorsqu’elles servent d’arguments à une procédures, elles sont toujours locales et leur contenu ne conserve leur valeur que durant l’exécution de la procédure. Il est néanmoins possible de créer des variables globales à l’intérieur d’une procédure.

Exemple :

DONNE &quot;Nomdelavariable 4

ECRIS SOMME 7 PRODUIT 5 CHOSE &quot;Nomdelavariable

27

En notation simplifiée et plus courante, on peut également écrire :

ECRIS SOMME 7 PRODUIT 5 :Nomdelavariable

27

De même, Logo comprend également des notations mathématiques préfixes ou infixes.

Exemple :
* EC SOMME 10 3  ⇒ préfixe : l'opérateur est devant.
* EC 10 + 3      ⇒ infixe   : l'opérateur est entre les nombres.

Formellement, seule le forme préfixe répond aux exigences de syntaxe comme quoi les objets suivent une opération à laquelle ils servent d'arguments. Tout comme l'interprétation directe d'un nombre, la forme infixe n'existe que parce que cette notation est familière.

Enfin, par défaut, Logo sauvegarde dans un seul fichier tout l'espace de travail et le restaure en une seule instruction.

=== Interface graphique : la tortue ===

Le terme &quot;Tortue&quot; relève d'une tradition née vers 1950 avec les premiers robots construits par le neurophysiologiste [[William Grey Walter]], pionnier de la cybernétique avec ce qu'il appellera ses &quot;[[tortues de Bristol|tortoises]]&quot;.

==== Description ====

À l'origine un robot de sol, la &quot;tortue&quot; est un robot sur l'écran, prêt à explorer son espace. Dans ce cas, le plus connu, elle se présente la plupart du temps sous la forme d’un triangle orienté dans la direction qu’elle va prendre. Elle traîne  à l’arrière – ''et non derrière elle, la nuance est d’importance d’un point de vue pédagogique'' – un crayon qui lui permet de laisser des traces de son passage. Ce crayon peut être levé (LC) ou remplacé par une gomme.  Avec l’évolution du matériel informatique, il pourra également prendre des couleurs différentes.

Au départ, ce robot occupe une position et une orientation précises. Au départ, ce seront  le milieu (position 0,0) et le haut de l’écran, c’est-à-dire vers le « Nord », au cap de 0°.

On travaille, donc, en '''coordonnées polaires''' et non pas en coordonnées cartésienne, même si le langage comprend la possibilité d’utiliser ces dernières. La Tortue se déplace comme un navire, c’est-à-dire en prenant une direction relative et en parcourant une distance à partir d’un point et d’une orientation de départ.

Mieux, elle se déplace, en réalité sur un [[tore]], ce qui explique qu’en position normale, elle « ENROULE », c’est-à-dire que si elle disparaît par un côté de l’écran, elle réapparait à son opposé.

Le concept de la « géométrie Tortue » est issu des travaux du Logo Group du MIT et permet à l’apprenant d’explorer un univers géométrique en s’identifiant à la tortue. Ce que Papert appellera la « syntonie avec le corps »&lt;ref&gt;[http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&amp;tid=7287 ABELSON &amp; DI SESSA, 1986].&lt;/ref&gt;.

Au départ, l’utilisateur lui donne des ordres simples, « militaires » : AVANCE, RECULE, DROITE, GAUCHE pour la faire se déplacer. Elle se déplace pas à pas et s’oriente par degré ; à chaque 360°, elle fait, donc, un [[tour complet]] sur elle-même (théorème du tour complet de la tortue). Du fait de son crayon, elle laisse une trace de son passage sur l’écran (sauf, bien sûr, si on lui a donné l’ordre de la lever).

Par la suite, ces ordres pourront être rassemblés dans des PROCÉDURES qui enrichiront le langage informatique et pourront, par conséquent, elles-mêmes être appelées dans d’autres procédures.

Dans un grand nombre d'interfaces graphique de '''Logo''', l'écran est divisé en 2 parties afin de permettre de visualiser à la fois les instructions qui lui sont données et leurs résultats :

* l'une pour le graphique proprement,
* l'autre pour introduire et voir les instructions déjà données.

==== Quelques exemples ====
[[Fichier:LOGO recursive star.png|thumb|Exemple d'image réalisable avec la tortue]]

Exemple de définition de procédure : la procédure CARRE devra tracer un carré à l'écran. Le texte est tapé dans l'éditeur du LOGO, puis sauvé.

&lt;pre&gt;
POUR CARRE
AV 100 TD 90
AV 100 TD 90
AV 100 TD 90
AV 100 TD 90
FIN
&lt;/pre&gt;

ou plus simplement

&lt;pre&gt;
POUR CARRE
REPETE 4 [AV 100 TD 90]
FIN
&lt;/pre&gt;

Emploi de CARRE dans une autre procédure :

&lt;pre&gt;
POUR PLCARRE
REPETE 36 [CARRE TD 10]
FIN
&lt;/pre&gt;

Dans cet exemple,
* «AV n» signifie «AVance la tortue du nombre de pas n»
* «TD n», «Tourne à Droite de n degrés (ici de 90 degrés)»

Pour employer PLCARRE, il suffit de taper dans la zone de commande PLCARRE.

Le passage de paramètres à une procédure est possible.

&lt;pre&gt;
POUR CARRE :LG
REPETE 4 [AV :LG TD 90]
FIN
&lt;/pre&gt;

Utilisation : CARRE 50 trace un carré de 50 pas de TORTUE.

Pour faire un CERCLE, il suffit de décrire le périmètre de celui-ci
&lt;pre&gt;
X = 36
Y = 5
répète X [
           TOURNEDROITE 360/X	
           AVANCE Y 
	 ]
&lt;/pre&gt;

''En réalité, il s'agira d'un polygone régulier à 36 côtés, cette formule ne s'applique qu'au versions LOGO où la Tortue ne peut tourner que par des angles de 10°.
''
La rosace présentée en illustration peut donc s'écrire (KTurtle)
&lt;pre&gt;
COULEURCRAYON 255, 0, 0
X = 36
Y = 5
répète X [
	TOURNEDROITE 360/X
	répète X [
		TOURNEDROITE 360/X
		AVANCE Y 
	]
]
&lt;/pre&gt;
pour un hexagone

REPETE 6[AV 100 TG 60]

==== Primitives  graphiques ====
{| class=&quot;wikitable&quot;
|+ Principales primitives de la tortue
|-
! scope=col | Français
! scope=col | Commande ou opération
! scope=col | Anglais
! scope=col | Définition
|-
| AV n ou AVANCE n || commande || FD n ou Forward n
| la tortue avance de n pas
|-
| RE n ou RECULE n || commande || BK n ou Back n || la tortue recule de n pas
|-
| TD n ou TOURNEDROITE n (DR n, DROITE n) || commande || RT n ou RIGHT n
| la tortue tourne de n degrés d'angle vers la droite
|-
| TG n ou TOURNEGAUCHE n (GA n, GAUCHE n)|| commande || LT n ou LEFT n
| la tortue tourne de n degrés d'angle vers la gauche
|-
| LC ou LEVECRAYON || commande || PU or PENUP || La tortue ne laisse pas de trace
|-
| BC ou BAISSECRAYON ||commande || PD or PENDOWN
| La tortue laisse sa trace (par défaut)
|-
| CT ou CACHETORTUE || commande ||HT ou HIDETURTLE
| la tortue n'est plus visible sur l'écran graphique
|-
| MT ou MONTRETORTUE || commande ||ST ou SHOWTURTLE
| La tortue est visible sur l'écran graphique
|-
| ENR ou ENROULE || commande || WRAP || Enroule l'écran graphique (valeur par défaut)
|-
| FEN || commande || WINDOWS
| La tortue peut sortir du jardin et disparaître de l'écran graphique
|-
| CLOS || commande || FENCE
| La tortue ne peut pas sortir du jardin
|-
| ORIGINE || commande ||HOME || Retour au milieu du carré de salade
|-
| VE || commande || CS ou CLEARSCREEN
| Efface toutes les traces et restaure l'état initial (tortue au centre et regardant vers le haut)
|-
| NETTOIE || commande || CLEAN
| Efface toutes traces de l'écran graphique sans changer la position de la tortue
|-
| VT || commande || CT or CLEARTEXT || Efface l'écran de commande
|-
| FCC n || commande || SETPC n
| Change la couleur du crayon, n est un entier positif
|-
| FCFG n || commande || SETBG n
| Change la couleur du fond, n est un entier positif
|-
| FCB n || commande || *****
| Change la couleur des bords, n est un entier positif
|-
| FCAP n || commande || SETH ou SETHEADING
| Fixe le ''cap'' de la tortue de maniere ''absolue'', selon l'angle de  n degrés
|-
| colspan=&quot;3&quot; | Ex : &lt;font color=green&gt; 0 CAP vers le haut de l'écran, 90 vers la droite, 180 en bas, 270 à gauche &lt;/font&gt;
|-
| FPOS [X Y] || commande || SETPOS [X Y]
| Fixe la POSITION de la tortue avec une LISTE de 2 nombres entiers (id : ''coordonnées cartésiennes'').
|-
| colspan=&quot;3&quot; | &lt;font color=green&gt; Ex : LC FPOS [50 35] BC ou avec des variables  DONNE &quot;X 50  DONNE &quot;Y 35  FPOS PH :X :Y&lt;/font&gt;
|-
| CAP n || opération || HEADING|| retourne l'orientation de la tortue exprimée en degrés
|-
| POSITION, POS || opération|| POS || retourne la position de la tortue en coordonnées cartésiennes.
|
|-
|}

{| class=&quot;wikitable&quot;
|+ Primitives Logo mathématiques
|-
! scope=col | Français
! scope=col | Anglais
! scope=col | Définition
|-
| n1 + n2 || n1 + n2
| Addition de nombres réels - Ex : EC 45.124 + 11 ou EC (+ 45 10 78 23)
|-
| n1 - n2 || n1 - n2
| Soustraction de nombres réels - Ex :EC 5 - 1.09
|-
| n1 * n2 || n1 * n2
| Multiplication de nombres réels - Ex :EC 5 * 9
|-
| n1 / n2 || n1 / n2
| Division de deux nombres réels - Ex :EC 45 / 9
|-
| SOMME n1 n2 || SUM n1 n2
| Addition de nombres réels - Ex : EC SOMME 45 11
|-
| DIFF n1 n2 ||  - n1 n2
| Soustraction de nombres réels - Ex :EC DIFF 5 1
|-
| PROD ou PRODUIT n1 n2 || PRODUCT n1 n2
| Multiplication de nombres réels - Ex :EC PROD 5 9.45
|-
| DIV n1 n2 || QUOTIENT n1 n2
| Division de deux nombres réels - Ex :EC DIV 45 11
|-
| QUOTIENT n1 n2 || QUOTIENT n1 n2
| Division de deux nombres réels - Ex :EC DIV 45 11
|-
| RESTE n1 n2 || REMAINDER n1 n2 ||  Reste de la division
|-
| ENT n || INT n
| Renvoie la partie entière du nombre réel - Ex :EC ENT 55.75 → 55
|-
| ARRONDI n || ROUND n
| Arrondit un nombre réel - Ex :EC ARRONDI 55.75 → 56
|-
| ABS n || ABS n
| Renvoie la valeur un nombre réel - Ex :EC ABS -55 → 55
|-
| HASARD n || RANDOM n
| Renvoie un nombre entier entre 0 et n-1
|-
| RC n ou racine n || SQR n
| Renvoie la racine carré d'un nombre réel - Ex :EC RC 25 → 5
|-
| LOG n || LOG n
| Renvoie le logarithme naturel d'un réel
|-
| LOG10 n || LOG10 n
| Renvoie le logarithme de base 10 d'un réel
|-
| EXP n || EXP n ||  Renvoie l'exponentielle d'un réel
|-
| SIN n || SIN n
| Renvoie le sinus d'un réel n en degrés - Ex :SIN 30
|-
| COS n || COS n
| Renvoie le cosinus d'un réel n en degrés
|-
| TAN n || TAN n
| Renvoie la tangente d'un réel n en degrés
|-
| ATAN n || ATAN n
| Renvoie tangente d'arc d'un réel n en degrés
|-
| PI || PI ||  3.141592…
|-
| RADIANS n || RADIANS n
| Convertit un angle en radians n en degrés
|-
| DEGRES n || DEGRES n
| Convertit un angle en degrés n en radians
|}

== Logo, philosophie de l'éducation ==

Il faut le dire tout de go : dès l’abord, Papert n’envisage pas Logo – et, l’informatique, en général - comme un outil pédagogique, ni, a fortiori, son usage scolaire, mais comme le moyen de créer un nouvel environnement d’apprentissage. Dans &quot;Jaillissement de l'esprit&quot; (op. cit.), il oppose l'apprentissage syntone à l'apprentissage dissocié  que présente traditionnellement l’école, dans laquelle ce qui est enseigné ne s’accorde pas avec les enfants (cf infra). Néanmoins, passé les premiers pas en laboratoire, force est de constater que les premières utilisations de Logo se passeront dans des écoles, lieux institutionnels – institutionnalisés – des apprentissages. Dès lors, sauf à réserver Logo à quelques clubs ou ateliers fréquentés par quelques privilégiés, le problème de son introduction dans le milieu scolaire va vite se révéler incontournable et, dans son sillage, apparaîtront les questionnements pédagogiques.

Le temps passant, Papert montrera de plus en plus de réticence vis-à-vis de l’école : « ''Une réforme (de l’enseignement) vise à modifier l'école, mais, in fine, c’est l'école qui change la réforme. On peut voir au premier abord une tautologie dans cette proposition d'expliquer les échecs d’une réforme. Mais dire que l'école change de la réforme est très différent de dire tout simplement que l'école résiste ou rejette la réforme. Elle résiste à la réforme d'une manière particulière - en s'appropriant ou en l'assimilant à ses propres structures. Ce faisant, elle désamorce l’action des réformateurs et parvient parfois à prendre dans quelque chose de ce qu'ils proposent'' » &lt;ref&gt;Papert, Seymour, &quot;Why School Reform Is Impossible&quot; (traduction libre), The Journal of the Learning Sciences 6(4), pp. 417-427, Taylor &amp; Francis Group, 1997&lt;/ref&gt;.
'''Selon lui, les ordinateurs ont plutôt la vocation de substituer une autre structure à l’école, pas de l’améliorer'''&lt;ref&gt;'Papert, S. &quot;The Children's Machine: Rethinking School in the Age of the Computer&quot;, 1992 (ISBN 0-465-01063-6) Traduction française : &quot;L'enfant et la machine à connaître. Repenser l'école à l'ère de l'ordinateur&quot;, Dunod, 1994.&lt;/ref&gt;.

=== Cadre théorique : les hypothèses de Papert ===

==== Dans le sillage de Piaget ====
Avec le projet Logo, Papert veut mettre en pratique les idées constructivistes de Piaget grâce à l'informatique. Il ajoute, toutefois, une dimension aux notions d’assimilation et d’accommodation développées par ce dernier : l’importance de l’affectif dans le processus d’apprentissage (NB : Piaget n’a pas étudié cet aspect par manque d’éléments théorique à ce sujet).

Une autre différence porte sur les raisons d’une difficulté de l’apprenant à assimiler certains concepts. 
Selon Piaget, certains concepts ne pourront être assimilés qu’à partir d’un certain âge et après l’assimilation d’autres concepts (les pré-requis). Ces stades de développement de l’intelligence sont communs à tous les enfants et ont un caractère universel, indépendant de la culture au sein de laquelle se passe l’apprentissage&lt;ref&gt;http://www.psybernetique.com/Introduction/piaget.htm&lt;/ref&gt;. Par contre, pour Papert, si l’acquisition d’un concept pose problème, c’est par manque de matériau à disposition de l’apprenant pour l’aider à l’assimiler dans sa culture. Autrement dit, l’ordre dans lequel sont acquises les connaissances n’a pas ce caractère universel, mais dépend de l’abondance ou de pénurie de matériaux permettant leur acquisition dans une culture donnée (cf  {{lien|John Curtis Gowan}}&lt;ref&gt;Gowan, J.C., &quot;Development of the Psychedelic Individual&quot;, Snyder Inst. of Research, 1974 (ISBN 978-0686279242)&lt;/ref&gt;. Partant de là, Papert propose de créer de nouveaux matériaux à manipuler par l’enfant qui soient propres à aider l’acquisition de notions comme les mathématiques et la physique et cela, au travers d’environnements construits à cet effet à partir de cette nouvelle venue qu’est l’informatique.

==== Apprentissage syntone versus apprentissage dissocié ====
Encore faut-il pour cela que ce support informatique réponde aux exigences d’’un tel matériau pour que l’enfant puisse s’en emparer et le manipuler comme les autres.

Pour ce faire, il part d’un constat : l’apprentissage le plus répandu et qui réussit le mieux, est celui de l’apprentissage de la langue. Or, cet apprentissage se produit naturellement, sans intervention d’enseignant désigné. Il se construit, point barre. Le Logo group va s’inspirer de ce modèle d’apprentissage de la langue (en dehors de l’école) pour tenter de l’appliquer à d’autres domaines. Pour cela, il faut que l’enfant continue à trouver un sens à ce qu’il fait, que ceci s’accorde avec sa perception et ce qu’il connaît déjà.
C’est tout le contraire, selon lui, d’un apprentissage scolaire dominé par une conception disciplinaire et transmissive de l’enseignement et le suivi d’un “programme d’enseignement” pour chaque niveau qui ne s’accorde pas avec l’enfant, mais qui lui est imposé.

Dès lors, prenant le contre pied les dictacticiels qui, créé pour enseigner à l’élève une discipline, ne font que reproduire l’enseignement classique avec un ordinateur, il veut que ce soit l’enfant qui apprenne à l’ordinateur à réaliser des tâches et non l’inverse et, donc, à l’instar de Dwyer avec le [[BASIC]], l’apprenant sera programmeur et non programmé. 
Par contre, contrairement à ce dernier qui, même simplifié, reste un langage d’informaticien, LOGO sera conçu dans une langue proche du langage naturel et, donc, facile à assimiler&lt;ref&gt;Solomon Cynthia, &quot;Computer Environments for Children: A Reflection on Theories of Learning and Education&quot;, MIT press, Mass., 1986&lt;/ref&gt;.

==== Apprendre les mathématiques en « mathématie » ====
Tout à l’opposé de cet apprentissage naturel du langage est, pour le mathématicien qu’est Papert, celui des mathématiques. En effet, pour nombre (la plupart ?) des personnes ayant suivi une scolarité traditionnelle, les mathématiques reste un sujet de dégoût.

Or, pour lui, la distinction entre “sciences” et “lettres” comme deux groupes de disciplines n’est que culturelle : tout le monde est naturellement mathématicien de par des besoins de la vie courante, ce qui n’empêchent pas certaines personnes de refuser les mathématiques dès qu’elles sont identifiées comme telles.
Si beaucoup de personnes sont mathophobes, c’est à cause de l’enseignement scolaires des mathématiques qui se caractérise par une dissociation du vécu des enfants et se résume souvent pour eux par des recettes à apprendre. Ces mathématiques scolaires sont une construction faisant suite à des accidents, ou plus généralement, une histoire, mais n’ont pas été réfléchies selon des critères objectifs. L’habitude est devenue la seule raison du contenu de ces programmes scolaires en mathématiques.

Pour remplacer cela, Papert propose de plonger les enfants en “mathématie”. Les enfants vont découvrir naturellement des notions de mathématiques dans un micromonde de la même manière qu’ils apprennent naturellement une langue ou d’autres concepts, telle que décrite par Piaget.
Ce micromonde où les mathématiques pourraient être appropriées par les enfants, doit reposer sur trois principes :
# Un principe de continuité, continuité avec les connaissances déjà bien assimilées par les enfants, ce qui permet un ancrage cognitif et un possible rapport affectif ;
# Un principe de puissance ajoutée, qui permet à l’enfant, grâce à ses nouvelles connaissances, de développer de nouveaux projets chargés de signification personnelle ;
# Un principe de résonance culturelle, per laquelle que les mathématiques apprises par les enfants trouve un sens dans un contexte social car, pour pouvoir avoir une à leurs yeux, il faut qu’elle en aient également aux yeux des adultes.

Si ce dernier principe démontre l’intérêt que Papert porte au champ socio-cognitif de l’apprentissage, il implique que l’enfant ne se retrouve pas seul devant l’ordinateur. Et la problématique de cet accompagnement contituera sans doute LA pierre d’achoppement pour Logo.

==== La tortue, objet de transition ====

Pour que l’enfant entre dans ce micromonde de la « mathématie », Logo comprend une voie d’accès qui lui propose un apprentissage syntone, cest-à-dire qu’il lui permette de relier la manipulation du nouveau matériau proposé avec ses apprentissages passés tout en restant attractif et motivant : d’où la partie graphique du langage consacrée à la Tortue.

La Tortue – quelle que soit sa forme : robot ou forme sur l’écran - est un objet anthropomorphique (au début, beaucoup d’enfants lui prêtent toutes sortes d’intentions !) dont les déplacements dans l’espace peuvent être commandés par des mots concrets, issus du langage familier. L’exécution des dessins par des commandes simples crée ainsi une seuil de communication avec l’ordinateur qui reste très proche du quotidien.

Apprendre à contrôler la Tortue met à contribution chez l’enfant son désir de communiquer, son plaisir de donner des ordres et son goût pour le mouvement. L’activité de programmation consiste, donc, à apprendre à l’ordinateur (la Tortue, en l’occurrence) ce qu’il veut lui vouloir faire. De la sorte, si l'enfant peut s'appuyer sur la connaissance intuitive qu'il a des mouvements de son compte (sur ses schèmes sensori-moteurs), en s'identifiant avec la Tortue (&quot;jouer Tortue&quot; avec son corps), il doit traduire son intuition sous une forme qui soit compréhensible à celle-ci. Or &quot;''traduire une intuition sous forme de programme, c'est la concrétiser, la rendre plus palpable et plus accessible à la réflexion''&quot; (Papert, 1981, o. c., p.&amp;nbsp;82).

La Tortue est, donc, un objet de transition entre l’acquis de l’enfant qui est la connaissance de son corps et de ses mouvements ainsi que le langage simple qui les commande ou les décrit. Cette appropriation est facilitée par trois éléments qui, mutatis mutandis, correspondent aux principes directeurs décrits plus haut :

# La compréhension d’un nouveau concept (schème) s’appuie sur les concepts acquis antérieurement : ''principe de continuité''
# La réalité et le plaisir du faire, ou mieux encore, du faire faire : ''principe de puissance''
# La valorisation par l’environnement social (c’est beau ce que l’on fait) : ''principe de résonance culturelle''.

Un autre aspect du langage Tortue réside dans une nouvelle approche de la géométrie en propposant un micromonde que l’enfant peut explorer et dans lequel il peut construire selon son mode d’apprentissage naturel et non sur une approche formelle et propositionnelle de cette partie des mathématiques : une nouvelle pierre d’achoppement pour Logo.

==== L'erreur n'est pas une faute ====

Traditionnellement, lorsqu’un élève fait une erreur en mathématiques – comme dans d’autres domaines -, il s’empresse de l’oublier. Cette réaction est encouragée par la sanction scolaire qui dit c’est soit &quot;faux&quot;, soit &quot;bon&quot;.

En LOGO, l’erreur n’est pas qualifiée de cette façon. Ce n’est qu’un défaut partiel et momentané dans un programme (« un simple [[bug (informatique)|bug informatique]] »). On ne jette pas la totalité d’un programme - ou d’une liste d’instructions dans les premiers temps - parce que tout ne se passe pas comme prévu. L’élaboration d’un dessin, puis d’un programme, se fait par une suite d’essais, d’erreurs et de corrections. Les enfants prennent conscience qu’il n’y pas que du “tout bon” et du “tout faux” puisque qu’ils peuvent s’approcher peu à peu, pas à pas, de la solution pour un projet initialement imaginé.

Papert développe longuement cet aspect de suites d’essai-erreur ainsi que le jugement de valeur porté sur l’erreur, car cette question est cruciale à ses yeux. LOGO ne peut pénaliser pas l’erreur de la même manière que l’enseignement classique qui décourage les enfants à se construire des théories.
L’objectif à poursuivre dans cette esprit, était de trouver le moyen de fournir à l’enfant un contexte lui permettant d’élaborer des “théories de transitions”. Ces théories de transitions sont communément qualifiées de “fausses”, sans plus. Or, dans leur processus d’apprentissage, les enfants se construisent des modèles qui leur permettent de se faire la main avant de les abandonner s'ils se révèlent inadéquats. Papert s’appuie ici sur les travaux de Piaget&lt;ref&gt;Piaget Jean &quot; L’épistémologie génétique&quot;, Paris, PUF, 1970&lt;/ref&gt; qui démontrent que ces fausses théories qu’élaborent les enfants sont nécessaires pour apprendre à penser. Les théories non orthodoxes des jeunes enfants ne résultent pas d’une faiblesse, mais sont un moyen pour eux d’assouplir leurs facultés cognitives, de développer en s’entraînant leur aptitude à la construction de théories plus orthodoxes. Les micromondes procureront, donc, aux enfants l’occasion de se construire des théories à eux et de les confronter à la réalité des choses en les testant sur l’ordinateur. De la sorte, ils entrent sans le savoir dans une démarche scientifique classique, mais ce nouveau statut de l'erreur sera une fois encore une autre pierre d’achoppement pour Logo.

==== La programmation structurée comme modèle de pensée ====
Piaget s'est interrogé sur une certaine convergence entre les résultats de ses recherches sur la genèse des opérations logiques et mathématiques et un certain nombre de résultats mathématiques atteints dans leurs recherches des structures-mères ([[Structure (mathématiques)|Structure_]]) par les [[Nicolas Bourbaki|Bourbaki]].

Chez ces derniers, une structure complexe est une combinaison de structures plus simples, dont les plus importantes sont des structures mères qui constituent des éléments fondamentaux. Or, Piaget va observer que les enfants développent des structures intellectuelles proches de ces dernières :
* chacune représente une activité cohérente dans la vie de l’enfant et pourrait en principe être développée indépendamment des autres ;
* chacune est intrinsèquement simple et permettent des regroupements (pas toujours conscients) ;
* elles possèdent une cohérence : elles s’acquièrent en parallèles les unes des autres et possèdent en commun un aspect formel.

Il existerait, donc, une similitude entre le parcours de l’enfant construisant l’arithmétique élémentaire et l’histoire de la mathématique, mais également entre les mécanismes qui permettent aux deux de construire une nouvelle connaissance plus complexe à partir d’anciennes plus simples. En bref, l’acquisition d’une structure facilite l’acquisition des autres.

Papert étend cette similitude à l’informatique par une autre correspondance avec la programmation : des procédures simples, en s’assemblant, peuvent former des résultats complexes.
Alors que Piaget cherchait à comprendre comment se développe l’enfant ''hinc et nunc'', Papert cherche à agir sur le développement via le nouvel environnement culturel permis par l’ordinateur. La culture informatique peut “''grandement renforcer, chez les enfants, leur capacité à concevoir les structures en place sous des aspects qui mobiliseront leur potentiel conceptuel''”&lt;ref&gt;(Papert, 1981, o.c.)&lt;/ref&gt;. Mais cela n’est possible que lorsque le langage informatique dispose de procédures pures (autonomes et mobilisables de manière modulaire) comme c’est le cas en Logo. En effet, dans son emploi, la programmation structurée devient assez vite indispensable. Elle consiste à découper un tout en petites parties indépendantes qui, une fois au point, peuvent entrer une ou plusieurs fois dans le tout. Dès qu’un enfant a un projet un peu ambitieux, il est confronté au handicap de répétition et à la difficulté de débugage. Or, ce dernier est largement facilité lorsque le projet est découpé en petites procédures (modules).

L’hypothèse de Papert est que la pratique de la programmation structurée aura des conséquences sur le raisonnement de l’enfant face à certaines autres tâches complexes dans la mesure où il y aura transfert de cette manière de décrire et d’aborder un problème  lorsqu’il sera confronté à d’autres situations situées dans un autre champ d’action.au nouveau problème qui se pose à lui. Mais encore faut-il pour cela que l’enfant accède à cette programmation structurée ! Encore une pierre d'achoppement.

=== La Tortue à l’épreuve de la pédagogie ===

Dans un premier temps, les enseignants, sans y être forcément favorables, ont bien accueilli l’alternative que leur apportait Logo comme un moindre mal à l’introduction de l’ordinateur à l’école face à l’enseignement assisté ([[EAO]]) ou à l’[[enseignement programmé]] par l’ordinateur (EPO). Rares furent toutefois ceux qui adhéraient à la vision de Papert en connaissance de cause tant sur le plan de l’apprentissage que sur celui de l'impact possible du nouvel outil informatique sur l'enseignement. Rien d’étonnant, dès lors, à ce que les conceptions des mises en œuvre de Logo divergeront rapidement entre un monde pédagogique centré sur le « comment produire un ''enseignement'' efficace ? »  et  Papert, centré comme Piaget sur le « quelles sont les conditions proprices à un ''apprentissage'' efficace ? ». Mais, par ailleurs, on ne peut nier que certains aspects de Logo faisaient problème (cf infra).

Il reste que comme le constate Jean-Michel Chevalier, &quot;''L'intensité des critiques (des pédagogues) est à la hauteur de l'engouement qu'il suscite dans les années 80''&quot;&lt;ref&gt;http://edutice.archives-ouvertes.fr/docs/00/35/92/36/PDF/d14p177.pdf&lt;/ref&gt;. Ceux-ci sont, en effet, guidés avant toute chose par un souci de rentabilité et de gain de temps en contexte scolaire, Tout à l'opposé de Papert.

Sur le plan expérimental, Logo avait d’abord été utilisé dans une approche surtout individualiste propre au contexte américain. En France, Gérard Bossuet va rapidement le présenter comme n’étant pas seulement un objet structurant, mais également comme un prétexte à la communication avec les autres, enfants ou adultes, au même titre que, par exemple, l’imprimerie chez [[Célestin Freinet]] &lt;ref&gt;Bossuet 1983, o. c.&lt;/ref&gt;. Partant de l’idée que la classe forme une micro-société englobant enfants, enseignants mais aussi parents et s’inspirant des travaux de Doise et Mugny sur l’importance de l’interaction sociale dans le développement cognitif&lt;ref&gt;Willem Doise et Gabriel Mugny, &quot;Le développement social de l'intelligence&quot;, Paris, InterÉditions, 1981&lt;/ref&gt;, Pierre Biernaux franchit encore un pas en expérimentant l’introduction des ateliers à l’intérieur même de cet autre entité sociale qu’est l’école - démarche qui impliquait nécessairement l’inclusion de l’équipe de chercheurs dans ses observations&lt;ref&gt;Biernaux, Pierre, &quot;Le système LOGO, {{3e}} année d'expériences'' in &quot;Informatique et société&quot;, Nicole Delruelle-Vosswinkel et Emile Peeters, eds, Éditions de l'Université de Bruxelles, 1984, ISBN 2- 800408-375&lt;/ref&gt;.
Plus tard, Resnick intégrera cette dimension de travail en groupe dans l’idée de « constructionnisme ».

==== Apprendre en « Mathématie » peut être déconcertant… pour l’enseignant ====

Très tôt, souvent dans le cadre de thèses de doctorat, des chercheurs se sont intéressés aux apport de Logo dans leur domaine - celui de l’enseignement des mathématiques - soit pour faciliter l’accession de certains concepts : géométrie, variable, récursion,… soit pour étudier l’opportunité de l’intégrer dans le cursus d’algèbre ou de géométrie&lt;ref&gt;HOYLES Celia, NOSS, Richard, eds « Learning mathematics and Logo », MIT, Boston (Mass.), 1982,  ISBN 0-262-08207-1&lt;/ref&gt;. Le plus souvent, ceci s’adressait à des élèves plus âgés et Papert, de rappeler dans la préface de l’ouvrage précité que le but de Logo était aussi, sinon avant tout de donner aux jeunes enfants la possibilité de se familiariser très tôt avec des notions proches, d’y &quot;toucher&quot; (to feel) sans pour autant forcément déjà en comprendre la signification, mais de sorte que soit facilitée leur acquisition plus tard.

Si pour ces spécialistes, l’enjeu était palpable, il en allait bien autrement dans l’enseignement proprement dit auprès de jeunes enfants qui œuvre dans un cadre d’objectifs à atteindre au travers d’un programme bien établi.  
En effet, la géométrie tortue ne correspond pas toujours à celle enseignée dans les écoles dans la mesure où la tortue se déplace comme le fait de manière naturelle – et dont il peut en prendre conscience  - l’enfant qui la commande : partir d’où on est, prendre une direction et avancer dans celle-ci d’un certain nombre de pas (&quot;''jouer « tortue''&quot;). Ainsi en va-t-il, par exemple, de la famille des polygones réguliers et, plus précisément, du triangle.

Dans l’enseignement, les polygones convexes réguliers sont définis par des angles et des côtés égaux. En Logo, ils se construisent par la formule générale qui obéit au Théorème du Tour complet de la Tortue (TTT) en 360° :

:REPETE N (AVANCE nbr, DROITE 360/N)

En considérant que le polygone se dessine par la droite et où nbr est un nombre quelconque et N est le nombre d’angles et de côtés, compris entre 3 et l’infini (note : Si N = 1, on obtient un point et si N= 2, un segment de droite).

Or, le problème se pose pour le triangle dont on enseigne que la somme de ses angles est toujours égale à 180°. Ce qui n’est pas le cas en Logo puisque l’on fait tourner la tortue 3 fois à 120°.
En fait, dans son exploration de l’espace, le robot tortue contourne l’objet géométrique. Tout comme l’enfant qui la commande, parcourerait un triangle sur le sol, elle le dessine sans en avoir une connaissance (ou une définition) préétablie. En conséquence de quoi, ses rotations doivent se penser en termes d’[[angles supplémentaires]] et non d’angles &quot;internes&quot;. En effet, la tortue s’arrêtant avant de tourner « regarde » devant elle, c’est-à-dire, dans le sens du segment de droite qu’elle vient de dessiner, puis tourne dans celui où elle va dessiner ensuite.

Ceci, comme d'autres aspects, ne va pas manquer d'être très déconcertant pour certains enseignants.

==== « ''Est-ce  Logo marche ? Nous constatons que oui, il marche à conditions de lui donner des jambes pédagogiques.''&lt;ref&gt;De Marcellus Olivier, « Pédagogie active et projets de classe en Logowriter » in Gurtner et Retschiski, 1991, ouvrage cité ci-après&lt;/ref&gt;&quot; ====
Plus tard vont apparaître d’autres recherches dans un champ plus large que l’apport mathématique de Logo et, plus particulièrement, sur son apport possible dans l’enseignement en général&lt;ref&gt;Gurtner J.-L. &amp; Retschitzki J. (éds.). &quot;Logo et apprentissages&quot;, Delachaux et Niestlé, Lausanne, 1991&lt;/ref&gt;.
Ici, l’optique, est, donc, claire :en quoi Logo peut aider l'enseignant dans la poursuite de ses objectifs :

« En éducation, l’informatique peut être d’abord considérée comme une technologie éducative, c’est-à-dire un ensemble de moyens pouvant faciliter l’enseignement et l’apprentissage des disciplines scolaires traditionnelles. »
&lt;ref&gt;Bruillard Éric, « Informatique et éducation : quelques liens entre connaissances et technologie. » in Agostellini S. « Comment penser la communication des connaissances », Paris, L’Harmattant, 1999&lt;/ref&gt;

Mais force est de constater que les phases expérimentales de ces recherches vont se révéler souvent bien courtes pour évaluer les effets à terme de son usage comme le regrette, par exemple, Valke qui, bien que n’observant pas de différences significatives entre son groupe expérimental et son groupe témoin, croit toutefois pouvoir déceler une tendance très claire : si la période de recherche avait été plus longue, un effet aurait pu apparaître &lt;ref&gt;Valcke Martin, « Micro-mondes et mathématiques au primaire» in Gurtner et Retschiski, 1991, o. c.&lt;/ref&gt;.

Or, de leur côté, Verchaffen, De Corte et Schrooten font remarquer l’importance d’un quota minimum d’heures de pratiques qui devrait, effectivement, avoir un impact sur les aptitudes cognitives des élèves des écoles élémentaires.. mais à condition que cette pratique soit conduite dans un environnement didactique vigoureux et orienté. Il estiment ce quota à une cinquantaine d’heures &lt;ref&gt;Verchaffen Lieve , De Corte Eric et Schrooten Hilde « Transfert des stratégies cognitives » in Gurtner et Retschiski, 1991, o. c.&lt;/ref&gt;.

Cette inquiétude de ne pas voir apparaître des résultats qui soient à la fois rapides et tangibles peut s’observer d’une autre manière comme chez Noss et Hoyles qui s’interrogent sur le plaisir d’utiliser REPETE ou le retour au mode pilotage, c’est-à-dire que l’élève ne prend pas appui sur le mode procédural pourtant déjà employé. Ils en tirent les conclusions qu’ils n’ont pas réfléchi sur les structures mathématiques et n’ont pas intégré la compréhension de l’outil &lt;ref&gt;Noss Richard, Hoyles Celia, « Deux pas en avant, un pas en arrière », in Gurtner et Retschiski, 1991, o. c.&lt;/ref&gt;.

Ce à quoi, Papert avait déjà répondu dans la préface de l’ouvrage précité de Hoyles et Noss, en soulignant que le plaisir de cette exploitation de cette commande magique par les enfants constitue, en fait, une approche de la récursivité. D’autre part,  l’intérêt que constitue la commande REPETE n fois en tant qu’une approche intuitive de la multiplication ; même si elle n’est pas évidente de premier abord.

Somme toute, l’apport de ces recherches expérimentales ne peut se comprendre à la lumière de s’éclairer par l'aphorisme suivant : « ''S’il faut neuf mois à une femme pour concevoir un enfant, suffit-il d’en réunir neuf pendant un mois pour arriver au même résultat ?'' ».
Or, Papert inscrit l’apport de l’informatique (et de Logo) dans une perspective de changement culturel, c’est-à-dire à long terme. Mais, par ailleurs, il faut bien avouer combien est difficile de trouver les moyens pour mener une recherche sur si long terme. Ainsi, Biernaux &lt;ref&gt;Biernaux, o. c.,1984&lt;/ref&gt; va s'y atteler en suivant des enfants de 4 classes pendant 7 années mais ne pourra exploiter les observations obtenues faute de moyens, mais aussi par le désintérêt suscité par Logo après un aussi long laps de temps.

==== L’accompagnement : problème central de l’environnement Logo ====

S’ils saluent sa relative simplicité et son caractère ludique qui rendent les premiers pas facile, Retschitzki et Gurtner insisteront plus tard sur le fait que Logo n'est ni aussi simple qu’il n’y paraît, ni véritablement limité dans ses possibilités. Par conséquent, pour que sa pratique soit profitable, un accompagnement est nécessaire mais il importe non seulement que celui-ci se fasse de manière continue mais surtout qu’il soit de qualité et, donc, opéré par des personnes disposant en la matière d’un sérieuse compétence&lt;ref&gt;Retschitzki, J. &amp; Gurtner, J.-L. « L ‘enfant et l’ordinateur », Mardaga, Sprimont (Belgique), 1996, ISBN 2-87009-633-X&lt;/ref&gt;. Observation plus que pertinente, mais qui reste à définir : par exemple, comment répondre à une équipe avec une pratique d’un heure par semaine pendant 6 ans qui demande à son enseignante comment écrire un programme en Logo qui compte le nombre de matchs à organiser pour un tournoi de ping-pong ? Que faire si une équipe de deux enfants de 6 ans, avec un an de logo dans les mêmes conditions, décide de construire une échelle '''centrée''' sur l’écran ?

À cet égard, il faut bien reconnaître que Papert reste sans doute par trop dans le vague à l’instar, d’ailleurs, de son maître à penser Piaget qui n’a jamais fourni (ou voulu fournir) d’indications claires en la matière (pour peu que cela soit possible). Mais, des travaux de l’un et de l’autre, on peut imaginer une pédagogie qui ne céderait ni au romantisme rousseauiste, ni à l’empirisme de l’éducation traditionnelle qui conçoit l’esprit de l’enfant comme entièrement – et exclusivement - formé par les interventions des adultes ou, éventuellement, d’enfants plus avancés. Mais, par contre, qui soulignerait l’importance d’un modèle d’éducation qui s’appuie sur l’activité constructrice et créative de l’enfant sans pour autant nier les rôles de la transmission culturelle et de l’interaction sociale.

Bref, il n’existe pas de recettes toutes faites en la matière.

C’est ainsi que pût s’observer aussi bien une large éventail de modalités d’accompagnement allant de la non-directivité complète aux manuels avec exercices préétablis de Christina Gaillard&lt;ref&gt;voir : Gaillard , « Je découvre Logo – Cahier de l’élève CM2 », Hachette, Paris, 1986 ; Je découvre Logo – livre du maître », Hachette, Paris, 1986, ISBN 2-01-012163-5 ;« Je découvre Logo CM1 (cahier de l’élève), », Hachette  Écoles, 1996, ISBN : 2-01-012013-2 ; « Je découvre Logo CM1 : livre du maître », Hachette informatique, 1996, ISBN 2-01-012014-0&lt;/ref&gt;.&lt;br /&gt;
===== l'approche pédagogique ou scolaire =====
Comme il fallait s’y attendre, à coup d’expérimentations contrôlées et de tests statistiques, les pédagogues se sont appliqués à proposer leurs recettes pour un bon usage de Logo, avec en vue l’optimisation de son efficacité dans un usage scolaire.
Par exemple, Tamara Lemerisie et d’autres vont proposer une classification hiérarchisée en fonction d’une efficacité croissante&lt;ref&gt;Lemersie Tamara  « ''Evolution d'un devis pédagogique favorisant le développement de la pensée procédurale en LOGO'' ». Résumé des actes du Colloque Logo et apprentissages, Fribourg, Suisse, 3-6 octobre 1990&lt;/ref&gt;{{,}}&lt;ref&gt;Lemerise Tamara, Dessurealt Claude, Marcotte « ''Élaboration d'un environnement logo favorable au développement d'habiletés en manipulation procédurale'' « Educational Studies in Mathematics Août 1992, Volume 23, Issue 4, pp 351-382&lt;/ref&gt; :
* Les projets libres : les projets sont choisis par les enfants  et les interventions du « maître » sont limitées aux demandes de l’enfant. Ce type d’environnement pédagogique - décrits faussement comme inspirés directement par la pratique de Papert – est tout de suite rejeté à partir de la constatation que la moitié des élèves ne savent pas exprimer ce qu’ils ont appris ou disent n’avoir rien appris… 
* Les projets orientés : qui sont, en réalité, des propositions émises par l’enseignant de réaliser des objectifs concrets : damiers, textes,… Ce qui se heurte à la nécessité d’une acquisition préalable de la création et de l’agencement des procédures… 
* Les projets structurés : proposés également par les enseignants en vue de favoriser la compréhension et la mémorisation de certains concepts et qui permettraient de contourner l’obstacle de l’acquisition du mode procédural.

En conséquence de quoi, s'appuyant sur les études précitées, Olivier De Marcellus proposera une sorte de vade-mecum du bon animateur Logo :&quot;
*Avoir des choses vraiment alléchantes à proposer (de vrais productions, c’es-à-dire perçues comme telles pas les élèves). Cela rejoint les propositions de S. Papert dans le cadre socio-cognitif (sic).
* Disposer d’un plan du micro-monde en question (resic) qui mène facilement d’une chose à l’autre (scénarios).
* Savoir clairement, dans chaque situation, ce qu’il (resic) va apporter et ce qu’il va demander aux élèves de fournir (scénarios et cahier d’élève).
* Savoir contrôler après coup ce que les élèves ont vraiment amené, ce qu’ils ont à peu près (resic) compris, ou si on leur a tout soufflé.
* Pouvoir prendre suffisamment de recul par rapport à la réalisation technique pour pouvoir faire réfléchir les élèves sur comment le projet fonctionne, relever le sens plus général des mécanismes expérimentés par rapport à l’informatique (resic), expliciter certaines démarches et concepts intellectuels.»&lt;ref&gt;De Marcellus Olivier (1990) « ''Pédagogie active et projets de classe avec Logowriter''.» Résumé des actes du Colloque Logo et apprentissages, Fribourg, Suisse, 3-6, octobre 1990.&lt;/ref&gt;

On est loin, très loin, des principes directeurs à la base du projet tel qu’énoncés par Papert (notamment sur le concept socio-cognitif) et, à la lecture de ce qui précède, on comprend mieux ses déclarations de 1997 citées en début de partie.
D’une manière plus générale, on est, en effet, frappé de l’absence d’autonomie laissée à l’enfant (devenu ici l’élève) dans la démarche ainsi que du gommage de l’aspect affectif dans son apprentissage, et, dès lors, on peut s’interroger sur les démarches ou concepts rééellement acquis. En vertu de quoi, il devenait légitime de se poser la question de l’utilité de Logo dans un tel contexte surtout eu égards aux coûts non négligeables tant en termes d’investissements personnels que matériels.

===== l'approche &quot;facilitation&quot; =====
Aux antipodes de ces démarches visant à « scolariser » Logo qui leur sont postérieures, les premiers usages de Logo étaient fortement teintés de cette non-directivité telle que décrite par Lemerise comme les « projets libres » où la passivité de l’accompagnateur est la règle. De fait, si l’attitude passive peut fonctionner lors de la découverte de Logo, durant la phase de « pilotage » de la tortue durant laquelle peut-être même est-elle souhaitable, elle montre vite ses limites. Mais celle-ci reflétait-elle bien la pensée de Papert et de Piaget ?

L’utilisation du terme « facilitateur » par Papert et, à sa suite, par Bossuet, semble avoir, en effet, induit chez certain l’idée d’une référence implicite à [[Carl Rogers]] qui n’est pourtant jamais cité par ces auteurs. Avant toute chose, il convient de rappeler que celui-ci, primo-auteur de la formule n’a, en définitive, jamais été non-directif. Lui-même est revenu d’ailleurs sur ce terme en lui préférant celui d’Approche Centrée sur la Personne&lt;ref&gt;http://www.acp-pr.org/caracteristiques.html&lt;/ref&gt;. La non-directivité n’est pas le laisser-faire ou le laxisme comme aiment à le faire croire autant ses détracteurs que parfois ses apologistes&lt;ref&gt;http://acp-pr.org/Resources/La%20Non%20directivite_Y_St_Arnaud.pdf&lt;/ref&gt;.

Par ailleurs, Papert parle en réalité de « ''facilitateur d’apprentissage'' » Tant dans les videos disponibles que dans « Jaillissement de l’esprit », il ne se confine nullement dans une attitude passive où il se bornerait à attendre les demandes des enfants, mais intervient, suggérant ici une solution, soulignant là une situation qu’il estime exploitable : « ''une situation riche'' ». La question reste comment et quand intervenir à bon escient ?

Forte d’une expérience de sept années de faciltateur dans un atelier Logo inséré dans une école, Mirelle Daubresse considérera comme essentielle le respect de l’autonomie de l’apprentissage chez les enfants si l’on veut que leur intérêt reste constant et qu’ils puissent trouver dans leurs activités en Logo les matériaux dont ils ont, personnellement, besoin et/ou qu’il leur seraient utiles&lt;ref&gt;Daubresse Mireille, « ''Cahiers de formation 1985-88'' », Groupe de Recherche sur l’Apprentissage Autonome et Logo (G.R.A.A.L., Université Libre de Bruxelles, documents non publiés&lt;/ref&gt;. 
De l’approche centrée sur la personne (en l’occurrence, l’enfant) de Rogers&lt;ref&gt;http://www.acp-pr.org/caracteristiques.htm&lt;/ref&gt;, elle retient que le rôle du facilitateur d’apprentissage est d’aider à choisir et à clarifier les projets des enfants de l’atelier, et de prendre en compte le désir de chacun de réaliser les projets, seul ou en équipe, qui ont une signification pour lui car c’est là que se niche  la force motivante qui va soutenir un apprentissage significatif. Mais, dans le cadre spécifique de Logo, d’autres exigences sont requises : 
* Une connaissance approfondie du langage pour pouvoir toujours garder une longueur d’avance sur l’élève mais également une pratique ''tout azimuth'' qui permette de pouvoir le suivre sa démarche et non de risquer d’imposer ou de privilégier la sienne.
* Una appréhension suffisante – avec adhésion - des théories constructivistes de Piaget sans lesquelles il n’est pas possible d’interpréter à leur juste valeur les démarches d’’apprentissage et de les replacer dans le contexte de l'âge, voire de  difficultés personnelles.
* Un entraînement à l’observation clinique qui permette un suivi continu nécessaire mais difficile dans un atelier où tant les enfants que leur projets différent dans leur degrés de difficultés et d’élaboration.

Quant aux principes d’intervention proprement dits, notamment en vue d’aider les enfants à franchir un pas de plus, elle considére qu’un principe doit toujours guider le facilitateur : garder constammant en-tête la notion d’équilibration&lt;ref&gt;voir [[Processus cognitifs]]&lt;/ref&gt; développée par Piaget, selon laquelle, pour être efficace, le déséquilibre, ici provoqué, ne doit jamais être ni insuffisant, ni être excessif, et s’appuyer sur les acquis  &lt;ref&gt;Piaget Jean, « L'équilibration des structures cognitives : problème central du développement » Paris: Presses univ. de France, Paris, 1975&lt;/ref&gt;{{,}}&lt;ref&gt;http://www.fondationjeanpiaget.ch/fjp/site/ModuleFJP001/index_gen_page.php?IDPAGE=122&amp;IDMODULE=22&lt;/ref&gt;.

Quand on sait que cette formation, appuyée par des longs extraits video in situ et des analyse de projets réels s’adressait à de petits groupes sur 20 jours répartis sur une année, on mesure combien l’accompagnement en Logo implique d’engagement personnel. Y compris, d'ailleurs, dans son usage plus &quot;scolaire&quot;.

==== Une tortue prétexte : le dimension affective ====

Comme signalé plus haut, Papert insiste sur le rôle de l’affectivité dans l’apprentissage. Si cet aspect est bien présent dans la dernière approche décrite ci-dessus, il l’est beaucoup moins dans l’approche pédagogique qui semble l’avoir gommée dans ses expérimentations. Mais force est de reconnaître avec Piaget que les outils pour la valider ou simplement l’étudier n’existent pas en dehors d’une observation forcément individuelle et, donc, peu propice à une généralisation.
En annexe, on trouvera quelques exemples tirés d’expériences en atelier dans lesquelles les praticiens de Logo se retrouveront certainement. Ils peuvent apporter un éclairage sur les événements affectifs susceptibles d’exercer une influence sur les apprentissages tels qu’ils peuvent survenir dans un environnement Logo. Soulignons au passage que la tortue, cet animal emblème, même si son choix doit beaucoup au hasard, présente des caractéristiques relativement neutres d’un point de vue affectif : un animal sympathique mais sans plus. Pas vraiment à chouchouter.

A leur lecture, on ne peut que regretter l’absence de publications relatives à l’utilisation de Logo en matière de remédiation et, plus généralement, sur la manière dont les enfants se saisissent de Logo pour régler certains obstacles à leur apprentissage. Ni, en miroir, comment son usage permet de détecter ces derniers. Par exemple, plusieurs mémoires de fin d’études ont été rédigés sur ce sujet à l’Université de Lille 2 ou à l’Institut Marie Haps à Bruxelles selon lesquels de bons résultats avaient été obtenu en orthophonie/logopédie.

Or, d’une manière générale c’est, semble-t-il avec les enfants présentant des difficultés d’apprentissage que Logo et sa tortue se sont révélés particulièrement prometteur dans la mesure, entre autres, qu’il ne demandait qu’un investissement limité à un personnel aguerri en la matière.

== Épilogue ==

Logo a marqué le passage d’une conception de l’emploi de l’ordinateur dans l’enseignement reposant sur un usage tutorial vers sa maîtrise que l’on jugeait devenir indispensable. L’enjeu, à cette époque, n’était pas nécessairement de favoriser l’apprentissage comme le concevait Papert, mais celui d’une véritable acculturation passant par sa programmation : la question était déjà posée au début des années 70 de savoir combien de temps quelqu’un qui ne connaît rien à l’ordinateur pourra être considéré comme instruit&lt;ref&gt;Luehrmann Arthur W. “Should the computer teach the student, or vice versa ?”, in Proceedings Spring Joint Conference, p. 407-410, New York, ACM, 1972&lt;/ref&gt;.
Lorsqu’il apparaît dans le paysage informatique, une autre question commençait à se poser : est-ce que l’alternative se limite bien à ce seul choix ou n’existe-t-il pas une troisième voie : celle d’un outil&lt;ref&gt;Taylor Robert P ( sous la direction de), « The Computer in the School : Tutor, Tool, Tutee, Teachers », College Press, Columbia University, New York, 1980&lt;/ref&gt;.
En effet, à cette époque sortiront les premiers logiciels bureautiques comme, par exemple, sur l’Apple II, [[Visicalc]] (tableur), Visidex (Gestion de fiches), Visifile (base de données) ou Visi On (générateur de graphiques) développés par Visicorp, ou encore Apple Plot (générateur de graphiques) et Apple Pie (Traitement de texte).

Commentant son texte 30 ans plus tard, Luehrmann concédait que, dans la trichotomie exposée par Taylor, c’est seulement l’utilisation comme outil qui a eu véritablement un impact dans les écoles et, plus particulièrement, les tableurs &lt;ref&gt;Luehrmann Arthur W. ,&quot;Should the computer teach the student...&quot; — 30 years later”, in Contemporary Issues in Technology and Teacher Education [Online serial], Volume 2, n° 3, 2002&lt;/ref&gt;.
Tout comme Papert, il concluait en regrettant le monopole de l’école sur l’éducation qui empêche les innovations. Prônant le développement des cours sur Internet, rejoignant ainsi le point de vue de plusieurs auteurs&lt;ref&gt;Christensen Clayton, Horn Michael, Johnson Curtis W., « Disrupting Class : How Disruptive Innovation Will Change the Way the World Learns », McGraw-Hills books, New York, 2008&lt;/ref&gt;{{,}}&lt;ref&gt;Collins Allan, Halverson Richard, « Rethinking Education in the Age of Technology : The Digital Revolution and Schooling in America », Teachers College Press, New York, 2009&lt;/ref&gt;{{,}}&lt;ref&gt;http://www.inrp.fr/Tecne/ressources/dea_giannoula_memoire.pdf&lt;/ref&gt; qui, pensant que les systèmes éducatifs actuels ne peuvent pas sérieusement intégrer les technologies informatiques, prévoient des changements très profonds des modes de scolarisation.

Mais, même s’il a joué un grand rôle, l’abandon de Logo ne doit pas seulement se comprendre au travers de son rejet par un monde pédagogique orienté sur l’enseignement plus que sur l’apprentissage et, en définitive plus soucieux de l’enseignant que de l’apprenant. L'essor de ce qu’on appelait alors les microordinateurs a d’abord profité à Logo mais celui-ci a souffert ensuite de leur succès et de l’accélération de l’innovation en la matière qui allait lui retirer plusieurs de ses principaux atouts :

* Le plaisir ressenti par l’enfant de la tortue de faire quelque chose de beau ne pèsera plus grand chose devant, par exemple, la finesse d’exécution offerte par le [[Macintosh]] et la facilité offerte par [[MacPaint]].
* La diffusion de l’ordinateur personnel lui retirera la valorisation par l’environnement social (cf principe de résonance culturelle) en même temps que le plaisir de la nouveauté.
* Le plaisir de commander et de faire faire (cf principe de puissance), les enfants le trouveront à moindre peine dans les jeux, et, cela, dès le plus jeune âge, c’est-à-dire avant même d’entrer à l’école&lt;ref&gt;{{ouvrage |langue=en |prénom1=Sherry |nom1=Turkle |titre=The Second Self: Computers and the Human Spirit|numéro d'édition=20|éditeur=MIT Press|lien éditeur=MIT Press|lieu=Cambridge, MA |année=2005 |pages totales=372 |isbn=978-0-262-70111-2 |présentation en ligne=http://books.google.lu/books?id=2PfkQwAACAAJ |consulté le= }}, initialement publié en 1984&lt;/ref&gt;.

'''En outre, il faut le rappeler, personne à l’époque n’avait vu venir l’Internet'''.

Papert a-t-il vraiment cru que Logo allait changer l’école ? Vraisemblablement pas, mais jusqu’à son accident de 2006 qui a mis fin à sa carrière de chercheur, il est resté convaincu, plus encore que d’autres, que l’informatique – et plus spécifiquement l’ordinateur personnel - allait modifier les conditions des apprentissages entraînant de manière inéluctable des changements dans l’enseignement et, par voie de conséquence, de l’école appelée, selon lui, à devenir obsolète à moyen terme. Dans cette perspective, il s’intéressera, notamment vers les conceptions de pédagogies actives de [[Pédagogie Montessori|Montessori]] ou de [[John Dewey|Dewey]].

En l'occurrence, Logo doit être considéré a posteriori comme un premier pas dans cette dynamique qui a bousculé le paradigme univoque de l’utilisation tutoriale de l’informatique. Pour Papert, il a été certainement l’occasion d’une mise en pratique de ce qu’il avait appris auprès de Piaget.
&lt;br /&gt;
Extrait d'un entretien avec Papert&lt;ref&gt;&quot;Un défi de taille pour l’école, entretien avec Papert &quot; N°446 - Cahiers pédagogiques, Dossier &quot;Le numérique à l’école&quot;, septembre 2001 http://www.cahiers-pedagogiques.com/spip.php?article2615&lt;/ref&gt; :

:« ''En 20 ans, les choses ont changé, les ordinateurs se sont répandus, ils ne sont plus seulement à l’école. Ils sont présents dans les maisons, par exemple''.
:Ce changement est important. L’école cède le pas à ce qui se passe à l’extérieur parce que cela est plus intéressant pour les enfants. À présent, ils peuvent être actifs avec des ordinateurs. Ils peuvent apprendre sans l’école. (…)
:
:''N’est-ce pas un problème si les enfants utilisent ces ordinateurs sans enseignant ? ''
:Pourquoi ? Il existe souvent des enfants qui collectivement en savent plus que leur enseignant. (…) , à présent, il y a plus de choses intéressantes à l’extérieur qu’à l’intérieur de l’école.
:
:''Dans ces conditions, comment l’ordinateur peut-il améliorer l’école ? ''
:Les ordinateurs ont plutôt la capacité de substituer une autre structure à l’école, pas de l’améliorer.
:
:''Internet jouera un rôle dans ce sens ?''
:Oui si Internet permet de se relier ensemble pour mener des projets, non dans ses usages actuels. (…)
:
:En 10 ou 15 ans, l’école va devenir obsolète, parce que ce qui s’y passe est une manière artificielle d’apprendre. On apprend vraiment parce qu’on en a besoin pour atteindre un objectif et pas parce qu’on nous dit qu’il faut l’apprendre &quot;
:

== Notes et références ==
{{Références|colonnes=2}}
* Si vous disposez de [[GNU-Linux]], et des [[CD-ROM]] [[Debian]] ou d'une connexion [[Internet]], vous pouvez installer '''Logo''', en tapant la commande « apt-get install ucblogo ». Pour le lancer, taper « logo » (version anglaise avec licence [[Licence publique générale GNU|GPL]])

== Annexes ==
{{Autres projets
|wikibooks=Programmation Logo
|wikibooks titre=Le langage de programmation Logo
}}

=== Articles connexes ===
* [[Seymour Papert]]
* [[Jean Piaget]]

=== Liens externes ===
* [http://www.algo.be/logo.html Logo - Apprendre à programmer, programmer pour apprendre] (Ressources Logo libres pour MS Windows et Linux)
* [http://el.media.mit.edu/logo-foundation/ Fondation Logo], soutenue par le [[MIT Media Lab]].
* {{mul}} {{ODP|Computers/Programming/Languages/Lisp/Logo/|Logo}}
* &quot;Un défi de taille pour l’école, entretien avec Papert &quot; N°446 - Cahiers pédagogiques, Dossier &quot;Le numérique à l’école&quot;, septembre 2001 http://www.cahiers-pedagogiques.com/spip.php?article2615
* Eftalia Giannoula, &quot;Lenfant et l'ordinateur : pratiques familiales et attentes scolaires&quot; (Universite René Descartes, Paris, 2000 (mémoire) http://www.inrp.fr/Tecne/ressources/dea_giannoula_memoire.pdf
* Turkle Sherry, &quot;The second self : Computers and the human spitit&quot;, MIT press, Mass., 1984, (ISBN 0-262-70111-1)
* http://www.programmer-a-l-ecole.fr Site personnel d'un professeur des écoles parisien qui enseigne la programmation - et en particulier le LOGO - à des élèves de cycle 3 .

{{Palette Langages de programmation}}
{{Portail|programmation informatique|TICE}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Micromonde]]
[[Catégorie:Logiciel éducatif]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour Linux]]
[[Catégorie:Logiciel pour Mac OS]]</text>
      <sha1>stu6mp86tdckwypq2o2alzxu2odoge9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Algol (langage)</title>
    <ns>0</ns>
    <id>8256</id>
    <revision>
      <id>101102469</id>
      <parentid>101102215</parentid>
      <timestamp>2014-02-09T21:42:58Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>syntaxe + typographie + wikif.</comment>
      <text xml:space="preserve" bytes="8444">{{Voir homonymes|Algol}}

'''Algol''' est un [[langage de programmation]]. Il a été créé à la fin des [[années 1950]]. Dérivé d'un projet UNESCO d'abord appelé IAL (''{{lang|en|International Algebraic Language}}''), son nom est l'[[Acronymie|acronyme]] d'{{Lang|en|'''''alg'''orithmic '''o'''riented '''l'''anguage''}} {{Référence nécessaire|(avec un clin d'œil à l'[[Beta Persei|étoile β Persei]])|date=[…] car : l'homonymie avec cette étoile est-elle volontaire ou le fruit du hasard ?}}. Son objectif était de décrire algorithmiquement des problèmes de programmation. Les principales différences au niveau de la conception par rapport à [[Fortran]] furent l'utilisation de blocs marqués par BEGIN END, permettant variables locales et tableaux dynamiques, et surtout la [[récursivité]], concepts qui seront largement repris par ses successeurs.

Le langage existe en trois versions : '''Algol 58''', '''Algol 60''' et '''[[Algol 68]]'''.

== Historique ==

Le premier rapport décrivant le langage date de [[1958]] et a donc donné lieu à Algol 58. Présentant des ambiguïtés sévères, il fut stabilisé sous le nom d'Algol 60, langage largement adopté dans les Universités, et qui fit faire des progrès importants à la compilation.
Ses trois principaux descendants sont :
* [[Algol 68]], conçu au Centre de Mathématiques Appliquées d'Amsterdam, et défini en décembre 1968 ; langage universel basé sur un système de 2 grammaires orthogonales (engendrant une grammaire potentiellement infinie) il permet de construire nouveaux types et nouveaux opérateurs, facilitant une approche très algébrique des applications ; jouant sur la puissance des mécanismes plutôt que sur leur nombre, il a été souvent perçu comme l'antithèse de [[PL/I]] ;
* [[Algol W]], créé peu après selon les propositions plus statiques de [[Niklaus Wirth]], membre du groupe de travail sur Algol 68 dont les propositions avaient été refusées. Wirth s'inspirera d'Algol W pour créer le [[Pascal (langage)|langage Pascal]], puis Modula 2 ;
* [[Simula]] (1967), conçu à Oslo, sur-ensemble d'Algol 60, ancêtre des langages objet (comme [[C++]], Modula 3, Oberon) permettant de définir des classes et des processus facilitant la [[simulation à événements discrets]].

Hormis un succès universitaire certain, Algol 60 sera peu utilisé dans des programmes commerciaux. Cela est dû au manque de fonctions standards d'entrée-sortie (corrigé en 1965 et surcorrigé dans Algol 68), et à une mauvaise adaptation aux programmes de gestion. Au plan scientifique, il était moins efficace que Fortran, tout en permettant des traitements a priori impossible dans ce langage.

Algol 60 a été publié en [[1960]]. [[John Backus]] et [[Peter Naur]] faisaient partie du comité qui l'a créé. Algol 60 a inspiré beaucoup de langages.  [[C. A. R. Hoare]] a déclaré à son sujet : « Voici un langage très en avance de son temps, il n'a pas seulement été une amélioration de ses prédécesseurs ''mais aussi une amélioration de presque tous ses successeurs'' ». Ce commentaire est parfois attribué faussement à [[Edsger Dijkstra]], célèbre aussi pour ses commentaires humoristiques.

La suite de cet article est principalement consacrée au langage Algol 60. En effet, sans mention de millésime le terme Algol désigne le langage Algol 60, tandis que les Algols désigne l'ensemble de la famille.

== Caractéristiques ==
Algol 60 est un langage typé, procédural récursif et à structure de blocs. Il permet un emploi dynamique des types mais ne permet pas à l'utilisateur d'en définir de nouveaux. Algol 60 a été défini sans instructions  d'entrées/sorties ; une implémentation sur une machine donnée en comportait nécessairement, mais elles variaient de l'une à l'autre. En réaction à cette situation, Algol 68 les a surspécifiées.

Algol 60 permet deux types de passage de paramètres lors de l'appel de procédure : [[passage par valeur]] et le [[passage par nom]], proche de la macro-substitution. Le passage par nom possède des qualités mal comprises, du fait d'une confusion avec le [[passage par référence]], plus répandu, aussi a-t-il été abandonné dans les successeurs d'Algol 60. Par exemple, on a reproché à ce mode Algol 60 l'impossibilité d'écrire une procédure échangeant deux valeurs si un des paramètres est un entier et l'autre un tableau indexé par ce même entier.

En réaction contre le manque de formalisme dans le projet Fortran, [[John Backus]] a conçu la [[Forme de Backus-Naur|BNF]] pour ''Backus Normal Form'' permettant la spécification de [[Algol 58]]. Cette méthode de description d'un langage a été révisée et étendue par [[Peter Naur]] sous le nom ''Backus Naur Form'' avec le même acronyme pour spécifier Algol 60, ainsi muni d'une [[grammaire indépendante du contexte]].

== Algol 68 ==

[[Algol 68]] a été défini comme langage universel basé sur des types et des opérateurs prédéfinis, des procédés de  construction de nouveaux types, et de nouveaux opérateurs avec possibilité de surcharge et d'extension des opérateurs prédéfinis, le tout permettant d'adapter le langage à chaque famille d'applications.

Comme une  [[grammaire indépendante du contexte]], telle que l'on peut définir avec BNF, s'avère une grammaire simple, que la rigueur demande de compléter par des restrictions sémantiques en langue naturelle, trop souvent ambiguës, l'équipe de [[Adriaan van Wijngaarden]] a retenu un système grammatical, dit {{Lien|trad=Van Wijngaarden grammar|grammaire de van Wijngaarden}} (seconde forme) couvrant la syntaxe en rapport avec la sémantique. S'appuyant sur une hyper-grammaire (donnant des schémas de règles ou hyper-règles) interagissant avec une méta-grammaire  (reflétant la théorie des types constructibles), le système grammatical produit une infinité de contraintes de BNF sémantiquement adéquates. Le Rapport Révisé a parfaitement illustré l'adéquation de ce dispositif, qui définit une syntaxe sémantiquement correcte. Cette approche totale facilite une compilation « carrée ».

==Architectures supportant Algol==
Le [[B5000]] de [[Burroughs Corporation]] et ses successeurs étaient des [[Automate à pile|machines à pile]] conçues pour être programmées avec un Algol étendu ; leur [[systèmes d'exploitation]] est écrit dans cet Algol depuis [[1961]], ouvrant la voie à l'écriture des systèmes d'exploitation en langage symbolique, reprise par [[Multics]] puis [[Unix]]. [[Unisys Corporation]] continue de commercialiser des machines descendant du B5000 supportant plusieurs compilateurs Algol étendus.

== Exemple de code (Algol 60) ==
Les programmes Algol 60 sont à format libre, avec le point-virgule comme séparateur principal. 
Les termes en caractère gras ('''procedure'''…) sont des mots réservés du langage. Chaque implémentation du langage peut utiliser sa propre convention lexicale (par exemple 'PROCEDURE').

 '''procedure''' Absmax(a) Taille:(n, m) Resultat:(y) Indices:(i, k);
     '''value''' n, m; '''array''' a; '''integer''' n, m, i, k; '''real''' y;
 '''comment'''  Dans la procédure Absmax (a, n, m, y, i, k)
          le plus grand élément en valeur absolue de la matrice a de taille
          n par m est transféré à y et les indices de cet élément à i et k ;
 '''begin''' '''integer''' p, q;
     y := 0; i := k := 1;
     '''for''' p:=1 '''step''' 1 '''until''' n '''do'''
         '''for''' q:=1 '''step''' 1 '''until''' m '''do'''
             '''if''' abs(a[p, q]) &gt; y then
                 '''begin'''
                     y := abs(a[p, q]);
                     i := p; k := q
                 '''end'''
 '''end''' Absmax

==Notes==
&lt;references/&gt;

==Voir aussi==
=== Liens externes ===
* {{en}} [http://www.fh-jena.de/~kleine/history/ Revised Report on the Algorithmic Language Algol 60] et d'autres documents
* {{en}} [http://www.lrz.de/~bernhard/Algol-BNF.html Algol 60 en BNF]
* {{en}} [http://www.masswerk.at/algol60/report.htm rapport Algol 60]
* {{fr}} {{Lien web|url=http://tel.archives-ouvertes.fr/tel-00009449/fr/|titre=Etude et réalisation d'un compilateur Algol 60 sur calculateur électronique du type IBM 7090/94 et 7040/44 / thèse de J.-C. Boussard, sur la base TEL-CNRS}}.

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>dv8ihrvqvygk8ukq15z0f3wfkzduqo6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fortran 90</title>
    <ns>0</ns>
    <id>122056</id>
    <revision>
      <id>95713108</id>
      <parentid>90509002</parentid>
      <timestamp>2013-08-10T20:38:49Z</timestamp>
      <contributor>
        <username>Arbautjc</username>
        <id>1453191</id>
      </contributor>
      <minor/>
      <comment>ne soyons pas ridicule : chacune de ces fonctionnalit&quot;s peutêtre trouvée dans d'autres langages (généricité dans Ada bien avant C++, etc.)</comment>
      <text xml:space="preserve" bytes="1746">{{ébauche|informatique}}
'''Fortran 90''' est une version du [[programmation|langage de programmation]] [[Fortran]], qui est très utilisé dans le domaine du [[calcul scientifique]] en raison du très grand nombre de programmes-source disponibles dans ce langage. Toutefois, ses utilisateurs ont voulu y ajouter au fil du temps les idées intéressantes utilisées dans d'autres langages. Cela a donné les versions Fortran 90, puis [[Fortran 95]].

Le Fortran 90 introduisit dans [[Fortran|FORTRAN]] les ajouts suivants :

* Noms jusqu'à 31 caractères
* Espaces significatifs même hors des libellés
* Les lignes peuvent aller jusqu'à 132 caractères (ligne d'imprimante de 11 pouces)
* Jusqu'à 39 lignes « suite » possibles
* Plusieurs instructions par ligne avec le « ''';''' »
* « '''!''' » utilisable comme signe de commentaire
* Inclusion de textes sources depuis des fichiers
* Constructions DO / CYCLE / EXIT / WHILE / CASE 
* Spécifications directes sur tableaux. Si A et B sont des tableaux, on peut écrire '''A=B*SIN(A)'''
* Gestion dynamique de mémoire, avec pointeurs et récursion possible des sous-programmes
* Types définis par l'utilisateur
* Surcharge d'opérateurs et appels génériques
* Utilisation d'interfaces pour les sous-routines appelées
* Introduction des modules (espace de noms)

''[[GNU Compiler Collection]]'' (GCC) permet de compiler du Fortran 90 à partir de la version 4.0.

== Liens externes ==
* {{pdf}} Standard [http://www.fortran.com/f90_std.pdf Fortran 90]
* [http://www.kcl.ac.uk/kis/support/cit//fortran/engfaq.html FAQ Fortran 90] (en anglais)

{{Portail|programmation informatique}}

[[Catégorie:Langage Fortran]]
[[Catégorie:Langage de programmation]]

[[en:Fortran#Fortran_90]]</text>
      <sha1>f0j6mxd0dg4voqk5hc6zbh0nu2d9h1y</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Groovy (langage)</title>
    <ns>0</ns>
    <id>258048</id>
    <revision>
      <id>101706276</id>
      <parentid>97356512</parentid>
      <timestamp>2014-03-01T20:51:00Z</timestamp>
      <contributor>
        <username>AméliorationsModestes</username>
        <id>1504543</id>
      </contributor>
      <minor/>
      <comment>/* Autres exemples */</comment>
      <text xml:space="preserve" bytes="5117">{{Voir homonymes|Groovy}}
{{Infobox Langage de programmation
|  nom = Groovy
|  logo = Groovy.png
|  paradigmes = [[Programmation orientée objet|Objet]], [[Programmation impérative|impératif]]
|  année = [[2003]]
|  auteur = [[Java Community Process]]
|  développeurs = 
|  typage = 
|  implémentations = 
|  dialectes = 
|  influencé par = [[Java (langage)|Java]], [[Python (langage)|Python]], [[Ruby]], [[Smalltalk]]
|  a influencé =
|  système d'exploitation = [[Multiplate-forme]]
|  licence = 
|  site web = [http://groovy.codehaus.org groovy.codehaus.org]
}}

'''Groovy''' est le nom d'un [[langage de programmation]] orienté objet destiné à la [[plate-forme Java]]. Il constitue une alternative au langage Java pour cette plate-forme et est inspiré de [[Python (langage)|Python]], [[Ruby]] et [[Smalltalk]]. Il est l'objet de la spécification [http://jcp.org/en/jsr/detail?id=241 JSR 241].

Groovy utilise une syntaxe très proche de Java, avec des accolades, et est directement [[Compilateur|compilé]], soit [[Compilation à la volée|à la volée dynamiquement]], soit classiquement avec un compilateur en [[bytecode]]. 

Groovy s'intègre et est entièrement compatible avec la [[machine virtuelle java|JVM]] étant donné que le [[bytecode]] est le même.
Il peut donc
* utiliser les [[Bibliothèque (logicielle)|bibliothèques]] Java,
* être utilisé dans des classes Java.

Groovy peut être comparé à [http://en.wikipedia.org/wiki/BeanShell BeanShell], l'objectif de faire un langage de scripting proche de java est le même, la mise en œuvre étant différente.

== Principales caractéristiques du langage ==

Groovy possède certaines caractéristiques qui le différencient du Java standard :
* [[typage statique]] et [[typage dynamique]],
* [[Liste (informatique)|listes]], [[Tableau associatif|maps]], et [[Expression rationnelle|expressions régulières]] nativement supportées,
* [[Fermeture (informatique)|fermetures ou clôtures]],
* [[surcharge des opérateurs]].

=== Comparaison entre Java et Groovy ===

Voici une comparaison de Java et Groovy :

'''Standard Java (Java 5+)'''
&lt;source lang=&quot;java&quot;&gt;
 class Filter {
     public static void main(String[] args) {
         for (String item : Arrays.asList(&quot;Rod&quot;, &quot;Carlos&quot;, &quot;Chris&quot;))
             if (item.length() &lt;= 4) System.out.println(item);
     }
 }
&lt;/source&gt;
'''Groovy'''
&lt;source lang=&quot;groovy&quot;&gt;
 list = [&quot;Rod&quot;, &quot;Carlos&quot;, &quot;Chris&quot;]
 shorts = list.findAll { it.size() &lt;= 4 }
 shorts.each { println it }
&lt;/source&gt;

=== [[Langage de balisage]] (XML, HTML…) ===

Une des caractéristiques notables de Groovy est sa gestion native des [[Langage de balisage|langages de balisage]] comme [[Extensible Markup Language|XML]] et [[Hypertext Markup Language|HTML]]. Cette prise en charge permet de définir et manipuler par programmation plusieurs types de structures avec une syntaxe commune.

Exemple :

'''ce code Groovy… '''
&lt;source lang=&quot;groovy&quot;&gt;
    import groovy.xml.MarkupBuilder
    def myXMLDoc = new MarkupBuilder()
    myXMLDoc.workbook {
       worksheet(caption:&quot;Employees&quot;) {
          row(fname:&quot;John&quot;, lname:&quot;McDoe&quot;)
          row(fname:&quot;Nancy&quot;, lname:&quot;Davolio&quot;)
       }
       worksheet(caption:&quot;Products&quot;) {
          row(name:&quot;Veeblefeetzer&quot;, id:&quot;sku34510&quot;)
          row(name:&quot;Prune Unit Zappa&quot;, id:&quot;sku3a550&quot;)
       }
    }
    println myXMLDoc
&lt;/source&gt;

'''… produit le contenu XML suivant :'''
&lt;source lang=&quot;xml&quot;&gt;
    &lt;workbook&gt;
       &lt;worksheet caption='Employees'&gt;
          &lt;row fname=&quot;John&quot; lname=&quot;McDoe&quot; /&gt;
          &lt;row fname=&quot;Nancy&quot; lname=&quot;Davolio&quot; /&gt;
       &lt;/worksheet&gt;
       &lt;worksheet caption='Products'&gt;
          &lt;row name=&quot;Veeblefeetzer&quot; id=&quot;sku34510&quot; /&gt;
          &lt;row name=&quot;Prune Unit Zappa&quot; id=&quot;sku3a550&quot; /&gt;
       &lt;/worksheet&gt;
    &lt;/workbook&gt;
&lt;/source&gt;

== Autres exemples ==

;[[Hello World]]
&lt;source lang=&quot;groovy&quot;&gt;
 print &quot;hello word&quot;

 def name='World'; println &quot;Hello $name!&quot;
&lt;/source&gt;

;Afficher une liste ordonnée de noms transformés en majuscule
&lt;source lang=&quot;groovy&quot;&gt;
 def names = ['Jean', 'John', 'Jill']
 println names.collect{ it.toUpperCase() }.sort()
&lt;/source&gt;

;Afficher les sept premiers carrés successifs de 2
&lt;source lang=&quot;groovy&quot;&gt;
 def num = 2G
 7.times {
   println &quot;$num&quot;
   num *= num
 }
&lt;/source&gt;
 2
 4
 16
 256
 65536
 4294967296
 18446744073709551616

;Définir des classes utilisateur
&lt;source lang=&quot;groovy&quot;&gt;
class Person  {
  String name
  String givenname
  int age
  String sex
}

class User extends Person {
  String userid
  String email
}

def titi = new User(name: 'titi')
titi.userid = 'titi1412'
titi.email = 'titi@acme.org'
titi.age = 40

def rominet = new Person(name: 'rominet', age: 40, sex: 'uhum')
println &quot;Hé ${rominet.name} , ici ${titi.name}, un vieux copain de promo. Écris-moi sur ${titi.email} !&quot;
&lt;/source&gt;

== Liens externes ==

* {{en}} [http://groovy.codehaus.org/ Groovy]
* {{fr}} [http://ericreboisson.developpez.com/tutoriel/java/groovy/ Une page consacrée à Groovy]


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Plateforme Java]]</text>
      <sha1>nit1r6hnukmhngfugeavv9cl987lwua</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FASM</title>
    <ns>0</ns>
    <id>188377</id>
    <revision>
      <id>101487536</id>
      <parentid>94754383</parentid>
      <timestamp>2014-02-22T10:26:10Z</timestamp>
      <contributor>
        <username>Julien1978</username>
        <id>363502</id>
      </contributor>
      <minor/>
      <comment>[[Projet:JavaScript/Notices/HotCatsMulti|HotCatsMulti]] :  + [[Catégorie:Produit lancé en 2000]]</comment>
      <text xml:space="preserve" bytes="2593">{{Infobox Logiciel
 | nom = Flat Assembler (FASM)
 | logo = 
 | image = FASM.PNG
 | description = 
 | taille image = 
 | développeur = Tomasz Grysztar
 | dernière version = 1.70.03
 | date de dernière version = 29/06/2012
 | version avancée = 
 | date de version avancée = 
 | environnement = [[DOS]], [[Linux]], [[Microsoft Windows|Windows]], [[Unix]]
 | type = 
 | licences = [[Licence BSD]]
 | site web = [http://www.flatassembler.net www.flatassembler.net]
}}
'''FASM''' (''flat assembler'') est un [[programme assembleur]] pour l'architecture [[IA-32]] (appelée également architecture [[x86]]) . Le nom signifie ''flat assembler''. FASM est écrit en [[langage assembleur]] et existe pour les systèmes [[DOS]], [[Dex4u|DexOS]], GNU/[[Linux]], [[Microsoft Windows|Windows]], et [[MenuetOS|Menuet]]. FASM a quelques caractéristiques évoluées pour un langage assembleur tel que les [[macro]]s, les structures, et les données virtuelles. FASM intègre des bibliothèques pour l'[[environnement graphique]] [[Microsoft Windows|Windows]] et [[OpenGL]].

== [[Hello world]] pour FASM ==
{{pertinence|date=septembre 2012}}
&lt;source lang=&quot;asm&quot;&gt;
org 100h        ; directive: à la compilation, les offsets du segment de code doivent être décalés de 256 octets
mov dx, message ; l'offset de la constante message définie à la fin est placé dans le registre dx. Pas besoin de mot-clé &quot;offset&quot; avec FASM

; appel de la fonction 09h de l'interruption 21h: affichage de la chaîne dont l'offset du premier caractère est dans dx jusqu'à ce quu soit rencontré le caractère de fin de chaîne ($)
mov ah, 09h
int 21h

; fonction 00h de l'interruption 16h: suspendre l'exécution jusqu'à ce qu'une touche soit frappée
xor ah, ah
int 16h

; fonction 4ch de l'interruption 21h: fin de l'exécution. La valeur de al est le code de sortie, ici 00h (=pas d'erreur)
mov ax, 4c00h
int 21h

; définition de la constante message
; pas besoin de déclarer le segment de données: on peut se contenter de déclarer les variables à la fin du programme et d'utiliser la directive org 100h au début
; le dollar est le caractère de fin de chaîne
message db &quot;Hello world!$&quot;
&lt;/source&gt;

== Lien externe ==

* [http://flatassembler.net/ FASM] (''source ouverte'', assembleur [[IA-32]])

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Compilateur]]
[[Catégorie:Logiciel libre sous licence BSD]]
[[Catégorie:Logiciel pour DOS]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour Unix]]
[[Catégorie:Produit lancé en 2000]]</text>
      <sha1>j8fmh3ju04wmt73tnks9gddq8wv43en</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Programme assembleur</title>
    <ns>0</ns>
    <id>7942</id>
    <revision>
      <id>101412704</id>
      <parentid>97820317</parentid>
      <timestamp>2014-02-19T22:17:58Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>typographie + wikif. + lien interne rectifié (REM. : d. c. mais p.-ê. pas art.)</comment>
      <text xml:space="preserve" bytes="2951">Un '''assembleur''' est un [[Programme informatique|programme d'ordinateur]] qui traduit un programme écrit en [[Langage Assembleur|langage assembleur]] — essentiellement, une représentation [[Mnémotechnique#En langage assembleur|mnémonique]] du [[langage machine]] — en [[code objet]].

En plus de traduire les [[mnémoniques]] d'instructions en [[code binaire]], les assembleurs sont capables de gérer des noms symboliques pour les emplacements [[Mémoire (informatique)|mémoire]] (pour stocker des [[Donnée (informatique)|données]] ou référencer des points du [[logiciel|programme]]) et un [[Macro-définition|langage macro]] pour effectuer des substitutions textuelles - typiquement utilisé pour coder des séquences courtes d'instructions fréquemment utilisées qui seront insérées dans le code plutôt que d'écrire des procédures.

Historiquement, les assembleurs sont apparus comme le premier outil permettant au programmeur de prendre du recul par rapport au [[code objet]] et de se consacrer à la [[programmation]] proprement dite.
Les programmes assembleurs sont plus simples à écrire que les [[compilateur]]s pour les [[Langage de haut niveau|langages de haut-niveau]]. Ils sont disponibles depuis les années [[1950]].

Les programmes assembleur donnent un accès plus direct au [[microprocesseur]] que l'on souhaite programmer. Toutefois les architectures [[Reduced instruction set computer|RISC]] comme le [[PowerPC]], le [[Architecture MIPS|MIPS]], [[SPARC]] et [[HP Precision]] demandent pour optimiser leur fonctionnement des réarrangements d'instructions difficilement compatibles avec l'usage lisible de l'assembleur. Le recours à un [[compilateur]] devient alors inévitable pour tirer le maximum de l'architecture sous-jacente, en particulier les [[pipeline (informatique)|pipeline]]s dont disposent les [[processeur]]s [[Reduced instruction set computer|RISC]].

== Liste d'assembleurs ==
* [[Assembleur 360]] pour [[IBM 360 et 370]] (1964)
* [http://plit.de/asem-51/ ASEM-51] (pour Intel [http://developer.intel.com/design/mcs51/ MCS-51])
* A56 (pour [[Motorola]] DSP56000 et DSP56001) qui va générer des signaux (sinusoïdal, rectangulaire, triangulaire).
* [http://eji.com/a86/ A86] est un assembleur [[x86]] pour [[DOS]]
* [[FASM]] (''source ouverte'', assembleur [[IA-32]])
* [[GNU Assembler]] (logiciel libre sous [[Licence publique générale GNU|GNU GPL]], disponible pour de nombreuses architectures)
* [[High Level Assembler]]
* [[MASM]] (assembleur [[x86]] de [[Microsoft]])
* [[NASM]] ([[logiciel libre]], assembleur x86)
* [[RosAsm]] (GNU GPL, [[Environnement de développement intégré|EDI]] pour l'assembleur [[x86]] avec [[débogueur]], interface de création de fenêtres et [[désassembleur]])
* [[TASM]] (assembleur [[x86]] de [[Borland]])

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]

[[en:Assembly language#Assembler]]

[[pt:Assembly#Montador]]</text>
      <sha1>k1sz8orbgo8ofzu7tspz1h390kppj7r</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fortran 95</title>
    <ns>0</ns>
    <id>122053</id>
    <revision>
      <id>95713133</id>
      <parentid>91642952</parentid>
      <timestamp>2013-08-10T20:39:57Z</timestamp>
      <contributor>
        <username>Arbautjc</username>
        <id>1453191</id>
      </contributor>
      <minor/>
      <comment>rien de surprenant, quand on se réfère à l'IEEE 754. Les flottants ne sont pas les nombres réels des mathématiques</comment>
      <text xml:space="preserve" bytes="1095">{{ébauche|informatique}}
'''Fortran 95''' est une version du [[programmation|langage de programmation]] [[Fortran]], qui est très utilisé dans le domaine du [[calcul scientifique]] en raison du très grand nombre de programmes-source disponibles dans ce langage. Toutefois, ses utilisateurs ont voulu y ajouter au fil du temps les idées intéressantes utilisées dans d'autres langages. Cela a donné les versions [[Fortran 90]], puis Fortran 95.

Fortran 95 reprend les extensions déjà définies dans Fortran 90 et y ajoute :

* Ajout principal :
** Ordre et construction ''FORALL''

* Ajouts secondaires :
** fonction CPU_TIME
** libération mémoire automatique des tableaux dynamiques
** la fonction SIGN distingue entre +0 et -0

Les rapports [[Organisation internationale de normalisation|ISO]] définissant le Fortran 95 sont le TR 15580 et le TR 15581

== Liens externes ==
* {{pdf}} Standard [http://www.fortran.com/f95_std.pdf Fortran 95]

{{Portail|programmation informatique}}

[[Catégorie:Langage Fortran]]
[[Catégorie:Langage de programmation]]



[[en:Fortran#Fortran_95]]</text>
      <sha1>q1h0vz9edn4t1mr0kmnfflewrqopjb2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lingo</title>
    <ns>0</ns>
    <id>125676</id>
    <revision>
      <id>101781821</id>
      <parentid>92630383</parentid>
      <timestamp>2014-03-04T14:43:29Z</timestamp>
      <contributor>
        <username>Thannoy</username>
        <id>577609</id>
      </contributor>
      <minor/>
      <comment>/* Classe rect */ Correction d'une erreur mineure de typo</comment>
      <text xml:space="preserve" bytes="18789">{{Voir_homonymes|Lingo (animal)}}

'''Lingo''' est le [[langage de script]] qui accompagne le logiciel [[Macromedia Director]]. &lt;br /&gt;
L'auteur du Lingo est le développeur John Henry Thompson. La lingo a été enrichi par de nombreuses sociétés ayant développé des [[xtras]], dont [[intel]], ageia, [[havok]]...

== Origine du nom ==
Le mot '''Lingo''' signifie en anglais [[argot]], au sens de ''langage vernaculaire'', langue spécialisée appartenant à un groupe précis (ex. l'argot des typographes).

Contrairement aux langages de niveau 4 les plus répandus (basic, javascript...), le script lingo ne reproduit pas les concepts de la programmation à l'identique mais les remanie à sa façon en vue d'une application efficace et simple. Afin de marquer la distinction il utilise des termes différents, par exemple le &quot;tableau&quot; est renommé &quot;list&quot;, une classe est appelée &quot;parent script&quot;...

== Caractéristiques du langage ==

Lingo utilise actuellement la syntaxe [[Basic]].

Lingo avait au départ une syntaxe [[verbose]] dérivé du langage [[HyperTalk]] utilisé dans le logiciel auteur [[HyperCard]] distribué sur les [[MacIntosh]] à partir de 1986. Il a été prévu au départ pour être le plus lisible possible pour les anglophones.

* set mavariable to 10
* go to frame 20
* set word 4 of montexte to &quot;bonjour&quot;

== Syntaxe ==
&lt;font id=&quot;exemple&quot;&gt;Voici un exemple de fonction :&lt;/font&gt;

&lt;pre&gt;
on multiplie(a,b) 
    return a*b
end multiplie
&lt;/pre&gt;

Les fonctions commencent en effet toutes par '''on [nom de fonction][(arguments)]''' et se terminent par '''end [nom de fonction]'''. Lingo est un langage très laxiste, on est par exemple autorisé à ne pas mettre les parenthèses après le nom de la fonction (on multiplie a, b).

À noter, les variables sont typées dynamiquement et il n'existe pas de différenciation entre le &quot;=&quot; d'affectation et le &quot;=&quot; de comparaison.

&lt;pre&gt;
if a=1 then
   b=2
else
   if a=&quot;une chaîne&quot; then
      b=3
   end if
end if
&lt;/pre&gt;

Après des années d'évolution syntaxique, Lingo est devenu un langage &quot;pointé&quot; assez classique, et donc très lisible.

Director est un logiciel dédié à l'interactivité. Par conséquent, Lingo permet l'interception facile d'un grand nombre d'évènements tels que : preparemovie (avant l'affichage), startmovie (au moment de l'affichage), mousedown (clic enfoncé), mouseup (clic relâché), etc. Certains scripts intercepteurs évènements concernent l'ensemble du programme, d'autres peuvent ne s'appliquer qu'à des objets précis, comme les ''sprites'' (occurrence d'un objet - par exemple graphique - sur la ''scène'').

&lt;pre&gt;
on mouseup 
        -- lorsque l'on clique sur l'objet auquel s'applique ce script''
   if the mouseh&lt;320 then
        -- si la position horizontale de la souris est inférieure à 320
      puppetsound(1, &quot;bing&quot;)
        -- on déclenche le son nommé &quot;bing&quot; sur la piste 1.
   end if
end
&lt;/pre&gt;

=== Variables ===

Les variables numériques en lingo sont simplifiées. Les variables globales ou d'objet ne se déclarent qu'en dehors des fonctions. Les variables locales sont déclarées implicitement.

Le typage est implicite, ainsi:
*a=10 crée un integer
*a=10.0 crée un décimal.

Il n'existe pas de variables booléennes, lingo utilise les entiers 0 et 1, qui pour des raisons de lisibilité peuvent toutefois s'écrire true et false.

Les chaînes de caractères peuvent être lus comme des tableaux à l'aide de la variable globale &quot;the itemDelimiter&quot; et la prioriété .item des strings, ou bien les propriétés .line et .word des string.

les noms des variables peuvent contenir des lettres, des chiffres, ou le signe underscore. Elles ne peuvent pas commencer par un chiffre.

=== Symboles ===

On peut créer des ''symboles'' avec le signe dièse ('''#'''). Un symbole n'est pas une variable mais un nom de variable ou fonction.

Par exemple, dans ''maCouleur = #rouge'', le mot ''#rouge'' ne signifie rien pour Lingo ; en revanche, maCouleur = couleurs[#rouge] permet de retrouver la propriété rouge de l'objet couleurs, la fonction call(#rouge, obj, arguments...) permet d'appeler la méthode rouge de l'objet obj.

=== Quelques opérateurs et fonctions ===

* l'affectation se fait avec le signe '''='''
* la comparaison se fait ainsi :
** '''=''' (égalité)
** '''&lt;''' (inférieur)
** '''&gt;''' (supérieur)
** '''&lt;=''' (inférieur ou égal)
** '''&gt;=''' (supérieur ou égal)
:: les opérateurs sont les mêmes qu'il faille comparer des entiers, des chaînes, ou quoi que ce soit d'autre.
* il y a deux types de division, toutes les deux se codent avec le caractère '''/'''. Si les deux nombres sont des entiers alors lingo effectue une division entière. Le reste de la division est obtenu avec l'opérateur '''mod'''.
* les fonctions '''bitAnd()''', '''bitOr()''', '''bitXor()''' et '''bitNot()''' permettent d'effectuer des opérations binaires sur des entiers traités comme des tableaux de 32 bits. Ces fonctions sont lourdes car elles passent par des conversions: pour lire rapidement un tableau de bits on utilise plutôt la division entière et le modulo, mais on perd le 32{{e}} bit.

=== Classes de base ===

Lingo possède une liste de classe correspondant aux structures de données classiques, avec d'importantes automatisations.

{|
|-
|'''classe lingo'''
|'''données correspondantes'''
|-
|list
|tableau linéaire
|-
|propList
|tableau associatif / struct
|-
|matrix
|tableau à 2 dimensions
|-
|point
|vecteur 2d
|-
|rect
|rectangle 2d
|-
|vector
|vecteur 3d
|-
|transform
|matrice 3d
|}

==== Classes de gestion des tableaux ====
===== Classe List =====

La classe list contient un tableau à mémoire dynamique. Ces tableaux sont &quot;one-based&quot;, le premier index est égal à 1. Cela permet d'utiliser le zéro comme identifiant nul lorsque l'on référence les indexes.

Y écrire ou y lire le contenu d'une cellule est une opération aussi lourde que la syntaxe pointée (plus lente sur des grosses listes que des petites). Pour optimiser les opérations sur les tableaux il faut utiliser le plus possible l'algèbre des tableaux, qui évite de nombreuses lectures de cellule.

Les listes se créent ainsi :

: ''&lt;nowiki&gt;monTableau = []&lt;/nowiki&gt;'' ou ''&lt;nowiki&gt;monTableau = [1,2,&quot;a&quot;,0,&quot;b&quot;]&lt;/nowiki&gt;'' 

Les tableaux peuvent contenir n'importe quel types de données:

: ''&lt;nowiki&gt;monTableau =[[1,vector(1,2,3)],[model1,image12]]&lt;/nowiki&gt;''

======Quelques méthodes ======

* '''list.sort()''' permet un tri croissant automatique.
* '''list.add()''' permet d'insérer des données dans une liste sortie en conservant l'ordre de tri.
* '''list.append()''' ajoute un élément à la fin du tableau, casse l'ordre de tri
* '''list.getOne( valeur )''' fait une recherche automatique dans le tableau pour trouver l'index de la valeur
* '''list.deleteOne( valeur )''' rechercher l'index de la valeur puis efface la cellule
* '''list.deleteAt( index )''' efface une valeur à un index précis
* '''list.addAt( index, value )''' insère une valeur à l'index voulu

======Algèbre des tableaux ======

Les tableaux peuvent utiliser tous les types d'opérateurs compatibles avec le contenu des cellules. Cela permet une considérable accélération des boucles de calcul puisque celles-ci sont alors gérées en natif.

Exemples avec les entier et les décimaux:

: '''[1,2,3]+[4,5,6]''' renvoie '''[5,7,9]'''
: '''[1,2,3]-[1,1,1]''' renvoie '''[0,1,2]'''
: '''[1,2,3]*[1,2,3]''' renvoie '''[1,4,9]'''
: '''[1,1] / [2,2.0]''' renvoie '''[0,0.5]'''
: '''[1,1]''' mod '''[2,2.0]''' renvoie '''[1,1]'''
: '''[1,2]''' &gt; '''[2,1]''' renvoie false (0)

Pour les exemples avec des tableaux de vecteurs et matrices, voir les classes vector et transform.

===== Classe propList =====

Contient un tableau associatif. Les identifiants peuvent être soit:

*des symboles: ''monTableau = [#age:24, #sexe:&quot;masculin&quot;, #taille: 1.80]''
*des chaines de caractère (attention, la lecture est très lente): monTableau = [&quot;age&quot;:10,&quot;sex&quot;:&quot;m&quot;]

L'algèbre est identique à celui des listes linéaires.

===== Classe matrix =====

Encode un tableau à deux dimensions. Ajouté à la v11 pour les terrains du moteur physx.

==== Classes de géométrie 2d ====
===== Classe point =====

Encode un vecteur 2d. Ses coordonnées se nomment &quot;locH&quot; et &quot;locV&quot;. Elles peuvent être entières ou décimales.
:'''p = point( a, b )'''
Les données se lisent par les propriétés locV / locH ou comme un tableau:
:'''p.locH ou p[1]''' renvoie '''a'''
:'''p.locV ou p[2]''' renvoie '''b'''

L'algèbre des vecteurs 2d se comporte exactement comme l'algèbre des tableaux et peut se combiner avec:
:'''point(1,1)+point(2,2)''' renvoie '''point(3,3)'''
:'''[p1,p2]+[p3,p4]''' renvoie '''[p1+p3,p3+p4]'''

===== Classe rect =====

Encode un rectangle. Les valeurs peuvent être entières ou décimales.

''':r = rect(left, top, right, bottom)'''
''':r.left, r.top, r.right, r.bottom ou r[1], r[2], r[3], r[4]''' renvoient ses coordonnées
''':r.width et r.height''' renvoient sa largeur et sa hauteur

Quelques méthodes:

: '''r1.intersects(r2)''' renvoie le rectangle d'intersection entre deux rectangles
: '''point.inside(r1)''' renvoie true si le point est à l'intérieur du rectangle
: '''map(targetRect, sourceRect, destinationRect)''' effectue une homothétie du point
: '''map(targetPoint, sourceRect, destinationRect)''' effectue une homothétie du rectangle
: '''rect1.union(rect2)''' renvoie le rectangle englobant deux autres rectangles

L'algèbre des rectangles est identique à celui des points 2d.

===== Classe quad =====

Encode un quadrilatère. Utile surtout pour les manipulations d'images.

==== Classes de géométrie 3d ====
===== Classe vector =====

Encode un vecteur 3d. Nombres décimaux uniquement.

:'''v=vector(10,20,30)'''

Ses coordonnées sont accessibles de deux manières: soit avec les propriétés x, y, z, soit avec l'index de dimension:
:'''v.x ou v[1]''' renvoie '''10'''

Quelques méthodes:
:'''vector.magnitude''' renvoie la longueur
:'''vector.normalize()''' lui attribue une longueur égale à 1 sans changer sa direction
:'''vector1.cross(vector2)''' renvoie le [[Produit vectoriel|produit de deux vecteurs]]

L'algèbre des vecteurs 3d diffère de celle des listes et des vecteurs 2d:
*la division et le modulo ne sont pas permis
*la multiplication renvoie le [[produit scalaire]]
:'''vector(1,0,0)*vector(0,1,0)''' renvoie '''0.0'''

L'algèbre des vecteurs peut se combiner avec celui des tableaux.
:'''[vector(1,0,0),vector(0,1,0)] + [vector(0,1,0),vector(1,0,0)]''' renvoie '''[vector(1,1,0),vector(1,1,0)]'''
:'''[vector(1,0,0),vector(0,1,0)] * [vector(0,1,0),vector(1,0,0)]''' renvoie '''[0,0]'''

===== Classe transform =====
Encode une [[matrice (mathématiques)|matrice]] de transformation 3d composée de 16 décimales.

:'''matrice = transform()'''

Les 3 premiers groupes de 4 nombres encodent les 3 vecteurs du repère. Le dernier groupe encode l'origine. (le {{4e}} nombre de ces groupes sert aux calculs internes).

Exemple: choisir le vecteur (0,0,1) pour l'axe X:
:'''matrice[1]=1'''
:'''matrice[2]=0'''
:'''matrice[3]=0'''

Quelques méthodes:
:'''matrice.invert()''' inverse la matrice
:'''matrice.inverse()''' renvoie l'inverse de la matrice
:'''matrice.rotate() matrice.translate()''' effectue une transformation absolue
:'''matrice.preRotate() matrice.preTranslate()''' effectue une transformation relative
:'''matrice1.multiply(matrice2)''' renvoie la matrice 2 transformée par la matrice 2
:'''matrice1.preMultiply(matrice2)''' renvoie la matrice 2 transformée par la matrice 1 en relatif
:'''matrice1.interpolate(matrice2,pourcentage)''' renvoie l'interpolation entre deux transformations

Algèbre des matrices:
:'''matrice1 * matrice2''' équivaut à multiply
:'''matrice * vecteur''' renvoie le vecteur transformé par la matrice

L'algèbre des matrices se combine également avec les tableaux:

:'''[matrice1,matrice2] * [vecteur1,vecteur2]''' renvoie le tableau des vecteurs transformés
:'''[matrice1,matrice2] * [matrice3,matrice4]''' renvoie le tableau des matrices transformés

=== Classes du moteur 3d ===

==== Classe Scene ====

Sous-classe de &quot;member&quot; qui s'affiche comme un sprite et permet de rendre une scene 3d avec directx ou opengl

Suit un pattern de type &quot;fabrique&quot;: tous les éléments de la scene 3d sont instanciés et détruits à l'aide de méthodes de la classe scene. En voici quelques-uns:

===== Classe modelresource =====

Stocke des vertexbuffers (&quot;meshes&quot;) et référence des shaders par défaut.

Note: ses méthodes de construction ne suivent pas la structure des vertexbuffer, chaque triangle est renseigné indépendamment. Une fois appelée la méthode build() les vecteurs sont triés par groupe utilisant le même shader, les vertexBuffer obtenus sont accessibles via le modificateur #meshDeform des models utilisant la ressource.

===== Classe model =====

Référence une matrice, une liste de shaders et un modelresource. Génère automatiquement une boundingSphere. La classe model permet d'afficher le modelResource. Son modificateur #meshDeform permet d'accéder aux vertexBuffer du modelResource.

==== Classe physx ====

Permet de contrôler une scene 3d avec le moteur physx de nvidia. Sous-classe d'xtra member, se contrôle comme un script xtra classique.

Suit le pattern fabrique qui permet de créer divers objets physiques: corps convexe, concave, cloth, personnage, etc. Requiert le modificateur #meshDeform pour lire les structures polygonales.

== Types de scripts ==

Il existe 4 types de scripts en Lingo, deux de type procédural, deux de type objet:

== Les scripts procéduraux ==

Utilisent uniquement des variables et fonctions globales. Leur utilisation doit rester limitée car les variables globales sont consommatrices de cpu et ram: elles sont dupliquées dans l'interprétateur javascript.

On utilise autant que possible les script objets, les script procéduraux uniquement quand c'est nécessaire.

=== &quot;movie script&quot; ===

Ce sont les scripts utilisés pour le code procédural.

Ces scripts reçoivent quelques fonctions-événements prédéfinis qui correspondent à l'ouverture de l'application, sa fermeture, le rafraichissement d'image.

Evenements d'ouverture et clôture:

*'''on prepareMovie''' s'exécute avant l'affichage de la première image. C'est là qu'on prépare le splash screen.
*'''on startMovie''' s'exécute après l'affichage de la première image. C'est là qu'on initialise l'application.
*'''on stopMovie''' s'exécute à la clôture de l'application, c'est là qu'on détruit son contenu.

Evenements de rafraichissement d'image:

*'''on prepareFrame''' s'exécute avant le rendu de l'image, c'est ici qu'on met les relevés de temps.
*'''on enterFrame''' s'exécute pendant le laps de temps restant avant le rendu de la prochaine image, c'est là qu'on met tous les calculs.
*'''on exitFrame''' s'exécute juste avant le déplacement de la tête de lecture, c'est ici qu'on lui indique l'image qu'elle doit rendre (avec go to)

Evenement indépendant:

*'''on idle''' s'exécute selon un intervalle multiple de 16 millisecondes (60 images par seconde). C'est là qu'on met le code indépendant du frameRate de l'application.

Evenements souris:

*'''on mouseDown''' et '''on mouseUp''', appelés quand la souris est pressée ou relâchée.

=== Les scripts dits d'acteur ===

Ce sont des scripts qui se trouvent directement à l'intérieur d'un acteur. Leur type n'est pas défini mais ils fonctionnent comme les &quot;movie script&quot;.

Ils reçoivent les évènements de souris et de rafraichissement lorsqu'une instance de l'acteur est visible.

== Les scripts objet ==
===Les scripts dits &quot;parents&quot;===

Permettent de simuler des classes d'objet. La syntaxe des méthodes reste procédurale : il faut faire passer une référence à l'objet &quot;me&quot; en premier argument.

==== classe instanciable ====

:un exemple de script parent instancié:
&lt;pre&gt;

-- propriétés

property pNombre 

-- méthodes constructeur et destructeur

on new me, n , obj
  pObject = obj
  pNombre = n
  return me
end

on delete me
  pObject = void
end

-- méthodes utilisateur

on incremente me
  pNombre = pNombre +1
end

&lt;/pre&gt;
Si ce script se nomme &quot;nombre&quot;, on l'instanciera par exemple de cette manière :
&lt;pre&gt;
monNouveauNombre = new(script &quot;nombre&quot;, 10, obj)
&lt;/pre&gt;
et on invoquera sa fonction &quot;incremente&quot; de cette manière :
&lt;pre&gt;
monNouveauNombre.incremente()
&lt;/pre&gt;

==== classe statique ====

Un script parent peut servir de classe statique.

On accède à sa référence comme ceci:
&lt;pre&gt;
myStaticClass = Script(&quot;script_name&quot;)
&lt;/pre&gt;

==== héritage ====

L'héritage en lingo ne fonctionne pas comme dans les langages objet classiques, il se base sur la propriété &quot;ancestor&quot; des scripts parents, qui correspond à une instance de la classe-mère. Il ne s'agit donc pas d'héritage mais d'une surcharge.

Director remonte automatiquement aux propriétés de l'objet ancestor depuis la référence fille ce qui permet de retrouver l'effet d'une classe héritée. '''Attention donc à la valeur de l'argument &quot;me&quot;: il doit toujours correspondre à l'instance de dernière génération.'''

Cela ne marche pas pour toutes les propriétés et méthodes des classes natives de director (auquel cas il faut pointer l'ancestor).

:Exemple de simulation d'une sous-classe de List

&lt;pre&gt;
property ancestor

on new ( me ) -- sous classe de l'objet list
  ancestor = [1,10,20,30]
  return me -- attention: on ne renvoie pas &quot;ancestor&quot; mais &quot;me&quot;
end
&lt;/pre&gt;

&lt;pre&gt;
obj=new Script( &quot;testClass&quot; )
put obj[ 1 ] -- on retrouve les propriétés de l'ancestor
&lt;/pre&gt;

=== Les scripts d'application ou &quot;behaviors&quot; ===

Ce sont des objets complexes dont le script n'est pas directement accessible. Ils contiennent de nombreux événements permettant d'interagir avec les sprites, la souris, le clavier, par exemple pour créer des boutons ou des éditeurs de texte.

Les scripts de comportement sont souvent développés pour être réutilisés par des graphistes ou intégrateurs. Par un simple drag and drop ces scripts se rattachent à des objets de la scène: image, sprite, acteur, frame... Ces scripts ont des fonctions prédéfinies qui permettent de paramétrer manuellement les instances de même que les composants [[flash]].

== Implémentations ==
Le Lingo est un langage propriétaire, il n'en existe donc qu'une seule implémentation.

=== Commandes lingo et syntaxe javascript ===

Depuis sa version '''MX2004''', le logiciel [[Adobe Director|Director]] accepte l'usage de deux langages différents : le '''Lingo''', et une implémentation de [[JavaScript]]/[[ECMAScript]] qui exécute une grosse partie des opérations lingo.

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>8alwe1zo08aupepp1tjxow21smdel23</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PowerBuilder</title>
    <ns>0</ns>
    <id>2359</id>
    <revision>
      <id>94755362</id>
      <parentid>93631419</parentid>
      <timestamp>2013-07-07T06:01:58Z</timestamp>
      <contributor>
        <username>Ggal</username>
        <id>362597</id>
      </contributor>
      <minor/>
      <comment>/* Obtenir de l'aide */ co- → co sans trait d'union</comment>
      <text xml:space="preserve" bytes="3520">{{Infobox Logiciel
 | nom = Powerbuilder
 | logo = 
 | développeur = [[Sybase]], une division de [[SAP_(entreprise)|SAP]]
 | environnement = [[Microsoft Windows]]
 | langue = [[Multilingue]]
 | type = [[environnement de développement intégré]]
 | site web = [http://www.sybase.com/products/development/powerbuilder www.sybase.com]
 | dernière version = 12.5
 | date de dernière version = {{date|12|août|2011}}
}}
'''Powerbuilder''' est un [[programmation|langage de programmation]] et un [[environnement de développement intégré]] initialement développé par la société PowerSoft, qui a été rachetée par [[Sybase]] en 1994, [[SAP_(entreprise)|SAP]] a ensuite racheté Sybase en 2010.

C'est un langage semi-compilé, [[Programmation orientée objet|orienté objet]], générant du [[C++]] utilisé principalement pour des applications de gestion. Il est disponible sous [[Microsoft Windows|Windows]].

Le principe central de Powerbuilder est la standardisation du dialogue avec les [[bases de données]] à l'aide de datawindows et la possibilité d'utiliser du langage [[Structured Query Language|SQL]] directement dans le langage PowerScript.

== Datawindow ==

Une datawindow est un composant logiciel qui présente dans une fenêtre les données issues d'une base de données [[Structured Query Language|SQL]]. Ce composant gère automatiquement l'affichage, la création, la modification et la suppression de données dans la table concernée. Ses formes de présentation diverses lui permettent d'être utilisée en liste, en forme libre, en rapport, etc.

== Obtenir de l'aide ==
Il existe plusieurs moyens d'obtenir de l'aide. Forums [[Network News Transfer Protocol|NNTP]] (anglais uniquement) ou web. Deux forums en français coexistent.

== Tests unitaires ==

Il est possible de faire des tests unitaires sur les projets PowerBuilder à l'aide de [[PBUnit]].

== Automatisation ==
OrcaScript permet d'automatiser la build d'une application PowerBuilder sans utiliser l'environnement graphique. OrcaScript peut aussi se connecter à un source control pour effectuer un &quot;getLatestVersion&quot;. 

==Communauté==
PowerBuilder est connu pour sa base de clients loyaux, et son développement facile&lt;ref&gt;[http://chrispollach.pbdjmagazine.com/10_reasons.htm]&lt;/ref&gt;.

Par conséquent, il y a une variété de groupes de communauté et de ressources pour les développeurs PowerBuilder souhaitant partager leurs techniques et s'assembler. Ceux-ci incluent :

- International Sybase User Group&lt;ref&gt;[http://www.ISUG.com]&lt;/ref&gt;

- PowerBuilder Developer's Journal&lt;ref&gt;[http://pbdj.sys-con.com/]&lt;/ref&gt;. 

Il existe aussi les blogs de TeamSybase&lt;ref&gt;[http://www.sybase.com/developer/sdncommunity/powerbuilder]&lt;/ref&gt; et leurs évangélistes&lt;ref&gt;[http://blogs.sybase.com/powerbuilder]&lt;/ref&gt;. 

PowerBuilderTV&lt;ref&gt;[http://www.powerbuilder.tv]&lt;/ref&gt; est une série des webinars par et pour la communauté PowerBuilder, avec sessions présentés par les évangélistes, développeurs et éditeurs PowerBuilder.

==Références==
{{Références}}

== Liens externes ==

* [http://www.sybase.com/products/developmentintegration/powerbuilder Site web de PowerBuilder]
* [http://www.visual-expert.com/index_fr.htm Novalys] fournisseur de greffons à PowerBuilder
* [http://pbadonf.fr/puntal/ Forum PowerBuilder à Donf !] 
* {{en}} [http://www.geocities.com/pbunit/ Site de PBUnit]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Environnement de développement intégré]]</text>
      <sha1>k7bo8u5x648h86j4v35dfm4364qupxq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Natural</title>
    <ns>0</ns>
    <id>2153</id>
    <revision>
      <id>97069286</id>
      <parentid>89733462</parentid>
      <timestamp>2013-09-28T14:54:19Z</timestamp>
      <contributor>
        <username>Olyvar</username>
        <id>722293</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.29 - [[P:HOM|Homonymies]] : Correction de 1 lien - [[Portabilité]]</comment>
      <text xml:space="preserve" bytes="5350">{{voir homonymes|Natural (homonymie)}}

'''Natural''' est un [[programmation|langage de programmation]] de quatrième génération semi-compilé, édité par la société allemande [[Software AG]]. 

==Définition==
Sa syntaxe est fortement inspirée de celle de [[Cobol]] : on y retrouve des instructions telles que ''move'', ''perform'', ''compute'', ainsi que des principes tels que  la redéfinition de données ou la possibilité de définir le scope d'une variable. Néanmoins, cette syntaxe reste assez simple et beaucoup moins verbeuse que Cobol :
*l'en-tête du programme est réduite à sa plus simple expression;
*il n'y a pas de caractère de [[fin de ligne]];
*...

L'intérêt d'un langage semi-compilé est sa [[portabilité (informatique)|portabilité]] sur différents systèmes ([[Ordinateur central|mainframe]], [[Unix]], [[Microsoft Windows|Windows]], etc.) ; en effet il suffit de porter le « RunTime Natural » sur une plateforme pour pouvoir y exécuter des programmes Natural originellement créés sur une autre plateforme (c'est le même principe que celui de [[Java (technologie)|Java]] avec les portages des [[Machine virtuelle Java|JVM]].

Ce langage fut créé au départ pour permettre l'accès aux [[base de données|bases de données]] [[Adabas]] (du même éditeur). Il s'est rapidement enrichi pour pouvoir supporter des bases de données relationnelles comme [[DB2]] ou non relationnelles comme DL1, [[VSAM]].
Il est surtout utilisé dans l'industrie et les sociétés de grande taille, car la base Adabas est supportée non seulement sur des plateformes comme Unix ou Windows mais surtout sur de gros systèmes autorisant une gestion d'I/O massive.

Les instructions d'accès au [[système de gestion de base de données]] (SGBD) sont fonctionnelles (elles masquent les requêtes physiques et l'organisation des données) : chaque instruction d'accès à une table de la base se présente sous forme d'une boucle de lecture suivant une clé simple ou composée. 

Par exemple, la lecture se présente sous la forme de deux mots-clefs.

&lt;pre&gt;READ Table    (Accès à la table → Début boucle de lecture)
   instruction(s).... sur l'enregistrement
   gestion de sortie de la boucle de lecture souvent à la discrétion du programmeur
END-READ      (Marqueur de fin de boucle)&lt;/pre&gt;

Le langage dispose d'extension permettant également le codage des accès sous forme de requêtes [[Structured Query Language|SQL]].

==Exemple de Source Natural==

&lt;pre&gt;DEFINE DATA PARAMETER /* paragraphe de déclaration des paramètres du programme
1 PARAM1  (A001) /* alphanumérique
1 PARAM2 (N004) /* Numérique
LOCAL /* paragraphe de déclaration des variables du programme
1 CLE_COMPOSEE (A022)
1 REDEFINE  CLE_COMPOSEE /* redéfinition de la variable cle_composee
  2 VAR1_1 (A001)
  2 VAR1_2 (N020)
1 VAR3  (L)  /* booléen
1 VAR4  (D)  /* Date
1 VAR5  (N5) /* Numérique sur 5 positions
END-DEFINE   /* début de programme

ON ERROR /* paragraphe de gestion des erreurs
   WRITE 'erreur N°' *ERROR-NR 'ligne ' *ERROR-LINE 'dans programme' *PROGRAM
END-ERROR

MOVE PARAM1 TO VAR1_1
MOVE PARAM2 TO VAR1_2

/* le paragraphe find .... end-find définit une boucle de lecture. 
/* Tant que des enregistrements de la table satisfont aux critères
/* de recherche, on revient au début de la boucle pour trouver 
/* l'enregistrement suivant ...
FIND TABLE WITH TABLE.CLE = CLE_COMPOSEE  /* boucle de recherche d'enregistrements 
 IF NO RECORD FOUND
  WRITE 'aucun enregistrement trouve'
  ESCAPE BOTTOM                           /* sortie de la boucle de lecture
 END-NOREC

 IF TABLE.CHAMP1 = 'toto'
  ESCAPE TOP               /* passage à l'itération suivante 
                           /* (pour éviter, par exemple, de traiter
                           /* certains enregistrements)
 END-IF

 PERFORM TRAITER_CHAQUE_RECORD_LU
END-FIND

DEFINE SUBROUTINE TRAITER_CHAQUE_RECORD_LU
    WRITE TABLE.CHAMP1 TABLE.CHAMP2
END-SUBROUTINE

END  /* fin de programme&lt;/pre&gt;

==Historique==
* La première version de Natural voit le jour en 1979.
* Limité au départ au monde des grands systèmes ([[International Business Machines Corporation|IBM]], [[Siemens (entreprise)|Siemens]], etc.), une version fonctionnant sous Windows est apparue durant les années 1990.
* Début 2003 un environnement de développement graphique (Natural for Windows) permet de développer et de mettre au point des programmes Natural sur mainframe à partir d'un poste de travail sous Windows.
* Natural 2006 s'enrichit d'un studio graphique sous Windows et aussi d'un studio sous forme de « plugin » [[Eclipse (logiciel)|Eclipse]]. 

==Évolutions==
Natural 2006 dispose d'un vocabulaire étendu pour traiter de façon native les documents XML.

Natural reste, comme Cobol, fortement orienté vers les applications de gestion, du fait:
*de ses facilités pour la manipulation des données (accès au SGBD, redéfinitions);
*de ses performances élevées notamment pour les traitements de masse.
*de ses facilités à gérer les interfaces utilisateurs de type [[Terminal 3270|3270]] pour des saisies contrôlées intensives.

==Liens externes==
* {{Site officiel|http://www.softwareag.com/fr/products/natural_2010/default.asp}}

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>oth04io2bbhrap5erc4bg5rs72mj9e0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PhBRML</title>
    <ns>0</ns>
    <id>289964</id>
    <revision>
      <id>79504803</id>
      <parentid>62405904</parentid>
      <timestamp>2012-06-06T11:59:02Z</timestamp>
      <contributor>
        <username>Ltrlg</username>
        <id>791461</id>
      </contributor>
      <minor/>
      <comment>changement de langue ([[WP:AA|atelier accessibilité]])</comment>
      <text xml:space="preserve" bytes="228">'''PhBRML''' ({{lang|en|Physically Based Rendering Modeling Language}}) est une extension du langage [[VRML|VRML 2.0]].

{{Sigle sans homonymie|6}}

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>f10zij7r3vy0f4wv8bv3asur4j0px1x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Booch</title>
    <ns>0</ns>
    <id>175120</id>
    <revision>
      <id>89843384</id>
      <parentid>57863349</parentid>
      <timestamp>2013-03-12T18:43:34Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 6 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2538502]]</comment>
      <text xml:space="preserve" bytes="1496">{{ébauche|informatique}}

La méthode '''Booch''' est, avec [[OMT]] et [[OOSE]], l'une des [[méthodes d'analyse et de conception]] [[orienté objet|orientées objet]] à l'origine d'[[Unified Modeling Language|UML]]. Son nom vient de celui de son concepteur, '''[[Grady Booch]]''', qui sera aussi l'un des pères du langage [[Unified Modeling Language|UML]] (avec [[Ivar Jacobson]], fondateur de la méthode [[Object Oriented Software Engineering|OOSE]] et [[James Rumbaugh]], fondateur de la méthode [[Object Modeling Technique|OMT]]).

Cette méthode permet de faciliter l'implémentation de programmes dans des langages de [[programmation orientée objet]], ainsi que de représenter les différentes phases du développement d'un projet. Pour les programmeurs, l'avantage est d'obtenir une modélisation d'une solution qui soit indépendante de son implémentation dans un langage particulier (par exemple [[Java (langage)|Java]], [[C plus plus|C++]], [[PHP]]...).

Ses concepts fondamentaux sont l'[[objet]], la [[classe (informatique)|classe]], la [[Méthode (informatique)|méthode]] et l'[[attribut]].

== Voir aussi ==
=== Liens internes ===
* [[Unified Modeling Language|UML]]

=== Liens externes ===
* [http://www.ifra.ing.tu-bs.de/docs/BoochReferenz/ The Booch Method (en anglais)]

{{Portail|programmation informatique}}

[[Catégorie:Gestion de projet]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Méthode d'analyse et de conception]]

[[de:Grady Booch#Booch-Notation]]</text>
      <sha1>d0vfhko7kz8fwekp5ari81p0984c9t5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Airelle (langage)</title>
    <ns>0</ns>
    <id>257305</id>
    <revision>
      <id>29704316</id>
      <parentid>25972431</parentid>
      <timestamp>2008-05-18T17:34:36Z</timestamp>
      <contributor>
        <username>Tieno</username>
        <id>2377</id>
      </contributor>
      <minor/>
      <comment>portail</comment>
      <text xml:space="preserve" bytes="234">{{ébauche|informatique}}
'''Airelle''' est un langage de programmation objet écrit au-dessus du langage [[Lisp]].

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>9n1x0a8yo1xaty9zsd0llmum8g99g1c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ada (langage)</title>
    <ns>0</ns>
    <id>27</id>
    <revision>
      <id>101613646</id>
      <parentid>101099812</parentid>
      <timestamp>2014-02-26T15:53:10Z</timestamp>
      <contributor>
        <ip>193.253.32.119</ip>
      </contributor>
      <comment>&quot;supposée avoir été&quot; -&gt; &quot;sans doute&quot;</comment>
      <text xml:space="preserve" bytes="12683">{{voir homonymes|Ada}}
[[Image:ada lovelace.jpg|thumb|right|Ada Lovelace (1840).]]
'''Ada''' est un [[langage de programmation]] [[Programmation orientée objet|orienté objet]] dont les premières versions remontent au début des [[années 1980]].

== Présentation ==
Ada&lt;ref&gt;[http://www.sei.cmu.edu/reports/03tn021.pdf/ What About Ada? The State of the Technology in 2003]&lt;/ref&gt; est un [[langage de programmation]] conçu par l’équipe de [[Compagnie internationale pour l'informatique|CII-Honeywell Bull]] dirigée par [[Jean Ichbiah]] en réponse à un [[cahier des charges]] établi par le [[département de la Défense des États-Unis]] (DoD). Son développement a commencé au début des [[années 1980]] pour donner '''Ada 83'''. Pour cela, l'équipe de Jean Ichbiah s'est inspirée de son précédent langage LIS (Langage d'Implémentation de Systèmes), conçu à la CII pour permettre le développement de systèmes d'exploitation portables (à 95 %, disait Ichbiah).

'''Ada 83''' a été ensuite repris et amélioré au milieu des [[années 1990]] pour donner '''Ada 95''', le second [[Programmation orientée objet|langage objet]] normalisé de manière internationale (publié en février 1995, il est précédé de peu par [[Common Lisp]], publié en décembre 1994). Sous les auspices de l’[[Organisation internationale de normalisation]] (ISO), le langage a bénéficié d'un amendement ('''Ada 2005''') puis d'une nouvelle révision appelée '''Ada 2012'''.

Le nom ''Ada'' a été choisi en l’honneur d’[[Ada Lovelace]], sans doute la première informaticienne de l’histoire. Il est associé à la couleur verte car, lors de l’appel d’offre du DoD, les différentes propositions étaient désignées par des couleurs pour éviter tout biais, et l’équipe qui l’a conçu était l’équipe verte.

Voici quelques particularités d’Ada :
* typage statique ;
* [[Module (programmation)|module]] par les paquetages et contrôle fin de la visibilité ;
* [[syntaxe]] claire et non ambiguë (inspirée de celle du [[Pascal (langage)|langage Pascal]]) ;
* généricité ;
* multi-tâche ;
* traits [[Système temps réel|temps réel]] intégrés au langage (tâches, objets protégés, interruptions) ;
* bibliothèques normalisées ;
* liens avec les autres langages ;
* annexes temps réel avec le [[Profil Ravenscar]] pour les systèmes sûrs ;
* le document de la norme ISO est librement téléchargeable (voir ci-dessous).

Il est souvent utilisé dans des [[système temps réel|systèmes temps réel]] et [[informatique embarquée|embarqués]] nécessitant un haut niveau de fiabilité et de sécurité.  De nos jours, Ada95 est employé bien sûr par son initiateur, mais aussi dans toutes les technologies de pointe ; en France, l’automobile, les transports ferroviaires (ALSTOM, Siemens Transportation Systems, ANSALDO STS) ([[TGV]], Corail, RER, METEOR), les technologies aéronautiques ([[Thales Air Systems]], [[Thales Avionics]], [[Airbus]], [[EADS Défense et sécurité]]) et les technologies spatiales ([[Thales Alenia Space]], [[EADS Astrium]], [[CNES]], [[Arianespace]]).

En [[2013 en informatique|2013]], il est possible de trouver des [[compilateur]]s Ada pour certains [[système d'exploitation|systèmes d’exploitation]] (Windows, Linux, VxWorks) et [[Architecture matérielle|architectures matérielles]], y compris un compilateur libre ([[GNAT]], inclus dans ''[[GNU Compiler Collection]]'') compilant de l’Ada 83/95/2005/2012.

Ada est parfois utilisé en introduction aux cours de [[programmation informatique]] avancée&lt;ref&gt;[http://d.feneuille.free.fr/enseignerada.htm Daniel Feneuille : Enseigner Ada (pourquoi ?, à qui ?, comment !)]&lt;/ref&gt;, et il peut être utilisé pour les cours d'introduction à la [[programmation]]&lt;ref&gt;C'est le cas au sein de l'école d'ingénieur française INSA de Toulouse. Voir [http://odf.insa-toulouse.fr/fr/formation/formation_ingenieur/offre_de_formation/cursus_ingenieur/sciences_et_technologies/ingenieur_genie_physique/deuxieme_annee_ingenierie_des_materiaux_composants_et_systemes/I2MAIF21-algorithmique_et_programmation_systeme_d_exploitation.html le programme détaillé].&lt;/ref&gt;.

== Autres langages dans la mouvance Ada ==
Ada est inspiré du [[Pascal (langage)|Pascal]] dont il a repris tant l'esprit de la syntaxe que de l'architecture. Le langage Ada a inspiré [[Bertrand Meyer]] pour la conception du langage [[langage Eiffel|Eiffel]], qui y ajoute des notions de programmation par contrat (mais se montre moins adapté à l'industrie sous certains aspects). La notion de [[programmation par contrat]], formalisée par Bertrand Meyer avec Eiffel, a amené la création d'une extension au langage Ada, {{lien|fr=SPARK (langage)|lang=en|trad=SPARK (programming language)|texte=SPARK}}, pour lui faire supporter des notations permettant d'exprimer des assertions contractuelles dans les spécifications.

Dans le domaine des bases de données, Ada a inspiré le langage [[PL/SQL]].

Le langage Ada est également à la base de la conception des différents langages de la norme [[CEI 61131-3|IEC 61131-3]], en particulier la partie déclarative commune à tous les langages et le langage ST ([[Texte structuré]]).

== &quot;Hello, world!&quot; en Ada 95 ou Ada 2005 ==
Un exemple courant pour montrer la syntaxe d’un langage est le programme [[Hello world]] :

&lt;source lang=&quot;ada&quot;&gt;
with Ada.Text_IO; -- Bibliothèque

-- Déclaration de la procédure &quot;Hello&quot;
procedure Hello is
begin
  -- Imprimer &quot;Hello, world!&quot; à l'écran
  Ada.Text_IO.Put_Line(&quot;Hello, world!&quot;);
end Hello;
&lt;/source&gt;

Il existe des raccourcis pour &lt;tt&gt;Ada.Text_IO.Put_Line&lt;/tt&gt; nécessitant moins de caractères, mais ils ne sont pas utilisés ici pour des raisons de compréhension. Pour des explications plus détaillées, vous pouvez consulter [[Wikibooks:Ada Programming/Basic]].

== Bref historique ==

* [[1974 en informatique|1974]] : Le [[département de la Défense]] [[États-Unis|américain]] s'aperçoit qu’il gaspille énormément d’argent en utilisant grosso modo un [[langage de programmation]] par application, et en entretenant des programmes écrits dans des langages obsolètes endémiques ou exotiques. Certaines sources avancent le chiffre de 500 langages de programmation employés en ces lieux.&lt;br&gt;Le résultat de cette prise de conscience est l’élaboration, en 3 ans, du cahier des charges d’un langage unique, suffisamment souple et puissant pour remplacer tous les autres, que ce soit pour le guidage de missiles ou les travaux sur l’[[intelligence artificielle]] en passant par les applications de gestion.

* [[1977 en informatique|1977]] : Le département lance un appel d’offres, remporté par une équipe dirigée par le Français [[Jean Ichbiah]].

* [[1980 en informatique|1980]] : [[Jean Ichbiah]] fonde la compagnie [[Alsys]] (Ada Language Systems).

* [[1983 en informatique|1983]] : Ada83 est normalisé aux [[États-Unis]] par l’[[ANSI]] (ANSI/MIL-STD-1815A-1983).

* [[1987 en informatique|1987]] : Ada83 fait l’objet de la [[norme internationale]] [[ISO]] 8652:1987.

* [[1990 en informatique|1990]] : À partir des améliorations apportées par les différents développeurs de compilateurs, l’Ada Joint Program Office lance un projet de révision du langage.

* [[1991 en informatique|1991]] : [[Alsys]] est revendu à Thomson-CSF et devient TSP.

* [[1992 en informatique|1992]] : Un contrat est passé entre le comité de révision ([[Ada9X Program Office]]) et l’[[Université de New York]] pour le développement d’un compilateur de référence pour le nouveau langage, qui sera [[logiciel libre|librement]] disponible. Ce compilateur, [[GNAT]], est basé sur la technologie [[GNU Compiler Collection|GCC]] de [[GNU]].

* [[1994 en informatique|1994]] : La société [[Ada Core Technologies]] (aujourd’hui [[AdaCore]]) est fondée par les membres du projet [[GNAT]] pour poursuivre la maintenance du compilateur et en assurer la commercialisation et le support.

* [[1995 en informatique|1995]] : La révision tant attendue arrive à son terme, Ada95 voit le jour. Une norme révisée est publiée, [[ISO]]/[[Commission électrotechnique internationale|CEI]] 8652:1995. Ada95 est le premier langage qui met en œuvre la [[programmation orientée objet]] à faire l’objet d’une norme internationale. Le compilateur [[GNAT]] couvre l’intégralité de la norme Ada95, y compris l’ensemble de ses annexes optionnelles.

* [[1996 en informatique|1996]] : TSP devient Aonix&lt;ref&gt;Greffe du tribunal de Commerce de Nanterre, {{formatnum:380249003}} RCS Nanterre&lt;/ref&gt;.

* [[2000 en informatique|2000]] : L’[[Ada Conformity Assessment Authority]] (ACAA) publie un ensemble de corrections mineures accumulées au cours des cinq années précédentes : le Technical Corrigendum 1.

* [[2003 en informatique|2003]] : Un [http://www.sei.cmu.edu/reports/03tn021.pdf rapport] du {{lien|fr=Software Engineering Institute|lang=en}} prédit la mort du langage Ada malgré sa supériorité sur les autres.

* [[2007 en informatique|2007]] : L'ISO publie l'Amendement 1 au langage qui introduit de nouvelles fonctions et officialise de nombreuses améliorations proposées initialement par les différents développeurs de compilateurs. Cette version du langage porte le nom d'Ada 2005, année durant laquelle l'Amendement fut figé pour publication par l'ISO.

* [[2012 en informatique|2012]] : L'ISO publie une nouvelle révision de la norme (Ada 2012), qui apporte notamment des facilités syntaxiques, la [[programmation par contrat]], le support des architectures [[Microprocesseur_multi-cœur|multi-cœurs]], et une extension de la bibliothèque prédéfinie.

== Voir aussi ==
=== Articles connexes ===
{{Autres projets
|wikibooks=Programmation Ada
|wikibooks titre=Programmation Ada
}}
* [[GNAT]] (compilateur Ada libre)
* [[MaRTE OS]] (système d'exploitation temps réel écrit en Ada)

=== Liens externes ===
* {{en}} [http://www.adaic.com Ada Information Clearinghouse] : les documents normatifs et bien d'autres choses encore.
* {{en}} [http://www.ada-auth.org/ Ada Conformity Assessment Authority] : ce groupe indépendant supervise la vérification de conformité des mises en œuvre du langage (autrefois appelé « validation ») et pilote le processus d’amendement et d’amélioration de la définition du langage.
* {{fr}} [http://www.ada-france.org Ada France] : cette association organise un concours tous les ans avec des prix élevés ({{unité|1500|€}} pour le premier prix).
* {{fr}} [http://groups.google.com/group/fr.comp.lang.ada fr.comp.lang.ada] : le groupe Usenet le plus actif en français
* {{en}} [http://groups.google.com/group/comp.lang.ada comp.lang.ada] : en anglais
* {{en}} [http://libre.adacore.com/ Les pages libres d’AdaCore] : AdaCore propose ici en téléchargement ses outils GPL notamment le compilateur GNAT et l’environnement de développement GPS.
* {{fr}} [http://ada.developpez.com Developpez] : Diverses ressources sur Ada.
* {{fr}} [http://libre.adacore.com/libre/tools/more_resources/ada-course-in-french/ un cours Ada95 complet (sauf temps réel)]
* {{en}} [http://www.everyspec.com/MIL-STD/MIL-STD+%281800+-+1999%29/ANSI-MIL-STD-1815A_8646/ MIL-STD-1815A, Ada Programming Language]
* {{en}} [http://www.ada2012.org/ Site d'information sur Ada 2012]

=== Bibliographie ===

* [[John Barnes (programmeur)|John Barnes]] ([[2000]]), ''Programmer en Ada 95'', ISBN 978-2-7117-8651-0
* [[John Barnes (programmeur)|John Barnes]] ([[2006]]), ''Programming en Ada 2005'', ISBN 978-0-321-34078-8
* [[Alan Burns and Andy Wellings]] ([[1998]]), ''Concurrency in Ada - second Edition'', ISBN 0 521 62911 X
* [[Pierre Breguet, Luigi Zaffalon]] ([[2003]]), ''Programmation séquentielle avec ADA 95'', ISBN 978-2-88074-404-5
* [[Pierre Breguet, Luigi Zaffalon]] ([[2003]]), ''Programmation concurrente et temps réel en ADA 95'', ISBN 978-2-88074-408-3
* [http://www.lea-linux.org/documentations/index.php/Dev-ada Léa-Linux] : Introduction au langage Ada.
* {{fr}} Simon Descarpentries, ''[http://sd12s.fdn.fr/realisations/articles/LM66/LM66_Ada%20GTK+,%20le%20duo%20gagnant.html Ada95 et GTK+, le duo gagnant ?]'' Article paru dans GNU/Linux Magazine France
* {{fr}} Jean-Pierre Rosen ''[http://fr.wikibooks.org/wiki/M%C3%A9thodes_de_g%C3%A9nie_logiciel_avec_Ada Méthodes de Génie Logiciel avec Ada] (WikiBook)

== Notes et références ==
{{Références}}

{{Palette|Langages de programmation}}

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Théorie des types|Ada]]
[[Catégorie:Programmation concurrente]]</text>
      <sha1>7qcm9gpx94voe79qm4w9fzqawokfr5o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awk</title>
    <ns>0</ns>
    <id>13417</id>
    <revision>
      <id>101683363</id>
      <parentid>96776125</parentid>
      <timestamp>2014-02-28T23:25:28Z</timestamp>
      <contributor>
        <username>Litlok</username>
        <id>38320</id>
      </contributor>
      <minor/>
      <comment>Introduction : simplification du titre de la page d'homonymie</comment>
      <text xml:space="preserve" bytes="8500">{{minuscule}}
{{voir homonymes|AWK}}
'''awk''' — dont le nom vient des trois créateurs, [[Alfred Aho]], [[Peter Weinberger]] et [[Brian Kernighan]] — est un [[Langage de script|langage]] de traitement de lignes, disponible sur la plupart des systèmes [[Unix]] et sous [[Windows]] avec [[Cygwin]] ou [[GNU Awk|Gawk]]. Il est principalement utilisé pour la manipulation de fichiers textuels pour des opérations de recherches, de remplacement et de transformations complexes.

== Présentation ==
Awk est le plus souvent utilisé pour la production de fichiers plats aux spécifications particulières (échanges entre différents systèmes d'informations hétérogènes). Il est aussi utilisé comme &quot;[[Analyse syntaxique|parser]]&quot; de fichiers [[Extensible Markup Language|XML]] ou de fichiers textes pour générer des commandes [[Structured Query Language|SQL]] à partir des données extraites. Il peut être utilisé aussi pour des opérations de calculs complexes et mise en forme de données brutes pour faire des tableaux statistiques.

On distingue awk, la commande originale, du ''new awk'' (nawk), arrivée un peu plus tard sur le marché. 
Les implémentations [[GNU]] de awk, sont en fait des ''new awk''. On trouve en général la commande awk dans /usr/bin sous Unix. Certains systèmes [[GNU/Linux]] le mettent dans /bin. En général, elle est dans la [[variable d'environnement]] [[Chemin d'accès#Variable d'environnement pour l'emplacement des exécutables|PATH]]. Cependant, on peut faire des scripts en awk et le [[shebang]] (#!/usr/bin/awk -f) devient faux. Le script est donc inutilisable si le binaire n’est pas là où on l’attend.

Il agit comme un filtre programmable prenant une série de lignes en entrée (sous forme de fichiers ou directement via l'entrée standard) et écrivant sur la sortie standard, qui peut être redirigée vers un autre fichier ou programme. Un programme Awk est composé de trois blocs distincts utilisables ou non pour le traitement d'un fichier (prétraitement, traitement, posttraitement). Awk lit sur l'entrée ligne par ligne, puis sélectionne (ou non) les lignes à traiter par des [[Expression rationnelle|expressions rationnelles]] (et éventuellement des numéros de lignes). Une fois la ligne sélectionnée, elle est découpée en champs selon un séparateur d'entrée indiqué dans le programme awk par le symbole FS (qui par défaut correspond au caractère espace ou tabulation). Puis les différents champs sont disponibles dans des variables : $1 (premier champ), $2 (deuxième champ), $3 (troisième champ), ..., $NF (dernier champ).

« awk » est aussi l'extension de nom de fichier utilisée pour les scripts écrits dans ce langage (rarement utilisée).

La syntaxe est inspirée du [[C (langage)|C]] :&lt;br /&gt;
&lt;code&gt;awk [options] [programme] [fichier]&lt;/code&gt;&lt;br /&gt;
où la structure du programme est :&lt;br /&gt;
&lt;code&gt;'motif1 { action1 }
motif2 { action2 } ...'&lt;/code&gt;
&lt;br /&gt;
Chaque ligne du fichier est comparée successivement aux différents motifs (le plus souvent des [[expression rationnelle|expressions rationnelles]], et globalement une expression booléenne) et l'action du premier motif renvoyant la valeur vraie est exécutée. Dans ce cas, ou si aucun motif n'est accepté, le programme lit la ligne suivante du fichier et la compare aux motifs en partant du premier.

Quelques options : 
* &lt;code&gt;-F séparateur&lt;/code&gt; : permet de modifier le séparateur de champs ;
* &lt;code&gt;-f fichier&lt;/code&gt; : lit le programme à partir d'un fichier.
* &lt;code&gt;-v awkVar=$shellVar&lt;/code&gt; : Permet de facilement intégrer des variables du shell dans le code awk.

== Description technique ==
Un fichier est divisé en lignes (''records'' en anglais) elles-mêmes divisées en champs (''fields'' en anglais)
*lignes : séparateur &lt;newline&gt; ; compteur NR.
*champs : séparateur espace ou tabulation ; compteur NF.

Les séparateurs d'entrée-sortie sont stockés dans des variables et peuvent être modifiés : 
*lignes : variables RS et ORS
*champs : variables FS et OFS

Pour retourner le n{{e}} champ :
* &lt;code&gt;$n&lt;/code&gt; où &lt;code&gt;n&lt;/code&gt; est un entier strictement positif ;
* &lt;code&gt;$0&lt;/code&gt; retourne la ligne entière.

Deux masques spéciaux : 
* &lt;code&gt;BEGIN&lt;/code&gt; : définit un programme avant de commencer l'analyse du fichier ;
* &lt;code&gt;END&lt;/code&gt; : définit un programme après l'analyse.

Pour définir un intervalle, on utilise la virgule comme ceci : 
* &lt;code&gt;NR == 1, NR == 10&lt;/code&gt; : l'action associée sera appliquée aux lignes 1 à 10.

Plusieurs fonctions sont déjà implémentées : 
* &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt; : fonctions d'affichage ;
* &lt;code&gt;cos(expr)&lt;/code&gt;, &lt;code&gt;sin(expr)&lt;/code&gt;, &lt;code&gt;exp(expr)&lt;/code&gt;, &lt;code&gt;log(expr)&lt;/code&gt; ;
* &lt;code&gt;getline()&lt;/code&gt; : lit l'entrée suivante d'une ligne, retourne 0 si fin de fichier (''EOF : end of file''), 1 sinon ;
* &lt;code&gt;index(s1, s2)&lt;/code&gt; : retourne la position de la chaîne s2 dans s1, retourne 0 si s2 ne figure pas dans s1 ;
* &lt;code&gt;int(expr)&lt;/code&gt; : partie entière d'une expression ;
* &lt;code&gt;length(s)&lt;/code&gt; : longueur de la chaîne s ;
* &lt;code&gt;substr(s,n,l)&lt;/code&gt; : retourne une partie de la chaine de caractères s commençant à la position n, et d'une longueur l.

Structures de contrôles : la syntaxe provient directement du C : 
* &lt;code&gt;'''if''' (test) {actions} '''else''' {actions}&lt;/code&gt;
* &lt;code&gt;'''while''' (test) {actions}&lt;/code&gt;
* &lt;code&gt;'''do''' {actions} '''while''' (test)&lt;/code&gt;
* &lt;code&gt;'''for''' (expr1;expr2;expr3) {actions}&lt;/code&gt;
* &lt;code&gt;continue&lt;/code&gt; : passe à l'élément suivant dans une boucle
* &lt;code&gt;break&lt;/code&gt; : sort d'une boucle

Par rapport au C il y a quelques extensions :
* &lt;code&gt;continue&lt;/code&gt; : hors d'une boucle, passe au motif suivant. 
* &lt;code&gt;next&lt;/code&gt; : passe à la ligne suivante
* tableaux assocatifs : &lt;code&gt;tableau[texte]=valeur&lt;/code&gt;
* &lt;code&gt;'''for''' (var in tableau) {actions}&lt;/code&gt;

== Quelques exemples ==
* &lt;code&gt;awk '{print $0}' fichier&lt;/code&gt; : affiche toutes les lignes de ''fichier'' (idem que &lt;code&gt;cat fichier&lt;/code&gt;).
* &lt;code&gt;awk '/2/ {print $0}' ref.txt&lt;/code&gt; : affiche toutes les lignes où le caractère 2 est présent (idem que &lt;code&gt;grep '2' ref.txt&lt;/code&gt;).
* &lt;code&gt;awk '$1~/2/ {print $0}' ref.txt&lt;/code&gt; : affiche toutes les lignes où le caractère 2 est présent dans le premier champ.
* &lt;code&gt;awk '{print NR &quot;:&quot;, $0}' fichier&lt;/code&gt; : affiche le contenu de ''fichier'', mais chaque ligne est précédée de son numéro.
* &lt;code&gt;awk -F: '{print $1}' /etc/passwd&lt;/code&gt; : renvoie la liste des utilisateurs (idem &lt;code&gt;cut -d : -f 1 /etc/passwd&lt;/code&gt;).
* &lt;code&gt;awk 'BEGIN {FS = &quot;:&quot;}{print $1}' /etc/passwd&lt;/code&gt; : idem que la précédente commande
* &lt;code&gt;awk '{s=s+$1} END {print s}' fichier&lt;/code&gt; : écrit la somme de tous les nombres de la première colonne de ''fichier''.
* &lt;code&gt;awk '/Motif1/ , /Motif2/' fichier&lt;/code&gt; : écrit toutes les lignes contenues dans le ''fichier'' entre le Motif1 et le Motif2.

== Implémentation ==
Il existe divers programmes qui utilisent la syntaxe du awk original, voici les plus connus :
* nawk (abréviation de ''new awk'') qui étend les fonctionnalités de la version initiale ;
* mawk une version connue pour sa rapidité dans certains cas ;
* gawk la version du GNU disponible sous les principaux OS, avec une modification qui existe pour travailler sur le réseau TCP/IP ;
* jawk une version fonctionnant sur la machine virtuelle Java.

== Voir aussi ==
* [[Sed (logiciel)|Sed]], un autre processeur de fichier, spécialisé dans le traitement de fichiers textes non organisés, basé sur la correspondance de motifs (en anglais, &quot;pattern matching&quot;) et non sur les colonnes et les lignes.

=== Articles connexes ===
* [[GNU Awk]]
* [[Stream Editor]]
* [[Commandes Unix]]

=== Liens externes ===
* {{en}} [http://www.catonmat.net/blog/awk-nawk-and-gawk-cheat-sheet/ antisèche AWK]
* {{en}} [http://www.linuxcertif.com/man/1/awk/ Page man de awk]

=== Bibliographie ===
* {{ouvrage|auteurs=Alfred V. Aho, Peter J. Weinberger et Brian W. Kernighan |année=[[1985]]|titre=AWK Langage de programmation|isbn= 2-87908-110-6}}
* {{ouvrage|auteur=Steve Bourne |titre=Le Système UNIX |trad=Michel Dupuy|pages=398|éditeur=Dunod|année= 1991|isbn=2-72960-014-0}} 
* Pour plus d'informations [http://www.shellunix.com/awk.html Shellunix.com]

{{Palette|Commandes Unix}}
{{Portail|programmation informatique}}

[[Catégorie:Commande Unix]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de script]]</text>
      <sha1>jnz27qq08t5g07trdkfxk2443t7g3p3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>B (langage)</title>
    <ns>0</ns>
    <id>43109</id>
    <revision>
      <id>91563113</id>
      <parentid>89795197</parentid>
      <timestamp>2013-04-01T10:32:01Z</timestamp>
      <contributor>
        <username>MattF</username>
        <id>332001</id>
      </contributor>
      <minor/>
      <comment>Ajout bandeau confusion et suppression parties sur la méthode B</comment>
      <text xml:space="preserve" bytes="2156">{{Confusion|texte=Ne doit pas être confondu avec le langage formel B utilisé dans la [[Méthode B]]}}

Le [[langage de programmation]] '''B''' est un langage depuis longtemps obsolète qui a représenté la transition entre [[BCPL]] et le [[langage C]]. C'est principalement l'œuvre de [[Ken Thompson]] et il apparut pour la première fois en [[1969]] environ.

== Description ==
C'était en fait le BCPL privé de tout ce que Thompson pensait ne pas être essentiel, afin de pouvoir être utilisé sur de petits ordinateurs et avec quelques changements pour correspondre aux goûts de Thompson (principalement réduire le nombre de caractères dans un programme).

Comme le BCPL et le [[Forth (langage)|Forth]], le B avait un seul type de donnée, le « mot » (''word'') d'ordinateur. La plupart des opérateurs (+, -, *, /) le considéraient comme un entier (''integer'') mais d'autres comme une adresse mémoire. Sur d'autres points, il pourrait se faire passer pour une ancienne version du C. Quelques bibliothèques de fonctions existaient, dont certaines ressemblaient vaguement aux fonctions d'entrée-sortie de la [[bibliothèque standard du C]].

== Historique ==

Les premières implémentations étaient pour les mini-ordinateurs de [[Digital Equipment Corporation|DEC]], [[PDP-7]] et [[PDP-11]] et ont été développées en même temps que [[UNIX]].

Le langage B a été implémenté sur les ordinateurs de la série Honeywell 6000 et leurs successeurs (''mainframes'') par une équipe de l'université de Waterloo, dans l'Ontario, au Canada, afin de pouvoir écrire pour le ''time-sharing'' de ces machines un succédané des commandes ''UNIX'' baptisé ''UW-Tools''. Le compilateur B et les ''UW-Tools'' étaient distribués gratuitement en France par Bull, jusque vers l'année 2000. 

D'après Ken Thompson, le B a été grandement influencé par BCPL, mais le nom B lui-même n'a rien à voir : c'était en fait une évolution d'un ancien langage, ''Bon'', du nom de l'épouse de Ken Thompson, prénommée Bonnie.


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ed9x71osqfjlk5c8lbt6sffiyj8ew5e</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Erlang (langage)</title>
    <ns>0</ns>
    <id>100757</id>
    <revision>
      <id>98746242</id>
      <parentid>97468368</parentid>
      <timestamp>2013-11-28T20:36:50Z</timestamp>
      <contributor>
        <ip>93.182.201.21</ip>
      </contributor>
      <comment>Supppression lien interdit d' acces</comment>
      <text xml:space="preserve" bytes="10383">{{voir homonymes|Erlang}}
{{Infobox Langage de programmation
 | nom                              = Erlang
 | logo                             = Erlang logo.png
 | paradigme                        = [[Programmation concurrente|Concurrent]]&lt;br /&gt;[[Programmation fonctionnelle|Fonctionnel]]
 | année                            = [[1987 en informatique|1987]]
 | auteur                           = [[Ericsson]]
 | développeur                      = [[Ericsson]]
 | dernière version stable          = 
 | date de dernière version stable  = 
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = [[Typage dynamique|Dynamique]]&lt;br /&gt;[[Typage fort|Fort]]
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[Prolog]]
 | a influencé                      = [[Scala (langage)|Scala]], [[Clojure]]
 | système d'exploitation           = [[Multi-plateforme]]
 | licence                          = [[Mozilla Public License]]
 | site web                         = [http://www.erlang.org/ erlang.org]
}}
[[File:LYME_software_bundle.svg|thumb|300px|[[LYME]] et LYCE sont basé sur '''Erlang''' et offre alternatives à [[LAMP]]]]
'''Erlang''' est un [[langage de programmation]], supportant plusieurs paradigmes : [[Programmation concurrente|concurrent]], [[Système temps réel|temps réel]], [[Architecture distribuée|distribué]]. Son cœur séquentiel est un [[Programmation fonctionnelle|langage fonctionnel]] à [[évaluation stricte]], [[Affectation (informatique)|affectation unique]], au typage dynamique fort. Sa couche concurrente est fondée sur le [[modèle d'acteur]]. Il possède des fonctionnalités de [[tolérance aux pannes]] et de mise à jour du code à chaud, permettant le développement d'applications à très haute disponibilité.

Il a été créé par [[Ericsson]], qui l'utilise dans plusieurs de ses produits, tel que le commutateur [[Asynchronous transfer mode|ATM]] AXD 301. Initialement [[Logiciel propriétaire|propriétaire]], il est publié sous licence [[Open Source]] en 1998. Il est également utilisé par d'autres entreprises développant des logiciels liés aux réseaux de [[télécommunications]], comme [[T-Mobile]] et [[Nortel]].
Il est aussi utilisé pour écrire le [[Liste de logiciels serveurs XMPP|serveur XMPP]] [[ejabberd]], le serveur [[Hypertext Transfer Protocol|HTTP]] [[Yaws]] ainsi que le [[logiciel de modélisation 3D]] [[Wings 3D]]. Il possède de nombreuses bibliothèques incluses dans la distribution de base et regroupées sous le nom de ''OTP ([[Open Telecom Platform]])''. OTP représente le [[framework]] standard de l'univers Erlang, la plupart des programmeurs l'utilisant comme base d'[[interopérabilité]]. Il peut s'interfacer avec d'autres langages comme [[Java (langage)|Java]] ou [[C plus plus|C++]].

« Erlang » fait référence au mathématicien [[Agner Krarup Erlang|Agner Erlang]], tout en étant la contraction d'''[[Ericsson]] Language''.

== Exemples ==

Comme tous les langages fonctionnels, Erlang repose beaucoup sur la [[Algorithme récursif|récursivité]].

En Erlang, la fonction [[factorielle]] peut s'écrire sous une forme récursive, comme suit : 

&lt;source lang=&quot;erlang&quot;&gt;
-module(fact). % le nom du fichier est fact.erl (fichier et module doivent porter le même nom)
-export([fac/1]). % exporte (publiquement) la fonction fac, d'arité 1 (un seul argument)

fac(0) -&gt; 1; % cas de base : notez le point-virgule qui signifie « ou »
fac(N) when N &gt; 0 -&gt; N*fac(N-1). % cœur récursif : quand N vaut 1, alors fac(N-1) retourne 1,
                                 % la récursion s'arrête et N * 1 est retourné comme résultat
&lt;/source&gt;

où &lt;code&gt;fac(0)&lt;/code&gt; est le cas de base, et &lt;code&gt;fac(N)&lt;/code&gt; le cœur récursif.

Une version utilisant la [[récursion terminale]], avec un accumulateur :

&lt;source lang=&quot;erlang&quot;&gt;
-module(tail_fact).
-export([tail_fact/1]).

tail_fact(N) -&gt; tail_fact(N,1). % interface publique : délègue à l'implémentation tail_fact/2
tail_fact(0,Acc) -&gt; Acc; % cas de base : si N vaut 0, on retourne l'accumulateur
tail_fact(N,Acc) when N &gt; 0 -&gt; tail_fact(N-1,N*Acc). % cœur récursif : contrairement au cas récursif simple,
                                                     % où la valeur de fac() est multipliée à N et doit être
                                                     % conservée en mémoire, ici tail_fact() est « seule »,
                                                     % l'accumulateur Acc permettant de passer à l'itération
                                                     % suivante sans conserver les N-1 valeurs de tail_fact()
                                                     % précédentes en mémoire (le cas de base gère le retour final)
&lt;/source&gt;

L'algorithme de tri [[tri rapide|Quicksort]] avec une implémentation également récursive peut s'écrire sous cette forme en Erlang (de nombreuses variantes existent) :

&lt;source lang=&quot;erlang&quot;&gt;
%% quicksort:qsort(List)
%% Trie une liste d'éléments
-module(quicksort).
-export([qsort/1]).
 
qsort([]) -&gt; [];
qsort([Pivot|Reste]) -&gt;
    qsort([ X || X &lt;- Reste, X &lt; Pivot]) ++ [Pivot] ++ qsort([ Y || Y &lt;- Reste, Y &gt;= Pivot]).
&lt;/source&gt;

Le code fait des appels récursifs à la fonction &lt;code&gt;qsort&lt;/code&gt; jusqu'à ce que l'ensemble soit trié. L'expression &lt;code&gt;[ X || X &lt;- Reste, X &lt; Pivot]&lt;/code&gt; peut se traduire par « Choisir l'ensemble des &lt;code&gt;X&lt;/code&gt; tels que &lt;code&gt;X&lt;/code&gt; est un membre de &lt;code&gt;Reste&lt;/code&gt; et &lt;code&gt;X&lt;/code&gt; est inférieur à &lt;code&gt;Pivot&lt;/code&gt; ». L'opérateur &lt;code&gt;++&lt;/code&gt; est celui de la concaténation entre les listes.

== Fonctionnalités notables ==

=== Le partage de données par passage de message ===
Contrairement aux [[processus léger]]s (threads) dans des langages classiques tels Java ou C, les processus Erlang ne partagent pas de mémoire pour communiquer ce qui permet d'éviter les problèmes liés à la [[Synchronisation_(multitâches)|synchronisation]]. La transmission d'informations se fait uniquement par passage de messages. La primitive qui permet l'envoi d'un message est ''send'', exprimée par &lt;code&gt;!&lt;/code&gt;.

La syntaxe est la suivante :
 Pid ! Message
dans lequel &lt;code&gt;Pid&lt;/code&gt; est l'identité du processus destinataire et &lt;code&gt;Message&lt;/code&gt; une expression quelconque.

À la différence d'autres langages concurrents comme [[Ada (langage)|Ada]], l'envoi et la réception d'un message sont [[Asynchrone|asynchrones]] en Erlang. Du point de vue de l'émetteur, l'envoi est instantané quel que soit l'état du destinataire. Le message est simplement remis dans la boîte aux lettres de ce dernier qui pourra le consommer au moment voulu. Cette propriété permet de découpler temporellement l'émetteur du receveur et ainsi de maximiser le niveau de concurrence dans le système tout en restant tolérant à la latence introduite par la communication dans un système distribué.

=== Gestion explicite du temps ===
Du fait de ses origines comme outil logiciel de télécommunications, Erlang permet la définition de contraintes de temps réel souple ''(soft real time)'', c'est-à-dire l'exécution d'une action à l'intérieur d'un temps déterminé. Erlang incorpore la gestion du temps dans la primitive de réception de message ''receive'', dont la syntaxe est la suivante:
&lt;source lang=&quot;erlang&quot;&gt;
 receive
     Message1 -&gt;
        Action1;
     Message2 -&gt;
        Action2
 after
     Timeout -&gt;
        ActionTimeOut
 end
&lt;/source&gt;

Le processus qui exécute le code ci-dessus attendra au plus, la valeur de l'expression &lt;code&gt;Timeout&lt;/code&gt;.  Si aucun message correspondant à &lt;code&gt;Message1&lt;/code&gt; ou &lt;code&gt;Message2&lt;/code&gt; n'est reçu par le processus d'ici là, il exécute alors l'action &lt;code&gt;ActionTimeOut&lt;/code&gt;.

=== La programmation distribuée à base de nœud et de processus ===
Les processus Erlang s'exécutent dans une machine virtuelle. Plusieurs machines virtuelles possiblement situées sur différents ordinateurs peuvent être connectées entre elles et former les nœuds d'un système distribué. La communication entre processus localisés sur des nœuds différents utilise les mêmes primitives et possède la même sémantique que pour la communication entre processus du même nœud. Du point de vue du programmeur, la localisation d'un processus est transparente.

Les connexions entre nœuds sont dynamiques. Un nœud peut joindre et quitter le système (ou en être isolé par une panne) à n'importe quel moment. Cette caractéristique autorise la tolérance aux pannes par redondance et la montée en charge d'une application par ajout de nouveaux nœuds.

=== La richesse de l'environnement ===
Bâties sur le langage, les bibliothèques ''Open Telecom Platform (OTP)'' offrent des fonctionnalités de distribution des traitements et de supervision des nœuds avancées, ainsi qu'une base de données répartie.  L'accent est mis sur la tolérance aux pannes puisque le couple Erlang/OTP permet entre autres de :
* mettre à jour le code d'un programme sans arrêter celui-ci
* désigner des processus superviseurs qui suivront des instructions bien précises en cas d'arrêt des processus supervisés (redémarrage immédiat ou retardé, décompte du nombre d'erreurs avant de ne plus essayer de redémarrer le processus fautif, etc.)
* mettre en place une hiérarchie de supervision redondante et centralisée de telle sorte que l'application soit entièrement supervisée tout en répartissant la logique de supervision à chaque niveau.

== Voir aussi==

===Articles connexes===

* [[Reia]], un langage de script pour la machine virtuelle Erlang

===Liens externes===
* {{en}} [http://www.erlang.org Site officiel] : implémentation Open Source
* {{en}} [http://www.erlang.org/download/erlang-book-part1.pdf Concurrent programming in Erlang], la bible du langage, en anglais.
* {{en}} [http://www.erlang.se Page d'Erlang chez Ericsson]  : licence et support Ericsson
* {{en}} [http://www.erlang-projects.org Erlang Projects] : un [[portail collaboratif]] dédié à Erlang

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage fonctionnel]]
[[Catégorie:Programmation concurrente]]</text>
      <sha1>8bpklro9edbol323f3oe6b5ypcnzfgi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fortran</title>
    <ns>0</ns>
    <id>1105</id>
    <revision>
      <id>101984368</id>
      <parentid>100973657</parentid>
      <timestamp>2014-03-11T19:30:28Z</timestamp>
      <contributor>
        <username>Verbex</username>
        <id>152500</id>
      </contributor>
      <comment>/* Compilateurs */</comment>
      <text xml:space="preserve" bytes="21913">{{à sourcer|date=avril 2007}}
{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                              = Fortran
 | logo                             = Fortran acs cover.jpeg
 | paradigme                        = Multi-paradigme : [[Programmation impérative|impératif]] ([[Programmation procédurale|procédural]], [[Programmation structurée|structuré]], [[Programmation orientée objet|orienté-objet]]), [[Généricité|générique]]
 | auteur                           = [[John Backus]]
 | développeur                      = [[John Backus]] &amp; [[IBM]]
 | date de première version         = 1957
 | dernière version stable          = Fortran 2008 (ISO/IEC 1539-1:2010)
 | date de dernière version stable  = 2010
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = [[Typage fort|fort]], [[Typage statique|statique]]
 | implémentations                  = Absoft, [[Cray]], [[Gfortran|GFortran]], [[G95]], [[IBM]], [[Intel Fortran Compiler|Intel]], Lahey/Fujitsu, [[Watcom C compiler|Open Watcom]], [[PathScale]], [[PGI compiler|PGI]], [[Silverfrost FTN95|Silverfrost]], [[Oracle Corporation|Oracle]], [[XL Fortran]], Visual Fortran, others
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[Speedcoding]]
 | a influencé                      = [[Algol 58]], [[BASIC]], [[C (langage)|C]], [[PL/I]], [[PACT I]], [[MUMPS]], [[Ratfor]]
 | système d'exploitation           = 
 | licence                          = 
 | site web                         = 
 | date de mise à jour              = 
}}

'''Fortran''' (&lt;u&gt;FOR&lt;/u&gt;mula &lt;u&gt;TRAN&lt;/u&gt;slator) est un [[langage de programmation]] utilisé principalement en [[calcul scientifique]].

== Historique ==

[[John Backus]], pionnier de l'informatique, publie en [[1954]] un article titré ''Preliminary Report, Specifications for the IBM Mathematical FORmula TRANslating System, FORTRAN.'' Il faut ensuite deux ans d'efforts à l'équipe qu'il dirige au sein d'[[International Business Machines Corporation|IBM]] pour écrire le premier [[compilateur]] FORTRAN ({{formatnum:25000}} lignes, pour l'[[IBM 704]]).

Le nom du langage a été écrit conventionnellement en majuscules (FORTRAN) jusqu'en 1992 et l'introduction du Fortran 90 à syntaxe libre&lt;ref&gt;Toutefois, on trouve déjà l'écriture « Fortran » dans le [http://bitsavers.trailing-edge.com/pdf/ibm/704/704_FortranProgRefMan_Oct56.pdf premier manuel de Fortran], remontant à 1956&lt;/ref&gt;. En FORTRAN 77, les lettres minuscules ne font pas partie du langage. Cette convention se retrouve dans cet article et est conforme aux différentes normes du Fortran, de 1966 à aujourd'hui.

Aujourd'hui encore ([[années 2010]]), le langage Fortran reste très utilisé pour plusieurs raisons :

# La présence de très nombreuses bibliothèques de fonctions, mises au point et améliorées durant de nombreuses années,
# l'existence de logiciels en Fortran ayant demandé des ressources très importantes pour leur développement, et dont le passage à un autre langage est jugé trop coûteux,
# l'existence de [[compilateurs]] Fortran performants qui produisent des exécutables très rapides,
# le langage est plus facilement accessible (que par exemple le C++) à un scientifique n'ayant pas eu un cursus spécialisé en informatique.

Toutefois, beaucoup de programmes scientifiques sont à présent écrits en [[C (langage)|C]] et [[C plus plus|C++]]&lt;ref&gt;Par exemple la [[GNU Scientific Library|GSL]] écrite en C, et [http://www.oonumerics.org/blitz/ Blitz++] ou [http://math.nist.gov/iml++/ IML++], en C++&lt;/ref&gt;, dont les compilateurs sont disponibles sur la plupart des machines. D'autres langages compilés sont parfois utilisés pour le calcul scientifique, et surtout des logiciels tels que [[Scilab]] ou [[Matlab]]. Ces derniers incorporent d'ailleurs les bilbiothèques [[Basic Linear Algebra Subprograms|BLAS]] et [[Linear Algebra Package|LAPACK]], développées en Fortran&lt;ref&gt;[http://www.mathworks.fr/company/newsletters/articles/matlab-incorporates-lapack.html MATLAB Incorporates LAPACK]&lt;/ref&gt;{{,}}&lt;ref&gt;[http://www.scilab.org/content/download/370/2662/file/Scilab_Computation.pdf Computation in Scilab]&lt;/ref&gt;. Matlab était d'ailleurs à l'origine un programme en Fortran, distribué aux universités et aux centres de recherche&lt;ref&gt;[ftp://ftp.funet.fi/pub/sci/math/misc/programs/matlab/ Code source de la première version de Matlab]&lt;/ref&gt;.

Le FORTRAN, créé à l'époque des [[Carte perforée|cartes perforées]] (en particulier avec le système [[Fortran Monitor System|FMS]]), optimise la mise en page de ses sources dans cette optique, jusqu'au [[Fortran 90]] qui introduit une syntaxe « libre ». Avant Fortran 90, le code commence à partir de la 7{{e}} colonne et ne doit pas dépasser la 72{{e}}. Il se présente alors ainsi :

* La colonne 1 peut contenir la lettre C indiquant un commentaire. Le caractère * est aussi accepté.
* Les colonnes 1 à 5 peuvent contenir une étiquette numérique (facultative) de l'instruction, dont la valeur peut être limitée à 32767 ou 9999 suivant le compilateur (en FORTRAN II des ordinateurs Advanced Scientific Instruments ASI 210 et ASI 2100). 
* La colonne 6 indique une suite de l'instruction précédente.
* Les colonnes 73 à 80 servent à l'identification et la numérotation des cartes perforées (souvent les trois initiales du projet, du chef de projet ou du programmeur, suivies de numéros de cinq chiffres attribués de dix en dix pour permettre des insertions de dernière minute). 

Il faut également noter qu'avant Fortran 90, les espaces n'ont pas de signification entre la 7{{e}} et la 72{{e}} colonne. Ainsi, la boucle « DO I=1,5 » peut aussi s'écrire « DOI=1,5 ». En revanche, « DO I=1.5 » est équivalent à « DOI=1.5 », une affectation.

De nombreux codes industriels ont été écrits en Fortran et la compatibilité des nouvelles versions avec les précédentes est indispensable, au prix de conserver des notions qui ne s'imposent plus. Pour cette raison, Fortran 90 est complètement compatible avec FORTRAN 77. Les versions suivantes du standard ont cependant introduit des incompatibilités.

Le langage [[BASIC]], dans sa version originale (1964), a été conçu comme un petit langage à caractère pédagogique permettant d'initier les étudiants à la programmation, avant de passer aux langages « sérieux » de l'époque : FORTRAN et [[Algol (langage)|Algol]]. On y retrouve donc quelques traits du langage Fortran.

== Compilateurs ==
Le compilateur libre [[GNU Compiler Collection|GCC]] permet de compiler le Fortran 77 (compilateur g77&lt;ref&gt;[http://www.kilmnj.com/g77/ Copie de l'ancien site de g77]&lt;/ref&gt;{{,}}&lt;ref&gt;[http://www.mbr-pwrc.usgs.gov/software/g77.html g77 pour Windows] sur le site de l'[[United States Geological Survey|USGS]]&lt;/ref&gt;, jusqu'à gcc 3.4.6). Le compilateur gfortran&lt;ref&gt;[http://gcc.gnu.org/wiki/GFortran GCC Wiki - GFortran]&lt;/ref&gt; apparaît avec GCC 4.0.0, en 2005&lt;ref&gt;[http://www.gnu.org/software/gcc/gcc-4.0/changes.html GCC 4.0 Release Series - Changes, New Features, and Fixes]&lt;/ref&gt;{{,}}&lt;ref&gt;[ftp://ftp.gnu.org/gnu/gcc/gcc-4.0.0/ Code source de GCC 4.0.0]&lt;/ref&gt;. Il est issu d'un [[fork]] réalisé en 2003 de {{Lien|fr=G95|lang=en|trad=G95}}, un autre compilateur libre, dont le développement a débuté en 2000. Le développent de G95 a par ailleurs été interrompu entre 2008 et 2012. En 2013, gfortran prend pleinement en charge le standard Fortran 95, et une partie de Fortran 2003&lt;ref&gt;[http://gcc.gnu.org/onlinedocs/gfortran/Fortran-2003-status.html gfortran - 4.1 Fortran 2003 status]&lt;/ref&gt; et Fortran 2008&lt;ref&gt;[http://gcc.gnu.org/onlinedocs/gfortran/Fortran-2008-status.html gfortran - 4.2 Fortran 2008 status]&lt;/ref&gt;. Il n'a d'ailleurs pas à rougir devant les compilateurs commerciaux, pour le support de ces deux « nouveaux » standards&lt;ref&gt;[http://fortranwiki.org/fortran/show/Fortran+2003+status Compiler Support for the Fortran 2003 Standard]&lt;/ref&gt;{{,}}&lt;ref&gt;[http://fortranwiki.org/fortran/show/Fortran+2008+status Compiler Support for the Fortran 2008 Standard]&lt;/ref&gt;, les fabricants étant parfois plus intéressés par l'amélioration de la vitesse du code produit que par les dernières fonctionnalités offertes par le standard.

{{Lien|fr=Open64|lang=en|trad=Open64}}&lt;ref&gt;[http://www.open64.net/ Open64]&lt;/ref&gt; est un autre compilateur [[Logiciel libre|libre]] de Fortran 95, à ne pas confondre avec AMD x86 Open64&lt;ref&gt;[http://developer.amd.com/tools-and-sdks/cpu-development/x86-open64-compiler-suite/ AMD - x86 Open64 Compiler Suite ]&lt;/ref&gt;, lui aussi libre. On trouve également le compilateur libre Open Watcom&lt;ref&gt;[http://www.openwatcom.org/index.php/Main_Page Open Watcom]&lt;/ref&gt;, mais il ne compile que du Fortran 77, et aucune évolution vers un standard plus récent n'est prévue.

On trouve de nombreux compilateurs commerciaux&lt;ref&gt;[http://www.polyhedron.com/compare0html Polyhedron Software - Fortran Compiler Comparisons]&lt;/ref&gt;, parmi lesquels : Lahey&lt;ref&gt;[http://www.lahey.com/ Lahey Fortran]&lt;/ref&gt;, Absoft&lt;ref&gt;[http://www.absoft.com/ Absoft Fortran]&lt;/ref&gt;, {{Lien|fr=PathScale|lang=en|trad=PathScale}}&lt;ref&gt;[http://www.pathscale.com/ekopath.html PathScale EKOPath]&lt;/ref&gt;, {{Lien|fr=Portland Group|lang=en|trad=The Portland Group}}&lt;ref&gt;[http://www.pgroup.com/ Portland Group Fortran]&lt;/ref&gt; (filiale de [[NVidia]]), [[NAG]], etc. La plupart des fabricants de stations de travail ou d'ordinateurs destinés aux calcul intensif, proposent également un compilateur de Fortran : Intel&lt;ref&gt;[http://software.intel.com/en-us/fortran-compilers Intel Fortran Compilers]&lt;/ref&gt;, IBM&lt;ref&gt;[http://www-03.ibm.com/software/products/us/en/fortcompfami/ IBM - Fortran Compilers family]&lt;/ref&gt;, [[Hewlett-Packard|HP]]&lt;ref&gt;[http://h71000.www7.hp.com/doc/fortran.html HP Fortran for OpenVMS documentation]&lt;/ref&gt;, SGI&lt;ref&gt;[http://www.sgi.com/products/software/irix/tools/prompf.html SGI - Fortran MP Applications Development]&lt;/ref&gt;, [[Oracle Corporation|Oracle]] (suite au rachat de ''[[Sun Microsystems]]''&lt;ref&gt;[http://www.oracle.com/technetwork/server-storage/solarisstudio/overview/index.html Oracle Solaris Studio]&lt;/ref&gt;), [[Unisys]]&lt;ref&gt;[http://public.support.unisys.com/common/epa/documentationlibraries.aspx Unisys - Documentation Libraries]&lt;/ref&gt;, Cray&lt;ref&gt;[http://docs.cray.com/ CrayDoc - Customer Documentation]&lt;/ref&gt;, etc. Cela comprend aussi les fabricants aujourd'hui disparus&lt;ref&gt;[http://bitsavers.trailing-edge.com/pdf/ Bitsavers - documentation d'ordinateurs anciens]&lt;/ref&gt;, tels que [[Control Data Corporation|CDC]] ou [[Digital Equipment Corporation|DEC]] (ce dernier a été racheté par [[Compaq]], qui a plus tard fusionné avec HP).

Certains de ces compilateurs commerciaux ont des versions gratuites pour une utilisation non commerciale : c'est le cas d'Intel&lt;ref&gt;[http://software.intel.com/en-us/articles/non-commercial-software-download/ Intel - Téléchargement de logiciels à usage non commercial]&lt;/ref&gt;, Oracle&lt;ref&gt;[http://www.oracle.com/technetwork/server-storage/solarisstudio/overview/index.html Téléchargement de Oracle Solaris Studio]&lt;/ref&gt;, PathScale. IBM a également mis à disposition une version beta de son compilateur XL Fortran pour [[MacOS X]] (sur [[PowerPC]]), jusqu'à la sortie de la version commerciale.

== Exemple ==
&lt;source lang=&quot;fortran&quot;&gt;
      PROGRAM DEGRAD 
! 
! Imprime une table de conversion degrés -&gt; radians 
! ================================================= 
! 
! Déclaration des variables 
      INTEGER DEG 
      REAL RAD, COEFF 
! 
! En-tête de programme 
      WRITE (*, 10) 
   10 FORMAT (' ',20('*') /                                             &amp;
     &amp;        ' * Degres * Radians *' /                                 &amp;
     &amp;        ' ', 20('*') )                                       
! 
! Corps de programme 
      COEFF = (2.0 * 3.1416) / 360.0 
      DO DEG = 0, 90 
         RAD = DEG * COEFF 
         WRITE (*, 20) DEG, RAD 
   20 FORMAT (' *  ',I4,'  * ',F7.5,' *') 
      END DO 
! 
! Fin du tableau 
      WRITE ( *, 30) 
   30 FORMAT (' ',20('*') ) 
! 
! Fin de programme 
      STOP 
      END PROGRAM DEGRAD      
&lt;/source&gt;

Notes :
* Ce programme est écrit en Fortran 90, en « forme fixe » et dans un style favorisant la compatibilité avec Fortran 77.
* Le symbole « ! » indique un commentaire. Il peut être remplacé par les caractères « C » ou « * » lorsqu'il sont utilisés comme premier caractère.
* La déclaration des variables est facultative en Fortran, mais sans déclaration, la variable DEG serait alors de type REAL (les variables dont le nom commence par une des lettres I, J, K, L, M ou N sont par défaut de type INTEGER, les autres de type REAL).
* L'instruction WRITE se réfère à une unité d'entrée-sortie (ici * désigne le terminal) et une spécification de format. Par exemple le format d'étiquette 20 indique qu'il faut écrire une espace, une étoile et deux espaces, un entier (la valeur de DEG) sur 4 caractères puis la valeur de RAD sur 7 caractères dont 5 après le point décimal et enfin une espace et une étoile. Une déclaration de FORMAT peut être n'importe où ; une habitude est de la mettre juste après le WRITE à laquelle elle se réfère, une autre est de les mettre toutes à la fin de l'unité de programme. Plus d'une instruction WRITE peut faire référence à un même FORMAT.
* Le caractère / à la fin d'une ligne indique une suite à la ligne suivante et le caractère &amp; au début de la ligne indique la suite de la ligne précédente.
* L'instruction « DO DEG = 0,90 » indique de répéter en boucle les instructions qui suivent (jusqu'au END DO) pour toutes les valeurs de DEG de 0 à 90 par pas de 1.

== Différentes versions de Fortran ==

Le langage Fortran a connu de nombreuses évolutions&lt;ref&gt;Voir aussi les sites du [http://www.nag.co.uk/sc22wg5/ Working Group 5] et du [http://www.j3-fortran.org/ comité J3] pour plus d'informations sur l'évolution actuelle du standard&lt;/ref&gt; :
* '''1956'''. Fortran II n'avait qu'une seule instruction de branchement conditionnel (« IF-arithmétique ») à trois adresses : &lt;code&gt;IF (A-B) 10, 20, 30&lt;/code&gt; indiquait de sauter aux instructions d'étiquette 10, 20 ou 30 selon que A-B était négatif, nul ou positif. Cette forme de IF était la seule à exister sur l'[[IBM 1130]] lancée pourtant plus de dix ans plus tard.
* '''1958'''. Fortran III n'est jamais sorti sous forme de produit. 
* '''1962'''. Fortran IV introduit, entre autres, l'instruction « IF-logique », permettant d'écrire &lt;code&gt;IF (A .GE. B) GOTO 10&lt;/code&gt; (aller à 10 si A est supérieur ou égal à B).
* FORTRAN V était le nom envisagé au départ pour [[PL/I]], langage de programmation universel d'IBM qui devait réunir les meilleurs aspects de Fortran (pour les applications scientifiques), de [[COBOL]] (pour les applications de gestion), avec quelques emprunts à [[Algol (langage)|Algol]].
* '''1965'''. Le standard ECMA Fortran&lt;ref&gt;{{pdf}} [http://www.ecma-international.org/publications/files/ECMA-ST-WITHDRAWN/ECMA-9,%201st%20Edition,%20April%201965.pdf Standard ECMA Fortran]&lt;/ref&gt;, situé à cheval entre le « Basic Fortran » et le « Fortran ANSI »
* '''1966'''. Fortran 66 (ANSI X3.9-1966)&lt;ref&gt;{{pdf}} [http://www.fh-jena.de/~kleine/history/languages/ansi-x3dot9-1966-Fortran66.pdf Standard Fortran 66]&lt;/ref&gt; est la première version officiellement standardisée (par l'[[American Standards Association]]) de Fortran. On la confond souvent avec Fortran IV.
* '''1978'''. Fortran 77 (ANSI X3.9-1978)&lt;ref&gt;{{pdf}} [http://www.fh-jena.de/~kleine/history/languages/ansi-x3dot9-1978-Fortran77.pdf Standard Fortran 77]&lt;/ref&gt;, entre autres améliorations, facilite la programmation structurée avec des blocs « IF / THEN / ELSE / ENDIF ». En 1978, une extension introduit entre autres « DO WHILE / END DO »&lt;ref&gt;{{pdf}} [http://www.everyspec.com/MIL-STD/MIL-STD-1700-1799/download.php?spec=MIL-STD-1753.011044.PDF MIL-STD-1753, Military Standard: Fortran, DOD Supplement to American National Standard X3.9-1978]&lt;/ref&gt;.
* '''1990'''. Fortran 90 (ANSI X3.198-1992)&lt;ref&gt;{{pdf}} [ftp://ftp.nag.co.uk/sc22wg5/N001-N1100/N692.pdf Standard Fortran 90]&lt;/ref&gt; : [[Bibliothèque logicielle|modules]], [[Algorithme récursif|récursivité]], [[surcharge des opérateurs]], nouveaux [[Type (informatique)|types de données]], etc. C'est une mise à jour importante pour mettre Fortran au niveau des autres langages modernes. Les restrictions concernant la mise en forme des programmes (colonnes 1 à 72) disparaissent : l'écriture se fait en format libre.
* '''1995'''. Fortran 95 (ISO/CEI 1539-1:1997)&lt;ref&gt;{{pdf}} [http://j3-fortran.org/doc/standing/archive/007/97-007r2/pdf/97-007r2.pdf Standard Fortran 95]&lt;/ref&gt;
* '''2003'''. Fortran 2003 (ISO/CEI 1539-1:2004)&lt;ref&gt;{{pdf}} [http://www.j3-fortran.org/doc/year/04/04-007.pdf Standard Fortran 2003]&lt;/ref&gt; : comme le [[COBOL]] 2002, Fortran supporte maintenant la [[programmation orientée objet]]&lt;ref&gt;initiée par [[Simula]] 67 et popularisée par C++ et [[Java (langage)|Java]].&lt;/ref&gt;. L'interface avec le langage C est assurée par le module interne ISO_C_BINDING, qui permet à un programme Fortran d'accéder facilement aux innombrables bibliothèques disponibles en C.
* '''2008'''. Fortran 2008 (ISO/CEI 1539-1:2010)&lt;ref&gt;{{pdf}} [http://www.j3-fortran.org/doc/year/10/10-007.pdf Standard Fortran 2008]&lt;/ref&gt;.
* La prochaine version prévue, Fortran '''2015''', apportera des modifications mineures au langage&lt;ref&gt;[http://software.intel.com/en-us/blogs/2013/08/08/doctor-fortran-goes-dutch-fortran-2015 Doctor Fortran Goes Dutch: Fortran 2015]&lt;/Ref&gt;.

== Bibliothèques graphiques ==
Les normes Fortran n'incluent pas d'instructions graphiques. Pour pallier ce manque, il faut utiliser des [[bibliothèque logicielle|bibliothèques]] :
* [https://github.com/jerryd/gtk-fortran gtk-fortran] : interface [[GTK+]] 2 et 3 / Fortran, entièrement écrite en Fortran 2003 standard grâce au module ISO_C_BINDING. Multiplateforme (Linux, Windows, Mac OS X...) Projet lancé en janvier 2011. Logiciel libre sous licence GPL 3.
* [http://sourceforge.net/projects/pilib pilib] (Platform Independent Library for Fortran) : interface Fortran 90-95 / GTK. Développement arrêté. Logiciel libre.
* Quickwin : bibliothèque graphique fournie avec le Compaq Visual Fortran (désormais Intel Visual Fortran). Ne fonctionne que sous Windows.
* [http://www.winteracter.com/ Winteracter] : interface graphique et outils de visualisation. Logiciel commercial pour Windows, Linux et MacOS X.
* [http://protodesign-inc.com/sansgui.htm SansGUI] : interface commerciale pour Windows et Compaq Visual Fortran.
* [http://www.dislin.de/ DISLIN] : bibliothèque graphique créée par le Max Planck Institute for Solar System Research. Multiplate-formes ([[UNIX]], Linux, [[FreeBSD]], OpenVMS, Windows et MS-DOS). Fonctionne avec de nombreux compilateurs. Gratuit pour un usage non-commercial.
* [http://www.japi.de/ JAPI] (Java Application Programming Interface) : interface Java/Fortran permettant de créer une interface graphique complète pour les programmes Fortran. Multiplate-formes (Windows, Linux, [[Solaris (système d'exploitation)|Solaris]]). Fonctionne avec de nombreux compilateurs (entre autres gfortran, Compaq Visual Fortran...) Logiciel libre sous licence LGPL.
* [http://wiki.tcl.tk/4004 Ftcl] : interface Fortran-[[Tool Command Language|Tcl]]/TK. Gratuit, open-source.
* [http://math.nist.gov/f90gl/ f90gl] : interface du Fortran 90 avec OpenGL, GLU et GLUT. Multiplate-formes. Fonctionne avec de nombreux compilateurs. Licence : domaine public.
* [http://spdg1.sci.shizuoka.ac.jp/grwinlib/english/ GrWin Graphics Library] : logiciel libre pour Windows.
* [http://www.xeffort.com/index.html Xeffort] : bibliothèque graphique pour Visual Fortran. logiciel libre pour Windows.
* [http://g2.sourceforge.net/ g2 graphical library] : pour Linux, [[AIX]], [[Digital Unix]], [[SunOS]], [[IRIX]], [[OpenVMS]], Windows. Logiciel libre sous licence LGPL.
* [http://plplot.sourceforge.net/ PLplot] : bibliothèque pour tracer des courbes scientifiques. Multiplate-formes (Linux, [[OpenSolaris]], [[Unix]], MS-DOS, Windows, Mac OS X). Logiciel libre sous licence LGPL.
* [http://www.astro.caltech.edu/~tjp/pgplot/ PGPLOT] : bibliothèque de routines graphiques, interactive, gratuite, multiplate-forme, gère beaucoup de périphériques de sortie.
* [ftp://dogfish.ocean.nova.edu/psplot/ PSPLOT], pour générer des dessins en [[PostScript]].

== Voir aussi ==
* [[Fortress (langage)|Fortress]], un langage visant à remplacer le Fortran
* [[Fortran 90]]
* [[Fortran 95]]

== Bibliographie ==
* ''The history of FORTRAN I, II, and III'' par '''[[John Backus]]''' dans ''The first ACM SIGPLAN conference on History of programming languages'', Los Angeles, CA, pages: 165 - 180, 1978, ISSN:0362-1340.

== Liens externes ==
* {{pdf}} [http://community.computerhistory.org/scc/projects/FORTRAN/FORTRAN_PreliminaryReport_1954.pdf Preliminary Report, Specifications for the IBM Mathematical FORmula TRANslating System, FORTRAN], 10 novembre 1954.
* [http://www.nag.co.uk/sc22wg5/ Site officiel des standards Fortran]
* {{en}} [http://www.polyhedron.com/compare.html Comparaison (benchmark) de différents compilateurs Fortran, en anglais]
* {{fr}} [http://fortran.developpez.com/ Cours, tutoriels, norme et forum Fortran]
* {{pdf}} [http://www.fortran.com/FortranForTheIBM704.pdf FORTRAN Reference Manual for the IBM 704 (1956)]

== Notes et références ==
{{Références|colonnes=2}}

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage Fortran]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Norme ISO]]
[[Catégorie:Norme CEI]]</text>
      <sha1>nmo1t4ru8bojho78cs0fqyut7rpvhsw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>J (langage)</title>
    <ns>0</ns>
    <id>102195</id>
    <revision>
      <id>97591834</id>
      <parentid>96244692</parentid>
      <timestamp>2013-10-19T13:45:15Z</timestamp>
      <contributor>
        <username>WikiCleanerBot</username>
        <id>351003</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.29 - [[P:HOM|Homonymies]] : Correction de 1 lien - [[Portabilité]]</comment>
      <text xml:space="preserve" bytes="1667">{{homon|J}}
{{ébauche|informatique}}

Le '''langage J''' a été créé au début des [[années 1990]] par [[Kenneth Iverson]], inventeur d'[[APL (langage)|APL]]. Iverson a raffiné [[APL (langage)|APL]] et considère avoir simplifié sa notation en lui ajoutant des concepts de verbes, d'adverbes et de conjonctions. Ces notions étaient déjà présentes en APL, où les variables ont un rôle de mots, les ''filtres'' d'adjectifs et les ''opérations'' et ''fonctions'' de verbes.

Le langage J s'interface avec le web, les bases de données, etc. Il est disponible sur plusieurs plateformes, dont [[Microsoft Windows|MS Windows]], [[Linux]] et [[MacOS X]]. La version ''J701'' est sous double licence : [[Licence publique générale GNU|GPL]]v3 ou une licence commerciale suivant l'usage envisagé.

== Accueil ==

L'arrivée du J a créé une scission dans le front des utilisateurs d'APL.

* Les uns ont apprécié que le langage soit enfin utilisable à partir d'un terminal ASCII classique : un terminal sur trois était alors électromécanique, et peu de ceux à écran disposaient de caractères programmables. 

* Les autres, trouvant plus parlants les signes spéciaux d'APL (proches des mathématiques classiques, ou les généralisant) ont préféré rester sur ce langage.

L'apparition de différentes extensions non compatibles entre [[Mise en œuvre|mises en œuvre]]s du langage APL a donné un peu d'élan supplémentaire à J, qui présente une plus grande [[portabilité (informatique)|portabilité]].

== Liens externes ==
{{officiel|http://www.jsoftware.com/}}

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>kbbc6w34od5tayo4m0ax7arrnmoalcm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Algol W</title>
    <ns>0</ns>
    <id>118808</id>
    <revision>
      <id>100746885</id>
      <parentid>94829279</parentid>
      <timestamp>2014-01-30T15:56:04Z</timestamp>
      <contributor>
        <ip>109.190.20.180</ip>
      </contributor>
      <comment>Typo + formulation</comment>
      <text xml:space="preserve" bytes="2392">{{ébauche|informatique}}

'''Algol W''' est une version du langage [[Algol (langage)|Algol]] due à [[Niklaus Wirth]], proposée au comité [[Algol 68]] pour succéder à [[Algol 60]]. Bien qu'antérieure au [[Pascal (langage)|Pascal]], elle était plus puissante à certains points de vue. En particulier toute expression ou tout bloc ramenait un résultat, ce qui permettait l'écriture d'expressions particulièrement élégantes.

Algol-W est visiblement une étape transitoire entre Algol 60 et Pascal. Il représente une modification relativement légère d'Algol 60, auquel N. Wirth a ajouté les types de données « string », « bitstring », les nombres complexes et les références à des enregistrements (structures), ainsi que le passage de paramètres par valeur, sans changer grand-chose d'autre.

Comme tous les autres langages de Wirth (Pascal, Modula-2, Oberon, etc.), Algol-W est un petit langage à typage statique qui diffère beaucoup moins d'Algol 60 que d'[[Algol 68]], langage nettement plus « gros » et plus complexe. 

== Exemple ==

 {{souligner|record}} PERSON (
     {{souligner|string}} NAME; 
     {{souligner|integer}} AGE; 
     {{souligner|logical}} MALE; 
     {{souligner|{{langue|anglais|reference}}}}(PERSON) FATHER, MOTHER, YOUNGESTOFFSPRING, ELDERSIBLING
 );
 
 {{souligner|reference}}(PERSON) {{souligner|procedure}} YOUNGESTUNCLE ({{souligner|reference}}(PERSON) R);
     {{souligner|begin}}
         {{souligner|reference}}(PERSON) P, M;
         P := YOUNGESTOFFSPRING(FATHER(FATHER(R)));
         {{souligner|while}} (P ¬= {{souligner|null}}) and (¬ MALE(P)) {{souligner|or}} (P = FATHER(R)) {{souligner|do}}
             P := ELDERSIBLING(P);
         M := YOUNGESTOFFSPRING(MOTHER(MOTHER(R)));
         {{souligner|while}} (M ¬= {{souligner|null}}) {{souligner|and}} (¬ MALE(M)) {{souligner|do}}
             M := ELDERSIBLING(M);
         {{souligner|if}} P = {{souligner|null}} {{souligner|then}} 
             M 
         {{souligner|else}} {{souligner|if}} M = {{souligner|null}} {{souligner|then}} 
             P 
         {{souligner|else}} 
             {{souligner|if}} AGE(P) &lt; AGE(M) {{souligner|then}} P {{souligner|else}} M
     {{souligner|end}}

== Voir aussi ==
* [[Algol]]
{{Autres projets|wiktionary=Algol W}}

{{Palette Langages de programmation}}
{{Portail|Informatique}}
[[Catégorie:Langage de programmation]]</text>
      <sha1>p5f3fv1vp31xm2ksjww2rf1okp6uzax</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Esterel (langage)</title>
    <ns>0</ns>
    <id>120346</id>
    <revision>
      <id>89799428</id>
      <parentid>82241178</parentid>
      <timestamp>2013-03-12T15:52:33Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q486926]]</comment>
      <text xml:space="preserve" bytes="3821">{{Voir homonymes|Esterel}}
{{ébauche|informatique}}

'''Esterel''' est le nom d'un [[langage de programmation]] conçu dans les [[années 1980]] par un groupe dirigé par [[Gérard Berry]].

Ce langage est dit [[programmation synchrone|synchrone]] et [[réactif]]. Il est [[programmation impérative|impératif]] et permet l'expression simple du [[Parallélisme (informatique)|parallélisme]] et de la [[Multitâche préemptif|préemption]]. Il est de ce fait bien adapté à la modélisation des systèmes à prépondérance contrôlée.

En tant que langage appartenant à la classe des systèmes informatiques ''réactifs'' :
* le programme ne se termine pas, il est cyclique ;
* il possède une grande vitesse de réaction en même temps qu'une connaissance de l'environnement exacte ;
* le parallélisme lui permet de gérer plusieurs capteurs et/ou incidents simultanément ;
* ses [[Processus (informatique)|processus]] peuvent être interrompus ou stoppés.

Ce langage peut modéliser de nombreux systèmes et milieux : [[logiciel]]s, matériels, contrôle de flux etc.

== Syntaxe/comportement du langage ==

Un signal S peut être activé ou désactivé. On l'active via l'instruction &lt;tt&gt;emit S&lt;/tt&gt;.
On change sa valeur (par exemple une valeur du type entier) via l'instruction &lt;tt&gt;emit S(valeur)&lt;/tt&gt;.

Pour illustrer l'instantanéité de l'activation des signaux, les instructions &lt;tt&gt;emit O; emit O1; emit O2; &lt;/tt&gt;aboutissent à l'activation instantanée et simultanée en une seule itération des trois signaux O, O1, et O2.
Une autre illustration : le symbole || signifie la parallélité des instructions qu'il sépare.

Un exemple de module :
   module ABRO:
   input A, B, R;
   output O;
   loop
      [ await A || await B ];
      emit O
   each R
   end module

Un exemple d'utilisation du module précédent dans un autre module :
   module ABCRO:
   input A, B, C, R;
   output O;
   signal AB in
      run ABRO [ signal AB / O ]
   ||
      run ABRO [ signal AB / A, C / B ]
   end module

AB / O signifie que le O de la sous-fonction ABRO est nommé AB dans la fonction ABCRO.

Le langage est encore en développement, sans véritable standard établi. Il existe plusieurs compilateurs Esterel qui permettent de générer du code [[C (langage)|C]], [[VHDL]] ou [[Verilog]].
La société Esterel Technologies a engagé un processus de normalisation de la version 7 du langage à l'IEEE en 2005. Le manuel de référence&lt;ref&gt;[http://www.esterel-technologies.com/files/Esterel-Language-v7-Ref-Man.pdf Manuel de référence]&lt;/ref&gt; présenté pour la normalisation est disponible.

Il en existe une version orientée objet : Esterel ++, conçue par Dassault Aviation. Différents formalismes graphiques (Syncharts, UML) sont proposés.

==Notes==
{{Reflist}}

== Voir aussi ==
=== Autres langages synchrones ===
* [[Lustre (langage)|Lustre]]
* [[Signal (langage)|Signal]] http://ptolemy.eecs.berkeley.edu/~eal/ee290n/lec22.scribe.html http://www.irisa.fr/espresso/Polychrony/
* [[Lucid Synchrone]]
* [[LCM (langage)|LCM]]

=== Liens externes ===
* [http://www.synfora.com/products/esterelStudio.html Synfora, Inc.]
* Des [http://www.cs.hmc.edu/~keller/courses/cs156/s98/slides/455.html diapositives] sur ce langage
* [http://beru.univ-brest.fr/~singhoff/ENS/UE_temps_reel/TP-STRL/tp.html TPs/exercices]
* [http://www.esterel-technologies.com/technology/scientific-papers/overview.html Publications scientifiques]
* Esterel ++ : [http://www.infres.enst.fr/~pautet/papers/pautet98esterel.ps www.infres.enst.fr]
* [http://www.di.ens.fr/~pouzet/lucid-synchrone Lucid Synchrone]

* Langages proches :
** [http://www.systemc.org/ SystemC]
** [http://www.ics.uci.edu/~specc/ SpecC]

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Programmation concurrente]]</text>
      <sha1>ff6q60k7aubmuqjl75s9rz8asdj3nvj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Occam (langage)</title>
    <ns>0</ns>
    <id>186550</id>
    <revision>
      <id>101574313</id>
      <parentid>101574283</parentid>
      <timestamp>2014-02-25T07:49:33Z</timestamp>
      <contributor>
        <ip>2A01:E35:2EBF:AE80:2677:3FF:FE39:26F0</ip>
      </contributor>
      <text xml:space="preserve" bytes="3799">Le [[langage de programmation]] '''Occam''' est un langage de programmation adapté à l'architecture parallèle, apparu en 1983.  Il a été développé par Inmos pour la programmation de ses architectures en parallèle [[Transputer]], mais a également été porté sur d'autres plates-formes.

Le nom est un hommage à [[Guillaume d'Occam]] (parfois orthographié Ockham) et au principe méthodologique du [[rasoir d'Occam]].

Le langage Occam est un langage procédural classique qui offre, outre l'exécution d'instructions séquentiellement (avec SEQ), l'exécution des instructions en parallèle (avec PAR) et même la mise en « parallèle asynchrone » de processus (avec ALT) pour une exécution non-déterministe d'un parmi plusieurs.
L'exécution en PAR des processus se fait avec des rendez-vous, comme en [[Ada (langage)|Ada]].

Occam contient aussi les « commandes gardées » de [[Edsger Dijkstra]] : un processus n'est lancé que si la valeur de sa garde, évaluée par le système, est vraie.

Le ''Transputer Development System'' (TDS) d'Inmos était l'outil de développement classique, mais il était possible d'utiliser ''Parallel C'' ou d'autres outils. L'éditeur du TDS était {{Pas clair|« foldé »}}, c'est-à-dire qu'il donnait la possibilité de plier et déplier des blocs de code, ce qui était très innovant ; à l'heure actuelle, il n'existe encore aucun remplaçant valable.{{refnec}}

Quelques notes sur les extraits de code ci-dessous :
* En Occam l'indentation est significative, ce qui évite les marqueurs de début et de fin de blocs communs à d'autres langages héritant de Pascal et C (begin...end, {...}, loop...endloop ''etc.'') ;
* Les CHAN OF sont les « canaux », portés par les liens bidirectionnels série rapides (2 Mb/s, 4 liens/Transputer, communication indépendante du CPU).

'''Quelques exemples de code réel'''
&lt;!--VGR 1991--&gt;

&lt;code&gt;&lt;pre&gt;
PROC Passe1 ( CHAN OF ANY FromKeyboard, CHAN OF INT FromServer, CHAN OF ANY ToServer, CHAN OF ANY FromNetwork, ToNetwork,
              []CHAN OF Process FromMenu, CHAN OF FilerProtocol FromFiler, ToFiler, []INT UserWindow, SystemWindow,
              []INT ConfigData, freespace, VAL []BYTE parnomfic, parNumVersion, FicSorties, INT FicSortiesPtr )
-- Constantes de configuration disque
VAL WrkExt IS &quot;.CPS&quot;:
VAL OutExt IS &quot;.LIE&quot;:
VAL IntExt IS &quot;.$$$&quot;:

VAL MaxCompressedRecordSize IS 45: -- taille avec compression CGA !!!
VAL kAccesSequentiel IS TRUE:
VAL theta1 IS 1.618 (REAL32):
-- Constantes estimees
VAL MaxTailleZone IS 9111833:
VAL MaxVilles2 IS INT ROUND ((REAL32 TRUNC MaxVilles)*theta1):
-- Variables
[ReadBufferSize]BYTE MyReadBuffer: 
INT FicPos, FicSize:     -- position dans, et nombre d'octets du, fichier
[80]BYTE FicRes1,
         FicInt:

-- Fonctions
BOOL FUNCTION EndOfFile() IS ( (FicPos+MyReadPtr) &gt;= FicSize ) :
BOOL FUNCTION NotFini() IS ( (Result=0) AND (NOT EndOfFile()) ) :

PROC Erreur ( VAL []BYTE par )
  [82]BYTE loc:
  --BOOL poub:
  --INT len:
  SEQ
    --len:=82
    --InitTabByte(loc,' ')
    [loc FROM 0 FOR (SIZE par)]:=par
    [loc FROM (SIZE par) FOR 2]:=&quot;*c*n&quot;
    --delete.string(len,loc,(SIZE par)  +  2,81  -  (SIZE par),poub)
    WriteInTextWindow(ToServer,SystemWindow,[loc FROM 0 FOR (SIZE par)  +  2]))
    --              previously UserWindow

&lt;/pre&gt;&lt;/code&gt;

Autre exemple :
&lt;code&gt;&lt;pre&gt;
IF
  sgf.res &amp;lt;&gt; 0
    SKIP
  TRUE
    IF
      compare.strings (ThfareKey, &quot;99999999&quot;) &amp;lt;&gt; 0
        SEQ
          ThfareKeyInt := AtoI (ThfareKey)
          ThfareOffsets [ThfareKeyInt] := Offset
      TRUE
        SKIP
&lt;/pre&gt;&lt;/code&gt;
Exemple de multiplexeur de canaux :
&lt;code&gt;&lt;pre&gt;
WHILE TRUE 
  VAR x;
  SEQ
    ALT
      c1 ? x
      c2 ? x
      c3 ? x
&lt;/pre&gt;&lt;/code&gt;

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>9fh6jgiqnuura3mowb5rzgma76om8zi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rebol</title>
    <ns>0</ns>
    <id>122984</id>
    <revision>
      <id>89806860</id>
      <parentid>87110374</parentid>
      <timestamp>2013-03-12T16:35:08Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 14 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1359171]]</comment>
      <text xml:space="preserve" bytes="5075">'''Rebol''' est un [[langage de programmation]] [[langage de script|script]] de haut niveau conçu et imaginé par [[Carl Sassenrath]] basé sur la [[sémantique dénotationnelle]] et se proclamant « Messaging Language ». On peut éventuellement le rattacher au langage [[Logo (langage)|Logo]] (surtout connu pour sa tortue) avec lequel il partage beaucoup de points communs. Il existe plusieurs versions de l'[[interpréteur]] Rebol dont certaines sont gratuites :
* Rebol Core (gratuit) : interpréteur en mode texte (sans interface graphique)
* Rebol View (gratuit) : apporte le support de l'interface graphique grâce, entre autres, à son dialecte VID.
* Rebol View/Pro (commercial) : Rebol View + Encryption (AES, RSA, ...) + l'accès aux bibliothèques dynamiques ([[Dynamic Link Library|DLL]])
* Rebol Command (commercial) : Rebol View/Pro + Accès base de données ([[ODBC]], [[Oracle]], [[MySQL]]) + Fast CGI + SSL ([[Secure Socket Layer]])

Le langage est disponible sur plusieurs plates-formes, notamment [[Windows]], [[Linux]], [[Mac OS X]] et [[OpenBSD|Open BSD]]&lt;ref&gt;http://www.rebol.com/what-rebol.html&lt;/ref&gt;.
Il est caractérisé par une grande rapidité de développement et de programmes légers, du fait de son haut niveau d'abstraction. Ainsi une ''[[adresse IP]]''
(exemple : 192.164.86.8) est considérée comme un [[type de données|type]] de base en rebol et dispose de fonctions de manipulation en propre, ce qui facilite l'écriture des programmes.

C'est un langage qui propose une implémentation orientée [[programmation objet|objet]] particulièrement simple mais très efficace. En effet, il n'y a pas de notion de [[classe]], chaque [[objet]] étant [[instanciation|instanciable]] à partir d'un autre. Les notions d'instanciation et d'héritage sont moins distinctes que dans la plupart des autres langages orientés objets. 
Il propose aussi un mécanisme très performant (instruction Parse) qui permet de définir simplement un dialecte, un langage personnalisé à la syntaxe choisie de manière à résoudre plus facilement un problème informatique qu'avec la syntaxe générale du langage.

Il dispose maintenant d'un [[plugin]] qui permet l'exécution d'[[applet]]s rebol depuis un [[navigateur web]] (en septembre 2004, disponible encore seulement pour [[Microsoft Windows|Windows]] et [[Internet Explorer]], mais une possibilité existe pour l'utiliser aussi avec [[Mozilla Firefox|Firefox]]).
&lt;!-- , voir sur le site [http://www.rebolfrance.org rebolfrance])
--&gt;

== Exemple ==

&lt;pre&gt;
REBOL [
   Title: &quot;Coucou&quot;
   File: %coucou.r
   Date: 12-January-2002
   Purpose: &quot;Afficher des mots dans une fenêtre&quot;
   Category: [view VID 1]
]
; Note : les différentes variables de l'en-tête de script ci-dessus sont toutes optionnelles

; Affichage dans la console
print &quot;Coucou tout le monde !&quot;

; Affichage dans une fenêtre
view layout [
   text &quot;Coucou tout le monde !&quot; 
   button &quot;Quitter&quot; [quit]
]
&lt;/pre&gt;

== Bibliographie ==
* ''Rebol Programmation'', Eyrolles, 2001, Olivier Auverlot {{ISBN|2-212-11017-0}}
* ''Rebol: Guide du programmeur'', Lulu.com, 2007, Olivier Auverlot
* ''Rebol: A programmer's guide'', Lulu.com, 2008, Peter WA Wood &amp; Olivier Auverlot

{{Autres projets|wikibooks=Programmation Rebol|wikibooks titre=Programmation Rebol}}

== Rebol3 ==

REBOL 3 a été lancé en 2004 et devait ouvrir Rebol au monde extérieur avec notamment l'intégration d'une couche ouverte facilitant l'intégration avec le monde extérieur via le module Host-Kit&lt;ref&gt;http://www.rebol.com/rebol3/architecture.html#section-6&lt;/ref&gt;. 
Mais seul face au projet, [[Carl Sassenrath]] souhaitant avoir la maîtrise totale sur son oeuvre, n'a pas réussi.
C'est finalement pendant l'été 2012, sur son [http://www.rebol.com/article/0510.html blog], qu'il lança une première lueur d'espoir à l'ensemble de la communauté en attente de nouvelles sérieuses depuis plus de 2 ans &lt;ref&gt;[[Carl Sassenrath]] a travaillé sur le projet [http://www.roku.com/ Roku] un boitier multimédia pour transformer votre télévision en [[SmartTV]]&lt;/ref&gt;.

Finalement, après beaucoup d'attente, le 12 décembre 2012 [[Carl Sassenrath]] a annoncé sur son [http://www.rebol.com/article/0519.html blog] la disponibilité du troisième opus du langage de programmation REBOL en [[Open Source]] 
Les sources sont disponibles sur [https://github.com/rebol/r3 github] sous licence [[Apache]].

== Liens externes ==
* [http://www.rebol.com Rebol.com]
* [http://www.rebol-france.org REBOL France] Site de la communauté francophone
* [http://www.rebolfrance.info RebolFranceWiki]
* [http://www.rebolforces.com Rebol Forces]
* [http://www.rebol.org Rebol.org]
* [http://www.reboltutorial.com Rebol Tutorial]
* [http://babelserver.org/rix RIX - the Rebol IndeXer] - moteur de recherche pour les documents REBOL
* [http://cheyenne-server.org Cheyenne - serveur HTTP performant écrit en REBOL]
* [https://github.com/rebol/r3 Sources REBOL3]

==Notes et références==

&lt;references /&gt;

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>4liz1ia01v9l6bcbdac2hsifjuftb6o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ruby</title>
    <ns>0</ns>
    <id>2631</id>
    <revision>
      <id>101893697</id>
      <parentid>101802042</parentid>
      <timestamp>2014-03-08T15:47:29Z</timestamp>
      <contributor>
        <username>Thyresias</username>
        <id>12381</id>
      </contributor>
      <comment>/* Exemples */  indentation standard (2 espaces)</comment>
      <text xml:space="preserve" bytes="17952">{{Voir homonymes}}
{{Infobox Langage de programmation
|  nom                    = Ruby
|  logo                   = Ruby-logo-notext.png
|  paradigmes             = [[Programmation orientée objet|Objet]], [[Programmation impérative|impératif]], [[Programmation concurrente|concurrent]], [[Programmation fonctionnelle|fonctionnel]]
|  année                  = [[1995 en informatique|1995]]
|  auteur                 = [[Yukihiro Matsumoto]]
|  développeurs           = [[Yukihiro Matsumoto]] et des contributeurs
|  dernière version stable= 1.8.7&lt;ref&gt;[http://www.ruby-lang.org/fr/downloads/ Télécharger Ruby sur le site officiel]&lt;/ref&gt;&lt;!-- note : la 1.9.1 est annoncée stable, bien que la page en français ne le mentionne pas --&gt;
|  date de dernière version stable = {{Date|31|mai|2008|en informatique}}
|  typage                 = [[Typage fort|Fort]], [[Typage dynamique|dynamique]]
|  implémentations        = Ruby, [[YARV]], [[Ruby MRI]], [[JRuby]], XRuby, [[Rubinius]], Cardinal, Gardens Point Ruby.NET, [[IronRuby]], MacRuby, [http://code.google.com/p/android-ruby/ android-ruby]
|  dialectes              = 
|  influencé par          = [[Eiffel (langage)|Eiffel]], [[Lisp]], [[Smalltalk]], [[Perl (langage)|Perl]], [[Python (langage)|Python]], [[Dylan (langage)|Dylan]], [[Ada (langage)|Ada]] et [[CLU (langage)|CLU]]
|  a influencé            = [[Groovy (langage)|Groovy]], [[Perl 6]]
|  système d'exploitation = [[Multiplate-forme]]
|  licences               = [[Licence Ruby]] et [[Licence publique générale GNU|GNU GPL]]
|  site web               = [http://www.ruby-lang.org/ www.ruby-lang.org]
}}
'''Ruby''' est un [[langage de programmation]] [[Logiciel libre|libre]]. Il est [[Interprète (informatique)|interprété]], [[Programmation orientée objet|orienté objet]] et multi-[[paradigme (programmation)|paradigme]]. Le langage a été standardisé au Japon en 2011 ([[Japanese Industrial Standard|JIS]] X 3017:2011)&lt;ref&gt;[http://www.webstore.jsa.or.jp/webstore/Com/FlowControl.jsp?lang=en&amp;bunsyoId=JIS+X+3017%3A2011&amp;dantaiCd=JIS&amp;status=1&amp;pageNo=0 JIS X 3017:2011 - Programming languages - Ruby]&lt;/ref&gt;, et en 2012 par l'[[Organisation internationale de normalisation]] (ISO 30170:2012)&lt;ref&gt;[http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=59579 ISO/IEC 30170:2012 Information technology - Programming languages - Ruby]&lt;/ref&gt;.

== Historique ==
[[Yukihiro Matsumoto|Yukihiro « Matz » Matsumoto]] est le créateur de Ruby. Frustré par son expérience en développement [[Smalltalk]] et [[Lisp]], il débute la conception d'un nouveau langage en [[1993 en informatique|1993]] sous [[GNU Emacs|Emacs]], puis publie une première version en [[1995 en informatique|1995]] sous [[licence libre]]. Il enchaîne depuis les nouvelles versions.

Des changements de version majeurs ont eu lieu&lt;ref&gt;[ftp://ftp.ruby-lang.org/pub/ruby/ Site FTP officiel de téléchargement]&lt;/ref&gt; :

* le {{Date|25|décembre|1998|en informatique}} pour la version 1.2.0,
* le {{Date|13|août|1999|en informatique}} pour la version 1.4.0,
* le {{Date|19|septembre|2000|en informatique}} pour la version 1.6.0,
* le {{Date|4|août|2003|en informatique}} pour la version 1.8.0,
* le {{Date|30|janvier|2009|en informatique}} pour la version 1.9.1 (première version stable de la branche 1.9)&lt;ref&gt;{{en}} [http://www.ruby-lang.org/en/news/2009/01/30/ruby-1-9-1-released/ Annonce de la version 1.9.1]&lt;/ref&gt;,
* le {{Date|30|octobre|2011|en informatique}} pour la version 1.9.3&lt;ref&gt;[http://www.ruby-lang.org/fr/news/2011/10/31/sortie-de-ruby-1-9-3-p0/ Sortie de Ruby 1.9.3-p0]&lt;/ref&gt;,
* le {{date|24|février|2013|en informatique}} pour la version 2.0.0&lt;ref&gt;{{en}} [http://www.ruby-lang.org/en/news/2013/02/24/ruby-2-0-0-p0-is-released/ Ruby 2.0.0-p0 is released]&lt;/ref&gt;.

La dernière version stable est la 2.1.0, publiée le 25 décembre 2013&lt;ref&gt;{{en}} [http://www.ruby-lang.org/en/news/2013/12/25/ruby-2-1-0-is-released/ Ruby 2.1.0 is released]&lt;/ref&gt;.

Depuis l'arrivée d'une documentation anglophone, et du {{lang|en|''framework web [[Ruby on Rails]]''}} en 2004, Ruby a connu un certain engouement qui n'a cessé de croître jusqu'en 2007 dans le monde de la programmation&lt;ref&gt;[http://www.ruby-lang.org/fr/about/ Explication de la croissance] sur le site officiel&lt;/ref&gt;.

== Philosophie ==
Ruby est fortement [[Programmation orientée objet|orienté objet]] et se rapproche ainsi du paradigme objet de [[Smalltalk]]&lt;ref&gt;La principale différence  étant que les structures de contrôle (if-then-else, while, etc.) ne sont pas des objets.&lt;/ref&gt; :
* toute [[donnée (informatique)|donnée]] est un [[Programmation orientée objet|objet]], y compris les [[Type (informatique)|types]] ;
* toute [[Fonction (informatique)|fonction]] est une [[Méthode (informatique)|méthode]] ;
* toute [[variable (informatique)|variable]] est une référence à un [[Programmation orientée objet|objet]].

Malgré cet aspect exclusivement [[Programmation orientée objet|objet]], la [[programmation procédurale]] est possible et fréquente.
Ruby utilise une [[syntaxe]] simple, inspirée par [[Eiffel (langage)|Eiffel]] et [[Ada (langage)|Ada]]&lt;ref&gt;{{en}} [http://hopl.murdoch.edu.au/showlanguage.prx?exp=2458&amp;language=Ruby Ruby sur HOPL], {{lang|en|''the History of Programming Languages''}}&lt;/ref&gt;.

Le langage est souvent présenté comme évitant au maximum les mauvaises surprises, selon le [[principe de moindre surprise]]&lt;ref&gt;[http://wiki.rubygarden.org/Ruby/page/show/PoLS Définition du PoLS sur le wiki de Ruby Garden]&lt;/ref&gt;.
Mais puisqu'il n'est pas possible d'éviter la surprise de ''tous'' les utilisateurs, [[Yukihiro Matsumoto]] précise qu'il cherche surtout à éviter ''sa'' propre surprise&lt;ref&gt;{{en}} [http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/143691 e-mail {{lang|en|''Re: A different perspective on Ruby''}} envoyé par matz le 26 mai 2005 sur ruby-talk]&lt;/ref&gt;.
Ainsi, plus on connaît le langage, plus on connaît la logique de son auteur, et moins on s'étonne des fonctionnalités qu'on découvre.

== Fonctionnalités ==
Les fonctionnalités principales sont :
* l'[[orienté objet|orientation objet]] omniprésente ;
* le [[ramasse-miettes (informatique)|ramasse-miettes]] chargé de libérer automatiquement la [[Mémoire informatique|mémoire]] ;
* le [[système de gestion d'exceptions]] pour gérer les erreurs exceptionnelles ;
* la possibilité de modifier les [[classe (informatique)|classes]] pendant l'exécution du [[programme informatique|programme]], qu'elles soient définies par l'utilisateur ou non ;
* l'intégration dans sa [[syntaxe]] des [[expression rationnelle|expressions rationnelles]] ;
* les blocs qui servent d'[[Itérateur (motif de conception)|itérateur]] et permettent de passer des morceaux de programme en paramètre ;
* l'[[héritage (Informatique)|héritage]] simple ;
* l'inclusion de [[module (programmation)|modules]] dans les [[classe (informatique)|classes]], une autre manière de concevoir l'[[héritage multiple]] ([[mixin]]) ;
* l'écriture d'[[Extension (logiciel)|extensions]] en [[C (langage)|C]] relativement simple ;
* les [[Nombre entier|nombres entiers]] de taille illimitée avec conversion automatique lorsque c'est nécessaire&lt;ref&gt;{{en}} [http://www.devx.com/enterprise/Article/31197 {{lang|en|''Ruby—A Diamond of a Programming Language, Part 2''}}], article publié sur [http://www.devx.com/ devx.com]&lt;/ref&gt; ;
* la portée des [[variable (informatique)|variables]] définie par leur forme : {{code|var}} est une [[variable locale]], {{code|@var}} est une [[variable d'instance]], {{code|@@var}} est une [[variable de classe]], {{code|$var}} est une [[variable globale]], {{code|Var}} est une [[constante]], etc. ;
* les [[Processus léger|{{lang|en|''threads''}}]] indépendants du [[système d'exploitation]] ;
* la [[Réflexion (informatique)|réflexion]], c'est-à-dire la possibilité pour les programmes et les objets de s'inspecter eux-mêmes et de se modifier.

== Implémentations ==
L'[[interprète (informatique)|interpréteur]] officiel, [[Ruby MRI]], fonctionne sur de nombreux [[système d'exploitation|systèmes d'exploitation]] : [[UNIX]], [[Linux]], [[Microsoft Windows]], [[MS-DOS]], [[OS X]], [[OS/2]], [[AmigaOS]], etc.
Il est publié sous la double licence [[logiciels libres|libre]] [[Licence publique générale GNU|GNU GPL]] et la licence Ruby&lt;ref&gt;[http://www.ruby-lang.org/en/LICENSE.txt Texte de la licence sur le site officiel]&lt;/ref&gt;.

Ruby est fourni avec [[Interactive Ruby|irb]], un [[interpréteur de commandes]] [[Interactivité|interactif]] pour tester en profondeur le fonctionnement du langage. Il existe une version [[web]] d'irb pour tester Ruby dans un navigateur&lt;ref name=&quot;tryruby&quot;&gt;{{en}} [http://tryruby.hobix.com/ {{lang|en|''Try Ruby!''}}] sur hobix.com&lt;/ref&gt;.

Depuis le {{date|1|janvier|2007|en informatique}}, le développement de Ruby (1.9) est basé sur l'interpréteur [[YARV]] écrit par [[Koichi Sasada]]&lt;ref&gt;{{en}} [http://blog.grayproductions.net/articles/the_ruby_vm_episode_i {{lang|en|''The Ruby VM: Episode {{I}}''}}], interview de matz et de ko1 sur la machine virtuelle de Ruby&lt;/ref&gt;.
Ce nouvel interpréteur apporte un gain notable en performances&lt;ref name=&quot;ruby-implementations-shootout&quot;&gt;{{en}} [http://antoniocangiano.com/2007/12/03/the-great-ruby-shootout {{lang|en|''The Great Ruby Shootout''}}], comparaison des performances des principaux interpréteurs Ruby&lt;/ref&gt;.

Il existe plusieurs autres interpréteurs Ruby&lt;ref name=&quot;ruby-implementations-shootout&quot;/&gt; :
; [[JRuby]]&lt;ref&gt;[http://jruby.sourceforge.net/ Site officiel de JRuby]&lt;/ref&gt; : Il est écrit en [[Langage de programmation Java|Java]] et interprète directement du code source écrit en Ruby.
; XRuby : Il convertit du code Ruby en bytecode [[Langage de programmation Java|Java]] et est plus rapide sur certains [[Test de performance|tests de performance]] que la version 1.8.5 de l'interpréteur officiel&lt;ref&gt;{{en}} [http://xruby.blogspot.com/2007/03/xruby-runs-most-benchmark-faster-than.html {{lang|en|''XRuby is faster than Ruby 1.8.5 in most benchmarks''}}]&lt;/ref&gt;.
; [[Rubinius]] : Une machine virtuelle simplifiée, inspirée de [[Smalltalk|Smalltalk-80]]&lt;ref&gt;{{en}} [http://on-ruby.blogspot.com/2006/12/rubinius-interview.html  Rubinius Interview]&lt;/ref&gt;, implémentée en Ruby même.
; Cardinal&lt;ref&gt;[http://cardinal2.rubyforge.org/ Site du projet Cardinal]&lt;/ref&gt; : Un interpréteur fonctionnant sous [[Parrot (machine virtuelle)|Parrot]].
; Gardens Point Ruby.NET : Un interpréteur fonctionnant sur le {{lang|en|''[[framework .NET]]''}}&lt;ref&gt;{{en}} [http://www.sapphiresteel.com/Ruby-NET-Integrating-the-Gardens Ruby.NET - Integrating the Gardens Point Compiler]
par Huw Collingbourne&lt;/ref&gt;.
; [[IronRuby]] : Un compilateur fonctionnant sur la [[Dynamic Language Runtime|DLR]] du {{lang|en|''[[framework .NET]]''}}&lt;ref&gt;{{en}} http://www.ironruby.net/&lt;/ref&gt;.
; Ruby for .Net : Un compilateur fonctionnant sur la [[Common Language Runtime|CLR]] du {{lang|en|''[[framework .NET]]''}} qui a été abandonnée au profit de [[Dynamic Language Runtime|IronRuby]].
; MacRuby : implémentation de Ruby 1.9 spécifique à [[Mac OS X|OS X]], fonctionnant par dessus le [[Objective-C|runtime Objective-C]]&lt;ref&gt;[http://www.macruby.org/ {{en}} Site officiel de MacRuby]&lt;/ref&gt;, permettant un usage natif des composants [[Cocoa (Apple)|Cocoa]], contrairement aux bindings RubyCocoa.
'' À noter qu'il existe aussi une solution non-libre, commercialisée par HipByte  basée sur le travail  du projet '''MacRuby''', appelé '''RubyMotion '''crée par Laurent Sansonetti''

''La version 2.0 permet de créer des applications graphiques pour [[Mac OS X|OS X]] et pour [[IOS (Apple)|IOS]].''

== Interprètes embarqués ==
Ruby possède une [[interface de programmation]] en [[C (langage)|langage C]] qui lui permet d'être intégré au sein d'autres [[logiciel]]s. Ruby est notamment utilisable dans :
* [[Apache HTTP Server|Apache]] avec ''mod_ruby'' ou ''Phusion Passenger'' pour générer des [[Page web|pages web]] en Ruby
* et [[PostgreSQL]] avec ''PL/ruby'' pour faire exécuter des commandes Ruby au serveur de [[base de données]].

Le logiciel de création de jeu vidéo {{lang|en|[[RPG Maker]]}} intègre dans ses versions XP et VX une bibliothèque nommée RGSS, {{lang|en|''Ruby Game Scripting System''}} permettant l'usage de scripts en Ruby.

== Bibliothèques ==
Il existe de nombreuses [[Bibliothèque (logicielle)|bibliothèques]] de fonctionnalités adjoignables au langage.
Le dépôt historique de ces bibliothèques est le {{lang|en|''Ruby Application Archive''}} (RAA)&lt;ref&gt;[http://raa.ruby-lang.org/ Ruby Application Archive]&lt;/ref&gt;.
Il contient des fonctionnalités supplémentaires pour Ruby comme des bibliothèques de classes et de modules, mais aussi des extensions permettant d'utiliser des bibliothèques tierces.

Le ''RAA'' contient également des logiciels écrits en Ruby. Parmi ces logiciels on trouve notamment ''Rubygems'' qui est un outil d'empaquetage et d'installation pour les extensions Ruby&lt;ref&gt;[http://www.rubygems.org/ Site officiel de Rubygems]&lt;/ref&gt;.
Il permet de déployer rapidement des bibliothèques et des programmes Ruby.

Le [[site web]] ''Rubyforge''&lt;ref&gt;[http://rubyforge.org/ RubyForge]&lt;/ref&gt; est également un hébergeur important de programmes et de bibliothèques écrites en Ruby.

== Exemples ==
Le classique {{lang|en|''[[Hello world]]''}} :

&lt;source lang=&quot;ruby&quot;&gt;
puts &quot;Hello World!&quot;
&lt;/source&gt;

Utilisation des objets :
&lt;source lang=&quot;ruby&quot;&gt;
# Tout est objet, même les nombres:
-199.abs                                                # 199
&quot;ruby is cool&quot;.length                                   # 12
&quot;Rick&quot;.index &quot;c&quot;                                        # 2
&quot;Nice Day Isn't It?&quot;.downcase.split(//).sort.uniq.join  # &quot; '?acdeinsty&quot;
&lt;/source&gt;

Utilisation de [[Mixin]] et de l'[[Héritage (Informatique)|Héritage]]
&lt;source lang=&quot;ruby&quot;&gt;
module AnimalSkills
  def eat
    puts &quot;I'm eating !&quot;
  end

  def move
    puts &quot;I'm moving !&quot;
  end

  def express; puts &quot;I'm expressing !&quot; end
end

class Animal
  include AnimalSkills # mixin

  @@name = 'an animal' # variable de classe

  def initialize size, weight, color # initialisation des variables d'instance
    @size = size.to_i
    @weight, @color = weight.to_i, color.to_s
  end

  def describe
    puts &quot;I'm #{@@name} !&quot;
    puts &quot;I'm #{@size} meter tall, I weigh #{@weight} kilograms and I'm &quot; &lt;&lt; @color
  end
end

class Zebra &lt; Animal # héritage
  @@name = 'a zebra' # rédéfinition de la variable de classe
   
  def initialize(size, weight, color = 'black and white') # surcharge
    super # appel de la méthode de la classe mère (Animal)
  end
end

z = Zebra.new(1, 50)

z.describe # =&gt; I'm a zebra ! / I'm 1 meter tall, I weigh 50 kilograms and I'm black and white
z.eat # =&gt; I'm eating !
&lt;/source&gt;

== Voir aussi ==
{{Autres projets
|wikibooks=Ruby
|wikibooks titre=Ruby
|wikiversity=Ruby
|commons=category:Ruby programming language
|commons titre=Ruby
}}
=== Articles connexes ===
* {{lang|en|[[Ruby on Rails]]}}
* [[Smalltalk]]
* [[Ruby MRI]]

=== Bibliographie ===
* {{ Ouvrage |
     titre = {{lang|en|Programming Ruby}} |
     nom1= Dave Thomas |
     nom2=Andrew Hunt |
lien auteur2=Andrew Hunt |
     langue = en |
lien auteur1=Dave Thomas (programmeur) |
     année = 2000 |
     isbn = 0-201-71089-7 |
     lire en ligne = http://ruby-doc.org/docs/ProgrammingRuby/
  }}
* {{ Ouvrage |
     titre = {{lang|en|Ruby in a Nutshell}} |
     nom1 = Yukihiro Matsumoto |
     année = 2002 |
     isbn = 2-84177-210-1 |
  }}
* {{ Ouvrage |
     titre = {{lang|en|Programming Ruby: The Pragmatic Programmer's Guide }}|
     auteur = [[Dave Thomas (programmeur)|Dave Thomas]], [[Chad Fowler]] et [[Andy Hunt]]  |
     langue = en |
     année = 2004 |
     isbn = 0-9745140-5-5 |
  }}
* {{ Ouvrage |
     titre = Débuter en Programmation avec Ruby |
     nom1 = Chris Pine |
     année = 2006 |
     isbn = 2-7440-2078-8 |
  }}
* {{ Ouvrage |
     titre = Ruby par l'exemple |
     nom1 = Lucas Carlson |
     nom2 = Leonard Richardson |
     année = 2006 |
     isbn = 978-2-84177-347-3 |
  }}
* {{ Ouvrage |
     titre = {{lang|en|The Ruby Way, Second Edition: Solutions and Techniques in Ruby Programming (2nd Edition)}} |
     auteurs = [[Hal Fulton]] |
     langue = en |
     année = 2006 |
     isbn = 0-672-32884-4 |
  }}
* {{ Ouvrage |
     titre = {{lang|en|Enterprise Integration with Ruby}} |
     auteurs = [[Maik Schmidt]] |
     langue = en |
     année = 2006 |
     isbn = 0-9766940-6-9 |
  }}
* {{ Ouvrage |
     titre = {{lang|en|Everyday Scripting with Ruby: For Teams, Testers, and You}} |
     auteurs = [[Brian Marick]] |
     langue = en |
     année = 2007 |
     isbn = 978-0-9776166-1-9 |
  }}
* {{ Ouvrage |
     titre = {{lang|en|Beginning Ruby: From Novice to Professional}} |
     nom1 = [[Peter Cooper (programmeur)|Peter Cooper]] |
     langue = en |
     année = 2007 |
     isbn = 978-1-59059-766-8 |
  }}

=== Liens externes ===
* {{fr}} [http://www.ruby-lang.org/fr/ Site officiel]
* {{fr}} [http://www.rubyfrance.org Association RubyFrance]
* {{fr}} [http://www.pagedegeek.com/ Des notes et cours sur Ruby]
* {{fr}} [http://news.humancoders.com/t/ruby Human Coders News - Ruby]
* {{en}} [http://www.jruby.org/ JRuby.org]
* {{fr}} [http://ruby-gnome2.sourceforge.jp/fr/ Ruby-GNOME2]
* {{en}} [http://rubycocoa.sourceforge.net/ RubyCocoa]

== Notes et références ==
{{Références|colonnes=2}}

{{Palette|Langages de programmation}}
{{Portail|informatique|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]
[[Catégorie:Ruby|*]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour Unix]]
[[Catégorie:Logiciel pour DOS]]
[[Catégorie:Logiciel pour OS/2]]
[[Catégorie:Produit lancé en 1995]]</text>
      <sha1>tsywxez95e72yf8rhgqiwifuv1c5rrx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Smalltalk</title>
    <ns>0</ns>
    <id>7027</id>
    <revision>
      <id>101155610</id>
      <parentid>101155561</parentid>
      <timestamp>2014-02-11T08:13:06Z</timestamp>
      <contributor>
        <username>Alex-F</username>
        <id>558388</id>
      </contributor>
      <comment>Annulation des modifications de [[Special:Contributions/193.48.129.35|193.48.129.35]] (retour à la précédente version de [[Special:Contributions/Marc Mongenet|Marc Mongenet]])</comment>
      <text xml:space="preserve" bytes="8895">{{Infobox Langage de programmation
|  nom                    = Smalltalk
|  logo                   = Smalltalk-balloon.png
|  paradigmes             = [[Programmation orientée objet|Objet]]
|  année                  = Développement démarré en [[1969]], disponible publiquement en [[1980]]
|  auteur                 = [[Alan Kay]], [[Dan Ingals]], Ted Kaehler, Adele Goldberg, Claude Roy
|  développeurs           = [[Xerox PARC]]
|  dernière version stable= 
|  typage                 = [[Typage dynamique|dynamique]]
|  implémentations        = [[Squeak]], [[GNU Smalltalk]], [[VisualWorks]], [[Pharo]]
|  dialectes              = 
|  influencé par          = [[Lisp]], [[Simula]]
|  a influencé            = [[Objective-C]], [[Self (langage)|Self]], [[Oak (langage)|Oak]], [[Java (langage)|Java]], [[Dylan (langage)|Dylan]], [[AppleScript]], [[NewtonScript (langage)|NewtonScript]], [[Python (langage)|Python]], [[Ruby]], [[Scala (langage)|Scala]], [[Perl 6]], [[Scratch (langage)|Scratch]]
|  système d'exploitation = [[Multiplate-forme]]
|  licence                = 
|  site web               = 
}}

'''Smalltalk''' est un [[langage de programmation]] [[Programmation orientée objet|orienté objet]], [[Réflexion (informatique)|réflexif]] et [[Typage dynamique|dynamiquement typé]]. Il fut l'un des premiers langages de programmation à disposer d'un [[environnement de développement intégré]] complètement graphique. Il a été créé en [[1972 en informatique|1972]]. Il est inspiré par [[Lisp]] et [[Simula]]. Il a été conçu par [[Alan Kay]], [[Dan Ingals]], [[Ted Kaehler]], [[Adele Goldberg (computer scientist)|Adele Goldberg]] au [[Palo Alto Research Center]] de [[Xerox]]. Le langage a été formalisé en tant que Smalltalk-80 et est depuis utilisé par un grand nombre de personnes. Smalltalk est toujours activement développé.

Smalltalk a été d'une grande influence dans le développement de nombreux langages de programmation, dont : [[Objective C|Objective-C]], Actor, [[Java (langage)|Java]] et [[Ruby]].

Un grand nombre des innovations de l'ingénierie logicielle des [[années 1990]] viennent de la communauté des programmeurs Smalltalk, tels que les [[Patron de conception|{{lang|en|''Design Patterns''}}]] (appliquées au logiciel), l’{{lang|en|''[[Extreme Programming]]''}} (XP) et le {{lang|en|''[[refactoring]]''}}. [[Ward Cunningham]], l'inventeur du concept du [[Wiki]], est également un programmeur Smalltalk.

== Historique ==
Il existe un grand nombre de variantes de Smalltalk, comme c'est souvent le cas avec les langages de programmation&lt;ref&gt;{{Lien web|url=http://www.world.st/try/implementations |titre=Implémentations de Smalltalk |publisher=The World of Smalltalk |accessdate=24 avril 2013}}&lt;/ref&gt;. Sans autre qualificatif, le mot '''Smalltalk''' est souvent utilisé pour désigner Smalltalk-80, la première version à avoir été rendue publique en 1980.

Smalltalk est le produit d'un groupe de chercheurs conduit par [[Alan Kay]] au [[Palo Alto Research Center]] (PARC) de [[Xerox]] ; Alan Kay a conçu les premières versions de Smalltalk qui ont été implémentées par [[Dan Ingalls]]. La première version, nommé Smalltalk-71, a été créée en quelques matinées sur le pari qu'un langage de programmation basé sur l'idée d'envoi de messages inspirée de [[Simula]] pouvait être réalisé en « une page de code ».

== Concepts ==
Les principaux concepts de Smalltalk sont :
* « Tout est [[programmation orientée objet|objet]]. »  Les chaînes de caractères, les entiers, les booléens, les définitions de classes, les blocs de code, les piles et la mémoire sont représentés en tant qu'objets.
* Tout est modifiable. Le langage permet par exemple de changer d'[[Environnement de développement intégré|IDE]] en cours d'utilisation, sans recompiler ni redémarrer l'application. De même, il est possible de créer de nouvelles instructions de contrôle dans le langage. Certaines implémentations permettent de changer la syntaxe du langage, ou la façon dont le [[ramasse-miettes (informatique)|ramasse-miettes]] fonctionne.
* Le typage est dynamique, donnant une certaine concision au langage.
* Un [[ramasse-miettes (informatique)|ramasse-miettes]] mémoire est intégré et transparent pour le développeur.
* Un [[système de gestion d'exceptions]] avec reprise est fourni.
* Les programmes Smalltalk sont généralement compilés en [[bytecode]], exécutés par une [[machine virtuelle]]. 
* [[compilation à la volée|La traduction dynamique]] : les machines virtuelles commerciales modernes compilent le bytecode vers le code machine natif de façon à obtenir de meilleures performances, une technique dont Smalltalk-80 a été le pionnier, développé par ParcPlace Systems au milieu des [[années 1980]]. Cette idée a été adoptée par le [[langage de programmation Java]] quelque dix ans après et renommée « compilation {{lang|en|''just-in-time''}} », ou JIT.
* Une classe peut hériter d'une seule autre classe ([[Héritage (Informatique)|héritage]] simple).

== Description ==
Smalltalk implémente, en plus des principes objets de base ([[Classe_(informatique)|classe]], [[Objet (informatique)|objet]], [[Héritage (informatique)|héritage]], [[Polymorphisme (informatique)|polymorphisme]]), des concepts originaux ([[métaclasse]]) et introduit la notion d'objet persistant, de traitement des exceptions et le principe [[Modèle-Vue-Contrôleur]]. 

Une caractéristique surprenante de Smalltalk est l'absence totale d'instructions de contrôle intégrées au langage : if-then-else, for, while, etc. Toutes ces instructions sont implémentées en utilisant des objets. Par exemple, les décisions sont prises en envoyant un message ifTrue à un objet Booléen, et en passant un fragment de code à exécuter si le Booléen est vrai. Le seul aspect intégré par défaut est la syntaxe pour envoyer un message à un objet.

L'exemple suivant illustre le style de programmation Smalltalk. L'exécution de ce code permet de trouver les voyelles dans une chaîne. Le {{bleu|{{!}}}} déclare les variables, {{bleu|:}} déclare les paramètres :
&lt;source lang=&quot;smalltalk&quot;&gt;
| aString vowels |
aString := 'This is a string'.
vowels := aString select: [:aCharacter | aCharacter isVowel].
&lt;/source&gt;

À la dernière ligne, la chaîne aString reçoit un message select: avec un bloc de code en argument.
Voici le code de la super-classe Collection qui fait le travail :
&lt;source lang=&quot;smalltalk&quot;&gt;
Collection&gt;&gt;select: aBlock
| newCollection |
newCollection := self species new.
self do: [:each | 
    (aBlock value: each) 
        ifTrue: [newCollection add: each]].
^newCollection
&lt;/source&gt;

Ce code répond au message en itérant au travers de ses membres (c'est la methode do:) en évaluant le code aBlock à chaque caractère ; aBlock (aCharacter isVowel) une fois évalué crée un booléen, qui est alors envoyé à ifTrue:. Si le booléen est vrai, alors le caractère est ajouté à la chaîne qui sera retourné.
Comme select est défini dans la classe abstraite Collection, on pourrait également l'utiliser de cette façon :
&lt;source lang=&quot;smalltalk&quot;&gt;
| rectangles aPoint|
rectangles := OrderedCollection 
  with: (Rectangle left: 0 right: 10 top: 100 bottom: 200)
  with: (Rectangle left: 10 right: 10 top: 110 bottom: 210).
aPoint := Point x: 20 y: 20.
collisions := rectangles select: [:aRect | aRect containsPoint: aPoint].
&lt;/source&gt;

== Notes et références ==
&lt;references /&gt;

== Voir aussi ==
{{Autres projets
 | wikibooks = Programmation Smalltalk
}}

=== Articles connexes ===

* [[Pharo]], [[Squeak]], [[GNU Smalltalk]], [[Cormas]] des implémentations libres de Smalltalk
* [[VisualWorks]] une implémentation professionnelle de Smalltalk proposant une licence gratuite pour &quot;usage personnel&quot;
* [[Scratch (langage)|Scratch]]
* [[Ruby]], [[Objective-C]] des langages objet modernes inspirés de Smalltalk

=== Liens externes ===
* [http://www.esug.org ESUG ({{lang|en|''European Smalltalk Users Group''}})] : association qui réunit industriels et universitaires utilisateurs de Smalltalk. Organise notamment une conférence annuelle depuis 1993. 
* {{en}} [http://planet.smalltalk.org/ {{lang|en|''Planet Smalltalk''}}] agrège des blogs sur Smalltalk.
* {{en}} [http://onsmalltalk.com/why-smalltalk « {{lang|en|''OnSmalltalk''}} »] blog d'un passionné de Smalltalk,

==== Didacticiels ====
* {{en}} [http://stephane.ducasse.free.fr/FreeBooks.html Livres gratuits sur Smalltalk]

==== Bibliographie ====
* &quot;Programmer objets avec Smalltalk&quot; de Gilles Clavel {{ISBN|978-2-225-85157-5}}
* ''Smalltalk : Programmation orientée objet et développement d'applications'', de Xavier Briffault et [[Gérard Sabah]]

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>tcoojkp6qc20k41bwafaesb3jmovexn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>UIML</title>
    <ns>0</ns>
    <id>169433</id>
    <revision>
      <id>100345942</id>
      <parentid>97788268</parentid>
      <timestamp>2014-01-17T20:24:00Z</timestamp>
      <contributor>
        <username>JnRouvignac</username>
        <id>114137</id>
      </contributor>
      <comment>Remplacement de la liste d'interfaces utilisateurs par une page listant toutes les interfaces utilisateurs</comment>
      <text xml:space="preserve" bytes="3345">'''UIML''' signifie '''User Interface Markup Language''' et est un dérivé d'[[Extensible Markup Language|XML]] permettant de décrire des [[interface graphique|interfaces graphiques]]. Normalement les gens pensent à employer XML pour décrire des documents ou des données, mais il est juste un formalisme qui peut être employé pour n'importe quel genre de données structurées. Il y a des outils qui convertissent une représentation d'UIML en représentation pour divers [[toolkit]]s (par exemple [[Abstract Window Toolkit|Java awt]]).

L'objectif est de créer à partir d'XML, un langage commun de description d'interface utilisateur, ouvert et [[logiciel libre|libre]] d'utilisation. Le but est de permettre le développement d'outils de création d'interfaces utilisateur qui soient indépendants des plateformes, qu'il s'agisse des plateformes actuelles ou futures.

Initié en 1997, le projet UIML vise à définir un métalangage canonique qui peut décrire n'importe quelle interface utilisateur, sans être tributaire du type d'unité ou d'interface graphique utilisée. UIML peut décrire les interfaces utilisateur qui sont aujourd'hui populaire - interface de bureau, interface web, interface mobile, système embarqué, ou encore applications « voix ». UIML peut également décrire les interfaces utilisateur pour les applications développées à la demande ou les applications à venir. Pour les développeurs qui intègrent les développements de tiers, UIML décrit la couche de présentation.

UIML fait l'objet d'une normalisation par l'[[Organization for the Advancement of Structured Information Standards|OASIS]] depuis 2009 environ&lt;ref&gt;[http://web.archive.org/web/20110719171715/http://www.uiml.org/  Home of the User Interface Markup Language (web.archive.org)] : &lt;cite&gt;[…] work on UIML has been transitioned into the Organization for the Advancement of Structured Information Standards (OASIS), an international body […], which now controls the UIML specification.&lt;/cite&gt;&lt;/ref&gt; ; dès‑lors, l’ancien site UIML.org qui a transféré{{à qui ?}} la responsabilité de la maintenance du standard à OASIS, n’existe plus.

[[XUL]], [[XAML]], [[MXML]]  fournissent des fonctionnalités semblables à UIML, mais ne sont pas des standards. Cependant, un autre standard, [[XForms]], couvre partiellement les mêmes fonctionnalités.

[[UsiXML]], un standard parallèle de IUML, vise la même finalité.

==Voir aussi==
* [[Liste de bibliothèques d'interface utilisateur]]

==Références==
{{références}}

==Liens externes==
* {{en}} [http://www.oasis-open.org/committees/tc_home.php?wg_abbrev=uiml OASIS User Interface Markup Language TC]
* {{en}}{{pdf}} [http://docs.oasis-open.org/uiml/v4.0/uiml-4.0.pdf User Interface Markup Language (UIML) Version 4.0 — Committee Specification 01] : version la plus récente du standard, datée de Mai 2009.
* {{en}} [http://www.packwood-cottages.freeserve.co.uk/uiml/vb2uiml.htm Projet VB2UIML, outil de conversion VisualBasic vers UIML]
* {{en}} [https://sourceforge.net/projects/uimldotnet Projet UIML.Net, outil de conversion UIML vers .Net]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Dialecte XML]]
[[Catégorie:Interface utilisateur]]
[[Catégorie:Langages de description d’interface utilisateur]]</text>
      <sha1>l4qml78itfmq7xwisghae42mwdwr8hc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Virtual Reality Markup Language</title>
    <ns>0</ns>
    <id>3133</id>
    <revision>
      <id>91759070</id>
      <parentid>89735605</parentid>
      <timestamp>2013-04-06T16:04:06Z</timestamp>
      <contributor>
        <username>ASGdev</username>
        <id>1334331</id>
      </contributor>
      <minor/>
      <comment>Dans &quot;Logiciels exportant en VRML&quot;, ajout du logiciel Art Of illusion. @ASG_dev</comment>
      <text xml:space="preserve" bytes="6451">Le '''Virtual Reality Modeling Language''' (abrégé en '''VRML''') ou '''Virtual Reality Markup Language''' est un langage de description d'univers virtuels en [[3D|3 dimensions]]. Ce langage interprété est une norme internationale [[ISO]] et les fichiers VRML ont habituellement pour extension .wrl.

C’est à proprement parler un langage de présentation et non de programmation, puisque comme pour le langage [[Hypertext Markup Language|HTML]] par exemple, un fichier VRML ne contient généralement pas une suite d'instructions mais plutôt les informations permettant au visionneur d'afficher ensuite les éléments (formes, senseurs, lumières, etc).

Présenté lors de la World Wide Web Conference de 1994, VRML n'est pas l'œuvre d'un unique programmeur, mais plutôt le résultat de la collaboration de plusieurs professionnels de la [[3D]], dont entre autres Mark Pesce, Tony Parisi, Gavin Bell ([[Silicon Graphics]]) et Paul Strauss ([[Silicon Graphics]]).

Le but premier de ce langage est de permettre la représentation d'univers interactifs 3D virtuels. Les fichiers .wrl sont des fichiers texte décrivant les scènes virtuelles à l'aide du langage VRML. Les fichiers .wrl, qui peuvent être stockés localement sur un ordinateur ou téléchargés depuis un serveur web, sont visualisés à l'aide d'un visionneur, qui est soit un plugin ajouté au navigateur web ou encore un logiciel autonome indépendant du navigateur web, qui est installé sur l'ordinateur de l'utilisateur.

Les programmes VRML peuvent décrire des formes simples (points, lignes, polygones) ou complexes (sphères, cubes, cônes, cylindres...), du texte, des images, des animations, des éclairages, des sons, des hyperliens, ainsi que leur agencement dans l'espace, leur texture, leur couleur, leur matériau...

==Exemple de description de forme en langage VRML==

 #VRML V2.0 utf8
 Shape {
   appearance Appearance {
     material Material {
       diffuseColor  .8 0 .2
       shininess .7
     }
   }
   geometry Cylinder {
     radius 1
     height 8
     side FALSE
     top TRUE
     bottom FALSE
   }
 }

Une fois le programme interprété par le visionneur, le monde virtuel s'affiche à l'écran, en 3D; la caméra (c'est-à-dire le point de vue) se positionne à l'endroit prévu de la scène, et l'utilisateur est alors libre de se déplacer dans ce monde (généralement à l'aide du clavier ou de la souris) et d'interagir avec les différents objets présents. Les &quot;sensors&quot; de proximité permettent de lancer une action lors du passage à proximité d'un objet, les &quot;sensors&quot; de touché permettent de déclencher, par exemple, avec un clique sur l'objet l'ouverture d'un autre monde virtuel...

En 1996, une nouvelle mouture du langage fut présentée : VRML 2.0 (par la suite rebaptisée VRML97). Parmi les améliorations par rapport à la version 1.0, on peut citer :
*animation des objets: les mondes créés ne sont plus condamnés à demeurer statiques
*interaction avec les objets : chaque objet du monde peut réagir à des signaux, ces signaux pouvant être générés par l'utilisateur (clavier, souris...) ou par d'autres objets du même monde.
*création de [[Langage de script|scripts]] d'animation (en [[JavaScript]]/[[ecmascript]]) inclus aux fichiers .wrl
*gestion des sons en 3D
*extrusions d'objets
*effets de brouillard
*utilisation d'une séquence vidéo en tant que texture d'un objet
*création de prototypes d'objets

En complément des informations de base concernant les différents objets de la scène 3D, le VRML v2 possède un véritable langage de programmation interne appelé VrmlScript, dont la syntaxe est similaire au JavaScript. Il permet notamment de manipuler les objets (nœuds) de la scène VRML (de type SFNode), ou d'autres types de données propres au VRML comme les SFTime, SFColor, ou encore SFRotation.
Un script écrit en VrmlScript est exécuté à l'intérieur d'un objet (ou nœud) de type Script{}, comme ceci :

 #VRML V2.0 utf8
 Script {
   field SFInt32 unNombre 123456
   field SVec3f  unVecteur 1 3 2
   url &quot;vrmlscript:
     function maFonction() {
       print('Hello world !');
       print('Voici un vecteur : '+unVecteur);
     }
   &quot;
 }


Ce langage ouvert et accessible à tous, est bien documenté sur le web et est souvent utilisé pour :
*représenter des objets réels numérisés.
*créer des jeux vidéo 2D/3D.
*représenter des objets dans des documentations techniques (la [[National Aeronautics and Space Administration|NASA]] avait par exemple publié un fichier VRML qui permettait d'observer le module [[Mars Pathfinder]] dans ses moindres détails)
*des sites Internet de rencontre et de discussion, où chaque visiteur choisit un [[avatar (informatique)|avatar]] pour le représenter, avant de s'aventurer dans le monde virtuel à la rencontre des avatars des autres visiteurs.
*des simulations d'intérieurs (pour l'étude de l'agencement et de l'éclairage des pièces)
*des graphiques statistiques en 3D (cartographie, histogrammes 3D...)

==Visionneurs VRML (pour la visualisation de fichiers VRML) ==
* [http://www.demotride.net/intro.html Démotride], visionneur VRML/X3D gratuit.
* [http://www.viewlife.com Webseed Studio 3D, outil d'authoring permettant de diffuser des fichiers VRML sur Internet sans plug-in activeX]

== Logiciels exportant en VRML ==
* Archicad
* [[SketchUp]]
* [[Blender (logiciel)|Blender]]
* [[Abaqus]]
* [[GPure]] (partiellement)
* TopStation de JSInfo
* 3ds Max
* Solid Edge
* Catia V5
* [[Art_of_Illusion|Art Of Illusion]]

==Voir aussi==
*[[PhBRML]]
*[[X3D]]
*[[U3D]]
* [[O3D]]

==Liens externes==
* {{en}} [http://cic.nist.gov/vrml/vbdetect.html VRML Plugin and Browser Detector]
* {{en}} [http://www.web3d.org/ Web3D Consortium]
* {{en}} [http://www.web3d.org/x3d/specifications/vrml/ISO-IEC-14772-VRML97/ Specifications du format]
* [http://www.web3d-fr.com/ Web-3D : un site explicatif avec de nombreux tutoriaux]
* [http://www.labo-caa.fr/Librairie-3D-pour-PHP-Php-Vrml.html Page du projet Php-Vrml permettant de créer des fichiers vrml à l'aide de php]
* [http://www.jstatsoft.org/v36/i08/ Open-source R software pour créer des fichiers vrml]
* [http://www.bonsurf.net/chats.htm Annuaire de plus de mille mondes virtuels VRML, ordre alphabétique + screenshots]


{{Portail|Informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Norme ISO]]
[[Catégorie:Format de données numériques]]
[[Catégorie:3D]]</text>
      <sha1>aqp0ajvxkk4qbkvnmy4g5acdg1xqg5l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lisaac</title>
    <ns>0</ns>
    <id>159948</id>
    <revision>
      <id>101612953</id>
      <parentid>96434907</parentid>
      <timestamp>2014-02-26T15:26:24Z</timestamp>
      <contributor>
        <username>Soren56</username>
        <id>513304</id>
      </contributor>
      <text xml:space="preserve" bytes="10762">{{Infobox Langage de programmation
|  nom                    = Lisaac
|  logo                   = 
|  paradigmes             = [[Programmation orientée prototype|prototype]], [[Programmation impérative|impératif]], [[Programmation objet|objet]]
|  année                  = [[2000]]
|  auteur                 = [[Benoît Sonntag]]
|  développeurs           = [[Institut national de recherche en informatique et en automatique|INRIA]], [[LORIA]] et [[Centre national de la recherche scientifique|CNRS]]
|  dernière version stable= [http://isaacproject.u-strasbg.fr/li/li_docs.html (spécification) 0.3] {{Date||septembre|2007|en informatique}}
|  typage                 = [[Typage fort|Fort]], [[Typage statique|statique]]
|  implémentations        = 
|  dialectes              = 
|  influencé par          = [[Self (langage)|Self]], [[Eiffel (langage)|Eiffel]], [[Smalltalk]]
|  a influencé            = 
|  système d'exploitation = [[Multiplate-forme]]
|  licence                = [[Licence publique générale GNU]] v3
|  site web               = [http://www.lisaac.org/ Isaac projet]
}}

'''Lisaac''' est un [[langage de programmation]] [[programmation impérative|impératif]] à [[Programmation orientée prototype|prototype]] [[compilateur|compilé]] conçu afin d'écrire le [[système d'exploitation]] [[Isaac (système d'exploitation)|Isaac]]. 

C'est un système intégralement modulaire et entièrement composé d'objets posés sur le matériel de la machine. C'est ainsi un langage de haut niveau conçu pour être adapté au développement de [[Pilote informatique|pilotes de périphériques]].

==Présentation générale==

Lisaac est inspiré du langage [[Self (langage)|Self]] pour les concepts d'[[Programmation orientée prototype|objets à prototypes]], issu de recherches poursuivies dans les [[années 1990]] par ''[[Sun Microsystems|Sun]] Research''. Il est aussi inspiré du langage [[Eiffel (langage)|Eiffel]], un langage objet à classes, pour les aspects d'ingénierie logicielle et notamment pour la [[programmation par contrat]]. Enfin les concepts utiles à la programmation [[Système d'exploitation|système]] comme la gestion des [[Interruption matérielle|interruptions]] ont été rajoutés.

L'[[Programmation orientée prototype|objet à prototypes]] se différencie de l'[[programmation orientée objet|objet à classe]] en ce qu'il n'est plus nécessaire de créer une [[Classe (informatique)|classe]], un « moule » de l'objet que l'on instanciera dans le corps du programme. 
Dans le monde à prototype, ne règnent que des objets. Un objet est vivant dès l'exécution. Un objet ne s'instancie pas, il se clone. Un objet peut posséder plusieurs parents ([[héritage multiple]]). Un objet peut dynamiquement changer de parents (héritage dynamique).

Le [[compilateur]] Lisaac génère du [[C (langage)|C ANSI]] optimisé et est ainsi [[multi-plateforme]].

==Caractéristiques==
===Un langage objet à prototype===

Dans [[Programmation orientée prototype|ce type de langage]], l'objet règne en maître. Un objet est physiquement présent en mémoire, il se clone. L'héritage se situe au niveau des objets, pas des classes.

Un objet héritant d'un autre objet, plusieurs objets peuvent hériter d'un même objet physique. Étant une entité physiquement séparée, il est possible de changer de parent à l'exécution (voir héritage dynamique)

===Protections===

En lisaac, on n'est plus limité par le ''private'', ''public'' et ''protected''. Plus exactement le ''protected'' est étendu :

On défini une méthode ou propriété publique ou privé en définissant dans Section Public ou Section Private.

Par contre, pour faire du protected, on va faire Section SELF ie. tous les objets héritant de SELF vont pouvoir accéder aux propriétés/méthodes de cette section, ce qui revient à protected.

Mais là où cela devient intéressant est la possibilité de définir Section NUMERIC ou Section ARRAY[STRING].

Dans ces sections, seuls les objets (resp.) NUMERIC et ARRAY[STRING] ainsi que leur descendance auront accès aux méthodes et propriétés définies dans ces sections.

===Héritage dynamique===

En lisaac, l'héritage peut se définir par une fonction. Imaginons l'objet DECOD_MPEG2 possédant une méthode renvoyant les Bitmap video issus du décodage :

On veut pouvoir lire la vidéo en mode fenêtré, en plein écran sur l'écran SVGA ou sur la sortie TV...

on a :

 - NAME := DECOD_MPEG2_TO_SCREEN 

 Section Inherit

 - videoparent : OBJECT ← 
 (

 + result : OBJECT;
 
 typ 
 .when 1 then { result := WINDOW;}
 .when 2 then { result := VIDEO_VGA;}
 .when 3 then { result := VIDEO_TVOUT;};
 
 result
 )
 
 
 
 Section Public
 
 - typ : INTEGER;
 
 - decode_flux ← 
 (
    putimage decode_to_bitmap;
 );

===Redéfinition des opérateurs===

On peut redéfinir les opérateurs dans n'importe quel objet vu qu'ils sont des méthodes comme les autres (il faut les mettre entre apostrophes, c'est tout).

Dans l'objet NUMERIC on a :
 - '+'  left 80  other:SELF :SELF ← self - -other;
Si on crée un objet MATRICE, on peut le redéfinir

 - '+'  left 80  other:SELF :SELF ← 
 
 (
 	+ result : SELF; 

 	result := SELF.create count; 
 	1.to tab.count do { i : INTEGER;
 		result.put (item i+other.item i) to i;
 	};
 
 	result
 )

On a redéfini l'opérateur + pour l'objet MATRICE.

===Priorités des opérateurs===

Comme on peut le voir dans l'exemple précédent, la priorité et l'associativité des opérateurs est programmable. Cela demande de la part du compilateur une étude approfondie afin de fixer l'ordre d'évaluation des expressions.

===Généricité===

On peut définir un objet générique de plusieurs objets :
DICTIONARY(CLE,VALEUR)

===Programmation par contrat===

Pour une meilleure fiabilité du code, des  mécanismes de [[programmation par contrat]] inspirés de la [[Notation Z]] ont été ajoutés. 

Lisaac permet de définir des ''require'', ''invariants'' et ''ensure'' comme en [[Eiffel (langage)|Eiffel]].

===Facilités système===

Lisaac offre deux fonctionnalités [[Système d'exploitation|systèmes]] :

* Section '''MAPPING'''
** Permet de définir avec précision un masque de bit.
** Permet de décrire des objets représentant une structure fixée par le matériel.
** Permet de créer des prototypes directement associés.
** Permet aussi de créer des tableaux de pixels en étant certain de pouvoir disposer de bonnes performances.
** Le compilateur gère automatiquement les spécificités des objets MAPPING

* Section '''INTERRUPT'''
** Permet de définir des interruptions système.
** Le compilateur gère le fait qu'une interruption est une opération spéciale qui doit être insensible au contexte.

=== Performances ===

De récents benchmarks&lt;ref&gt;http://isaacos.loria.fr/li_benchs.html&lt;/ref&gt; ont démontré les performances du code produit par le [[compilateur]] : un décodeur [[Moving Picture Experts Group|MPEG]]1/2 complet, écrit en [[C (langage)|C]] a été traduit en lisaac en conservant rigoureusement les mêmes structures algorithmiques.

Les résultats sont encourageants : avec 37 % de lignes de code en moins que le source C, Lisaac produit un exécutable 1,9 % plus lent que l'exécutable produit à partir du source C. De plus, grâce à la gestion dynamique de la mémoire, le lecteur est plus fiable.

De nouvelles optimisations sont à l'étude afin de réduire cet écart.

Voir aussi suppression de la liaison dynamique

===Suppression de la liaison dynamique===

Les langages objets classiques, jusqu'à [[SmartEiffel]], utilisent des VFTs (de l'anglais ''Virtual Function Table'') pour [[Compilateur|compiler]] la liaison dynamique: :

Soient l'objet IMAGE, et ses deux descendants PNG et XCF. Quand on appelle la fonction PNG.affiche_toi() en [[Java (langage)|Java]] ou PNG→affiche_toi() en [[C plus plus|C++]], on se retrouve en [[assembleur]] avec un appel du type :
 Call dword ptr [__adresse_de_PNG + index_dans la_VFT_de_la_fonction_affiche_toi()]

L'adresse de PNG (l'objet receveur) pointe sur la base de la VFT, ensuite on ajoute le bon index pour recuperer le champ correspondant à la bonne méthode...

Ce qui implique que cela vide le cache du processeur et que l'inlining est bloqué à la [[Compilateur|compilation]].

Le [[compilateur]] lisaac optimise la liaison dynamique en analysant finement le type dynamique des objets grâce à un algorithme de prédiction de type. La liaison dynamique supprimée, il devient possible de procéder à des inlining et à des spécialisations de code.

===Syntaxe et sémantique===

La syntaxe est d'abord inspirée de [[Smalltalk]] mais aussi d'[[Eiffel (langage)|Eiffel]] et de [[Self (langage)|Self]], la syntaxe des blocs d'instructions est largement inspirée de [[C (langage)|C]].

Lisaac est sémantiquement et syntaxiquement très proche des langages Self et Eiffel.  Il reprend aussi quelques éléments syntaxique du C et du [[Pascal (langage)|Pascal]]. Comme son grand frère Self, ce langage est minimaliste avec l’absence de construction pour les conditionnelles, les boucles et les itérations : Le compilateur Lisaac ne sait pas ce qu'est une conditionnelle, on implémente celle-ci avec les trois objets Boolean, True, False (True et False héritant de Boolean), dans lesquels les conditionnelles (if ; if/else, etc.) sont définies.
Un pattern matching, au sein du [[compilateur]], va reconstruire les séquences afin de les optimiser et de les rendre aussi rapides qu'en C.

L’approche à objets a pu être respectée par l’absence de types de base (comme par exemple le ''int'', nombre entier, en Java) pour laisser place à une encapsulation objet à la manière du langage Eiffel et de ses objets de type ''expanded''.

== Versions ==

La numérotation des versions du compilateur Lisaac ne suit pas le schéma classique : chaque numérotation du compilateur suit la spécification qu'il implémente.
Les compilateurs disponibles en téléchargement sont généralement stables, attendus qu'ils ne sont disponibles que lorsqu'ils sont débogués. C'est une volonté ferme de son auteur.

== Lien externe ==
{{Autres projets|wikibooks=Programmation Lisaac|wikibooks titre=Programmation Lisaac}}
* [http://www.lisaac.org/ Le projet Isaac / Lisaac]
* [http://lisaac.u-strasbg.fr/ Wiki sur Lisaac, Isaac et Isaacos (sur le site de l'université de Strasbourg) ]
* [https://alioth.debian.org/projects/lisaac/ Lisaac sur alioth.debian.org]
* [http://packages.debian.org/search?keywords=lisaac/  Paquets Lissac dans Débian]

== Notes et références ==
{{Références}}


{{Palette Langages de programmation}}
{{Portail|Informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>97ck1fouu46yj87w6jm1evvk6u9o1h5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Self (langage)</title>
    <ns>0</ns>
    <id>306642</id>
    <revision>
      <id>89900325</id>
      <parentid>83123339</parentid>
      <timestamp>2013-03-13T01:39:40Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 8 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1864529]]</comment>
      <text xml:space="preserve" bytes="633">{{Voir homonymes|Self}}

[[Self]] est un [[programmation orientée objet|langage de programmation orienté objet]] à [[Programmation orientée prototype|prototype]] issu de recherches poursuivies par [[Craig Chambers]] et [[Ole Agesen]] dans les [[années 1990]] par ''[[Sun Microsystems|Sun]] Research''.

== Voir aussi ==

=== Articles connexes ===

* [[Lisaac]], langage s'inspirant de Self

=== Liens externes ===

* [http://research.sun.com/self/ Site officiel du langage Self] (sur le site research.sun.com)

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>jh1d87em7bocwj7xd1mrat9lygyydg1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Simula</title>
    <ns>0</ns>
    <id>263155</id>
    <revision>
      <id>100303975</id>
      <parentid>98539296</parentid>
      <timestamp>2014-01-16T11:09:56Z</timestamp>
      <contributor>
        <username>399man</username>
        <id>507922</id>
      </contributor>
      <minor/>
      <comment>Ajout de l'infobox « Langage de programmation », remplie à l'aide de la version anglaise (https://en.wikipedia.org/wiki/Simula). À améliorer.</comment>
      <text xml:space="preserve" bytes="8439">{{Infobox Langage de programmation
|  nom                    = Simula
|  logo                   = 
|  paradigmes             = [[Programmation orientée objet|Objet]]
|  année                  = [[1967]]
|  auteur                 = [[Ole-Johan Dahl]], [[Kristen Nygaard]]
|  développeurs           = 
|  dernière version stable= 
|  typage                 = 
|  implémentations        = 
|  dialectes              = 
|  influencé par          = [[Algol (langage)|Algol 60]]
|  a influencé            = [[Programmation orientée objet|Les langages orientés objet]]
|  système d'exploitation = 
|  licence                = 
|  site web               = 
}}
'''Simula''' ({{lang|en|'''''Sim'''ple '''u'''niversal '''la'''nguage''}}) a été créé en [[1962 en informatique|1962]] sous la dénomination Simula I par Ole-Johan Dahl et Kristen Nygaard à partir d'[[Algol (langage)|Algol 60]]. Le langage évolua en 1967 sous le nom de Simula 67 en implantant le premier le modèle de classe de Hoare (Record Class,  [[Charles Antony Richard Hoare|Hoare]] 1965). Il est donc le premier langage à classes et donc le père de tous les langages à classes tel que [[Smalltalk]], [[C++]],  [[Java (langage)|Java]], ou encore [[Eiffel (langage)|Eiffel]]. Il inspira Dan Ingalls dans la conception de [[Smalltalk]] qui introduisit la programmation orienté objet. C'est la raison pour laquelle Simula 67 est souvent considéré à tort comme le premier langage orienté objet alors que ce paradigme est introduit bien après Simula 67 dans les années 1970 par Alan Kay.

== Historique ==

Simula a été développé dans les [[années 1960]] au {{lang|en|''[[Norwegian Computing Centre]]''}} d'[[Oslo]], initialement par [[Ole-Johan Dahl]] et [[Kristen Nygaard]]. Syntaxiquement parlant, c'est un sur-ensemble d'[[Algol (langage)|Algol]], qui ajoute à celui-ci les concepts, aujourd'hui familiers, des langages à classes comme [[C plus plus|C++]]  [[Java (langage)|Java]] ou autres et de la [[simulation à événements discrets]].

Simula n'a jamais été un simple langage universitaire, puisqu'il a été utilisé pour des applications industrielles {{Quand|jusqu'à aujourd'hui}}, mais son influence historique est considérée comme plus importante que les applications qui auraient pu être développées avec lui.

Par '''Simula''' on entend généralement '''Simula-67''', c'est-à-dire la version de 1967, alors que la version précédente datait de 1962 : '''Simula {{I}}'''.

== Simulation discrète ==
Comme son nom l'indique, en plus de constituer un langage de programmation généraliste, Simula a été conçu de façon à contenir des bibliothèques de classes offrant un support de concepts spécifiques à la [[simulation à événements discrets]]. La classe {{lang|en|''Process''}}, héritant de ''Simulation'' permettait ainsi à l'utilisateur d'hériter pour ses propres classes de simulation du comportement de base d'un processus pouvant s'exécuter en mode dit « ''quasi-parallèle'' », à l'aide du concept de [[coroutine]].

Une coroutine est une routine à plusieurs points de sortie et qui, à chaque ré-entrée du flot d'exécution dans celle-ci lors d'un appel à l'instruction '''Resume''', reprend son exécution à la dernière instruction où le flot l'avait précédemment quitté lors d'un appel à l'instruction '''Detach'''. Le point d'exécution est stocké dans le LSC : {{lang|en|''Local Sequence Counter''}}.

Pour clarifier le propos, le programme suivant produirait l'affichage indiqué plus bas : 

 {{blue|Begin}}
   Ref(TwinProcess) firstProc, secondProc;
   {{blue|Class}} TwinProcess(Name); 
   Text Name;
   {{blue|Begin}}
         {{vert|! Initial coroutine entry (creation)}}
      Ref(TwinProcess) Twin;
      OutText(Name); OutText({{gris|&quot;: Creation&quot;}}); OutImage;
         {{vert|! First coroutine exit}}
      Detach;
         {{vert|! Second coroutine entry}}
      OutText(Name); OutText({{gris|&quot;: Second coroutine entry&quot;}}); OutImage;
          {{vert|! Second coroutine exit: switch to the twin's coroutine}}
      Resume(Twin);
          {{vert|! Last coroutine entry}}
      OutText(Name); OutText({{gris|&quot;: Last coroutine entry&quot;}}); OutImage;
      Resume(Twin);
  {{blue| End}};
   {{blue|Begin}}
      firstProc :- {{Blue|New}} TwinProcess ({{gris|&quot;1st Proc&quot;}});
      secondProc :- {{blue|New}} TwinProcess ({{gris|&quot;2nd Proc&quot;}});
      firstProc.Twin:- secondProc;
      secondProc.Twin :- firstProc;
      OutText({{gris|&quot;Starting&quot;}}); OutImage;
      Resume(firstProc);
      OutText({{gris|&quot;End&quot;}});
  {{blue| End}};
  {{blue|End}};

Affichage :

  1st Proc: Creation
  2nd Proc: Creation
  Starting
  1st Proc: Second coroutine entry
  2nd Proc: Second coroutine entry
  1st Proc: Last coroutine entry
  2nd Proc: Last coroutine entry
  End

La bibliothèque de simulation discrète permettait de gérer la file des processus au moyen d'instructions dédiées ('''Activate''', '''Passivate''', '''Hold''', etc.)

== Programmation objet ==
La plupart des constructions qui permettront plus tard la réalisation des  concepts principaux de la [[programmation orientée objet]] sont d'ores et déjà présents dans '''Simula 67''' :
* les '''classes''' comme structure de données dans Simula rassemblant variables et opérations sur ces dernières (dans Simula, il représentaient des activités),
* l'instanciation via l'instruction '''New''',
* les '''relations''' entre objets (ou processus dans le jargon originel de Simula) au moyen de références : '''Ref( )''' et affectation de références avec l'instruction ''':-'''
* référence sur l'instance courante grâce au mot clé '''This'''
* Test de référence nulle automatique nativement supporté '''Inspect-Do-Otherwise''' : ''Inspect rect do Draw'' ici, ''x.Draw'' ne sera appelé que si ''x'' n'est pas une référence ''nulle'' (mot clé : '''None''')
* fonctions virtuelles
* appel de méthode par notation pointée ('''dot-notation''') : &lt;objet&gt;.&lt;méthode&gt;
* appel qualifié (i.e. statiquement lié) de méthodes virtuelles à l'aide de l'opérateur '''Qua''' ou avec '''Inspect-When'''
* reconnaissance de type à l'exécution (instruction '''Inspect''', '''Is''', '''In''')
* héritage simple entre classes
* restriction d'accès ('''Hidden''', '''Protected''')
* classes imbriquées (ou internes)
* Imbrication sophistiquée des appels du corps de méthode de la classe via l'instruction '''Inner''', qui peut ainsi permettre d'obliger l'exécution de code avant et/ou après l'exécution du corps d'une classe dérivée : on voit déjà se profiler le concept d'assertions, implémentées par [[Eiffel (langage)|Eiffel]] dans les [[années 1980]], ou même la [[Programmation orientée aspect|programmation par aspect]], qui sera développée dans les [[années 1990]].
* un [[ramasse-miettes (informatique)|ramasse-miettes]] {{en en|garbage-collector}}.

Cette liste succincte permet de prendre conscience de la '''percée conceptuelle''' opérée par Simula en 1967 dans le domaine des langages impératifs structurés.

Malheureusement, les auteurs de Simula apportèrent une certaine confusion dans le monde de la programmation orientée objet. Avec l'apparition de ce nouveau paradigme avec Smalltalk, Ole Johan Dahl et Kristen Nygaard, changèrent les dénominations utilisées dans Simula pour se conformer aux concepts véhiculés dans Smalltalk (classes d'objets, objets, attributs, méthodes, etc.) et déclarèrent que Simula 67 fut en fait le premier langage orienté objet. Pourtant, l'approche utilisée dans Simula 67 n'est pas celle définie par Alan Kay, l'auteur de la programmation orientée.

== Voir aussi ==
=== Articles connexes ===
*[[Programmation orientée objet]]
*[[BETA]]  (le successeur de  Simula)

=== Liens externes ===
* {{en}} [http://staff.um.edu.mt/jskl1/talk.html {{lang|en|''Introduction to OOP in Simula''}}] – par J.Sklenar, basé sur le séminaire de 1997 « {{lang|en|''30 Years of Object Oriented Programming''}} (OOP) » de l'Université de Malte
* {{en}} [http://heim.ifi.uio.no/~kristen/FORSKNINGSDOK_MAPPE/F_OO_start.html {{lang|en|''How Object-Oriented Programming Started''}}] – par Dahl et Nygaard, version abrégée d'un article d'une encyclopédie sur la page du site de Nygaards.


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>7ga0ow4b45bs400vm175mjow0zi7yz7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Oberon (langage)</title>
    <ns>0</ns>
    <id>26184</id>
    <revision>
      <id>89779120</id>
      <parentid>84036818</parentid>
      <timestamp>2013-03-12T12:51:13Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 16 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1323362]]</comment>
      <text xml:space="preserve" bytes="2357">{{voir homonymes|Oberon}}
{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                              = Oberon
 | logo                             = 
 | paradigme                        = [[Programmation impérative|impératif]], [[Programmation structurée|structuré]], [[Programmation modulaire|modulaire]]
 | auteur                           = [[Niklaus Wirth]] et [[Jürg Gutknecht]] (avec [[Hanspeter Mössenbock]] pour Oberon-2)
 | développeur                      = 
 | typage                           = [[Typage fort]] et [[Typage statique|statique]]
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[Modula-2]]
 | a influencé                      = [[Go (langage)|Go]], Oberon-2, Oberon-07, Zonnon
 | système d'exploitation           = MS Windows, Mac OS X, Linux, Solaris
 | licence                          = [[Licence BSD|Type BSD]]
 | site web                         = [http://www.oberon.ethz.ch/ www.oberon.ethz.ch]
 | date de mise à jour              = 
}}

'''Oberon''' (alias '''Oberon-1''') est un langage de programmation développé par [[Niklaus Wirth]] et [[Jürg Gutknecht]] de [[1985 en informatique|1985]] à [[1987 en informatique|1987]].

Quoique le langage soit basé sur [[Modula-2]] — dont Wirth est l'auteur —, plusieurs propriétés ont été éliminées et l'extension de type, en outre, fut introduite.

Sa syntaxe ressemble au [[Pascal (langage)|Pascal]].

Oberon élimine également le mécanisme explicite de [[désallocation de mémoire]] et intègre un [[ramasse-miettes (informatique)|ramasse-miettes]].

En [[1991 en informatique|1991]], Niklaus Wirth, Jürg Gutknecht et [[Hanspeter Mössenbock]] conçoivent '''Oberon-2''', une extension d'Oberon qui inclut les [[Procédure liées au type|procédures liées au type]] (méthodes), la [[polymorphie]] des [[programmation orientée objet|objets]], les [[Tableau croisé dynamique|tableaux dynamiques]] et l'exportation de variables en lecture seulement.

== Liens externes ==
* {{Officiel|en|http://www.oberon.ethz.ch}}
* {{ODP|Computers/Programming/Languages/Oberon/|Oberon}}

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>8x7umk3eau0jgwscoyi7wqxw9tfuz2l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>OPL (langage informatique)</title>
    <ns>0</ns>
    <id>324794</id>
    <revision>
      <id>61308940</id>
      <parentid>51484434</parentid>
      <timestamp>2011-01-15T18:13:11Z</timestamp>
      <contributor>
        <ip>78.192.132.151</ip>
      </contributor>
      <comment>/* Liens externes */ + palette langages</comment>
      <text xml:space="preserve" bytes="1781">{{Homonyme|OPL}}
{{Ébauche|informatique}}

L''''OPL''' ('''Optimization Programming Language''') est le [[langage informatique|langage]] de [[programmation]] des [[ordinateur]]s [[Psion]], apparu sur les modèles [[Psion#MC|MC]], comme dérivé du POPL des [[Psion#Organiser I|Organiser I]] et [[Psion#Organiser II|II]].

Il existe une version pour les [[Psion#Series 3|Series 3]], une version étendue pour les [[Psion#Series 3a|Series 3a]], [[Psion#Series 3c|3c]], [[Psion#Siena|Siena]] et [[Psion#Series 3 MX|3 MX]] (gestion du niveau de gris, du plus grand écran etc.), et une version pour [[Psion#Series 5|Series 5]], très différente, gérant, par exemple, les menus cascadés ou l'écran tactile.

Il est possible de faire tourner les programmes écrits pour Series 3 en mode compatibilité sur les ordinateurs plus récents de la même architecture.

C'est un langage facile d'abord, grâce à la bonne documentation fournie par PSION, souvent à l'achat du matériel, et grâce à la présence, sur l'appareil, de l'éditeur de programmes et du compilateur.

Le langage est [[Programmation procédurale|procédural]], les [[variable (informatique)|variables]] sont typées et déclaratives, et le code est semi-compilé (réversible avec le logiciel ''revtrans'').

L'éditeur étant limité à {{Unité|40|kio}} pour le texte source (mais il y a déjà moyen de faire beaucoup dans cette limite), il existe un programme additionnel permettant de gérer les ''include''.

Il est possible, également, d'incorporer dans l'OPL des parties de code en C.

== Liens externes ==
[http://www.99-bottles-of-beer.net/language-opl-520.html Exemple de code OPL]

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>a3lsstto84aqjiu30vod88hpdce36n6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Io (langage)</title>
    <ns>0</ns>
    <id>334901</id>
    <revision>
      <id>89914824</id>
      <parentid>86415521</parentid>
      <timestamp>2013-03-13T04:00:42Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 13 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q756175]]</comment>
      <text xml:space="preserve" bytes="5673">{{Voir homonymes|Io}}
'''Io''' est un [[langage de programmation]] pur [[Programmation orientée objet|objet]] basé sur les [[Programmation orientée prototype|prototypes]] et distribué sous [[licence BSD]]. Il a été créé en [[2002 en informatique|2002]] par [[Steve Dekorte]].

== Présentation ==

Lorsque Steve Dekorte imagina son langage, il le voulait léger, simple, [[multi-plateforme]] et facile à embarquer dans un autre programme. C'est ainsi qu'est né Io (dont le nom doit refléter sa simplicité).

Il s'inspire de différents langages tout en tirant parti de leurs qualités respectives :
* [[Smalltalk]] : toutes les valeurs sont des objets ;
* [[Self (langage)|Self]] ;
* [[NewtonScript]] ;
* [[Act1]] : héritage différentiel des prototypes, acteurs et promesses de réponse pour la concurrence entre tâches ;
* [[LISP]] : le code est un environnement d'exécution basé sur un arbre accessible en lecture et en écriture ;
* [[LUA]] : léger et pouvant être embarqué.

Io est un [[langage de script]] disposant de plusieurs extensions dans divers domaines tels que le [[chiffrement]] des données, la programmation [[Réseau informatique|réseau]], le [[graphisme]] ou encore les [[base de données|bases de données]].

== Machines virtuelles ==
'''Io''' se décline sous trois [[machine virtuelle|machines virtuelles]] ce qui lui apporte une grande portabilité puisque celui-ci (comme tout [[Langage interprété informatique|langage interprété]]) peut être exécuté sous n'importe quelle architecture pour autant que la machine virtuelle soit disponible pour celle-ci.

=== IoVM ===
''IoVM'' est la base du langage ; la plupart des fonctionnalités se trouvant dans ''IoServer''  et ''IoDesktop''. Elle peut être utilisé indépendamment ou en tant que langage embarqué dans un plus grand projet.

=== IoServer ===
''IoServer'' apporte de nombreuses fonctionnalités par rapport à la conception d'applications [[serveur informatique|serveurs]] telles que les applications [[Web]].

=== IoDesktop ===
Et enfin, ''IoDesktop'', se veut être une solution de développement [[multimédia]]. Il est donc possible par son intermédiaire d'exploiter des images, [[OpenGL]] et tout ce qui est en rapport avec le multimédia.
&lt;br /&gt;
&lt;br /&gt;

Ces trois machines virtuelles permettent aux scripts Io de fonctionner de manière identique peu importe le système. Elles sont actuellement disponibles sous [[Mac OS X]], [[Linux]], [[Berkeley software distribution|BSD]], [[Irix]], [[Win32]] et [[Symbian OS|Symbian]]. Cependant, écrites en [[C (langage)|C]] [[ANSI]], elles peuvent être facilement portées sur de nombreuses autres [[Plate-forme (informatique)|plates-formes]].

== Caractéristiques du langage ==
* '''Basé sur les [[Programmation orientée prototype|prototypes]]''' : héritage réalisé par le [[clonage]] des objets et la maintenance d'un lien dynamique entre le clone et l'original.
* '''Pur objet''' : toutes les entités manipulés par Io dérivent du même prototype {{lang|en|''Object''}}.
* [[ramasse-miettes (informatique)|ramasse-miettes]] : les objets sont automatiquement [[allocation de mémoire|alloués]] et supprimés.
* '''[[Type (informatique)|Types]] dynamiques''' : Bien que Io possède une notion de types, les [[variable (informatique)|variables]] n'ont pas de types définit de même que les opérations sur les prototypes. Il existe cependant des [[Méthode (informatique)|méthodes]] permettant de vérifier le type d'un objet.
* '''Fortement typé''' : toutes les interactions se font à l'aide de messages vers les objets. On n'accède jamais à la mémoire directement.
* '''[[Langage interprété informatique|Interprété]]''' : le [[code source]] produit n'est pas [[Compilateur|compilé]] vers un {{lang|en|''[[bytecode]]''}} mais plutôt converti vers une représentation dans la [[Mémoire informatique|mémoire]].
* '''Le code est une donnée''' : les {{lang|en|''blocks''}} de code sont réinjectés dans les objets et peuvent être modifier et créés dynamiquement.
* '''[[Introspection (informatique)|Réfléchi]]''' : conséquence de la réinjection du code, il est possible d'investir les propriétés de chaque objet (de même pour le code source) lors de l'exécution.
* '''Dynamique''' : puisque le code est une donnée, il est possible de changer un programme logique durant son exécution. Il est aussi possible de changer dynamiquement les attributs et les opérations sur un objet durant l'exécution. Combiné avec les prototypes, Io autorise la modification dynamique d'une classe d'objets.

== Exemples de code ==
'''Io''' est un langage qui se veut simple et puissant. Voici quelques exemples de code.

=== Commentaires ===
&lt;source lang=&quot;io&quot;&gt;
 //Les commentaires C++ peuvent être utilisés
 # tout comme ceux des scripts bash
 /* ou encore les commentaires
 sur plusieurs lignes */
&lt;/source&gt;

=== Bonjour tout le monde ===
La ligne de code suivante fera apparaître le message ''Bonjour tout le monde !'' à l'écran.
&lt;source lang=&quot;io&quot;&gt;
 &quot;Bonjour tout le monde !&quot; println
&lt;/source&gt;

=== Compter les moutons ===
&lt;source lang=&quot;io&quot;&gt;
 for(i, 1, 100,
      mouton := block(i,
      if(i == 1, return &quot;1 mouton&quot;)
      return &quot;&quot; .. i .. &quot; moutons&quot;
 )
&lt;/source&gt;

Pour plus d'exemples, vous pouvez visiter la [http://www.iolanguage.com/about/samplecode/ page d'exemples] sur le site officiel.

== Voir aussi ==

=== Liens externes ===

* {{en}} [http://www.iolanguage.com/ Site officiel de Io]
* {{en}} [[b:en:Programming:Io|Wikibooks : tutoriel pour les débutants]]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de script]]</text>
      <sha1>rp4m4el3dgvfyy9c50g6oprc2bl4omx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>VisualWorks</title>
    <ns>0</ns>
    <id>343043</id>
    <revision>
      <id>97530868</id>
      <parentid>89916563</parentid>
      <timestamp>2013-10-16T20:46:47Z</timestamp>
      <contributor>
        <username>Romanc19s</username>
        <id>26084</id>
      </contributor>
      <minor/>
      <comment>orthographe</comment>
      <text xml:space="preserve" bytes="701">{{ébauche|informatique}}

'''VisualWorks''' est une implémentation de [[Smalltalk]] développée initialement au [[Xerox PARC]], puis par [[ParcPlace Systems]] et enfin repris par [http://www.cincom.com/ Cincom]. VisualWorks s'exécute sur plusieurs plates-formes comme Apple [[Apple Macintosh|Macintosh]], [[GNU/Linux]], plusieurs versions d'[[UNIX]] et [[Microsoft Windows|Windows]]. 

== Voir aussi ==
=== Articles connexes ===
* [[L. Peter Deutsch]]

=== Liens externes ===
* [http://smalltalk.cincom.com/downloads/ Télécharger VisualWorks]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Dialecte Smalltalk]]</text>
      <sha1>sc23ku7ne0fycjt2524foz0pf8syclz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Locomotive BASIC</title>
    <ns>0</ns>
    <id>346122</id>
    <revision>
      <id>89917451</id>
      <parentid>58341049</parentid>
      <timestamp>2013-03-13T04:26:10Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1753474]]</comment>
      <text xml:space="preserve" bytes="1315">{{ébauche|informatique}}

'''Locomotive BASIC''' est un dialecte propriétaire du langage de programmation [[BASIC]] écrit par [[Locomotive Software]]. Disponible seulement sur certaines Compatible PC Amstrad ([[Amstrad PC-1512]] par exemple) et tous les [[Amstrad CPC]] où l'interpréteur était intégré sur une puce mémoire non-modifiable ([[Mémoire morte|ROM]]). C'est le principal ancêtre du [[Mallard BASIC]] se trouvant sur les [[Amstrad PCW]].

Il a été édité en plusieurs versions : la version 1.0 se trouvait sur les modèles CPC464, la version 1.1 sur les CPC664, la version 1.2 sur les CPC6128 et la version 1.4 sur les machines Amstrad CPC Plus.

À noter toutefois que les versions 1.2 et 1.4 s'annoncent comme étant des 1.1 à l'invite. Si la transition entre les versions 1.0 et 1.1 apportait son lot de nouvelles commandes, les versions 1.2 et 1.4 n'offraient rien de nouveau sinon des corrections de bugs ou des améliorations de performance.

== Voir aussi ==

* [[BASIC]]
* [[Amstrad CPC]]

== Liens externes ==

* [http://amstrad.cpc.free.fr/article.php?sid=37 Amstrad.cpc.free.fr] - Interview de Richard Clayton, fondateur de Locomotive Software, à propos du Locomotive BASIC.

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Amstrad]]</text>
      <sha1>bux2km7yhjv1erh6b59yfl99td06x06</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>CDuce</title>
    <ns>0</ns>
    <id>351987</id>
    <revision>
      <id>89920198</id>
      <parentid>62406497</parentid>
      <timestamp>2013-03-13T04:56:22Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2931220]]</comment>
      <text xml:space="preserve" bytes="815">{{ébauche|informatique}}

'''CDuce''' est un [[langage de programmation]] [[programmation fonctionnelle|fonctionnel]], d'ordre supérieur, fortement typé, adapté à la manipulation sûre et efficace de documents [[Extensible Markup Language|XML]].

Une opération de filtrage par motifs permet d'exprimer de manière concise des extractions de données complexes, et le système de type garantit que tous les documents valides en entrée seront traités de manière exhaustive, et qu'aucun document invalide en sortie ne pourra être produit.

Le projet [[OCamlDuce]] vise à intégrer CDuce dans le langage généraliste [[OCaml]].

== Lien externe ==
* [http://www.cduce.org Site Web]

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de transformation XML]]</text>
      <sha1>jas09ptrdjri98nbebggchsbpenmkqm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Visual DialogScript</title>
    <ns>0</ns>
    <id>366242</id>
    <revision>
      <id>100120911</id>
      <parentid>100107926</parentid>
      <timestamp>2014-01-10T19:57:52Z</timestamp>
      <contributor>
        <username>Romanc19s</username>
        <id>26084</id>
      </contributor>
      <comment>Annulation des modifications 100107926 de [[Spécial:Contributions/171.16.208.2|171.16.208.2]] ([[User talk:171.16.208.2|d]])</comment>
      <text xml:space="preserve" bytes="2046">{{Langue du titre|en}}
'''''{{lang|en|Visual DialogScript}}''''', souvent abrégé '''VDS''' est un [[langage de programmation]] simplifié de type [[Langage de script|script]] ou [[batch]].

== Fonctionnalités ==

Il permet de programmer de manière rapide un utilitaire basique pouvant automatiser certaines tâches rapides ou ne nécessitant pas l'intervention d'un langage de programmation plus complexe.

== Fonctionnement ==

Un exécutable compilé d'environ 10-15 ko représente le programme écrit. Une fois le programme lancé, le langage est '''interprété''' par une [[Dynamic Link Library|dll]] équivalente à la version du logiciel par exemple ''VDSRUN30.dll'' pour ''Visual DialogScript 3'', ou ''VDSRUN40.DLL'' pour ''Visual DialogScript 4''

== Améliorations ==

* La version 2 de ''VDS'' étant 16-bits, les programmeurs avec l'avènement du 32-bits passèrent la version 3.0 en 32-bits total. Parmi les évolutions des versions de 2.0 à 4.0, on notera principalement l'ajout de nouvelles fonctions de type ''@la_fonction()'' et de nouvelles ''commandes'' programmables.

Depuis la version 5, Visual DialogScript est capable entre autres de :
* Manipuler et mettre en œuvre les [[Application_programming_interface|API]] du système Microsoft Windows. Cela permet d'ouvrir certaines possibilités jusqu'alors inexploitées par ce langage.
* La création de modules DSU permettant la redistribution et la réutilisation de ces modules dans des codes de programmation tierce.
* La possibilité d'utiliser les fonctions ''INCLUDE'' et ''DEFINE'' proche des langages de type C++, mais de manière simplifié.
* L'inclusion de ''RESSOURCE'' permettant l'injection de ressources au fichier exécutable.

== Exemple de code &quot;Hello World&quot; ==
&lt;pre&gt;
Title Hello
Info Hello World !
Exit
&lt;/pre&gt;

==Voir aussi==

* {{en}} [http://www.dialogscript.com Site officiel de Visual DialogScript]
* {{en}} [http://www.vdsworld.com Communauté Visual DialogScript]

{{Portail programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>rdrxh8v7ta2bawho5b7hqvntwddvsjz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>SableVM</title>
    <ns>0</ns>
    <id>389014</id>
    <revision>
      <id>89933402</id>
      <parentid>62406903</parentid>
      <timestamp>2013-03-13T07:08:53Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 4 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2564839]]</comment>
      <text xml:space="preserve" bytes="1315">'''SableVM''' est un [[programme informatique]] consistant en une [[machine virtuelle]] [[logiciel libre|libre]] pour [[Java (technologie)|Java]] développée par l'équipe SableVM. Celle-ci se propose de réaliser un ensemble maintenable et portable. Le logiciel est distribué sous licence [[LGPL]]. Il utilise également [[GNU Classpath]] (dont les droits sont détenus par la [[Free Software Foundation]]) sous licence [[Licence publique générale GNU|GPL]] sauf pour le lien.

SableVM est compatible avec les spécifications complètes de Java. La machine virtuelle a été conçue de manière à s'approcher des performances des [[compilateur]]s [[Compilation à la volée|JIT]] (''just-in-time''). SableVM est la première [[machine virtuelle Java]] libre qui supporte le ''JVMDI'' (''Java Virtual Machine Debugging Interface'') et ''JDWP'' (''Java Debug Wire Protocol''). Ces interfaces de [[débogage]] sont utilisées par [[Eclipse (logiciel)|Eclipse]] pour offrir un environnement de développement efficace et riche. 

==Liens internes==
* [[SableJIT]]
* [[Kaffe]]
* [[GCJ]]
* [[Machine virtuelle Java]]

==Liens externes==
* {{en}} [http://www.sablevm.org www.sablevm.org]

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Plateforme Java]]</text>
      <sha1>7xaw2pc1iuw9p3extz323yc5m8f62s7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Processing</title>
    <ns>0</ns>
    <id>404704</id>
    <revision>
      <id>100149528</id>
      <parentid>99177144</parentid>
      <timestamp>2014-01-11T17:05:00Z</timestamp>
      <contributor>
        <ip>82.66.86.193</ip>
      </contributor>
      <text xml:space="preserve" bytes="7773">{{Infobox Langage de programmation
 | nom et logo                      = oui
| nom                    = '''Processing'''
| logo                   = Processing Logo Clipped.svg
| dernière version stable          = 2.0.1
| date de dernière version stable  = {{date|1|juillet|2013}}
| année                  = 2001
| auteurs                 = Ben Fry et Casey Reas
| système d'exploitation = [[Multi-plateforme]]
| licence = [[GNU General Public License|GPL]] et [[GNU Lesser General Public License|LGPL]]
| site web               = [http://processing.org/ www.processing.org]
}}
'''Processing''' (autrefois [[typographie|typographié]] '''Proce55ing''') est une librairie [[Java (langage)|java]] et un [[Environnement de développement intégré|environnement de développement]] [[logiciel libre|libre]] (sous licence [[Licence publique générale GNU|GNU GPL]]), créé par [[Benjamin Fry]] et [[Casey Reas]], deux artistes [[États-Unis|américains]]. Processing est le prolongement « multimédia » de [[Design by numbers]], l'environnement de programmation graphique développé par [[John Maeda]] au [[MIT Media Lab|Media Lab]] du [[Massachusetts Institute of Technology]]. 

Processing est tout particulièrement adapté à la création plastique et graphique interactive. 
Le logiciel fonctionne sur [[Macintosh]], [[Microsoft Windows|Windows]], [[Linux]], [[Berkeley Software Distribution|BSD]] et [[Android]]. Il est basé sur la plate-forme [[Java (langage)|Java]] — il permet d'ailleurs de programmer directement en langage Java.

Il existe également une version en [[Javascript]] de Processing, appelée [[Processing.js]], cette version pouvant être exécuté dans un environnement [[HTML 5]] ou via [[node.js]].

Les programmes réalisés avec Processing peuvent être lus par les navigateurs internet équipés du plug-in java, mais aussi sous forme d'applications indépendantes pour Windows, Linux ou Mac OS X (en réalité n'importe quelle machine disposant d'une [[Machine virtuelle Java]]).
[[Image:Processing-ide.png|thumb|300px|L'environnement de développement Processing.]]

== Philosophie ==
Le principe majeur de Processing est la simplicité, dans la mise en œuvre des programmes comme dans la syntaxe du langage. Adapté à la création graphique, Processing réclame moins d'efforts que Java pour effectuer des tâches simples telles que la modification d'une animation à intervalle régulier (qui permet des créations animées). Ses fonctionnalités sont limitées aux besoins des créateurs d'images 2D et 3D générées par programmation mais peuvent être étendues, par le biais de modules externes, à la capture d'un flux vidéo, à la génération et à la manipulation de son, à l'interfaçage des ports d'entrées-sorties, etc.

Processing s'adresse aux artistes en « arts numériques » et aux graphistes, notamment dans le domaine du [[graphisme d'information]] et dans celui du graphisme génératif. Il permet d'élaborer des sketches.

== Syntaxe ==
On peut écrire le traditionnel [[Hello world]] de cette manière :
&lt;source lang=&quot;java&quot;&gt;
void setup()
{
  println(&quot;Hello World!&quot;);
}
&lt;/source&gt;

et même ainsi, sans la moindre déclaration préliminaire :

&lt;source lang=&quot;java&quot;&gt;
  println(&quot;Hello World!&quot;);
&lt;/source&gt;

Cependant, la méthode suivante est sans doute plus typique du fonctionnement de Processing : 

&lt;source lang=&quot;java&quot;&gt;
void setup(){
  size(300, 300);
  background(0);
}

void draw(){
 size(300, 300);
 text(&quot;Bonjour monde!&quot;, width/2, height/2);
}
&lt;/source&gt; 

Les gestionnaires ''setup()'' et ''draw()'' sont deux fonctions pré-définies très importantes dans processing. La première, setup(), est exécutée une seule fois au lancement du programme. La seconde, ''draw()'' est lancée à intervalle régulier, par défaut dix fois par seconde.

Processing emploie un [[Typage fort|typage rigoureux]] et est [[sensibilité à la casse|sensible à la casse]]. La structure de ses fonctions de base (comparaisons, conditions, boucles, etc.) est familière pour les utilisateurs du C++ ou de Java.

Par exemple, une condition s'évalue ainsi :

&lt;source lang=&quot;java&quot;&gt;
if (a==1)
{
  print(&quot;ok&quot;);
}
&lt;/source&gt; 

et une boucle se construit de cette façon :

&lt;source lang=&quot;java&quot;&gt;
for(int i=0;i&lt;255;i++)
{
  print(i);
}
&lt;/source&gt;

== Proce55ing ==
{{section à sourcer}}
L'ancien nom de Processing, ''Proce55ing'', a été forgé ainsi car le [[nom de domaine]] ''Processing.org'' était pris et le site officiel a d'abord dû exister à l'adresse ''Proce55ing.org''. À présent, les auteurs de Processing disposent du nom de domaine ''Processing.org'', ils n'utilisent plus l'ancienne forme du nom et en déconseillent l'usage. Cependant, de nombreuses personnes abrègent le nom en '''p5'''.

== Extensions et projets alternatifs ==
Le projet ''[[Arduino]]'', qui se base sur ''Processing'', comme son « ancêtre », ''Wiring''&lt;ref&gt;[http://wiring.org.co/ Wiring], un environnement de programmation et de prototypage de cartes électroniques pour des sketches artistiques ou autres&lt;/ref&gt;, permet la manipulation de circuits électroniques extérieurs pour interfacer des capteurs ou des appareils électroniques divers (servomoteurs, leds…). Un autre environnement logiciel, Fritzing, a été conçu pour aider les utilisateurs au prototypage de matériel destiné à être utilisé avec ''Arduino'' et ''Processing''. Le projet ''Mobile Processing'', comme son nom l'indique, a l'ambition de porter ''Processing'' sur téléphones portables. Enfin, ''[[Processing.js]]'' est une implémentation [[JavaScript]] de Processing.
Depuis sa version 1.5.1, Processing peut produire des applications pour plate-forme [[Android]] et accéder aux capteurs spécifiques aux dispositifs mobiles (accéléromètre, GPS, etc.). Depuis la version alpha de Processing 2.0, Processing pourra aussi exporter directement du contenu au format HTML5/Javascript.

De nombreuses librairies externes peuvent être ajoutées à Processing pour accéder à des ressources telles que la vidéo, le son, la reconnaissance faciale, la caméra Kinect, les moteurs physiques, etc.

== Bibliographie ==
* ''Processing : le code informatique comme outil de création'', par Jean-Michel Géridan et Jean-Noël Lafargue, éd. Pearson 2011 {{ISBN|978-2744024535}}
* ''Design génératif - Concevoir, programmer, visualiser'', par Julia Laub, Hartmut Bohnacker, Benedikt Grob et Claudius Lazzeroni. éd. Pyramid. {{ISBN|978-2350172156}}
* ''[http://fr.flossmanuals.net/Processing/ Processing]'', ouvrage collectif libre en français / Flossmanuals
* ''Programming Interactivity'', par Joshua Noble, O'Reilly, 2009
* ''Algorithms for Visual Design Using the Processing Language'', par Kostas Terzidis, Wiley, 2009
* ''Pixels, Patterns, and Processing'', par Daniel Shiffman, Morgan Kaufmann, 2008
* ''Processing: A Programming Handbook for Visual Designers and Artists'', par Casey Reas et Ben Fry, MIT Press, 2007
* ''Visualizing Data'', par Ben Fry, O'Reilly, 2007
* ''Processing: Creative Coding and Computational Art'', par Ira Greenberg, Friends of Ed, 2007

== Voir aussi ==
* [[Processing.js]]
* [[NodeBox]] (''Processing-like'' modulaire, programmé en [[Python_(langage)|Python]])

== Notes et références ==
{{Références}}

== Liens externes ==
* {{fr}} [http://fr.flossmanuals.net/processing/ Manuel libre] de Flossmanuals
* {{fr}} [http://hyperbate.fr/dernier/?page_id=2482 Tutoriel] sur ''le Dernier blog''.
* {{en}} [http://processing.org/ Site officiel]
* {{en}} [http://www.openProcessing.org openProcessing], un dépôt (à la manière de FlickR) de programmes réalisés en langage Processing et diffusés sous licence libre.

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>qg4wdoihi6zr6l4oxc2rxklicn0se68</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Izibasic</title>
    <ns>0</ns>
    <id>293795</id>
    <revision>
      <id>99306495</id>
      <parentid>59399977</parentid>
      <timestamp>2013-12-16T19:26:21Z</timestamp>
      <contributor>
        <username>Soren56</username>
        <id>513304</id>
      </contributor>
      <text xml:space="preserve" bytes="731">'''IziBasic''' est un [[langage de programmation]] de la famille des [[BASIC]], destiné aux [[assistants personnels]] sous [[Palm OS]]. Le public visé est constitué aussi bien de programmeurs débutants ou amateurs que plus expérimentés.

IziBasic est un outil de développement de haut niveau, de type compilateur pour [[BASIC]], qui construit des applications autonomes, directement sous Palm OS, sans nécessiter l'utilisation d'un PC.

Les codes sources sont écrits en utilisant :

* soit l'application Memo qui est livrée avec toutes les machines sous [[Palm OS]],

* soit un éditeur [[Doc (informatique)|DOC]] embarqué de votre choix.


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>730hcvnsyjclg4me3730fsi2std1vph</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Stream Editor</title>
    <ns>0</ns>
    <id>468290</id>
    <revision>
      <id>100262719</id>
      <parentid>97252745</parentid>
      <timestamp>2014-01-14T22:55:48Z</timestamp>
      <contributor>
        <username>Illwieckz</username>
        <id>20228</id>
      </contributor>
      <minor/>
      <comment>/* Exemple */ le nom du caractère espace est féminin</comment>
      <text xml:space="preserve" bytes="12066">{{homonyme|Sed}}
'''sed''' (abréviation de '''S'''tream '''ED'''itor, « éditeur de flux ») est, comme [[awk]], un [[programme informatique]] permettant d'appliquer différentes transformations prédéfinies à un flux séquentiel de données textuelles. sed lit des données d'entrée ligne par ligne, modifie chaque ligne selon des règles spécifiées dans un langage propre (appelé « script sed »), puis retourne le contenu du fichier (par défaut). Bien qu'originellement écrit pour [[Unix]], par {{lien|Lee E. McMahon}} en [[1973]]/[[1974]] ([[Bell Labs]]), sed est maintenant disponible sur pratiquement tous les systèmes d'exploitation disposant d'une interface en [[ligne de commande]].

== Présentation ==
sed est souvent décrit comme un [[éditeur de texte]] non-interactif. Il diffère d'un éditeur conventionnel en ceci que la séquence de traitement des deux flux d'informations nécessaires (les données et les instructions) est inversée. Au lieu de prendre une par une les commandes d'édition pour les appliquer à l'intégralité du texte (qui doit alors être intégralement en mémoire), sed ne parcourt qu'une seule fois le fichier de texte, en appliquant l'ensemble des commandes d'édition à chaque ligne. Comme une seule ligne à la fois est présente en [[Mémoire vive|mémoire]], sed peut traiter des fichiers de taille complètement arbitraire.

== Principe de fonctionnement ==
Le jeu de commandes de sed est basé sur celui de l'éditeur [[ed (logiciel)|ed]]. En effet, la majorité des commandes fonctionne de manière similaire, malgré l'inversion du paradigme. Par exemple, la commande &lt;code&gt;25d&lt;/code&gt; signifie ''s'il s'agit de la ligne 25, alors efface-la (c'est-à-dire, ne la renvoie par vers la sortie)'', au lieu de ''va à la ligne 25 et efface-la'', telle que ed l'exécute. Les exceptions notables sont les commandes de copie et de déplacement, qui s'appliquent sur un intervalle de lignes, et qui par conséquent n'ont pas d'équivalent direct dans sed. À la place, sed introduit une [[mémoire tampon]] supplémentaire appelé ''hold space'', ainsi que des commandes pour la manipuler.

Par exemple, la commande ed pour copier la ligne 25 à la ligne 76 (&lt;code&gt;25t76&lt;/code&gt;) pourrait être codée en deux commandes distinctes dans sed (&lt;code&gt;25h;76g&lt;/code&gt;). La première mémorise la ligne dans le ''hold space'', la seconde la récupère lorsqu'il est temps.

== Utilisation ==
L'exemple suivant montre une utilisation habituelle de sed :
 sed -e 's/Ancien/Nouveau/g' nomFichierEntrée &gt; nomFichierSortie

La commande &lt;code&gt;s&lt;/code&gt; signifie ''substitute'' (« substituer »). Le drapeau &lt;code&gt;g&lt;/code&gt; signifie ''global'', ce qui indique que toutes les occurrences dans chaque ligne doivent être remplacées. Après le premier caractère &lt;code&gt;/&lt;/code&gt; est donnée une [[expressions rationnelles|expression rationnelle]] que sed doit trouver. Après le deuxième &lt;code&gt;/&lt;/code&gt; est précisée l'expression remplaçant ce qu'il a trouvé. La commande de substitution (&lt;code&gt;s///&lt;/code&gt;) est de loin la commande de sed la plus puissante et la plus fréquemment utilisée.

Une application possible de la substitution est la correction d'une faute d'orthographe récurrente, ou le remplacement de toutes les occurrences d'un sigle. Par exemple :
 sed -e 's/ficheir/fichier/g' sed.wikipedia &gt; sed.wikipedia.correct
 sed -e 's/WP/Wikipedia/g' sed.wikipedia &gt; sed.wikipedia.correct

Il n'est pas obligatoire d'utiliser « &lt;code&gt;/&lt;/code&gt; » comme délimiteur. Les caractères « &lt;code&gt;# , - .&lt;/code&gt; » (liste non exhaustive) peuvent également servir pour éviter l'accumulation d'anti-slash de « protection » rendant la syntaxe peu lisible. Les commandes suivantes sont équivalentes:
 s/\/un\/chemin\/vers/\/une\/autre\/chaine/

 s#/un/chemin/vers#/une/autre/chaine#

sed peut aussi servir à numéroter les lignes d'un fichier, supprimer les balises [[Hypertext Markup Language|HTML]] d'un texte, etc. Toutefois, sur certaines plates-formes, le langage [[Perl (langage)|Perl]] est bien souvent utilisé en remplacement de sed.

Sur Unix, sed est souvent utilisé comme [[filtre (informatique)|filtre]] dans un [[Tube Unix|tube]] :
 production_de_données | sed -e 's/x/y/'
Dans cet exemple, des données sont générées, puis elles sont modifiées à la volée en remplaçant les ''x'' par des ''y''.

Plusieurs substitutions, ou autres commandes, peuvent être regroupées dans un fichier, appelé ''script sed'' (&lt;code&gt;subst.sed&lt;/code&gt; dans l'exemple suivant), puis appliquées sur les données :
 sed -f subst.sed nomFichierEntrée &gt; nomFichierSortie

En plus des substitutions, d'autres types de traitements simples sont disponibles. Par exemple, le script suivant retire les lignes vides ou qui ne contiennent que des espaces :
 sed -e '/^ *$/d' nomFichierEntrée 
Cet exemple utilise des [[métacaractère]]s pour former des [[expressions rationnelles]] :
{| border=&quot;0&quot;  align=&quot;center&quot; style=&quot;border: 1px solid #999; background-color:#FFFFFF; width:90%;&quot;
|- align=&quot;center&quot; bgcolor=&quot;#CCCCCC&quot;
! Méta-caractère !! Correspondance
|-----
| &lt;code&gt;^&lt;/code&gt;     || correspond au début d'une ligne (juste avant le premier caractère)
|-----bgcolor=&quot;#EFEFEF&quot;
| &lt;code&gt;$&lt;/code&gt;     || correspond à la fin d'une ligne (juste après le dernier caractère)
|-----
| &lt;code&gt;.&lt;/code&gt;     || correspond à n'importe quel caractère unique
|-----bgcolor=&quot;#EFEFEF&quot;
| &lt;code&gt;*&lt;/code&gt;     || correspond à aucune ou plusieurs occurrences du caractère qui précède
|-----
| &lt;code&gt;[ ]&lt;/code&gt;   || correspond à n'importe lequel des caractères cités entre les crochets
|}

sed permet également l'utilisation des champs pour identifier certaines parties d'une chaîne de caractère. Un champ est défini par une expression rationnelle identifiée par les balises &lt;code&gt;\(&lt;/code&gt; et &lt;code&gt;\)&lt;/code&gt;, le champ peut ensuite être utilisé avec &lt;code&gt;\n&lt;/code&gt; où &lt;code&gt;n&lt;/code&gt; est le numéro du champ (le nombre de champs est limité à 9). Exemple : permuter deux champs séparés par un tiret :

 s/\(.*\)-\(.*\)/\2-\1/

Autre exemple : afficher les N derniers caractères d'une chaîne :

 s/\(.*\)\(.\{N\}\)/\2/

Deux champs sont définis : &lt;code&gt;\1&lt;/code&gt; qui contiendra les premiers caractères et &lt;code&gt;\2&lt;/code&gt; qui contiendra les N derniers. Les accolades de l'expression rationnelle qui permettent de spécifier le nombre d'occurrences &lt;code&gt;{N}&lt;/code&gt; doivent être protégées par un anti-slash.

== Programmation ==
Les structures complexes sont possibles avec sed, dans la mesure où il peut être assimilé à un [[langage de programmation]] très spécialisé mais simple. Par exemple, le contrôle du fil d'exécution peut être géré à l'aide d'étiquettes (''labels'', un &lt;code&gt;:&lt;/code&gt; suivi du nom de l'étiquette) et de l'instruction de branchement &lt;code&gt;b&lt;/code&gt;. Une instruction &lt;code&gt;b&lt;/code&gt; suivie d'un nom d'étiquette valide transférera le fil d'exécution au bloc suivant l'étiquette. Si l'étiquette n'existe pas, alors l'instruction termine le script.

sed est l'une des commandes Unix les plus anciennes permettant à la [[ligne de commande]] de traiter des fichiers de données. Il a naturellement évolué comme successeur de la célèbre commande [[grep]]. Cousin du plus jeune [[Awk]], sed permet au script shell d'effectuer des traitements puissants et très utiles. sed a probablement été l'un des tout &lt;!-- 'tout' est ici adverbe --&gt; premiers outils d'Unix à réellement encourager l'utilisation omniprésente des expressions régulières. En ce qui concerne la vitesse de traitement, sed est généralement plus rapide que [[Perl (langage)|Perl]], et sensiblement plus rapide que Awk.

sed et Awk sont souvent cités comme étant les ancêtres et les inspirateurs de [[Perl (langage)|Perl]]. En particulier, la syntaxe &lt;code&gt;s///&lt;/code&gt; de l'exemple précédent fait partie intégrante de la syntaxe de Perl.

Le langage de sed ne dispose pas de variable et ne possède qu'un [[goto]] primitif comme instruction de contrôle de flux. Toutefois, il est [[turing-complet]] [http://sed.sourceforge.net/grabbag/scripts/turing.txt].

== Extensions ==
[[GNU]] sed intègre plusieurs nouvelles fonctionnalités telles que l'édition « en place » (le fichier original est remplacé par le résultat du traitement par sed). L'édition en-place est souvent utilisée pour remplacer un script [[ed (logiciel)|ed]]. Par exemple :

 $ cat oumina.txt
 ali  all  albachmohandiss  alaska  alahoma  allo alala  talbidot  taligh
 $ sed -i 's/al/d/g' oumina.txt
 $ cat oumina.txt
 di dl dbachmohandiss daska dahoma dlo dda tdbidot tdigh

peut être utilisé à la place de
 ed fichier
 1,$ s/abc/def/
 w
 q

Il existe une version améliorée de sed, appelée '''super-sed''' ([[ssed]] [http://www.gnu.org/directory/text/editors/super-sed.html]), qui intègre des expressions rationnelles compatibles avec Perl.

== Exemple ==
L'exemple qui suit montre comment sed, qui traite habituellement chaque ligne séparément, peut supprimer les sauts de lignes des lignes dont la ligne qui suit commence par une espace.

Pour illustrer l'effet souhaité, considérons le texte suivant :
 This is my cat
  my cat's name is betty
 This is my dog
  my dog's name is frank

La commande sed donnera :
 This is my cat my cat's name is betty
 This is my dog my dog's name is frank

Voici la commande :
 sed 'N;s/\n / /g;P;D;'
qui peut se décomposer de la manière suivante (les &lt;code&gt;;&lt;/code&gt; permettent de séparer les commandes) :
 N;s/\n / /g;P;D;
 &amp;nbsp;
 N                  lit (aussi) la ligne suivante
   s/\n / /g         effectue la substitution...
    /\n /                ... d'un saut de ligne suivi d'une espace...
        / /              ... par une simple espace...
           g             ... pour toutes les occurrences
             P       retourne le résultat du traitement
               D     efface ce qui reste afin de ne pas afficher
                         la ligne suivante deux fois 
e façon plus concrète on peut regrouper les entêtes d'un fichier type mbox ( par exemple ), en le déroulant et supprimant les corps :
 #fichier nommer headers.sed
 #commande sed -nf headers.sed /var/mail/my_mbox
 :start                                #etiquette start
 /^From /{                             #addresse &quot;^From &quot;
         N;                            #ajouter une ligne au motif courant
         s/\n\(\t\| \)//;
         /.*\n$/{                      #aux l'addresses \n$
                         p             #afficher le motif courant
                         b end         #branchement sur end
                 }
         b start                       #branchement sur start
 }
 :end                                  #étiquette end

== Voir aussi ==
=== Articles connexes ===
* [[tr (Unix)]]
* [[Regexp|Expressions rationnelles]]
* [[Ed (logiciel)|Ed]]
* [[Awk]]
* [[Perl (langage)|Perl]]

=== Liens externes ===
* {{en}} [http://sed.sourceforge.net/sedfaq.html FAQ de sed]
* {{en}} [http://www.gnu.org/software/sed/manual/sed.html Page de manuel GNU de sed]
* {{en}} [http://www.openbsd.org/cgi-bin/man.cgi?query=sed Page de manuel sur OpenBSD de sed]
* [http://www.shellunix.com/sed.html Documentation succincte]
* {{en}} [http://sed.sourceforge.net Principal site de ressources sed]
* {{en}} [http://www.pement.org/sed/ sed, en particulier pour Windows/DOS]
* {{en}} [http://www.catonmat.net/blog/sed-stream-editor-cheat-sheet/ Sed antisèche]
* [http://www.commentcamarche.net/faq/sed-478 Documentation très complète]
* [http://sed.sourceforge.net/sed1line_fr.html Nombreux exemples en francais. Documentation très complète]
* [http://man2linux.blogspot.com/search/label/sed Tutoriels et explications sur le filtre sed]
* [http://www.scotchlinux.tuxfamily.org/doc/sed.php Page man de sed et illustrée]

{{Palette|GNU|Commandes Unix}}
{{Portail|logiciels libres}}

[[Catégorie:Commande Unix]]
[[Catégorie:Logiciel du projet GNU]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Éditeur de texte]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>en8q2s6har5k2y2iyjcaa4hkksw7w2u</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ArmScript</title>
    <ns>0</ns>
    <id>475326</id>
    <revision>
      <id>87647447</id>
      <parentid>76830220</parentid>
      <timestamp>2013-01-14T21:39:30Z</timestamp>
      <contributor>
        <ip>46.65.53.57</ip>
      </contributor>
      <text xml:space="preserve" bytes="1073">'''ArmScript''' est un [[langage de programmation]] [[Interprète (informatique)|interprété]] qui repose sur des commandes. Il a été créé en novembre 2005.

Il reprend les bases des autres langages (variables, etc.) mais tout le langage repose sur des fonctions prédéfinies, qui prennent des arguments qui peuvent être des variables ou des ''flags''. Un nouveau système d'arguments, les ''surplus'', rendent le [[code source]] plus compréhensible en plusieurs points.

Actuellement, le langage permet :
* des fonctions de gestion des entrées/sorties sur la sortie standard (console) et les fichiers (affichage, lecture, écriture, etc.),
* des fonctions de date (stockage puis affichage, etc.),
* des fonctions de création / affectation / destructions de variables,
* quelques fonctions système [[Linux]],
* des structures conditionnelles.

L'intérpreteur normalisé s'appelle ''arm''

À long terme, ArmScript serait le langage principal du [[système d'exploitation]] hypnOS.

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>dw0b63krdgtr4ff4qdm7eemkm1nh3j6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Inform (programmation)</title>
    <ns>0</ns>
    <id>333579</id>
    <revision>
      <id>89912826</id>
      <parentid>80456485</parentid>
      <timestamp>2013-03-13T03:43:38Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 11 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q539268]]</comment>
      <text xml:space="preserve" bytes="2481">{{Homonyme|Inform}}
'''Inform''' est un langage de [[programmation]] optimisé pour la création de jeux en [[fiction interactive]], créé en [[1993]] par [[:en:Graham Nelson|Graham Nelson]].

==Vue d'ensemble==

Le système Inform est composé d'une part d'un [[compilateur]] qui génère des fichiers lisibles par les [[machine virtuelle|machines virtuelles]] ''zmachines'' ou ''glulx'', et d'autre part de bibliothèques qui aident à la modélisation d'aventures textuelles. Les manuels disponibles pour l'apprentissage d'Inform sont uniquement en anglais, bien qu'il soit tout à fait possible de réaliser des jeux en français grâce aux traductions de certaines bibliothèques du système. Quelques jeux existent déjà en français (voir les liens externes).

Le langage inform 6 est à la fois [[Programmation procédurale | procédural]] et [[Programmation orientée objet | orienté objet]].

==Inform 7==

Le 30 avril 2006, Graham Nelson a annoncé la version beta Inform 7 sur la liste de diffusion rec.arts.int-fiction &lt;ref&gt;[http://groups.google.com/group/rec.arts.int-fiction/browse_thread/thread/f5919cf1b49badac/17791dfefeec46e0#17791dfefeec46e0 Annonce]&lt;/ref&gt;. Cette nouvelle version, qui a pris à lui et son équipe 3 ans de développement dans le plus grand secret, est décrite comme une &quot;réinvention radicale&quot;. Inform 7 est en effet un programme complet tournant sur MacOSX, Windows et Linux, et la nouvelle syntaxe utilise dorénavant du code source en [[Langue_naturelle| langue naturelle]], sous forme de règles déclaratives, permettant à un auteur d'écrire avec plus de liberté. Inform 6 est toujours utilisé en traitement sous-jacent du code transcrit par l'interface d'Inform 7.

== Notes et références ==
&lt;references /&gt;

==Liens externes==
* {{en}} [http://www.inform-fiction.org/ Site officiel]
* [http://jlpo.free.fr/ La traduction originale du système Inform 6 en français, incluant également une traduction du premier jeu d'aventure textuel.]
* [http://informfr.tuxfamily.org/ Le nouveau dépôt pour les traductions d'Inform 6 et Inform 7.]
* [http://ifiction.free.fr/ La fiction interactive en français]. On y traite surtout d'Inform du fait de sa bonne adaptation à la langue française.
* [http://www.siteduzero.com/tutoriel-3-215762-creer-des-jeux-textuels-avec-inform-7.html Un tutoriel pour apprendre Inform 7].

{{Portail|informatique|jeu vidéo}}

[[Catégorie:Fiction interactive]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>lcy4lbqdt0073il0toz9echvfytfev3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Sather</title>
    <ns>0</ns>
    <id>506270</id>
    <revision>
      <id>89976753</id>
      <parentid>74284060</parentid>
      <timestamp>2013-03-13T13:25:00Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 6 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q602012]]</comment>
      <text xml:space="preserve" bytes="2048">'''Sather''' est un [[langage de programmation]] [[orienté objet]]. Il est né aux alentours de [[1990 en informatique|1990]] à l’{{lang|en|''International Computer Science Institute''}} à l'[[Université de Californie (Berkeley)|Université de Berkeley]], développé par une équipe internationale menée par [[Steve Omohundro]]. Il supporte le [[ramasse-miettes (informatique)|ramasse-miettes]] et la [[Programmation générique|généricité]] par sous-typage.

Il vaut probablement mieux le voir comme un langage orienté objet, avec de nombreuses idées empruntées au [[Eiffel (langage)|langage Eiffel]]. Même le nom est inspiré d'Eiffel, la [[Tour Sather]] se situe à Berkeley. Sather s'inspire également d'autres langages de programmation et paradigmes : [[itérateur]]s, [[programmation par contrat]], [[classe abstraite|classes abstraites]], [[héritage multiple]], [[fonction anonyme|fonctions anonymes]], [[surcharge d'opérateur]], [[contrevariance]]. Certaines de ces caractéristiques ne sont normalement présentes que dans les langages de [[programmation fonctionnelle]].

L'implémentation originelle de Berkeley est maintenant maintenue par de nombreuses personnes, pas toutes de Berkeley, et a été adoptée par la {{lang|en|''[[Free Software Foundation]]''}}. Il existe au moins deux autres implémentations : Sather-K de l'[[université de Karlsruhe]], et Sather-W de l’{{lang|en|''[[University of Waikato]]''}}.

Sather est implémenté par un compilateur vers le [[C (langage)|langage C]], c'est-à-dire que le compilateur ne sort pas du [[code objet]] ni du [[code machine]], mais des fichiers source C en tant que [[langage intermédiaire]].

== Hello World ==

 class HELLO_WORLD is
  main is 
   #OUT+&quot;Hello World\n&quot;; 
  end; 
 end;

== Liens externes ==
* {{en}} [http://www.icsi.berkeley.edu/~sather/ Page officielle de Sather]
* {{en}} [http://www.gnu.org/software/sather/ GNU Sather]


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>b8wp6g737hus0zzyw757qs6wqzplvct</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>TTCN</title>
    <ns>0</ns>
    <id>312908</id>
    <revision>
      <id>89902598</id>
      <parentid>80975426</parentid>
      <timestamp>2013-03-13T02:01:45Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 6 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2007031]]</comment>
      <text xml:space="preserve" bytes="2669">'''TTCN''' est un [[langage de programmation]] pour les  [[test (informatique)|tests]] des [[protocole de communication|protocoles de communication]]. Une suite de tests TTCN consiste en un grand nombre de scénarios de test écrits en TTCN.

Jusqu'à la version 2, le langage est écrit d'une manière non conventionnelle dans des tables et appelé '''''t'''ree and '''t'''abular '''c'''ombined '''n'''otation'' (« notation combinée arborescente et tabulaire »). La lecture et l'écriture dans ce langage nécessitaient des éditeurs spécifiques à TTCN.
Avec la version 3, TTCN fut renommé '''''t'''esting and '''t'''est '''c'''ontrol '''n'''otation'' (« notation de tests et de contrôle de tests »). Il est plus proche des langages de programmation modernes et peut s'écrire dans un éditeur de texte traditionnel. TTCN-3 est encore plus flexible que TTCN-2, parce qu'il peut être utilisé pour tester les logiciels traditionnels, en plus des protocoles.

Pour leur exécution, toutes les versions ont besoin de compilateurs ou d'interpréteurs dédiés.

TTCN est largement utilisé par exemple par l'[[European Telecommunications Standards Institute|ETSI]] et l'[[Union internationale des télécommunications|UIT]] pour tester les protocoles de télécommunication. Les tests de conformité des standards ETSI comme [[ISDN]], [[DECT]], [[Global System for Mobile Communications|GSM]], [[Enhanced Data Rates for Global Evolution|EDGE]] ou [[Troisième génération|3G]] ont été effectués en TTCN. Depuis quelques années, il est utilisé pour tester d'autres protocoles standards comme [[Bluetooth]] et [[Internet Protocol|IP]].

L'exécution de ces tests sur des produits (par exemple, des téléphones fixes ou mobiles ou des éléments de réseau) permet de vérifier que l'implémentation du protocole de ces produits respecte les exigences définies par les standards de télécommunication.

TTCN est souvent utilisé en tandem avec [[ASN.1]].

== Voir aussi ==
===Articles connexes===
* {{en}} [http://www.etsi.org/ptcc/downloads/ptcc_ttcn1_tutorial.pdf Tutoriel TTCN-1]
* {{en}} [http://www.etsi.org/ptcc/downloads/ptcc_ttcn2.ppt Introduction à TTCN-2]
* {{en}} [http://www.etsi.org/ptcc/ptccttcn3.htm Introduction à TTCN-3]
* {{en}} [http://www.ttcn-3.org Site de la communauté TTCN-3]
* {{en}} [http://www.etsi.org/ptcc/ptccabout.htm ETSI PTCC]
* {{en}} [http://www.itu.int/ITU-T/studygroups/com07/ttcn.html Groupe d'études TTCN de l'UIT]
* {{en}} [http://www.blukaktus.com/TTCN3-QRC.html TTCN-3 Reference Card]

{{Portail|Télécommunications}}

[[Catégorie:Langage de programmation|Ttcn]]
[[Catégorie:Recommandation de l'UIT-T|Ttcn]]</text>
      <sha1>o8n3kjfczdw9pmjbt5u1w9a2s2k0qtq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>SR (programmation)</title>
    <ns>0</ns>
    <id>282726</id>
    <revision>
      <id>89890439</id>
      <parentid>65225246</parentid>
      <timestamp>2013-03-12T23:43:10Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q446168]]</comment>
      <text xml:space="preserve" bytes="341">{{ébauche|informatique}}

'''SR''' (abriéviation de '''Synchronizing Resources''') est un [[langage de programmation]] dédié à la [[programmation concurrente]].

== Lien externe ==

* {{en}} [http://www.cs.arizona.edu/sr/ Site officiel]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation|Sr (programmation)]]</text>
      <sha1>khzhbydp1o0a1okosnixl4cvclhf6pv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>BCPL</title>
    <ns>0</ns>
    <id>233267</id>
    <revision>
      <id>89866344</id>
      <parentid>86937345</parentid>
      <timestamp>2013-03-12T20:30:20Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 20 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q810009]]</comment>
      <text xml:space="preserve" bytes="4114">'''BCPL''' ('''''Basic Combined Programming Language''''') est un [[langage de programmation]] créé par [[Martin Richards]] de l'[[Université de Cambridge]] ([[1966]]) et une réponse aux difficultés rencontrées avec son prédécesseur le [[Combined Programming Language]] (CPL) durant les [[années 1960]]. Le premier [[compilateur]] fonctionnel fut écrit pendant sa visite du [[Massachusetts Institute of Technology]] (MIT) au printemps [[1967]]. Ce langage fut décrit la première fois dans un journal au ''1969 Spring Joint Computer Conference''. [[Dennis Ritchie]] développa plus tard le [[C (langage)|C]] à partir du BCPL.

== Histoire ==

BCPL est un langage de programmation propre, puissant et portable. Il rend possible l'écriture de compilateurs petits et simples. C'est notamment un choix populaire pour [[Boot|l'amorçage]] d'un système. D'après les informations reçues, quelques compilateurs peuvent fonctionner sur 16 [[Octet|ko]] seulement. Plusieurs logiciels d'exploitation ont été écrits partiellement ou complètement en BCPL (par exemple, [[TRIPOS]] ou [[AmigaOS#Kickstart|Amiga Kickstart]]). 

Une raison majeure de la portabilité de BCPL s'explique par la structure de ses compilateurs, qui sont scindés en deux parties
* Le front-end analyse la source et produit du code pour une [[machine virtuelle]] dédiée (le [[machine O-code|O-code]], O valant pour &quot;Objet&quot;)
* le back-end récupère alors ce O-code et le traduit en [[langage machine]]. 

En peu de temps cette pratique devint courante, voir le [[Pascal (langage)|Pascal]] ou [[Java (langage)|Java]], mais le compilateur BCPL de [[Martin Richards]] a été le premier à utiliser une [[machine virtuelle]] à cette fin.

Ce langage n'est pas courant, puisqu'il ne possède qu'un seul [[types de données|type de données]] : 
le type ''word'' comportant un nombre fixe de bits (nombre habituellement choisi pour s'aligner sur le langage machine). L'interprétation de toutes les valeurs est déterminée par l'opérateur utilisé lors du traitement. Pour permettre ce fonctionnement, l'exécution ne réalise pas de [[Types de données|contrôle de type]].

La [[notation hongroise]] a été développée pour aider les programmeurs à éviter les fautes de [[Types de données|type]] endémiques en BCPL.

En 1979, BCPL était supporté par au moins 25 architectures ; en 2001 il n'était plus que très peu utilisé. La conception de BCPL influença significativement le [[B (langage)|langage B]], qui lui-même influença le [[C (langage)|C]], qui est à présent le langage de choix 
pour la [[programmation système]].

La philosophie du BCPL peut être récapitulée par la citation du livre, ''BCPL, the language and its compiler'' :

:''The philosophy of BCPL is not one of the tyrant who thinks he knows best and lays down the law on what is and what is not allowed; rather, BCPL acts more as a servant offering his services to the best of his ability without complaint, even when confronted with apparent nonsense. The programmer is always assumed to know what he is doing and is not hemmed in by petty restrictions.''

== Hello World ==

C'est d'après les informations reçues le langage originel du fameux [[Hello world]].

  GET &quot;LIBHDR&quot;
  
  LET START () BE
  $(
     WRITES (&quot;Hello world!*N&quot;)
  $)

Le premier [[MUD]][http://www.mudconnect.com/mud_intro.html] fut aussi écrit en BCPL .

== Voir aussi ==
=== Liens externes ===
* [http://www.catb.org/~esr/jargon/html/B/BCPL.html The Jargon file] (en anglais)
* [http://www.cl.cam.ac.uk/users/mr/ Martin Richards Home Page] (en anglais)
* [http://www.cl.cam.ac.uk/users/mr/BCPL.html MR's BCPL distribution] (en anglais)

== Sources ==
* ''BCPL, the language and its compiler'', Richards, M and Whitby-Stevens, C. Cambridge University Press, 1980. (ISBN 0-521-28681-6)
* ''BCPL - a tool for compiler writing and systems programming'', Richards, M. Proceedings of the Spring Joint Computer Conference, vol 34, pp 557-566, 1969.

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation|Bcpl]]</text>
      <sha1>33jlj31asbckyei03vbxwmnthogbefb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ABAP</title>
    <ns>0</ns>
    <id>77553</id>
    <revision>
      <id>98214694</id>
      <parentid>89842978</parentid>
      <timestamp>2013-11-10T08:54:18Z</timestamp>
      <contributor>
        <username>FDo64</username>
        <id>1163433</id>
      </contributor>
      <minor/>
      <comment>Maintenance modèles : paramètres obsolètes ou erronés, redirections... avec [[Wikipédia:AutoWikiBrowser|AWB]]</comment>
      <text xml:space="preserve" bytes="11266">'''ABAP''' est un [[langage de programmation]] propriétaire, faisant partie de l'ensemble logiciel [[Systems, applications, and products for data processing|SAP]]. Il s'agit actuellement du langage utilisé dans la programmation des Web Application Server faisant partie de la plateforme [[Netweaver]] pour la réalisation de [[progiciel]]s.

Sa version ''ABAP/4'' est [[programmation objet|objet]], le chiffre ''4'' faisant de plus référence à son appartenance à la classe des [[L4G|langages de quatrième génération]].

== Histoire ==
L'acronyme '''ABAP''' signifiant à l'origine '''''A'''llgemeiner '''B'''erichts'''a'''ufbereitungs'''p'''rozessor '' (''processeur générique pour la préparation de rapport'') et a par la suite été anglicisé en '''A'''dvanced '''B'''usiness '''A'''pplication '''P'''rogramming.

ABAP est l'un des successeurs du [[COBOL]] et est apparu dans les [[années 1980]] dans la vague des [[L4G|langages de quatrième génération (L4G)]]. Il s'agit d'un dérivé du langage permettant de réaliser des sorties de données (appelées ''rapports'') de l'application [[Systems, applications, and products for data processing|SAP R/2]], sur lequel de nombreuses multinationales avaient bâti leur architecture d'application professionnelle. ABAP a par la suite été maintenu comme langage de référence pour les applications [[Systems, applications, and products for data processing|SAP R/3]] qui sont apparus en [[1992]].

À l'origine, ce langage comprenait le concept de ''Base de données logique'' qui devait permettre à tout utilisateur de créer lui-même les rapports dont il avait besoin. Il s'est avéré en fait que développer des programmes avec ce langage ne pouvait être fait en pratique que par des professionnels disposant d'une solide expérience.

Le langage a été par la suite étendu pour englober un modèle de données orienté objets (ABAP Objects) à partir de sa version 4.5, pour être finalement intégré comme langage d'un produit plus général appelé NetWeaver. Ce dernier utilise aussi bien ABAP que le [[Java (langage)|java]].

C'est un langage interprété.

== Composants du langage ==
''' ''Le code source'':''' il est écrit directement dans un composant de SAP appelé [[SAP Workbench]] et il sera stocké dans la base d'information de l'outil. Ce langage, de même que [[Java (langage)|java]], a besoin d'être [[compilateur|compilé]] pour pouvoir être exécuté. Cependant, à la différence de java, avant chaque utilisation d'un programme, le processeur SAP vérifie qu'il possède la dernière version du programme. Si ce n'est pas le cas, ce dernier est recompilé à la volée.

''' ''Le dictionnaire de données'' ([[DDIC]]) ''': la base de données est masquée pour le programmeur. Il y accède donc au travers de clauses faisant partie du langage lui-même. De même, la gestion du modèle de données est réalisée au travers d'un composant qui créera ou modifiera lui-même les tables de données. Ce dictionnaire de données comprend :
* Des ''' ''domaines'' '''représentant un concept élémentaire (par exemple un fournisseur, une référence article) ; chaque élément de donnée comprend au minimum un type de donnée et la spécification de son occupation mémoire.
* Des ''' ''éléments de données'' '''. Chaque élément de donnée est construit à partir d'un domaine et correspond à une utilisation particulière de ce dernier pour stocker une information, ou pour afficher un champ. Chaque élément de donnée comprend quatre descriptions textuelles qui peuvent être traduites (de manière à rendre l'application utilisable par des locuteurs de différentes langues).
* Des ''' ''structures'' et des ''tables'' '''de différents types permettant de stocker des informations, d'utiliser des types composites pour les transferts de données entre programmes et de stocker de l'information dans la base.

Un ''' ''outil de transport'' '''. À chaque modification d'un programme, celui-ci doit être ''transporté'' de l'environnement dans lequel il est créé vers un environnement de test puis dans l'environnement de production (chacun de ces environnements dispose de jeux de données distincts, il peut exister plus de trois environnements dans un système d'information donné). Cette opération est réalisée par la mise en œuvre d'un ''ordre de transport''.

== ABAP pour quoi faire ? ==
ABAP jusqu'à l'apparition de NetWeaver était la brique constituante des systèmes [[SAP R/3]]. Il permet de réaliser :

* Des ''' ''rapports'' '''. ABAP a été conçu à l'origine pour cela et comprendre des clauses générant automatiquement des rapports. Un rapport est constitué en général d'un écran de sélection de données et d'une liste affichant le résultant. Les rapports peuvent aussi être générés par un utilisateur avec [[SAP Business Report]] ou par un utilisateur simplement averti avec [[SAP Query]].

* Des ''' ''transactions'' '''. Une transaction est constituée d'une succession d'écrans appelés [[Dynpro]], chaînés entre eux par un programme contenant la logique de la transaction.

* Des ''' ''fonctions'' '''. Il s'agit de sous-programmes contenant la description d'une fonctionnalité du système. Ces fonctions peuvent être internes et permettre ainsi une plus grande cohérence du système ou permettre la communication avec d'autres systèmes. Si les systèmes externes sont aussi des systèmes [[SAP R/3]] on parlera de fonctions '''RFC''' (''Remote Function Call'') sinon la fonction sera généralement encapsulée et les appels pourront être réalisés à partir d'autres langages, on parlera alors de '''BAPI'''. Enfin, il existe d'autres variétés de fonctions et de protocole comme par exemple :
* '''tRFC''': ''transactional RFC'' qui permet de réaliser de véritables transactions entre systèmes ;
* '''qRFC''': ''queued RFC'' qui permet d'assurer la synchronisation d'appels en masse entre deux systèmes ; ce protocole permet ainsi d'assurer la consistance des données dans le module de [[datawarehouse]] BW.

* Des programmes de gestion d''''IDOCs'''. Un Idoc est un document de format unique composé de segments qui, une fois rassemblés et exécutés permettent diverses opérations au sein du système (création de commandes client, de demandes d'achats, gestion de données du personnel…). L'avantage d'un Idoc est, que de par sa composition, il peut provenir de systèmes externes pour être reconstruit dans SAP et inversement.

ABAP a évolué pour intégrer la programmation objets. Tous les concepts de la programmation objets se retrouvent dans ABAP Objects. ABAP Objects constitue une extension du langage ABAP, avec lequel il est totalement compatible : ainsi il est possible qu'un programme comporte à la fois une partie procédurale et une partie orientée objets, car le déroulement procédural du programme peut à tout moment instancier une classe puis appeler les méthodes de l'objet qu'il vient de créer.

== Exemples de programmes ABAP ==

Le grand classique:
&lt;source lang=&quot;abap&quot;&gt;
 REPORT Z_XX_TRANSACTION.
 *
 * -- Commentaire de ligne
 *
 PARAMETERS p_input(16) TYPE c DEFAULT 'Hello the World!'.
 
 *
 *-- Affichage du résultat:
 *
  WRITE: / 'L''entrée était: ', p_input.
&lt;/source&gt;

{{Boîte déroulante/début|titre=Un exemple plus commun avec recherche dans la base de données:}}
&lt;source lang=&quot;abap&quot;&gt;
 REPORT Z_XX_TRANSACTION.
 *
 * -- Declaration de données
 *
 TABLES:
  TSTC,                                                 &quot;Tables des transactions
  TSTCT.                                                &quot;Tables de leurs descriptions
 
 * Tables internes pour l'exemple
 DATA : XT_TSTC TYPE TABLE OF TSTC,
        XE_TSTC TYPE TSTC,
        XT_TSTCT TYPE TABLE OF TSTCT,
        XE_TSTCT TYPE TSTCT.
 *
 &quot; -- Début de la déclaration de l'écran de sélection
 SELECT-OPTIONS S_TCODE FOR TSTC-TCODE OBLIGATORY.
 *
 *
 *------------------
 START-OF-SELECTION.  &quot; -- Début de l'extraction des données
 *------------------
  CLEAR: XT_TSTC,
         XT_TSTCT.
  SELECT * FROM TSTC INTO TABLE XT_TSTC
    WHERE TCODE IN S_TCODE.
  IF sy-subrc EQ 0.                                      &quot; Si la sélection s'est bien passée
    SORT XT_TSTC BY TCODE.                               &quot; On trie la table par nom de transaction (facultatif)
  ENDIF.
 *
  SELECT * FROM TSTCT INTO TABLE XT_TSTCT
    WHERE TCODE IN S_TCODE
    AND   SPRSL = SY-LANGU.
  IF sy-subrc EQ 0.
    SORT XT_TSTCT BY TCODE.                              &quot; On trie la table par nom de transaction
                                                         &quot; (obligatoire pour lecture dichotomique plus bas)
  ENDIF.
 *
 *
 *------------
 TOP-OF-PAGE.
 *------------
  &quot;    -- Haut de page (sur chaque page)
  WRITE / 'Programme exemple: liste de transactions '.
  SKIP.                                                  &quot;Saut de ligne
  ULINE.                                                 &quot;Ligne continue horizontal
 *
 *                                                
 *------------
 END-OF-PAGE.
 *------------
  &quot;    -- Bas de page (sur chaque page)
  ULINE.
 *
 *
 *-----------------
 END-OF-SELECTION.  &quot;Traitement des données après sélection
 *-----------------
  LOOP AT XT_TSTC INTO XE_TSTC.                          &quot;Boucle sur les transactions
    &quot; Recherche de la description
    READ TABLE XT_TSTCT INTO XE_TSTCT
                    WITH KEY TCODE = XE_TSTC-TCODE
                             BINARY SEARCH.              &quot;Lecture dichotomique ⇒ meilleur performance
    IF SY-SUBRC NE 0. &quot; Erreur
      WRITE : /  &quot;Saut de ligne
              SY-VLINE,                                  &quot;Barre verticale
              XE_TSTC-TCODE, SY-VLINE,                   &quot;Code puis barre
              (25) '-- Pas de description --',            &quot;Largeur du texte spécifiée
              SY-VLINE.                                  &quot;Barre verticale
    ELSE.
      WRITE : /                                          &quot;Saut de ligne
              SY-VLINE,                                  &quot;Barre verticale
              XE_TSTC-TCODE, SY-VLINE,                   &quot;Code puis barre
              (25) XE_TSTCT-TTEXT,                       &quot;Description sur 25 caractères
              SY-VLINE.                                  &quot;Barre verticale
    ENDIF.
  ENDLOOP.
&lt;/source&gt;
Ce qui donne pour l'écran de selection :

[[Fichier:Ecran selection exampl ABAP.PNG]]

Et pour le résultat :

[[Fichier:Resultat example ABAP.PNG]]
{{Boîte déroulante/fin}}

=== Liens externes ===
* [http://www.sdn.sap.com SAP Developer Network]
* [http://www.sap-integration.net SAP-Integration] Une communauté française d'aide à SAP et au langage ABAP contenant des tutoriaux
* [http://saprfc.sourceforge.net Interface PHP / SAPRFC] Permet d'interfacer des applications web / PHP à SAP et d'y executer des BAPI, Modules fonctions executables à distance&lt;!-- Suggestion de présentation des annexes. Aide : [[Aide:Notes]] et références --&gt;
* [http://www.sapdev.info Sapdev] Blog de trucs et astuces en ABAP
* [http://www.sapetabap.com sapetabap] La base de connaissance dédiée à l'ABAP en français

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation|Abap]]</text>
      <sha1>6v0dycnari9ybky2g1qm5v2ghsdijm8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ABCL/1</title>
    <ns>0</ns>
    <id>344812</id>
    <revision>
      <id>89916782</id>
      <parentid>85144530</parentid>
      <timestamp>2013-03-13T04:19:38Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2818994]]</comment>
      <text xml:space="preserve" bytes="727">'''ABCL/1''' (Actor-Based Concurrent Language) est un langage à prototype et [[Programmation concurrente| concurrent]] créé en 1986 par Akinori Yonezawa, of the ''Department of Information Science'' de l'[[Université de Tokyo]].

ABCL/1 utilise des envois de messages asynchrone entre les objets afin d'implémenter la concurrence. Il nécessite [[Common Lisp]].

==Références==
* ''ABCL: An Object-Oriented Concurrent System'', A. Yonezawa ed, MIT Press 1990

==Voir aussi==
===Articles connexes===
* [[ABCL/c plus|ABCL/c+]]
* [[ABCL/R]]
* [[ABCL/R2]]

=== Liens externes ===
* [http://web.yl.is.s.u-tokyo.ac.jp/pub/abcl1/ site web]

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation|Abcl/1]]</text>
      <sha1>i42qbusj2k4v22humxthcgkpl1binto</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tcl (langage)</title>
    <ns>0</ns>
    <id>541783</id>
    <redirect title="Tool Command Language" />
    <revision>
      <id>35675892</id>
      <parentid>4662413</parentid>
      <timestamp>2008-11-28T17:24:52Z</timestamp>
      <contributor>
        <username>Hercule</username>
        <id>271994</id>
      </contributor>
      <minor/>
      <comment>[[Wikipédia:WikiProject Check Wikipedia]] : correction Plusieurs catégories sur une même ligne</comment>
      <text xml:space="preserve" bytes="145">#redirect [[Tool Command Language]] 
[[Catégorie:Langage de programmation]] 
[[Catégorie:Langage de script]] 
[[Catégorie:Langage impératif]]</text>
      <sha1>g9lkvqs6hdkvpfos0xpskltnovjvacq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tk (informatique)</title>
    <ns>0</ns>
    <id>119866</id>
    <revision>
      <id>92494409</id>
      <parentid>89818194</parentid>
      <timestamp>2013-04-26T15:44:32Z</timestamp>
      <contributor>
        <username>Bub's wikibot</username>
        <id>373944</id>
      </contributor>
      <minor/>
      <comment>Robot : Mise en forme du logo et de l'image</comment>
      <text xml:space="preserve" bytes="15685">{{Voir homonymes|TK}}
{{Infobox Logiciel
 | nom = Tk
 | logo = Tcl.svg
 | image = 
 | description = 
 | développeurs = [http://www.tcl.tk/community/coreteam/ Tcl Core Team et al.]
 | dernière version = [http://www.tcl.tk/software/tcltk/8.5.html 8.5.12]
 | date de dernière version = {{date|27|juillet|2012|en informatique}}
 | environnement = [[Multiplate-forme]]
 | langue = 
 | type = Bibliothèque d'interface graphique
 | licence = [[Licence BSD|BSD]]
 | site web = [http://www.tcl.tk/ www.tcl.tk]
}}
'''Tk''' est une [[Bibliothèque logicielle|bibliothèque]] d'[[interface graphique|interfaces graphiques]] [[multiplate-forme]]. Conçu à l'origine pour un [[langage de script]] inventé par John Ousterhout et connu sous le nom de [[Tool Command Language|Tcl]], il s'interface aujourd'hui avec d'autres langages tels que [[Perl (langage)|Perl]], [[Python (langage)|Python]], [[Ruby]], [[Lua]], [[Common Lisp]], [[Restructured Extended Executor|REXX]], [[Ada (langage)|Ada]], [[Prolog]], [[Objective Caml|OCaml]], [[R (logiciel)|R]] ou [[APL (langage)|APL]].

Tk existe aussi pour les [[Navigateur web|navigateurs]] web sous la forme d'un ''[[plugin]]'', [http://www.tcl.tk/software/plugin/ Tcl plugin], qui permet d'exécuter des tclets ([[applet]]s écrits en Tcl-Tk).

== Les ''widgets'' ==
{|
|----- valign=&quot;bottom&quot;
| width=&quot;50%&quot; |
Tk propose nativement une collection de [[Composant d'interface graphique|composants d'interface graphique]] (''widgets'') :

* &lt;code&gt;button&lt;/code&gt; ([[Bouton (informatique)|bouton poussoir]])
* &lt;code&gt;checkbutton&lt;/code&gt; ([[case à cocher]])
* &lt;code&gt;radiobutton&lt;/code&gt; ([[bouton radio]])

* &lt;code&gt;label&lt;/code&gt; (étiquette)
* &lt;code&gt;entry&lt;/code&gt; ([[Zone de texte|champ de texte]] en entrée)
* &lt;code&gt;listbox&lt;/code&gt; (liste défilante)
* &lt;code&gt;tk_optionMenu&lt;/code&gt; (liste)
* &lt;code&gt;menu&lt;/code&gt; (menu déroulant)
* &lt;code&gt;menubutton&lt;/code&gt; (menu déroulant à partir d'un bouton)

* &lt;code&gt;scale&lt;/code&gt; (curseur horizontal et vertical)
* &lt;code&gt;spinbox&lt;/code&gt; (zone de sélection numérique)
| width=&quot;50%&quot; |
* &lt;code&gt;frame&lt;/code&gt; (cadre)
* &lt;code&gt;labelframe&lt;/code&gt; (cadre avec titre)
* &lt;code&gt;scrollbar&lt;/code&gt; ([[barre de défilement]])
* &lt;code&gt;panedwindow&lt;/code&gt; (panneau coulissant)

* &lt;code&gt;text&lt;/code&gt; (conteneur hypertexte évolué)
* &lt;code&gt;canvas&lt;/code&gt; (conteneur d'objets graphiques 2D évolué)

* &lt;code&gt;tk_chooseColor&lt;/code&gt; (sélecteur de couleur)
* &lt;code&gt;tk_chooseDirectory&lt;/code&gt; (sélecteur de répertoire)
* &lt;code&gt;tk_dialog&lt;/code&gt; (boîte de dialogue modale)
* &lt;code&gt;tk_getOpenFile&lt;/code&gt; (sélecteur de fichier)
* &lt;code&gt;tk_messageBox&lt;/code&gt; (boîte de message)
* &lt;code&gt;tk_popup&lt;/code&gt; ([[menu contextuel]])
|}
Chaque ''widget'' possède des propriétés modifiables selon le type (taille, relief, couleur, contenu, état, événement).

== Gestion de la géométrie ==

Pour contrôler la dimension et agencer graphiquement les ''widgets'', il existe trois 
gestionnaires de géométrie :

* grid (dispose les ''widget'' selon une grille)
* pack (empile ou dispose côte-à-côte les ''widgets'' selon un ordre relatif)
* place (dispose les ''widgets'' de manière absolue)

Tant qu’un ''widget'' n’est pas associé à un gestionnaire de géométrie, il n’apparaît pas 
à l'écran.

== Gestion des événements ==

À la différence d'un programme en ligne de commande où l'interaction avec l'utilisateur 
est séquentielle, l'interface graphique fait intervenir la notion de ''programmation événementielle'' avec une autre logique. À tout moment, chaque ''widget'' est susceptible d'être affecté par l'action de l'utilisateur (l'événement).
Il existe des événements simples ([[Clic (informatique)|clic]] de [[Souris (informatique)|souris]] sur un bouton, saisie au [[Clavier d'ordinateur|clavier]] dans un champ) et des événements plus complexes (navigation dans un menu ou une liste 
déroulante).

À chaque ''widget'' est attaché par défaut un certain nombre de réponses automatiques à des événements. Celles-ci correspondent à une gestion des événements de bas niveau où le programmeur n'a que très peu à intervenir. Une ''boucle événementielle'' les prend en charge et les répartit.

Ensuite, par l'intermédiaire de l'option &lt;code&gt;-command&lt;/code&gt;, on peut lier un ''widget'' 
à un appel de procédure ou une commande extérieure (''callback'').
Si l'on souhaite associer à un ''widget'' une réponse particulière non définie par défaut, 
Tcl-Tk dispose d'un mécanisme très flexible grâce à la commande &lt;code&gt;bind&lt;/code&gt;.

== Exemples ==
* Un simple bouton bleu avec écriture blanche associé à une commande pour quitter.

&lt;source lang=&quot;tcl&quot;&gt;
pack [button .b -text Quitter -bg blue -fg white -command exit]
&lt;/source&gt;

* Un message d'avertissement avec &lt;code&gt;tk_messageBox&lt;/code&gt;.

&lt;source lang=&quot;tcl&quot;&gt;
tk_messageBox -message &quot;Vous devez entrer une valeur entre 1 et 100&quot; \
              -type ok -icon warning
&lt;/source&gt;

* Une horloge digitale en 6 lignes de code.

&lt;source lang=&quot;tcl&quot;&gt;
proc every {t script} {
 eval $script
 after $t [list every $t $script]
}
pack [label .horloge -textvariable time -font {Lucida 18}]
every 1000 {set ::time [clock format [clock seconds] -format %H:%M:%S]}
&lt;/source&gt;

* Affichage de caractères [[unicode]] grecs, russes, hébreux, arabes, chinois et japonais dans un ''widget'' &lt;code&gt;text&lt;/code&gt;.
&lt;source lang=&quot;tcl&quot;&gt;
package require Tk
bind all &lt;Escape&gt; {exit}

wm title . &quot;Exemple Unicode&quot;
pack [text .t -font {Arial 14}]
.t insert end &quot;
Grec\t\t \u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC\u03B3\u03BB\u03CE\u03C3\u03C3\u03B1
Russe\t\t \u0420\u0443\u0441\u0441\u043A\u0438\u0439\u044F\u0437\u044B\u043A
Hebreu\t\t \u05DD\u05D9\u05DC\u05E9\u05D5\u05E8\u05D9\u05DC\u05D9\u05D0\u05E8\u05E9\u05D9
Arabe\t\t \uFE94\uFEF4\uFE91\uFEAE\uFECC\uFEDF\uFE8D\uFE94\uFEE4\uFEE0\uFEDC\uFEDF\uFE8D
Chinois traditionnel\t \u4E2D\u570B\u7684\u6F22\u5B57
Japonais\t\t \u65E5\u672C\u8A9E\u306E\u3072\u3089\u304C\u306A,\u6F22\u5B57\u3068\u30AB\u30BF\u30AB\u30CA
&quot;
&lt;/source&gt;

* Utilisation du ''widget'' &lt;code&gt;canvas&lt;/code&gt; pour afficher un polygone dont le nombre de côtés varie interactivement à l'aide d'un curseur horizontal.
&lt;source lang=&quot;tcl&quot;&gt;
package require Tk
bind all &lt;Escape&gt; {exit}

proc AffichePolygone {w x y n} {
 set r 140; set angle [expr {6.28318/$n}]
 for {set i 0} {$i &lt; $n} {incr i} {
   lappend l [expr {cos($angle*$i)*$r+$x}] [expr {sin($angle*$i)*$r+$y}]
 }
 $w delete all
 $w create polygon $l -outline black -width 1 -fill blue
}

set edge 3
wm title . &quot;Polygone&quot;
pack [canvas .c -background white -width 320 -height 320]
pack [scale .sc -from 1 -to 12 -length 240 -resolution 1 \
           -orient horiz -bd 1 -showvalue true -variable edge \
           -command {AffichePolygone .c 160 160}]
&lt;/source&gt;

== Bibliothèque standard ==
Tk dispose d'une [[bibliothèque standard]] appelée [http://wiki.tcl.tk/13901 Tklib] (le pendant pour Tcl étant la Tcllib) exclusivement écrite en Tcl. Elle contient divers modules pour la représentation graphique de données, la gestion et l'affichage de textes, les tables, les champs d'entrée spécifiques ainsi que les [http://wiki.tcl.tk/2251 BWidget] (une bibliothèque de ''widgets'' de haut niveau).

== Histoire de Tk ==
John Ousterhout a commencé à concevoir cette [[Interface Homme-machine|IHM]] à la fin de l'année [[1988]] parallèlement au développement de Tcl. Tk a subi l'influence du système [[HyperCard]] d'[[Apple, Inc.|Apple]]. Il a été développé en [[C (langage)|C]] et était basé sur [[Xlib]] en fournissant une dizaine de composants IHM appelés ''widgets'' ([[Mot-valise|contraction]] de ''window gadget''). À cette époque, ils ne fonctionnaient que sous [[UNIX]].

La combinaison de Tcl et Tk (appelé Tcl-Tk ou Tcl/Tk) fut présentée la première fois en janvier 1991 à la ''Conférence USENIX''. Il permettait de s'affranchir de la complexité et du temps de développement accru d'une application écrite avec la bibliothèque [[Motif (bibliothèque graphique)|Motif]]. Par la suite, le développement de Tk était suffisamment découplé de celui de Tcl pour être utilisé avec d'autres langages. Les versions pour [[Microsoft Windows|Windows]] et [[Macintosh]] apparurent en 1994 sous l'impulsion des développeurs du laboratoire de [[Sun Microsystems]]. Par souci de clarté, en août 1997, la décision fut prise d'aligner les numéros de version de Tk sur ceux de Tcl.

En décembre 2007 sort Tcl-Tk 8.5. Cette version a la particularité d'inclure un moteur de thèmes qui améliore grandement l'aspect visuel de l'interface graphique rompant ainsi définitivement avec l'héritage de la bibliothèque Motif. 
En décembre 2012, sort Tcl-Tk 8.6. Un travail a été effectué sur les coordonnées des objets dans le widget &lt;code&gt;canvas&lt;/code&gt; et sur le support du format [[Portable Network Graphics|PNG]].

== Annexes ==
=== Historique des versions significatives ===

{| class=&quot;wikitable&quot;
! Version !! Date de sortie !! Principales nouveautés
|-
|| 8.6 || {{date|20|décembre|2012}} ||
* Support du format PNG avec contrôle du canal alpha
* Sélecteur de fonte qui tient compte de la plate-forme
* Déplacement absolu des objets dans le widget canvas
* Rotation de textes dans le widget canvas
* Nom de couleurs aux standards du Web
|-
|| 8.5 || {{date|20|décembre|2007}} ||
* Inclusion d'un moteur de thèmes dans le noyau
* Fontes anti-crénelées (''anti-aliasées'') sous X11
* Un widget &lt;code&gt;text&lt;/code&gt; plus fluide et harmonisé sous toutes les plates-formes
* Inclusion des onglets, des boîtes combinées, des listes arborescentes et des barres de progression
* Gestion de la transparence pour les fenêtres
|-
|| 8.4 || {{date|10|septembre|2002}} ||
* Inclusion des &lt;code&gt;spinbox&lt;/code&gt;, des panneaux coulissants (&lt;code&gt;panedwindow&lt;/code&gt;) et des cadres avec titre (&lt;code&gt;labelframe&lt;/code&gt;)
* Calage asymétrique pour la gestion de la géométrie
* Widgets composites (texte et image) pour les boutons, les labels et les menus
* Gestion de la transparence pour les images
|-
|| 8.3 || {{date|10|février|2000}} ||
* Extension des options du widget &lt;code&gt;canvas&lt;/code&gt;
* Amélioration de la prise en charge des images
* Gestion du quadruple clique de souris
|-
|| 8.1 || {{date|29|avril|1999}} ||
* Support d'Unicode
|-
|| 8.0 || {{date|18|août|1997}} ||
* Aspect natif pour les plates-formes Macintosh et Windows
* Nouvelle interface pour le widget &lt;code&gt;menu&lt;/code&gt;
* Nouveau mécanisme pour la gestion des fontes
* Inclusion d'applications externes dans Tk sous Unix
* Support des images dans le widget &lt;code&gt;text&lt;/code&gt;
* Tk fonction dans l'environnement sécurisé Safe-Tcl
* Alignement des numéros de version de Tk sur ceux de Tcl
|-
|| 4.2 || {{date|16|octobre|1996}} || 
* Réécriture du gestionnaire de géométrie (&lt;code&gt;grid&lt;/code&gt;)
* Widgets standardisés pour le sélecteur de fichier, le sélecteur de couleur et les boîtes de message
* Première version pour Windows et Macintosh
|-
|| 4.1 || {{date|21|avril|1996}} || 
* Nouveau gestionnaire de géométrie (&lt;code&gt;grid&lt;/code&gt;)
* Amélioration des performances du widget &lt;code&gt;text&lt;/code&gt;
* Première version pour Windows et Macintosh
|-
|| 4.0 || [[1er juillet]] [[1995]] || 
* Support des formats d'image XPM et GIF
* Extension des options du widget &lt;code&gt;text&lt;/code&gt;
* Meilleure compatibilité avec Motif
|-
|| 3.0 || [[décembre]] [[1992]] || 
* Export en [[Postscript]] du contenu du widget &lt;code&gt;canvas&lt;/code&gt;
* Meilleure gestion des couleurs
|-
|| 2.2 || [[août]] [[1992]] || 
* Widget &lt;code&gt;text&lt;/code&gt;
* Amélioration du widget &lt;code&gt;canvas&lt;/code&gt;
* Commande d'attente d'un événement (&lt;code&gt;tkwait&lt;/code&gt;)
* Options &lt;code&gt;-state&lt;/code&gt; pour neutraliser un widget
* Nouvelles options pour les champs en entrée
|}

=== Bibliothèques et extensions les plus utilisées ===
* [http://blt.sourceforge.net/ BLT] (ensemble de ''widgets'' pour la représentation de données)
* [http://www.tkzinc.org/ TkZinc] (canvas 2D étendu basé sur [[OpenGL]])
* [http://tclbitprint.sourceforge.net/ TkPath] (canvas au format [[Scalable Vector Graphics|SVG]])
* [http://sourceforge.net/projects/tkimg/ Img] (gestion des [[Format d'image|formats d'image]])
* [http://tktreectrl.sourceforge.net/ TkTreeCtrl] (listes [[Arborescence|arborescentes]])
* [http://www.tcl3d.org/ Tcl3d] (un conteneur 3D OpenGL)
* [http://tktable.sourceforge.net/tile/index.html Tile] (Moteur de thèmes)

=== Mots réservés ===
&lt;source lang=&quot;tcl&quot;&gt;
bell        labelframe  tk_bisque            ttk::checkbutton	ttk_vsapi
bind	    listbox	tk_chooseColor	     ttk::combobox	winfo
bindtags    loadTk      tk_chooseDirectory   ttk::entry	        wm	
bitmap      lower	tk_dialog	     ttk::frame
button	    menu	tk_focusFollowsMouse ttk::image
canvas      menubutton	tk_focusNext	     ttk::intro
checkbutton message	tk_focusPrev	     ttk::label
clipboard   option	tk_getOpenFile	     ttk::labelframe	
colors	    options	tk_getSaveFile	     ttk::menubutton	
console	    pack	tk_menuSetFocus	     ttk::notebook	
cursors	    panedwindow	tk_messageBox	     ttk::panedwindow	
destroy	    photo	tk_optionMenu	     ttk::progressbar	
entry	    place	tk_popup	     ttk::radiobutton	
event	    radiobutton	tk_setPalette	     ttk::scale
focus	    raise	tk_textCopy	     ttk::scrollbar	
font	    scale	tk_textCut	     ttk::separator	
frame	    scrollbar	tk_textPaste	     ttk::sizegrip	
grab	    selection	tkerror		     ttk::spinbox
grid	    send	tkvars		     ttk::style	
image	    spinbox	tkwait		     ttk::treeview	
keysims	    text	toplevel	     ttk::widget	
label	    tk		ttk::button	     ttk_image
&lt;/source&gt;

=== Références ===
* John K. Ousterhout, ''Hypergraphics and Hypertext in Tk'', The X Resource, Issue Five, 1993
* Cameron Laird, Kathryn Soraiz, ''Tk sets the standard'', UnixInsider 8/4/2000. [http://www.itworld.com/AppDev/1243/UIR000804tk/pfindex.html]
* Kathryn Edwards, ''The A-Z of Programming Languages: Tcl'', Computerworld, May 2009. [http://www.computerworld.com.au/article/301772/a-z_programming_languages_tcl]

=== Livres ===
* {{fr}} Bernard Desgraupes, ''Tcl/Tk - Apprentissage et Référence'', Vuibert, ISBN 2-7117-8679-X, 2002.
* {{en}} John K. Ousterhout, ''Tcl and the Tk Toolkit'', Addison-Wesley, Reading, MA, USA, ISBN 0-201-63337-X, 1994. (Draft disponible en [http://slwww.epfl.ch/SIC/SL/logiciels/TclTk/TclTk_tk3.6_doc.html ligne])
* {{en}} Brent B. Welch, ''Practical Programming in Tcl and Tk'', Prentice Hall, Upper Saddle River, NJ, USA, ISBN 0-13-038560-3, 2003. (Plusieurs chapitres en [http://www.beedub.com/book/ ligne])
* {{en}} J. Adrian Zimmer, ''Tcl/Tk for Programmers'', IEEE Computer Society, distribué par John Wiley and Sons, ISBN 0-8186-8515-8, 1998. (Plusieurs chapitres en [http://jazimmer.net/sbf/tcl/book/home.html ligne])
* {{en}} Cliff Flynt, ''Tcl/Tk for Real Programmers'', Morgan Kaufman Publishers, ISBN 0-122-61205-1, 1998.
* {{en}} Eric Foster-Johnson, ''Graphical applications with Tcl and Tk'', M&amp;T, ISBN 1-55851569-0, 1997.
* {{en}} Mark Harrison et Michael McLennan, ''Effective Tcl/Tk Programming'', Addison-Wesley, Reading, MA, USA, ISBN  0-201-63474-0, 1998.
* {{en}} Mark Harrison (ed), ''Tcl/Tk Tools'', O'Reilly Media, ISBN 1-56592-218-2, 1997.

== Voir aussi ==
=== Articles connexes ===
* [[Tkinter]]

=== Liens externes ===
{{Autres projets|wikibooks=Programmation_Python/Tkinter}}
* {{en}} [http://www.tcl.tk/ Site officiel]
* {{fr}} [http://wfr.tcl.tk/ Wiki Tcl-Tk]
* {{en}} [http://wiki.tcl.tk/ Wiki Tcl-Tk]

{{Portail|informatique|logiciels libres}}

[[Catégorie:Widget]]
[[Catégorie:Logiciel libre sous licence BSD]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de script]]
[[Catégorie:Langage impératif]]</text>
      <sha1>okvvn5xcwf6vlo0i8hn4e4bq5oj4vs5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Plankalkül</title>
    <ns>0</ns>
    <id>588408</id>
    <revision>
      <id>90007167</id>
      <parentid>86728389</parentid>
      <timestamp>2013-03-13T17:28:46Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 14 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q34280]]</comment>
      <text xml:space="preserve" bytes="3673">{{paronyme|Plan Calcul}}
{{ébauche|informatique}}

'''Plankalkül''' est un [[langage de programmation]], conçu de [[1942]] à [[1946]] par l'allemand [[Konrad Zuse]]. À l'époque, Zuse ne fit aucune communication scientifique à ce sujet, pour diverses raisons : la [[Seconde Guerre mondiale]] faisait rage, et il consacrait tous ses efforts à la conception et à la commercialisation de son ordinateur, le [[Zuse 3]].

La première publication mentionnant Plankalkül date de [[1948]]. En [[1975]], il fut décrit et implémenté à l'occasion de la thèse de J. Hohmann. Le premier compilateur, proposé par l'[[université libre de Berlin]], a été achevé en [[2000]], soit cinq ans après la mort de Zuse.

== Description ==

D'après Zuse, Plankalkül est le premier [[langage de haut niveau]].

Ce langage eut pourtant le même destin malheureux que son créateur. Ainsi il était extrêmement innovant, mais en dehors du courant principal, mondial, du développement de l'informatique. Il demeura donc très largement inconnu. 

Ce langage présente une innovation rare, voire unique, pour un langage informatique : les programmes s'écrivent en deux dimensions, de la même façon que la notation algébrique. Il est donc plus proche des traditions du plan et de la formule que de celles de la prose et du récit.

Pour ces raisons, certains le rapprochent même des langages à objet dont il serait un ancêtre, à un niveau intermédiaire entre ces derniers et l'algèbre classique.

== Exemple ==

Le programme ci-dessous calcule le maximum de trois variables en appelant la fonction ''max'':

 P1 max3 (V0[:8.0], V1[:8.0], V2[:8.0]) =&gt; R0[:8.0]
 max(V0[:8.0], V1[:8.0]) =&gt; Z1[:8.0]
 max(Z1[:8.0], V2[:8.0]) =&gt; R0[:8.0]
 END
 P2 max (V0[:8.0], V1[:8.0]) =&gt; R0[:8.0]
 V0[:8.0] =&gt; Z1[:8.0]
 (Z1[:8.0] &lt; V1[:8.0]) → V1[:8.0] =&gt; Z1[:8.0]
 Z1[:8.0] =&gt; R0[:8.0]
 END

==Références==
* Zuse, Konrad (1943), &quot;Ansätze einer Theorie des allgemeinen Rechnens unter besonderer Berücksichtigung des Aussagenkalküls und dessen Anwendung auf Relaisschaltungen&quot;, (i.e. ''Inception of a universal theory of computation with special consideration of the propositional calculus and its application to relay circuits''.) unpublished manuscript, Zuse Papers 045/018.
* Zuse, Konrad (1948/49). &quot;Über den allgemeinen Plankalkül als Mittel zur Formulierung schematisch-kombinativer Aufgaben&quot;. Arch. Math. 1, pp.&amp;nbsp;441–449, 1948/49.
*Zuse, Konrad (1972). &quot;Der Plankalkül&quot;. Gesellschaft für Mathematik und Datenverarbeitung. Nr. 63, BMBW - GMD - 63, 1972. &lt;div class=&quot;references-small&quot;&gt; &lt;!--Uses Cite.php--&gt;&lt;references/&gt; &lt;/div&gt;
* Giloi, Wolfgang, K. (1997). &quot;Konrad Zuse's Plankalkül: The First High-Level &quot;non von Neumann&quot; Programming Language&quot;. IEEE Annals of the History of Computing, vol. 19, no. 2, pp.&amp;nbsp;17–24,  April–June, 1997. [http://doi.ieeecomputersociety.org/10.1109/85.586068 (abstract)]

==Liens externes==
* [http://delivery.acm.org/10.1145/370000/361515/p678-bauer.pdf?key1=361515&amp;key2=3342588511&amp;coll=&amp;dl=acm&amp;CFID=15151515&amp;CFTOKEN=6184618 The &quot;Plankalkül&quot; of Konrad Zuse: A Forerunner of Today's Programming Languages] by [[Friedrich L. Bauer]]
* [[Raúl Rojas|Rojas, Raúl]], et al. (2000). &quot;Plankalkül: The First High-Level Programming Language and its Implementation&quot;. Institut für Informatik, Freie Universität Berlin, Technical Report B-3/2000. [http://www.zib.de/zuse/Inhalt/Programme/Plankalkuel/Plankalkuel-Report/Plankalkuel-Report.htm (full text)]
* Mauerer, Wolfgang. [http://www.bytesex.de/mauerer/pk/ &quot;Der Plankalkül von Konrad Zuse&quot;], 1998.
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>nka95vzm5gvz0gpvbjxbay769qx2m8b</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Unified Parallel C</title>
    <ns>0</ns>
    <id>627602</id>
    <revision>
      <id>90018084</id>
      <parentid>81361372</parentid>
      <timestamp>2013-03-13T18:51:43Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 6 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2095090]]</comment>
      <text xml:space="preserve" bytes="2600">'''Unified Parallel C''' ('''UPC''') est une extension du [[langage_C|langage de programmation C]] conçue pour les calculs hautes-performances sur des [[supercalculateurs]] [[calcul parallèle|parallèles]], y compris les architectures à espace d'adressage global ([[symmetric multiprocessing|SMP]] et [[Non Uniform Memory Access|NUMA]]) et celles à [[mémoire distribuée]] ([[clusters]]). Le langage définit un [[espace d'adressage]] partagé et partitionné, où les [[variable_(informatique)|variables]] peuvent être directement lues et écrites par n'importe quel [[thread (informatique)|thread]], mais chaque variable est physiquement associée avec un simple [[processeur]]. '''UPC''' utilise un modèle de calcul de type [[SPMD]] (Single Program Multiple Data) dans lequel la quantité de [[thread (informatique)|thread]] est fixée à la [[compilation (informatique)|compilation]], typiquement avec un seul thread d'exécution par processeur.

Pour [[implémenter]] le parallélisme, UPC étend la [[norme]] [[C (langage)#Normalisations|C ISO 99]] avec les concepts suivants:

* Un modèle d'[[exécution_(informatique)|exécution]] [[parallèle]] explicite
* Un espace d'adressage partagé
* Des primitives de synchronisation et un modèle de cohérence de la mémoire
* Des primitives de gestion de la mémoire

Le '''langage UPC''' est issu des expériences avec trois autres langages antérieurs qui proposaient des extensions parallèles au C ISO 99 (AC, Split-C, and Parallel C Preprocessor (PCP)). UPC n'est pas un simple agrégat de ces trois langages, mais plutôt une tentative de synthèse des meilleures caractéristiques de chacun. UPC combine les avantages du paradigme de la programmation à mémoire partagée, du contrôle de la disposition des données et des performances du paradigme de programmation par échange de messages.



==Support par les compilateurs==

UPC a été implémenté dans certains compilateurs commerciaux et de recherche, dont :
* [http://www.hp.com/go/upc HP Unified Parallel C (UPC)]
* Cray UPC
* [http://www.alphaworks.ibm.com/tech/upccompiler IBM XL UPC Compilers]
* [http://upc.lbl.gov/ Berkeley UPC]
* [http://www.intrepid.com/upc.html GCC UPC]
* [http://www.upc.mtu.edu/ Michigan Tech MuPC]

== Voir aussi ==
* [[Co-array Fortran]]
* [[High Performance Fortran]]
* [[OpenMP]]

== Liens externes ==
* [http://upc.gwu.edu/ Page principale de Unified Parallel C]
* [https://upc-wiki.lbl.gov/UPC/index.php/Main_Page Wiki UPC]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]</text>
      <sha1>bz7r403qvrd48f4l3d5dtzard6hb3zg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>LSE (langage de programmation)</title>
    <ns>0</ns>
    <id>621044</id>
    <revision>
      <id>95251910</id>
      <parentid>95251883</parentid>
      <timestamp>2013-07-24T21:36:04Z</timestamp>
      <contributor>
        <ip>184.151.114.207</ip>
      </contributor>
      <comment>Correction d'une erreur de copier-coller</comment>
      <text xml:space="preserve" bytes="6710">{{Voir homonymes|LSE}}

'''LSE''' est un [[langage de programmation]] conçu au début des [[années 1970]] par une équipe de [[École supérieure d'électricité|Supélec]] sous la direction d'Yves Noyelle. À l'instar du [[BASIC]], c'est un langage destiné aux débutants en programmation ; il possède une syntaxe francophone.

== Histoire ==
LSE est le résultat d'une évolution d'un langage plus ancien, le LSD, conçu lui aussi à [[École supérieure d'électricité|Supélec]]&lt;ref&gt;Yves Noyelle, « [http://www.epi.asso.fr/revue/54/b54p216.htm La saga du LSE et de sa famille, LSD/LSG/LST] », ''Bulletin de l'EPI'', {{n°}}54, juin 1989, {{p.}}216–233 ; extrait des actes du colloque sur l'histoire de l'informatique en France (Grenoble, 3-5 mai 1988), Philippe Chatelin (dir.), [[École nationale supérieure d'informatique et de mathématiques appliquées|ENSIMAG]], 1988, {{vol.}}2, 428{{nb p.}} {{ISBN|2-950288-70-7}} &lt;small&gt;(éd. complète)&lt;/small&gt; {{ISBN|2-950288-72-3}} &lt;small&gt;({{vol.}}2)&lt;/small&gt;.&lt;/ref&gt;.

Son sigle avait initialement deux significations :
* Langage symbolique d'enseignement,
* Langage de Sup-Élec,
auxquelles sont venues se joindre, parmi bien d'autres :
* Langage simple à enseigner, 
* Langage sans espoir.

LSE doit sa diffusion à sa mise à disposition par le [[ministère de l'Éducation nationale]] français sur les ordinateurs destinés aux lycées, jusqu'à l'arrivée des PC et compatibles, lesquels n'en ont pas été équipés. Le langage d'origine supportait les [[Procédure (informatique)|procédures]] (contrairement au BASIC)&lt;ref&gt;Stéphane Berche, « [http://www.inrp.fr/publications/edition-electronique/revue-francaise-de-pedagogie/INRP_RF056_2.pdf Comparaison LSE/BASIC] », ''[[Revue française de pédagogie]]'', {{n°}}56, juillet-septembre 1981, {{p.}}33–46.&lt;/ref&gt;. 

Le langage a été révisé en 1983 par [[Jacques Arsac]]&lt;ref name=&quot;Arsac&quot;&gt;[[Jacques Arsac]], « [http://www.epi.asso.fr/fic_pdf/b38p116.pdf LSE83] », ''Bulletin de l'EPI'', {{n°}}38, juin 1985, {{p.}}116–137.&lt;/ref&gt;, pour enfin intégrer la notion de boucle explicite indispensable à toute bonne [[programmation structurée]], et se débarrasser définitivement de son « ALLER EN » ([[goto]]). À noter, l'introduction des [[Système de gestion d'exceptions|exceptions]].

Cela n'a pas empêché LSE de sombrer rapidement dans l'oubli à la suite de l'abandon de celui-ci par le gouvernement français. Il existe cependant une petite communauté d'utilisateurs et le langage a fait l'objet d'une révision proposée par [[Luc Goulet]] (LSE2000) qui reprend en bonne partie les propositions de 1983 et inclut des améliorations. Notamment elle ajoute au langage la prise en charge de la [[programmation orientée objet]] et [[Programmation orientée aspect|aspect]]. Un [http://fr.wikibooks.org/wiki/Programmation_LSE wikilivre] décrit la proposition LSE-2000.

== Aspects politiques ? ==
En fait, les ambitions pédagogiques annoncées n'étaient pas sans arrières-pensées politiques sur la place de la France (et de son industrie informatique) dans le monde, comme le montre le texte suivant&lt;ref&gt;« [http://www.epi.asso.fr/revue/28/b28p036.htm Participation EPI au « schéma directeur »] », ''Bulletin de l'EPI'', {{n°}}28, décembre 1982.&lt;/ref&gt;, remis au ministère en 1982 par l'[[Enseignement public et informatique|EPI]] (association d'enseignants en informatique) :
{{Citation bloc|Le LSE doit être, pour l'instant, conservé.
&lt;br /&gt;Il est totalement maîtrisé dans son évolution par les enseignants eux-mêmes. Il est apte, par sa  normalisation actuelle comme par ses développements en cours (graphique) à répondre aux besoins dans tous les ordres d'enseignement. Il peut être amélioré (Bulletin {{n°}}26, {{p.}}14). Son vocabulaire et sa syntaxe française constituent un argument décisif dès lors que l'introduction de l'informatique est réalisée dans les collèges, les écoles et la formation permanente. Il est urgent de se préoccuper d'installer le LSE sur les micro-ordinateurs français destinés au grand public. (l'EPI a pris des contacts avec la [[CAMIF]] et [[Thomson (entreprise)|THOMSON]] à ce sujet).
&lt;br /&gt;Ainsi la France est en mesure de fournir un modèle complet d'introduction de l'informatique dans l'éducation. Ce modèle peut être un des éléments permettant de retrouver le rôle culturel qu'elle a perdu dans de nombreux pays (des versions du LSE en espagnol et en anglais existent déjà).}}

== Exemples de programme ==

=== Les bouteilles de bière ===

   1*CHANSON DES 99 BOUTEILLES DE BIERE
   2*PASCAL BOURGUIGNON, &lt;PJB@INFORMATIMAGO.COM&gt;, 2003
  10 FAIRE 20 POUR N←99 PAS -1 JUSQUA 1
  20 &amp;STROF(N)
  30  AFFICHER['IL EST TEMPS D’’ALLER AU MAGASIN.',/]
  40 TERMINER
 100 PROCEDURE &amp;STROF(N) LOCAL S1,S0;CHAINE S1,S0;S1←&quot;S&quot;;S0←&quot;S&quot;
 110 SI N=2 ALORS S0←&quot;&quot; SINON SI N=1 ALORS DEBUT S1←&quot;&quot;;S0←&quot;&quot; FIN
 120 AFFICHER[U,' BOUTEILLE',U,' DE BIERE SUR LE MUR.',/]N,S1
 130 AFFICHER[U,' BOUTEILLE',U,' DE BIERE.',/]N,S1
 140 AFFICHER['EN PRENDRE UNE, LA FAIRE PASSER.',/]
 150 AFFICHER[U,' BOUTEILLE',U,' DE BIERE SUR LE MUR.',2/]N-1,S0
 160 RETOUR

=== Anagramme récursive ===

Exemple extrait du papier de Jacques Arsac sur LSE83&lt;ref name=&quot;Arsac&quot; /&gt; :

 1 CHAINE A,B,BP
 5 FAIRE
 10 AFFICHER 'A = ' ;LIRE A ; SI A=’’ ALORS FINI IS
 11 AFFICHER 'B = ' ;LIRE B ; BP ← B
 12
 15 R SI LGR(A) # LGR(B) ALORS .FAUX. SINON &amp;ANAG(A,B) IS
 20 SI R ALORS AFFICHER A, 'EST ANAGRAMME DE ',BP
 21 SINON AFFICHER A, 'N’’EST PAS ANAGRAMME DE 1, BP
 22 IS
 25 BOUCLER
 29
 30 TERMINER
 31
 50 FONCTION &amp;ANAG(U,V) LOCAL J {lgr(u)=lgr(v)}
 51 SI U=' ' ALORS RESULTAT .VRAI. IS
 52 SI J = 0 ALORS RESULTAT .FAUX. IS
 54 RESULTAT &amp;ANAG(SCH(U,2, ' '),MCH(V,J,l, ' '))
 55 $&amp;ANAG
 99 $

=== Exemple LSE2000 ===
 * Quelques déclarations
 * Suivies d'une boucle
 BOOLEEN A←.VRAI.,B←.FAUX.
 ENTIER U,W,X←200
 NOMBRE PI←3.14159
 CHAINE CHN
 TABLEAU DE ENTIER TBL[3,3]
 QUEUE DE CHAINE Q[8]
 ENSEMBLE DE NOMBRE  NPREMIER←{1.0,2.0,3.0,7.0}
 
 CHN←'Salut'
 X ← SELON X ALORS 1,2,3,7,11 SINON 0
 POUR U←0 JUSQUA 2 FAIRE
     POUR W←0 JUSQUA 2 FAIRE
         TBL[U,W]←X
     BOUCLER
 BOUCLER
 TERMINER

== Références ==
{{Références}}

{{Autres projets
 |wikibooks=Programmation LSE
 |wikibooks titre=Programmation LSE
}}

== Voir aussi ==
* [[BASIC 1.0]]
* [[Plan informatique pour tous]]
* [[Linotte (langage)|Linotte]], langage de programmation en français 

=== Lien externe ===

[http://sites.google.com/site/phoenixlse2000/ Compilateur PhoenixLSE (LSE2000)]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Plan informatique pour tous]]</text>
      <sha1>l90ed8co4jfjy4eejet23n7a2wer422</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>RPL</title>
    <ns>0</ns>
    <id>360456</id>
    <revision>
      <id>101160985</id>
      <parentid>90302824</parentid>
      <timestamp>2014-02-11T12:08:54Z</timestamp>
      <contributor>
        <username>Julien1978</username>
        <id>363502</id>
      </contributor>
      <minor/>
      <comment>[[Projet:JavaScript/Notices/HotCatsMulti|HotCatsMulti]] :  + [[Catégorie:Produit lancé en 1984]]</comment>
      <text xml:space="preserve" bytes="2440">{{ébauche|informatique}}

Le '''RPL''' est un [[langage de programmation]] procédural inventé par [[Hewlett-Packard]] en [[1984]] pour ses [[calculatrice]]s ([[HP-28]], [[HP-48|48]], [[HP-49|49]])&lt;ref&gt;[http://www.hpmuseum.org/rpl.htm Description du langage RPL + programmation] Sur le site hpmuseum.org&lt;/ref&gt;.

== Origine du nom ==
Le seul nom commercial du langage est '''RPL''', et, bien que la transcription officielle d'HP soit « ''ROM-based Procedural Language'' »&lt;ref name=&quot;hpjournal&quot;&gt;[http://www.hpl.hp.com/hpjournal/pdfs/IssuePDFs/1987-08.pdf HP Journal d'août 1987], à la sortie de la première machine utilisant ce langage (page 21, colonne 2, ligne 17), c'est bien le terme &quot;ROM-Based Procedural Language&quot; qui est utilisé.&lt;/ref&gt;, de nombreux utilisateurs l'ont traduit par « ''Reverse Polish Lisp'' » (« ''Lisp polonais inversé'' ») en raison des ascendants de ce langage : le LISP et le FORTH&lt;ref name=&quot;wickes&quot;&gt;Voir la [http://www.faqs.org/faqs/hp/hp48-faq/part2/ FAQ du groupe Usenet comp.sys.hp48] : selon [[Bill Wickes]], l'un des membres de l'équipe de développement, {{lang|en|''« RPL stands for Reverse Polish Lisp. [...] RPL was never particularly intended to be a public term [...] there was an attempt to create a less whimsical name — hence &quot;ROM-based procedural language&quot; [...] The development team never calls it anything but (the initials) RPL. »''}}&lt;/ref&gt;. Il dérive des langages [[Forth (langage)|Forth]] (langage pour machines de 4{{e}} génération) et [[Lisp]], dont le nom signifie « LISt Processor ». Le RPL utilise la [[notation polonaise inverse]].

== Fonctionnement ==
Ce langage utilise une [[Pile (informatique)|pile]] et est pourvu des instructions classiques de boucles et tests. ({{lang|en|FOR NEXT, IF THEN ELSE END, CASE THEN END, WHILE REPEAT END, DO UNTIL END}}), qui permet de faire une réelle programmation, similaire au [[Basic]]

== Évolution ==
Le langage RPL/2 &lt;ref&gt;{{en}} {{fr}} [http://www.rpl2.net/ Site officiel du langage RPL/2] Sur le site rpl2.net&lt;/ref&gt; est une version améliorée du langage originel disponible sur la plupart des systèmes d'exploitation actuels : tous Unix (Posix 2001 ou SysV), OS/2 et eComStation, Windows avec Interix ou Cygwin.

== Notes et références ==
&lt;references&gt;

&lt;/references&gt;

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Calculatrice HP]]
[[Catégorie:Produit lancé en 1984]]</text>
      <sha1>nvqh84xma05ube2prkw0zumpov56nb4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PureBasic</title>
    <ns>0</ns>
    <id>239648</id>
    <revision>
      <id>101689341</id>
      <parentid>97311258</parentid>
      <timestamp>2014-03-01T09:52:16Z</timestamp>
      <contributor>
        <username>Dadu</username>
        <id>55405</id>
      </contributor>
      <comment>Suppression section historique (sans intérêt dans Wikipedia. Cf page Discussion).</comment>
      <text xml:space="preserve" bytes="7427">{{Infobox Langage de programmation
| nom = Purebasic
| logo = 
| paradigme = Impérative
| année = 2000
| auteur = Fantaisie Software
| développeur = Fred Laboureur
| dernière version stable = 5.11 (le 19 mars 2013)
| typage = 
| implémentations = 
| dialectes = 
| influencé par = BASIC
| a influencé = 
| système d'exploitation = [[Microsoft Windows|Windows]], [[Mac OS]], [[Linux]], ([[AmigaOS]] abandonnée et maintenant open source)
| licence = [[Logiciel propriétaire]]
| site web = [http://www.purebasic.com http://www.purebasic.com]
}}

'''PureBasic''' est un [[langage de programmation]] de type [[BASIC]] compilé. La version actuelle stable est la 5.11.

Plusieurs points le caractérisent :
*Simplicité : la syntaxe [[BASIC]] est simple à apprendre.
*Rapidité : les applications produites sont optimisées (taille réduite) et rapides.
*Portabilité : le code source est portable d'un [[système d'exploitation]] à l'autre. Il existe une version de PureBasic pour [[Linux]], [[Microsoft Windows|Windows]], [[AmigaOS]], et [[Mac OS]].
*Sans dépendances : le langage ainsi que les applications ne nécessitent pas d'installation obligatoire, il est donc aisé de le transporter sur une clef USB.
*Création de DLL : La création de DLL standard (Non ActiveX, utilisable dans n'importe quel autre language) est aussi aisée que la création d'exe.
*Le prix : Les mises à jour sont gratuites à vie.

PureBasic possède un jeu de commandes étendues (plus de 1400 commandes internes) auxquelles s'ajoute un accès simplifié à une grande partie de l'API du système d'exploitation. Le programmeur peut appeler les commandes de l'API de Windows, de Linux ou Mac OS directement comme s'il s'agissait des commandes internes à PureBasic, sans avoir à les déclarer au préalable (ainsi que les constantes). Rien de mieux qu'un exemple pratique pour illustrer ceci. Comparons un programme simple en visual basic avec son équivalent en PureBasic : comment obtenir le chemin du répertoire Windows.

:'''Visual Basic:'''
 Private Declare Function GetWindowsDirectory Lib &quot;kernel32&quot; Alias &quot;GetWindowsDirectoryA&quot; _
 (ByVal lpBuffer As String, ByVal nSize As Long) As Long
 Const MAX_PATH = 260
 strWindowsDirectory$ = Space$(MAX_PATH)
 lngReturn&amp; = GetWindowsDirectory(strWindowsDirectory$, MAX_PATH)

:'''PureBasic:'''
 strWindowsDirectory$ = Space(#MAX_PATH)
 lngReturn = GetWindowsDirectory_(strWindowsDirectory$, #MAX_PATH)

== Description ==
=== Caractéristiques ===
PureBasic gère de nombreux types :
* Ascii (.a)
* Byte (.b)
* Char (.c)
* Double (.d)
* Float (.f)
* Integer (.i)
* Long (.l)
* Quad (.q)
* String (.s)
* Unicode(.u)
* Word (.w)
* Structures définies par l'utilisateur

PureBasic supporte de nombreuses fonctionnalités :
* Support de l'Unicode
* Support du Thread-Safe
* Support du 64-bit (Windows, Linux, MacOs)
* Support de différents processeurs (x86, x64, PowerPC)
** 3DNOW/MMX/SSE/SSE2
* Support de l'assembleur inline (Assembleur de type FASM (Windows et Linux) et NASM (MacOs))
*  Support de différents API
** Windows : Win32
** Linux : GTK+, OpenGL, SDL, LibC
** MacOS : Carbon, Cocoa
** Tous : LibXML
* Spécifique à Windows
** Support des thèmes pour Windows XP
** Support de l'[[UAC_(Microsoft_Windows) | UAC]] de Windows Vista

PureBasic permet de créer :
* Windows
** Exécutables (.exe) de type '''GUI''' ou '''Console'''
** DLLs (.dll)
** UserLibraries via un outil externe : Tailbite ou Moebius
** Import Libraries (.lib) via un outil externe
* Linux
** Exécutables de type  '''GUI''' ou '''Console'''
** Shared Libraries (.so)
* MacOS
** Exécutables de type  '''GUI''' ou '''Console'''
** Shared Libraries ([[Mach-O|.dylib]])

=== Bibliothèques ===

Pour information, voici la liste officielle des bibliothèques PureBasic : 

:'''Bibliothèques générales'''

::2D Drawing, CDAudio, Cipher, Clipboard, Console, Database, Date, Desktop, DragDrop, File, FileSystem, Font,
::Gadget, Help, Image, ImagePlugin, Library, Linked List, Math, Memory, Menu, Misc, Movie, Network,
::OnError, Packer, Preference, Process, Printer, Requester, Scintilla, Sort, StatusBar, String, SysTray, Thread,
::Toolbar, Window, XML, Regular Expression

:'''Bibliothèques pour les jeux 2D'''

::Joystick, Keyboard, Module, Mouse, Palette, Sprite &amp; Screen, Sprite3D, Sound, SoundPlugin

:'''Bibliothèques pour les jeux 3D '''

::Engine3D, Billboard, Camera, Entity, Gadget3D, Joint, Light, Material, Mesh, Node, Node Animation, Particle, 
::Sound3D, Special Effect, Spline, Static Geometry, Terrain, Texture, Vertext Animation, Window3D

Vous pouvez bien sûr créer vos propres bibliothèques en langage C ou en assembleur, ou encore directement en PureBasic grâce à un utilitaire développé par un utilisateur de PureBasic ([http://www.inicia.es/de/elchoni/TailBite/ Tailbite]).
=== Exemples ===

Cette simple ligne de code PureBasic créera un exécutable autonome minuscule de 4,50 [[octet|Ko]] (4 608 octets) pour Windows. 

 MessageRequester(&quot;&quot;, &quot;Hello World&quot;)

Et ce qui suit est un court mais parfait exemple d'un programme fonctionnel avec PureBasic. La somme des nombres saisis par l'utilisateur est affichée automatiquement. Ce programme montre comment créer une fenêtre, des gadgets supplémentaires, ainsi que la gestion des événements et un calcul mathématique simple. Ce code compile dans un exécutable autonome de 14,5 Ko (14 848 octets) qui peut être utilisé sur n'importe quel PC équipé de Windows 95 au serveur 2003 de Windows en passant par Windows XP, Vista ou Windows 7. 

 &lt;code&gt;OpenWindow(1, 300, 300, 100, 100, &quot;Title&quot;)
   StringGadget(1, 10, 10, 50, 20, &quot;&quot;)
   StringGadget(2, 10, 40, 50, 20, &quot;&quot;)
   TextGadget(3, 80, 30, 50, 20, &quot;&quot;)
   Repeat
     Event = WaitWindowEvent()
     If Event = #PB_Event_Gadget
       FirstValue = Val(GetGadgetText(1))
       SecondValue = Val(GetGadgetText(2))
       SetGadgetText(3, Str(FirstValue + SecondValue))
     EndIf
   Until ev = #PB_Event_CloseWindow
&lt;/code&gt;

== Outils ==
=== Moebius ===
Moebius est un outil open source créé par Progi1984 qui permet de créer à partir de code Purebasic une userlib, sous Windows et Linux.
Lien : &lt;strike&gt;[http://code.google.com/p/moebius-pb/ http://code.google.com/p/moebius-pb/]&lt;/strike&gt;&lt;sup&gt;Lien HS&lt;/sup&gt;

=== Tailbite ===
Tailbite est un outil créé par ElChoni qui permet de créer à partir de code Purebasic une userlib, uniquement sous Windows.
Lien : [http://www.tailbite.com http://www.tailbite.com]

=== Visual designer ===
L'éditeur visuel de PureBasic (concepteur d'interfaces graphiques utilisateur) a été créé pour le langage de programmation PureBasic et est bien sûr développé en PureBasic.

=== MADLib ===
MADLib est une bibliothèque (UserLib) de fonctions, pour PureBasic. Elle a été compilé par l'utilitaire Tailbite. Développé par MAD.
Lien : [http://sourceforge.net/projects/madlibforpb/ http://sourceforge.net/projects/madlibforpb/]

== Références ==
{{Références}}

== Annexes ==
=== Liens externes ===
* [http://www.purebasic.com/ PureBasic : site officiel]
* [http://www.purearea.net/ PureArea.net : site indispensable]
* [http://comtois.developpez.com/tutoriels/purebasic/presentation/ Présentation de PureBasic]
* [http://www.games-creators.org/index.php/PureBasic Games-Creators portail français du jeu vidéo]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:BASIC]]</text>
      <sha1>a0jalphet7ry06p9aw626720q2kp5ux</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Syp script</title>
    <ns>0</ns>
    <id>744923</id>
    <revision>
      <id>87307758</id>
      <parentid>78755974</parentid>
      <timestamp>2013-01-05T18:47:16Z</timestamp>
      <contributor>
        <username>Sebleouf</username>
        <id>141929</id>
      </contributor>
      <minor/>
      <comment>ortho</comment>
      <text xml:space="preserve" bytes="1969">{{Voir homonymes|Syp_script}}
{{Infobox Langage de programmation
| nom                    = Syp Script
| logo                   = Syp.jpg
| année                  = [[2005]]
| auteur                 = [[gg_tk]]
| typage                 = [[Typage dynamique|Dynamique]]
| influencé par          = [[REBOL]], [[BASIC]]
| système d'exploitation = [[Multi-plate-forme]]
| license                = [[GNU GPL]]
| site web               = [http://dev.freezee.org/sypscript dev.freezee.org/sypscript]
}}

'''Syp Script''' (Simple Yet Powerful Scripting Language, soit en français langage de script simple pourtant puissant) est un nouveau langage de programmation libre (distribué sous licence GNU/GPL), facile a apprendre, et de haut niveau.

Vous pouvez créer tout type d'applications, y compris des applications consoles, multimedia et pour le réseau en un minimum de lignes de code.

L'interpréteur Syp existe pour la plupart des systèmes d'exploitation les plus utilisés (windows, Linux et autres Unix).

== Exemples ==

Un grand classique...

&lt;pre&gt;
!print &quot;Quel est votre nom?&quot;
prenom: !ask

!print (&quot;Bonjour &quot; + :prenom)
&lt;/pre&gt;

Récupération d'une page HTML

&lt;pre&gt;
code: !read_file http://dev.freezee.org/sypscript
!print :code
&lt;/pre&gt;

Récupération d'un fichier sur Internet

&lt;pre&gt;
!copy_file http://dev.freezee.org/sypscript/downloads/syp_script_0.2_src.tar.bz2 &quot;sources.tar.bz2&quot;
&lt;/pre&gt;

Exécution d'un script sur Internet (programmation distribuée)

&lt;pre&gt;
!parse_file http://dev.freezee.org/sypscript/downloads/sypgendoc.syp
&lt;/pre&gt;

== Liens externes ==

* [http://ggtk.free.fr/sypscript Site officiel]
* [http://freshmeat.net/projects/sypscript/ Syp Script sur Freshmeat]
* [http://www.programmazione.it/index.php?entity=eitem&amp;idItem=36141 Review sur programmazione.it]
* [http://dev.freezee.org/sypscript/downloads/introsypscript.pdf Cours en francais]

{{Portail|programmation informatique|logiciels libres}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ld79p2wavuih6wxwqnvxwez6yy8gfue</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Query by Example</title>
    <ns>0</ns>
    <id>215356</id>
    <revision>
      <id>99100278</id>
      <parentid>99098227</parentid>
      <timestamp>2013-12-10T20:01:38Z</timestamp>
      <contributor>
        <username>Romanc19s</username>
        <id>26084</id>
      </contributor>
      <minor/>
      <comment>[[Interface graphique]] correction homonymie</comment>
      <text xml:space="preserve" bytes="3839">[[Image:Kexi Win2000 Addressbook - Queries Countries (edit).png|thumb|L'interface QBE de [[Kexi]]]]
'''Query by Example''' (abr. '''QBE''', en français ''interrogation par l'exemple''), est un type d'[[Interface graphique|interface utilisateur]] servant à effectuer des recherches dans des [[bases de données relationnelles]]. Le principe d'une interface QBE est que l'utilisateur présente un ''exemple'' du résultat de recherche attendu - sous forme d'une matrice, puis le soumet au [[SGBD]]. Celui-ci recherchera alors toutes les données qui correspondent à cet exemple. Les tables de la base de données sont présentées à l'écran, et l'utilisateur peut les manipuler en vue de créer l'exemple&lt;ref&gt;{{en}} Gad Ariav - James Clifford,''New directions for database systems'',Intellect Books - 1986,{{ISBN|9780893913441}}&lt;/ref&gt;{{,}}&lt;ref&gt;{{en}} Yannis Vassiliou - New York University,''Human factors and interactive computer systems'',Intellect Books - 1984,{{ISBN|9780893911829}}&lt;/ref&gt;.

QBE a été inventé par [[Moshe Zloof]] pour le compte de [[International Business Machines|IBM]], en [[1977]].

== Particularités ==

Avec ce système le résultat prime sur les moyens de mise en œuvre. Avec QBE, il ne s'agit pas, pour l'utilisateur, ni le développeur, d'apprendre un langage de requêtes, mais tout simplement de définir une image de la réponse que l'on veut obtenir, pour voir figurer les données répondant à l'interrogation demandée.

Il a été inventé par [[Moshe Zloof]] pour le compte de la compagnie IBM, en [[1977]]. Commercialisé à partir de [[1978]], il a connu un certain succès grâce à son introduction au sein de la première version de [[Paradox (base de données)|Paradox]] (1.0 pour DOS) en [[1985]].

QBE est dès l'origine un langage relationnel complet intégrant la division relationnelle, opération décrite dans l'algèbre relationnelle de [[Edgar Frank Codd|Codd]] qui n'est toujours pas présente de manière simple dans les plus récentes normes SQL (SQL:2003). En revanche QBE ne permet pas la récursivité dans les requêtes, alors que la version normative SQL:1999 le permet.

==Exemple==

Voici un exemple de requête QBE et son équivalent SQL :

===Requête QBE===

 == T_CLIENT_CLI ===== CLI_NUM ============= CLI_NOM ===
                   | Check _join1!    | Check           |
                   |                  |                 |
 
 == T_COMMANDE_CDE ===== CLI_NUM =========== CDE_DATE ================= CDE_MONTANT ===
                     | _join1         |   ≥  2000-01-01, ≤2000-03-31  | SOMME &lt; 10000   |
                     |                |                             |                 |

===Requête SQL===

 SELECT CDE.CLI_NUM, CLI_NOM
 FROM   T_CLIENT_CLI CLI
        LEFT OUTER JOIN T_COMMANDE_CDE CDE
             ON  CLI.CLI_NUM = CDE.CLI_NUM
 WHERE  CDE_DATE BETWEEN DATE'2000-01-01' AND '2000-03-31'
 GROUP  BY CDE.CLI_NUM, CLI_NOM
 HAVING SUM(CDE_MONTANT) &lt; 10000

== Disponibilité ==
Les [[SGBD|systèmes de gestion de base de données]] suivant mettent à disposition une interface QBE:
* [[Ashton-Tate]] [[dBase]]
* [[Corel]] [[Paradox (base de données)|Paradox]]
* [[Microsoft Access]]
* [[FileMaker]]
* [[Kexi]]
* [[OpenOffice.org Base]]
* [[LibreOffice|LibreOffice Base]]

== Notes et références ==
&lt;references /&gt;

== Voir aussi ==
===Liens externes ===
* [http://sqlpro.developpez.com/cours/qbe/?page=sommaire Les requêtes QBE en long en large et en travers]
* [http://pages.cs.wisc.edu/~dbbook/openAccess/thirdEdition/qbe.pdf Syntaxe de QBE et des opérateurs relationnels]

{{portail|programmation informatique|bases de données}}

[[Catégorie:Grand Système IBM]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Base de données]]

[[ca:Consulta mitjançant exemple]]
[[es:Sistemas de consulta por ejemplo (multimedia)]]</text>
      <sha1>i1zk01adu35u946wy6d4lshyzkb0pwn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Combined Programming Language</title>
    <ns>0</ns>
    <id>762972</id>
    <revision>
      <id>90060454</id>
      <parentid>81720186</parentid>
      <timestamp>2013-03-14T00:34:16Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 9 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2347334]]</comment>
      <text xml:space="preserve" bytes="2149">{{Voir homonymes|CPL}}

'''CPL''' '''(Combined Programming Language)''' était un [[langage de programmation]] développé conjointement par le ''Laboratoire de Mathématiques (Mathematical Laboratory)'' de l'[[Université de Cambridge]] et l'''Unité d'Informatique (Computer Unit)'' de l'[[Université de Londres]] au cours des années [[1960]]. 

Cette collaboration est à l'origine du mot ''Combined'' dans le nom final du langage (qui était originellement ''Cambridge Programming Language''). En [[1963]] il fut mis en place sur l'[[Titan_(ordinateur)|ordinateur Titan]] de Cambridge et l'[[ordinateur Atlas]] de Londres.

Il a été grandement influencé par l'[[ALGOL|ALGOL 60]] mais, au lieu d'être extrêmement léger, élégant et simple, CPL était lourd, peu élégant, et complexe. Il était censé être bon à la fois pour la programmation scientifique (à la manière du [[FORTRAN]] et de l'[[ALGOL]]) et également pour la programmation commerciale (comme le [[COBOL]]). Il visait de cette manière un peu le même objectif que le [[PL/I|PL/1]] ou, plus tard, l'[[Ada (langage)|Ada]].

CPL s'avéra trop exigeant pour les petits ordinateurs et les technologies de compilateurs de l'époque. Des compilateurs convenables furent probablement écrits à partir de 1970, mais le langage ne fut jamais populaire et semble avoir disparu dans les années 1970.

Plus tard, un langage basé sur le CPL, nommé [[BCPL]] (pour ''Basic CPL'', mais originellement ''Bootstrap CPL''), était un langage beaucoup plus simple, visant principalement la [[programmation système]], et particulièrement l'écriture de [[compilateur]]s. BCPL mena ensuite au [[B (langage)|langage B]] puis au [[C (langage)|langage C]], qui reste dans les années 2010 l'un des langages les plus populaires.


== Liens externes ==
* {{en}} [http://comjnl.oxfordjournals.org/cgi/reprint/6/2/134.pdf &quot;The main features of CPL&quot;].  Computer Journal, volume 6, p 134 (1963) par Barron, D. W., Buxton, J. N., Hartley, D. F., Nixon, E., Strachey, C. PDF (1063 kB).

== Note ==
&lt;references /&gt;

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>987y47cpfaei3fnq7dc4hpn960k0us5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Query Management Facility</title>
    <ns>0</ns>
    <id>755392</id>
    <revision>
      <id>90057559</id>
      <parentid>62406836</parentid>
      <timestamp>2013-03-14T00:08:40Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3061763]]</comment>
      <text xml:space="preserve" bytes="245">{{Langue du titre|en}}
'''''{{lang|en|Query Management Facility}}''''', ou QMF, est un outil développé par [[IBM]] pour [[DB2]].

{{portail|programmation informatique}}

[[Catégorie:Grand Système IBM]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>e6gkhyvz46sv2p95oadawqqwl99nhc5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Restructured Extended Executor</title>
    <ns>0</ns>
    <id>103552</id>
    <revision>
      <id>99900098</id>
      <parentid>99899939</parentid>
      <timestamp>2014-01-04T17:03:51Z</timestamp>
      <contributor>
        <ip>90.32.97.251</ip>
      </contributor>
      <text xml:space="preserve" bytes="3666">'''Restructured Extended Executor''' (REXX) est un [[Langage informatique|langage]], qui a été inventé par Mike Cowlishaw, chercheur d'[[International Business Machines Corporation|IBM]]. Il s'appelait initialement REX (''R''evised ''EX''ecutor), mais le [[sigle]] était déjà déposé. [[Langage interprété]] [[Procédure (informatique)|procédural]], il est un des seuls héritiers du [[PL/I]], ou du moins de la [[syntaxe]] claire du PL/I. 

{{refnec|C'est le langage de [[Langage de script|script]] le plus utilisé sur les [[mainframe]]s d'[[International Business Machines Corporation|IBM]]}}, en particulier ''[[Machine virtuelle|VM]]/ [[Conversation Monitor System|CMS]]'', puis plus tard ''[[Multiple Virtual Storage|MVS]]/[[Time_Sharing_Option | TSO]]'' et ''[[z/OS]]''. 

Il dispose d'une version [[Open Source]], fournie en standard avec certaines distributions [[Linux]]. Les interprètes REXX, tant commerciaux qu'[[open source]], sont disponibles sur une vaste gamme de plates-formes et des [[compilateur]]s sont disponibles pour toutes les unités centrales IBM.

Sa syntaxe a été conçue dans un but essentiel de faciliter l’apprentissage et la relecture du code.

Voici par exemple un programme REXX :
&lt;pre&gt;
 do i=1 to 5
    if i=3 then say &lt;nowiki&gt;&quot;&lt;/nowiki&gt;Trois&lt;nowiki&gt;&quot;&lt;/nowiki&gt;
           else say i
 end
&lt;/pre&gt;

Son exécution donne 
&lt;pre&gt;
1
2
Trois
4
5
&lt;/pre&gt;

un autre exemple de programme REXX :
&lt;pre&gt;
 liste_mots=&quot;un deux trois quatre cinq&quot;     /* liste des 5 premiers chiffres */
 do i=1 to words(liste_mots)                /* boucler pour chacun des mots de liste_mots */ 
   say word(liste_mots,i)                   /* Afficher le &quot;i&quot;eme mot  */ 
 end                                        /* fin de la boucle */ 
&lt;/pre&gt;
qui peut s'écrire également :
&lt;pre&gt;
 liste_mots=&quot;un deux trois quatre cinq&quot;;do i=1 to words(liste_mots);say word(liste_mots,i);end
&lt;/pre&gt;
Son exécution donne 
&lt;pre&gt;
un
deux
trois
quatre
cinq
&lt;/pre&gt;
== Principes ==
# syntaxe très proche du [[PL/I]]
# usage systématique des minuscules (lecture 30&amp;nbsp;% plus rapide, selon son créateur ''Mike Cowlishaw'') ;
# caractère de fin de ligne inutile (sauf quand on veut séparer plusieurs instructions sur une même ligne) ;
# pas de mots réservés ;
# pas de {} ni de []. L'indexation se fait par un ''point qualifiant'' qui permet l'indexation numérique ou par chaîne de caractères (hash). exemples : service.3095 ou anniversaire.patron ;
# pas de pointeurs ;
# peu de parenthèses requises ;
# grammaire intuitive (voir l'exemple ci-dessus) ;
# opérations conditionnelles standards (do i=..., do forever, while / do et do until) ;
# [[système de gestion d'exceptions]] d'une utilisation très simple grâce à l'activation ''signal on ...''.
# l'instruction ''parse'' permet la décomposition de chaînes structurées en leurs éléments de base de façon plus lisible (mais aussi moins concise) que les [[expression rationnelle|expressions rationnelles]].

Il existe un compilateur Rexx qui permet d'obtenir à la fois des scripts plus stables dans le cas d'une gestion par version, une exécution plus rapide, et une certaine protection contre le vol ou les modifications intempestives du code source.

== Dérivés ==
REXX a donné deux évolutions différentes, mais restées peu utilisées car incompatibles entre elles :

* NetREXX, orienté réseau
* Object REXX, orienté objet

[http://regina-rexx.sourceforge.net/ Regina] a davantage de succès : c'est simplement la version de REXX en [[logiciel libre]].

{{Portail|informatique|programmation informatique}}

[[Catégorie:Grand Système IBM]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>jti0avuc2v9m47ya3he6k4uqskt64s3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Frame representation language</title>
    <ns>0</ns>
    <id>740258</id>
    <revision>
      <id>62406099</id>
      <parentid>27215144</parentid>
      <timestamp>2011-02-18T10:11:08Z</timestamp>
      <contributor>
        <username>Léna</username>
        <id>29802</id>
      </contributor>
      <minor/>
      <comment>Ajout rapide de {{portail}} : + programmation informatique ; avec [[Projet:JavaScript/Notices/BandeauxPortails|BandeauxPortails]]</comment>
      <text xml:space="preserve" bytes="660">{{ébauche|informatique}}
'''FRL''', pour '''Frame representation language''', est un [[langage de programmation]] inventé par [[Marvin Minsky]].

Il repose sur la structure de donnée bénéficiant d'une structure globale standardisée appelée ''frame'', modèle conçu pour représenter les connaissances et permettant la réalisation de systèmes règles-faits intimement liés, selon un principe similaire aux [[système expert|systèmes experts]], mais aussi selon le principe opposé (les données déclenchant alors les règles).

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Intelligence artificielle]]</text>
      <sha1>11ngif8zq5nrzygci5g52s9lmg9leb7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ICON</title>
    <ns>0</ns>
    <id>586605</id>
    <revision>
      <id>90008231</id>
      <parentid>82881887</parentid>
      <timestamp>2013-03-13T17:35:49Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 12 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1156474]]</comment>
      <text xml:space="preserve" bytes="2842">'''Icon''' est associé à un langage de programmation de haut niveau découlant des langages [[SNOBOL]]-4, CLU et C (K&amp;R).
C'est un langage impératif et procédural, dont la syntaxe ressemble aux langages [[C (langage)|C]] et [[Pascal (langage)]].

== Histoire ==
Icon fut créé en 1980 par Griswold (Université d'Arizona).
L'évolution d'Icon continue, sa version est actuellement la 9.
Son successeur est Unicon crée à l'Université du Nevada, qui intègre en plus une couche objet, une interface plus complète avec Unix et une interface avec [[Structured Query Language|SQL]].

== Exemples de code ==
Commençons par le classique ''[[Hello world]]'' :

    # Helloworld
    procedure main()
      write(&quot;Hello World !&quot;)
    end


Voici un exemple de programme Icon qui lit en entrée un fichier et affiche sur la sortie standard le fichier avec les lignes numérotées :

    # Ceci est un commentaire
    procedure main(args)
        fichier := &amp;input
        fichier := open( args[1] ) | stop(&quot;Erreur d'ouverture de fichier&quot;)
        numerote_ligne(fichier)
    end
    procedure numerote_ligne(fichier)
        compte := 0
        while ligne := read(fichier) do
            writes(compte +:= 1, &quot; &quot;, ligne, &quot;\n&quot;)    
    end

== Concepts ==
ICON est un langage de haut niveau, ce qui signifie qu'il permet au programmeur d'utiliser des concepts plutôt éloignés du fonctionnement réel d'une machine. De ce fait, il propose différents mécanismes très évolués comme les générateurs ou encore l'évaluation dirigée par le but.

Les '''générateurs''' permettent, à partir d'une expression, de fournir une suite de valeurs. Par exemple :
    every i:= (1 to 3) | (3 to 1 by -1) do ...
va nous permettre de faire varier ''i'' de 1 à 3 puis de 3 à 1. Ou encore
    if (x | y) = (3 | 5) then ...
permet de tester si l'une des variables ''x'' ou ''y'' a la valeur 3 ou 5

Le mécanisme de '''l'évaluation dirigée par le but''' permet de lancer une série d'opérations répétitives, sans se soucier du cas d'arrêt. Par exemple dans le cas où nous souhaiterions afficher toutes les valeurs d'un tableau ''tab'', nous ferions :
    every write(!tab)

ICON permet certaines constructions, souvent plus connues des langages fonctionnels, mais néanmoins fort pratiques :
    write( case i of {
      0       : &quot;parfait&quot;
      1|-1    : &quot;pas loin&quot;
      default : &quot;loin...&quot;
    })

Voici un autre exemple pour montrer la puissance des différents opérateurs existants dans le cas du mélange d'une tableau :
    every 1 to *tab do
      ?tab :=: ?tab

== Liens externes ==
* {{en}} ''[http://www.cs.arizona.edu/icon/ Site officiel]''
* {{fr}} ''[http://www.linux-france.org/article/lgazette-fr/issue-27/lg-27-4.html petit aperçu d'Icon]''

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ntdw2zyzk3xoxcuopj9qhotnx2qixpb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Assembleur</title>
    <ns>0</ns>
    <id>7941</id>
    <revision>
      <id>101781793</id>
      <parentid>101023083</parentid>
      <timestamp>2014-03-04T14:42:42Z</timestamp>
      <contributor>
        <ip>213.41.72.26</ip>
      </contributor>
      <comment>/* Afficher Bonjour */</comment>
      <text xml:space="preserve" bytes="19785">{{autre4|le langage d'assemblage|le programme produisant un exécutable à partir d'un source écrit dans ce langage|Programme assembleur}}
{{autre|le métier de fabrication des ordinateurs|Assembleur d'ordinateur}}

Un '''langage d'assemblage''' ou '''langage assembleur''' est, en [[programmation informatique]], un [[langage de bas niveau]] qui représente le [[langage machine]] sous une forme lisible par un humain. Les combinaisons de [[bit]]s du langage machine sont représentées par des symboles dits « [[mnémonique]]s » (du grec ''mnêmonikos'', relatif à la [[Mémoire (informatique)|mémoire]]), c'est-à-dire faciles à retenir. Le [[programme assembleur]] convertit ces mnémoniques en langage machine en vue de créer par exemple un [[fichier objet]] ou un  [[fichier exécutable]].

Dans la pratique courante, le même terme ''assembleur'' est utilisé à la fois pour désigner le langage d'assemblage et le programme assembleur qui le traduit. On parle ainsi de « programmation en assembleur ».

== Histoire ==
{{...}}
[[Fichier:IBM1620SPSpunchcard.agr.jpg|thumb||Carte formatée pour être perforée pour l'assembleur de l'IBM 1620.|alt=La carte fait apparaître plusieurs zones de colonne pour correctement séparer le numéro de ligne, l'étiquette ou label, l'instruction et les opérandes.]]

Les programmes de l'EDSAC (1949), premier calculateur à programmes enregistrés, étaient rédigés en utilisant des mnémoniques alphabétiques d'une lettre pour chaque instruction. La traduction était alors faite à la main par les programmeurs, une opération longue, fastidieuse et entachée d'erreurs.

Le premier programme assembleur a été écrit par Nathaniel Rochester pour l'IBM 701 (le premier ordinateur commercialisé par IBM) en 1954.

Les langages d'assemblages ont éliminé une grande partie des erreurs commises par les programmeurs de la première génération d'ordinateurs, en les dispensant de mémoriser les codes numériques des instructions et de faire des calculs d'adresses. La programmation en assembleur était alors utilisée pour écrire toutes sortes de programmes.

Dans les années 1970-80, l'utilisation de l'assembleur pour écrire des applications a été très largement supplantée par l'emploi de langages de programmation de haut niveau : FORTRAN, COBOL, PL/I, etc.

Les systèmes d'exploitations ont été écrits en langage d'assemblage jusqu'à l'introduction de MCP de Burroughs, en 1961, qui était écrit en ESPOL, un dialecte d'Algol.

L'assembleur est revenu quelque peu en faveur sur les premiers micro-ordinateurs, où les caractéristiques techniques (taille mémoire réduite, puissance de calcul faible, architecture spécifique de la mémoire…) imposaient de fortes contraintes, auxquelles s'ajoute un facteur psychologique important, l'attitude « hobbyiste » des premiers utilisateurs de micro-ordinateurs, qui ne se satisfaisaient pas de la lenteur des programmes écrits avec le BASIC interprété généralement fourni avec l'ordinateur.

Des gros programmes ont été écrits entièrement en assembleur pour les micro-ordinateurs, comme le système d'exploitation DOS de l'IBM PC (environ 4000 lignes de code), et la tableur Lotus 1-2-3 (son rival Multiplan, qui existait déjà sous CP/M, était écrit en C). Dans les années 1990, c'était aussi le cas pour la plupart des jeux pour consoles vidéo.

== Particularités de l'assembleur ==
=== Un langage spécifique à chaque processeur ===
Le [[langage machine]] est le seul langage qu'un [[processeur]] puisse exécuter. Or chaque famille de processeurs utilise un [[jeu d'instructions]] différent.

Par exemple, un processeur de la famille [[x86]] reconnaît une instruction du type
 10110000 01100001
En langage assembleur, cette instruction est représentée par un équivalent plus facile à comprendre pour le programmeur :
&lt;source lang=&quot;asm&quot;&gt;
  movb $0x61,%al
&lt;/source&gt;

(10110000 = movb %al&lt;br /&gt;
01100001 = $0x61)

Ce qui signifie : « écrire le nombre 97 (la valeur est donnée en [[hexadécimal]] : 61{{ind|16}} = 97{{ind|10}}) dans le [[registre (informatique)|registre]] AL ».

Ainsi, le langage assembleur, représentation exacte du langage machine, est spécifique à chaque [[architecture de processeur]]. De plus, plusieurs groupes de mnémoniques ou de syntaxes de langage assembleur peuvent exister pour un seul ensemble d'instructions, créant ainsi des [[macro-instruction]]s.

=== Désassemblage ===
La transformation du ''code assembleur'' en langage machine est accomplie par un [[Programme (informatique)|programme]] nommé [[Programme Assembleur|assembleur]]. L'[[Rétroingénierie|opération inverse]], à savoir retrouver l'assembleur équivalent à un morceau de code machine, porte un nom : il s'agit de ''désassemblage''.

Contrairement à ce que l'on pourrait penser, il n'y a pas toujours de correspondance un à un (une [[bijection]]) entre le code assembleur et le langage machine. Sur certains processeurs, le désassemblage est donc impossible à réaliser de façon certaine. L'impossibilité d'un désassemblage peut avoir diverses raisons : usage de code auto-modifiant, instructions de taille variables, impossibilité de faire la différence entre code et données, etc.

Qui plus est, de nombreux éléments présents dans un code assembleur sont perdus lors de sa traduction en langage machine. Lors de la création du code en assembleur, le programmeur peut affecter des noms aux positions en mémoire, [[Commentaire (informatique)|commenter son code]], utiliser des macro-instructions ou utiliser du code généré sous conditions au moment de l'assemblage. Tous ces éléments sont réduits lors de l’assemblage à ce qui est strictement nécessaire pour la machine et n'apparaissent donc pas clairement lors du désassemblage : par exemple, une position en mémoire n’est repérée que par son adresse numérique ou par un [[offset]].

=== Instructions machine ===
Certaines opérations fondamentales sont disponibles dans la plupart des jeux d'instructions.
* déplacement dans la mémoire :
** chargement d'une valeur dans un registre ;
** déplacement d'une valeur depuis un emplacement mémoire dans un registre, et inversement ;
* calcul :
** [[addition]], ou [[soustraction]] des valeurs de deux registres et chargement du résultat dans un registre ;
** combinaison de valeurs de deux registres suivant une opération [[Algèbre de Boole (logique)|booléenne]] (ou opération bit à bit) ;
* modification du déroulement du programme :
** saut à un autre emplacement dans le programme (normalement, les instructions sont exécutées séquentiellement, les unes après les autres) ;
** saut à un autre emplacement, mais après avoir sauvegardé l'instruction suivante afin de pouvoir y revenir (point de retour) ;
** retour au dernier point de retour ;
* comparaison :
** comparer les valeurs de deux registres.

Et on trouve des instructions spécifiques avec une ou quelques instructions pour des opérations qui auraient dû en prendre beaucoup. Exemples :
* déplacement de grands blocs de [[Mémoire (informatique)|mémoire]] ;
* [[multiplication]], [[division]] ;
* [[arithmétique]] lourde ([[sinus (mathématiques)|sinus]], [[cosinus]], [[racine carrée]], opérations sur des [[vecteur]]s) ;
* application d'une opération simple (par exemple, une addition) à un ensemble de données par l'intermédiaire des extensions [[MMX (processeur)|MMX]] ou [[Streaming SIMD Extensions|SSE]] des nouveaux processeurs.

=== Directives du langage assembleur ===
En plus de coder les instructions machine, les langages assembleur ont des [[directive (Préprocesseur)|directives]] supplémentaires pour assembler des blocs de données et affecter des [[Adressage mémoire|adresses]] aux instructions en définissant des étiquettes ou labels.

Ils sont capables de définir des expressions symboliques qui sont évaluées à chaque assemblage, rendant le code encore plus facile à lire et à comprendre.

Ils ont habituellement un [[Macro-définition|langage macro]] intégré pour faciliter la génération de codes ou de blocs de données complexes.

== Exemples simples ==
Voici quelques exemples simples :
* en syntaxe [[AT&amp;T (assembleur)|AT&amp;T]] (écrits pour l'[[Programme assembleur|assembleur]] [[GNU]] (GAS) pour [[Linux]]) ;
* utilisant le jeu d'instructions [[i386]] ;
* à utiliser comme suit :
 $ gcc foo.S -c -o foo.o
 $ ld foo.o -o foo
 $ ./foo

=== Afficher Bonjour ===
(les commentaires se trouvent après les points-virgule)

&lt;source lang=&quot;asm&quot;&gt;

str:
 .ascii &quot;Bonjour\n&quot;
 .global _start

_start:
movl $4, %eax
movl $1, %ebx
movl $str, %ecx
movl $8, %edx
int $0x80
movl $1, %eax
movl $0, %ebx
int $0x80

;Compilation:
;as code.s -o code.o
;ld code.o -o code

;Execution:
;./code
&lt;/source&gt;

=== Lire le clavier (16 caractères max) puis l'afficher ===
&lt;source lang=&quot;asm&quot;&gt;
# define N 16

         .global _start

         .comm   BUFF    , N

_start: mov     $3      , %eax
        mov     $0      , %ebx
        mov     $BUFF   , %ecx
        mov     $N      , %edx
        int     $0x80

        mov     %eax    , %edx
        mov     $4      , %eax
        mov     $1      , %ebx
        mov     $BUFF   , %ecx
        int     $0x80

        mov     $1      , %eax
        mov     $0      , %ebx
        int     $0x80
&lt;/source&gt;

== Exemples simples, syntaxe [[Intel]] [[x86]] ==
Voici les mêmes exemples, avec quelques différences :
* en syntaxe [[Intel]] [[x86]], écrit pour l'assembleur [[NASM]] ;
* utilisant le jeu d'instructions [[i386]] ;
* à utiliser comme suit:
 $ nasm -f elf foo.asm
 $ ld foo.o -o foo
 $ ./foo

=== Afficher Bonjour ===
(les commentaires se trouvent après les points-virgule)

&lt;source lang=&quot;asm&quot;&gt;
section .data    ; Variables initialisées
        Buffer:           db 'Bonjour', 10    ; En ascii, 10 = '\n'. La virgule sert à concaténer les chaines
        BufferSize:     equ $-Buffer    ; Taille de la chaine

section .text    ; Le code source est écrit dans cette section
        global _start     ; Définition de l'entrée du programme

_start:    ; Entrée du programme

        mov eax, 4    ; Appel de sys_write
        mov ebx, 1    ; Sortie standard STDOUT
        mov ecx, Buffer    ; Chaine à afficher
        mov edx, BufferSize    ; Taille de la chaine
        int 80h    ; Interruption du kernel

        mov eax, 1    ; Appel de sys_exit
        mov ebx, 0    ; Code de retour
        int 80h    ; Interruption du kernel
&lt;/source&gt;

=== Lire le clavier (64 caractères max) puis l'afficher ===
&lt;source lang=&quot;asm&quot;&gt;
section .bss                                    ; Section des variables non-initialisées
        Buffer:   resb 64                       ; Réservation de 64 blocs (octets ?) mémoire pour la variable où sera stockée l'entrée de l'utilisateur
        BufferSize:         equ $-Buffer        ; taille de cette variable

section .text                                   ; Section du code source
        global _start

 _start:                                        ; Entrée du programme

        mov eax, 3                              ; Appel de sys_read
        mov ebx, 0                              ; Entrée standard STDIN
        mov ecx, Buffer                         ; Stockage de l'entrée de l'utilisateur
        mov edx, BufferSize                     ; Taille maximale
        int 80h                                 ; Interruption du kernel

        mov eax, 4                              ; Appel de sys_write
        mov ebx, 1                              ; Sortie standard STDOUT
        mov ecx, Buffer                         ; Chaine à afficher
        mov edx, BufferSize                     ; Taille de la chaine
        int 80h                                 ; Interruption du kernel

        mov eax, 1                              ; Appel de sys_exit
        mov ebx, 0                              ; Code de retour
        int 80h                                 ; Interruption du kernel
&lt;/source&gt;

== Usage du langage assembleur ==
Il y a des débats sur l'utilité du langage assembleur. Dans beaucoup de cas, des [[compilateur]]s-[[Optimisation de code|optimiseurs]] peuvent transformer du [[langage de haut niveau]] en un code qui tourne aussi efficacement qu'un code assembleur écrit à la main par un très bon programmeur, tout en restant beaucoup plus facile, rapide (et donc moins coûteux) à écrire, à lire et à maintenir.

L'efficacité était déjà une préoccupation dans les années 1950, on en trouve trace dans le manuel du langage FORTRAN (sorti en 1956) pour l'ordinateur IBM 704:

''     Object programs produced by Fortran will be nearly as efficient as those written by good programmers.''

Les compilateurs ayant entre-temps fait d'énormes progrès, il est donc évident que l'immense majorité des programmes sont maintenant écrits en langages de haut niveau pour des raisons économiques, le surcoût de programmation l'emportant très largement sur le gain résultant de l'amélioration espérée des performances.

Cependant, il reste quelques cas très spécifiques où l'utilisation de l'assembleur se justifie encore :
# quelques calculs complexes écrits directement en assembleur, en particulier sur des [[Parallélisme (informatique)|machines massivement parallèles]], seront plus rapides, les compilateurs n'étant pas assez évolués pour tirer parti des spécificités de ces architectures ;
# certaines routines (''[[Pilote informatique|drivers]]'') sont parfois plus simples à écrire en langage de bas niveau ;
# des tâches très dépendantes du système, exécutées dans l'espace mémoire du [[système d'exploitation]] sont parfois difficiles, voire impossibles à écrire dans un langage de haut niveau. Par exemple, les instructions assembleur qui permettent à [[Windows]] de gérer le changement de tâche (LGDT et LLDT) sur microprocesseur i386 et suivants ne peuvent pas être émulées ou générées par un langage évolué. Il faut nécessairement les coder dans un court sous-programme assembleur qui sera appelé à partir d'un programme écrit en langage évolué.

Certains compilateurs transforment, ''lorsque leur option d'optimisation la plus haute n'est pas activée'', des programmes écrits en langage de haut niveau en code assembleur, chaque instruction de haut niveau se traduisant en une série d'instructions assembleur rigoureusement équivalentes et utilisant les mêmes symboles ; cela permet de voir le code dans une optique de [[Bug (informatique)#D.C3.A9bogage|débogage]] et de ''[[Profilage de code|profilage]]'', ce qui permet de gagner parfois beaucoup plus de temps en remaniant un [[algorithme]]. En aucun cas ces techniques ne peuvent être conservées pour l'optimisation finale.

La programmation des  [[système embarqué|systèmes embarqués]], souvent à base de [[microcontrôleur]]s, est une « niche » traditionnelle pour la programmation en assembleur. En effet ces systèmes sont souvent très limités en [[Ressource (informatique)#Autres types de ressources|ressources]] (par exemple un  microcontrôleur [[PIC 16F84 de Microchip|PIC 16F84]] est limité à 1024 instructions de 14 bits, et sa mémoire vive contient {{unité|136|octets}}). et requièrent donc une programmation de bas-niveau très optimisée pour en exploiter les possibilités. Toutefois, l'évolution du matériel fait que les composants de ces systèmes deviennent de plus en plus puissants à un coût et à une consommation électrique constants, l'investissement dans une programmation « tout assembleur » beaucoup plus coûteuse en heures de travail devient alors un non-sens en termes d'efforts. Typiquement, la programmation en assembleur est beaucoup plus longue, plus délicate (car le programmeur doit prendre en compte tous les micro-détails du développement dont il s'abstient en langage évolué) et donc considérablement plus coûteuse que la programmation en langage de haut niveau. Il ne faut donc la réserver qu'aux situations pour lesquelles on ne peut pas faire autrement.

== Macro-assembleur ==
Beaucoup d'assembleurs gèrent un langage de [[Macro-définition|macros]]. Il s'agit de regrouper plusieurs instructions afin d'avoir un enchaînement plus logique et moins fastidieux.&lt;br /&gt;
Par exemple (en assembleur Microsoft [[MASM]]) :&lt;br /&gt;
&lt;source lang=&quot;asm&quot;&gt;
  putchar Macro   car          ; Prototype de la macro
          ifdef   car          ; si car est défini
          mov     dl,car       ;   le mettre dans dl
          endif
          mov     ah,2         ; ah=2 : fonction &quot;putchar&quot; en DOS
          int     21h          ; appel au DOS
          endm                 ; fin macro
&lt;/source&gt;
est une macro qui affiche un caractère sous [[MS-DOS]]. On l'utilisera par exemple ainsi :&lt;br /&gt;
&lt;source lang=&quot;asm&quot;&gt;
        putchar &quot;X&quot;
&lt;/source&gt;
Et cela générera :
&lt;source lang=&quot;asm&quot;&gt;
        mov    dl,&quot;X&quot;
        mov    ah,2
        int    21h
&lt;/source&gt;

=== Pseudo-instructions ===
Une pseudo-instruction est un type particulier de macro-instruction. Elle est prédéfinie par l'éditeur du logiciel assembleur et sa fonction est d'émuler une instruction manquante du processeur ou de faciliter l'usage d'une instruction existante. Comme la pseudo-instruction a un nom très ressemblant à celui d'une vraie instruction du processeur, il est possible à première vue de la confondre avec une de ces dernières. Par exemple, un processeur [[Reduced instruction set computer|RISC]] peut ne pas posséder d'instruction JMP, instruction permettant de sauter à un point particulier du programme et de continuer son exécution en séquence. L'éditeur du logiciel aura dans ce cas créé à l'intention du programmeur une pseudo-instruction « JMP &lt;paramètre&gt; », qui sera remplacée à l'assemblage par une instruction « mov  ''pc'', &lt;paramètre&gt; », ''pc'' étant le pointeur de l'instruction sur le point d'être exécutée. Autre exemple, une pseudo-instruction « PUSH &lt;paramètre&gt; » sera remplacée par un stockage de &lt;paramètre&gt; à l'adresse pointée par ''sp'' avec pré-décrémentation de celui-ci, ''sp'' étant le [[Pointeur (programmation)|pointeur]] de [[Pile (informatique)|pile]] du processeur.

Sur des microprocesseurs ou microcontroleurs RISC tels que ceux de la famille [[Architecture ARM|ARM]], il n'existe pas d'instruction assembleur permettant de charger n'importe quelle constante immédiate dans un registre, quelle que soit sa valeur. La plupart des assembleurs disposent d'une pseudo-instruction permettant un tel chargement de la façon la plus efficace possible en termes de temps d'exécution, épargnant cette tâche au programmeur.

== Programmation structurée en assembleur ==
Support pour [[programmation structurée]] : quelques éléments de programmation structurée ont été intégrés pour encoder le flux d'exécution par Dr. H.D. Mills ({{date||mars|1970}}), et mis en œuvre par Marvin Kessler qui a étendu l'assembleur S/360 macro avec if / else / endif et même des blocs de contrôle de flux. Cela a été un moyen de réduire ou d'éliminer l'utilisation des opérations de [[GOTO]] dans le code assembleur.

== Notes et références ==
{{Références}}

== Voir aussi ==
=== Articles connexes ===
* [[Programme assembleur]]

=== Liens externes ===
{{Autres projets|wiktionary = assembleur}}
* {{fr}} [http://www.jourlin.com/public/initiation-programmation-assembleur-bits.pdf Initiation à la programmation en assembleur 64 bits] Cours et exercices corrigés avec GNU/linux, par P. Jourlin

{{Palette|Paradigme de programmation|Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]

[[pl:Asembler#Język asemblera]]</text>
      <sha1>5q640pdqohmfye9y0slvg3y4d2v690t</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Identificateur</title>
    <ns>0</ns>
    <id>856805</id>
    <revision>
      <id>101235219</id>
      <parentid>100283569</parentid>
      <timestamp>2014-02-13T23:35:10Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>/* Règles de nommage */ syntaxe (REM. : d. c. mais p.-ê. pas art.)</comment>
      <text xml:space="preserve" bytes="4698">{{ébauche|informatique}}
En [[programmation informatique]], un '''identificateur''' ou '''identifiant''' est un mot reconnu par le langage (concrètement par un [[compilateur]] ou [[Interprète (informatique)|interpréteur]]) qui permet, tel une étiquette, de désigner une [[donnée]] du [[Programme (informatique)|programme]] : [[variable (informatique)|variable]], [[constante]], [[Procédure (informatique)|procédure]], [[Type (informatique)|type]]{{nobr|, etc.}}

On peut distinguer les langages de programmation suivant les [[jeu de caractères|jeux de caractères]] autorisés pour l’écriture des identifiants : [[American Standard Code for Information Interchange|ASCII]] uniquement, jeux de caractères locaux, ou [[Unicode]].

== Langages à identifiants Unicode ==

Unicode définit dans une de ses annexes&lt;ref&gt;[http://www.unicode.org/reports/tr31/ {{en}}{{lang|en|''UAX #31: Identifier and Pattern Syntax''}}&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;, une base pour spécifier les identificateurs, tout en permettant à chaque langage de fonctionner sur des variantes de cette base.

Les langages [[Ada (langage)|Ada]], [[Java (langage)|Java]], [[Microsoft .NET]], [[Perl 5.16]], [[Perl 6]], [[StarOffice Basic]] sont compatibles avec des identificateurs Unicode.

Les langages [[Common Lisp|Clisp]], [[Delphi (langage)|Delphi]] devraient/pourraient être compatibles avec des identificateurs Unicode.
* [http://packages.debian.org/testing/devel/ocaml-ulex ocaml-ulex]
* Pour le langage [[C (langage)|C]], la norme ISO/IEC 9899:1999 définit dans son annexe normative D les caractères autorisés dans les identificateurs, en reprenant la norme ISO/IEC TR 10176:1998&lt;ref&gt;[&lt;!-- http://www.iso.ch/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=28707&amp;ICS1=35&amp;ICS2=60&amp;ICS3= {{en}}{{lang|en|''ISO/IEC TR 10176:1998, Guidelines for the preparation of programming language standards''}} --&gt;http://www.iso.org/iso/fr/home/store/catalogue_tc/catalogue_detail.htm?csnumber=28707 ''ISO/IEC TR 10176:1998, Technologies de l’information — Lignes directrices pour la préparation des normes des langages de programmation'']&lt;/ref&gt;. Sont notamment permis des ensembles de caractères latins, grecs, cyrilliques, tibétains, et CJK. {{nombre|14|plages}} de chiffres, en plus de la plage ASCII, ainsi que certains caractères spéciaux sont également autorisés.

Le langage Python ambitionne de pouvoir supporter des identificateurs dans des langues autres que la seule langue anglaise avec le PEP 3131 &lt;ref&gt;
http://www.python.org/dev/peps/pep-3131/
&lt;/ref&gt;.

== Règles de nommage ==

Les développeurs ont parfois besoin d’exprimer les concepts qu’ils utilisent avec des mots et des symboles qui leur sont familiers, en particulier pour les non anglophones.

Par ailleurs, avec l’usage croissant d’[[Internet]], l’usage d’Unicode se répand. En programmation, il est présent :
* dans les [[chaîne de caractères|chaînes de caractères]] des langages, en particulier Java et .NET représentent par défaut toutes les chaînes en Unicode ;
* dans les systèmes d’exploitations, en particulier dans [[Microsoft Windows]].

Les langages s’interfaçant avec Java et .NET nécessitent le support d’identifiants Unicode, pour être interopérables. Sans cela, une portion de l’[[espace de noms]] ne serait pas accessible.

== Exemples ==

* En Delphi les anciens identificateurs commençaient par a..z ou tiret bas (_), suivi de a..z, 0..9, ou tiret bas. 
* Avec Unicode : suite de caractères [[Alphabet|alphabétiques]] Unicode ou tirets bas.

== Relation avec les [[métadonnée]]s ==

Dans les [[langages de balisage]], mais également dans tous les types de [[ressources informatiques]] et tous les types d’application, on peut employer des [[métadonnée]]s pour décrire les données. L’[[identifiant (métadonnée)|identifiant]] est l’un des [[élément (métadonnée)|éléments]] couramment employés pour l’accès aux ressources (URI). L’identifiant peut faire l’objet de règles de nommage.

== Voir aussi ==
=== Articles connexes ===
{{Autres projets|wiktionary = identificateur}}
* [[Identifiant (métadonnée)]]
* [[Sigil (informatique)]]

=== Notes et références ===
&lt;references /&gt; &lt;!-- aide : http://fr.wikipedia.org/wiki/Aide:Notes et références --&gt;

=== Liens externes ===
* {{en}} http://www.unicode.org/reports/tr31/
* {{en}} http://www.adahome.com/rm95/rm9x-02-01.html
* {{en}} http://clisp.sourceforge.net/impnotes.html#encoding

{{Palette|Programme informatique}}
{{portail|informatique|programmation informatique}}

[[Catégorie:Programmation informatique]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Identifiant]]</text>
      <sha1>b8nwcteo9anlxmobqg5kjro5lognxyo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>DarkBASIC</title>
    <ns>0</ns>
    <id>414797</id>
    <revision>
      <id>100119244</id>
      <parentid>98181280</parentid>
      <timestamp>2014-01-10T19:12:38Z</timestamp>
      <contributor>
        <username>EmDee</username>
        <id>456411</id>
      </contributor>
      <comment>Correction d'homonymie</comment>
      <text xml:space="preserve" bytes="3933">{{ébauche|jeu vidéo}}
'''DarkBasic''' est un [[langage de programmation]] orienté [[3D]] servant à la [[création de jeux vidéo]]. Dérivé du [[BASIC]], il permet de réaliser tout type de jeux de façon assez simple. Mais attention, ce n'est pas un logiciel &quot;[[pointer et cliquer]]&quot;. Ainsi, pour pouvoir exprimer sa créativité, l'utilisateur aura besoin d'apprendre un langage de programmation. Ce langage a été conçu pour être facilement appris, et une rubrique d'aide complète est proposée avec tous les éditeurs de Dark Basic.

Le logiciel se compose d'un [[Environnement de Développement Intégré|IDE]] (environnement de développement), de quelques exemples de jeux, ainsi que d'un manuel contenant la description et la syntaxe de chaque commande. La communauté du Dark Basic étant motivée, des éditeurs de texte à soulignement syntaxique &quot;libres&quot; ont vu le jour, nécessitant quand même l'installation du compilateur.

Pour réaliser les environnements (objets 3D, sols, ...) ainsi que les textures et les sons, deux solutions s'offrent à un utilisateur de Dark Basic. Il peut soit développer ses propres outils de création ou utiliser des logiciels pouvant exporter les données dans des formats compatibles avec Dark Basic.

Une nouvelle version de Dark basic, DarkBasic Professional, reprend les bases du DarkBasic original, mais tout a été repensé. C'est un moteur de jeu très puissant et facile à programmer tout en étant très flexible grâce notamment à l'ajout de DLL et de plug-ins. Les programmes ne sont plus transformés en bytecode, mais compilés en langage machine. Cette nouvelle version est mise à jour régulièrement, et une version utilisant DirectX 10 verra peut-être jour. Néanmoins, ce langage reste critiqué par sa lenteur d'exécution comparé a C++ ou a d'autre langages non spécialisés. La vitesse de traitement des données est extrêmement lente.

Jeux réalisés avec ce langage :
* [[BallRacer]] : Course de billes en [[3D]].
* [[La Destinée du Feu]] : [[Action-RPG]] en [[2D]]
* [[The Secret Of Manes]] : [[Jeu de tir en vue subjective]] (FPS) en [[3D]]
* Les jeux de la [[team Alienware]]

==Distribution==
DarkBasic et DarkBasic Professional ont été distribués en France par [[Focus Home Interactive]], sous le nom de 3D Games Creator et 3D Games Creator Pro. Il était dès lors possible de se procurer l'IDE, en version boîte, dans n'importe quel centre commercial au rayon jeux vidéo. Cependant le nombre de produit mis a disposition était relativement faible, ce qui fait qu'il est maintenant impossible de se procurer une version boîte par les circuit de distribution classique. Il est cependant possible de se procurer des exemplaires sur le marché de l'occasion, ou bien directement sur le site de l'équipe The Game Creators.

Il n'existe pas à ce jour de compilateur alternatif pour le langage DarkBasic, malgré certaines lacunes des compilateurs officiels (portabilité inexistante, consommation de ressources...). Un projet de compilateur alternatif a été lancé en 2005 par un utilisateur du DarkBasic, mais semble pour le moment en stand-by&lt;ref name=&quot;Compilateur Dpp&quot;&gt;http://jipem.net/e107_plugins/content/content.php?content.13&lt;/ref&gt;.

==Communauté==
Darkbasic étant un langage essentiellement «commercial», la plus grande partie de la communauté se retrouve sur les sites des éditeurs. Concernant la communauté Française, celle-ci se regroupait sur le forum du site officiel de Focus Home Interactive. Cependant, ce forum, bien que mine d'information, ne semble aujourd'hui plus disponible.

==Références==
&lt;references /&gt;

== Articles connexes ==


==Lien externe==
* {{en}} [http://darkbasic.thegamecreators.com Site officiel de ''The Game Creators''] (entreprise ayant créé ''Dark Basic Professional'')

{{Portail jeu vidéo}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Développement de jeu vidéo]]</text>
      <sha1>g2j4pgh989s3inn0uulfrw64q2bx4a1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Scala (langage)</title>
    <ns>0</ns>
    <id>904004</id>
    <revision>
      <id>100498881</id>
      <parentid>99889371</parentid>
      <timestamp>2014-01-22T15:14:06Z</timestamp>
      <contributor>
        <username>Jmax</username>
        <id>68688</id>
      </contributor>
      <comment>/* Autres ressources */ cf [[WP:LE]]</comment>
      <text xml:space="preserve" bytes="7338">{{Voir homonymes|Scala (homonymie)}}
{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom et logo                      = 
 | nom                              = Scala
 | logo                             = Scala.png
 | paradigme                        = [[Programmation orientée objet|Objet]], [[Programmation impérative|impératif]], [[Programmation fonctionnelle|fonctionnel]]
 | auteur                           = [[Martin Odersky]]
 | développeur                      = Programming Methods Laboratory of [[École Polytechnique Fédérale de Lausanne|EPFL]]
 | dernière version                 = 2.11.0-M5
 | date de première version         = {{year|2003}}
 | dernière version stable          = 2.10.3 
 | date de dernière version stable  = {{date|1|octobre|2013|en informatique}}
 | dernière version avancée         = 2.11.0-M5
 | date de dernière version avancée =  
 | typage                           = [[typage statique|statique]], [[typage fort|fort]], [[inférence de types|inféré]], [[Système structural de types|structurel]]
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[Eiffel (langage)|Eiffel]], [[Java (langage)|Java]], [[Pizza (langage)|Pizza]]&lt;ref&gt;Martin Odersky et al., An Overview of the Scala Programming Language, 2nd Edition&lt;/ref&gt;, [[Haskell]], [[Erlang (langage)|Erlang]], [[Standard ML]], [[OCaml]], [[Smalltalk]]
 | a influencé                      = 
 | système d'exploitation           = [[Machine virtuelle Java|JVM]], [[Common Language Runtime|CLR]] 
 | licence                          = [[Licence BSD|BSD]]
 | site web                         = [http://www.scala-lang.org www.scala-lang.org]
 | date de mise à jour              = {{release date|2012|04|14}} 
}}
'''Scala''' est un [[langage de programmation]] [[Paradigme (programmation)|multi-paradigme]] conçu à l'[[École polytechnique fédérale de Lausanne]] (EPFL) pour exprimer les modèles de programmation courants dans une forme concise et élégante. Son nom vient de l'anglais ''Scalable language'' qui signifie à peu près « langage adaptable » ou « langage qui peut être mis à l'échelle ». Il peut en effet être vu comme un [[métalangage]].

Scala intègre les paradigmes de [[programmation orientée objet]] et de [[programmation fonctionnelle]], avec un [[typage statique]]. Il concilie ainsi ces deux paradigmes habituellement opposés (à de rares exceptions près, telle que le langage [[OCaml]]) et offre au développeur la possibilité de choisir le paradigme le plus approprié à son problème.

Il est prévu pour être compilé en [[bytecode Java]] (exécutable sur la [[Machine virtuelle Java|JVM]]), ou [[Microsoft .NET|.Net]]. Ces deux plateformes sont supportées officiellement par l'EPFL.

Si on souhaite l'utiliser exclusivement avec la JVM, il est alors possible d'utiliser les bibliothèques écrites en Java de façon complètement transparente. Ainsi, Scala bénéficie de la maturité et de la diversité des bibliothèques qui ont fait la force de Java depuis une dizaine d'années. De plus, il est possible d'invoquer du code écrit en Scala à partir de programmes écrits en Java ce qui facilite la transition de Java à Scala.

Les développeurs habitués à un seul paradigme (par exemple ceux ayant utilisé principalement Java qui, lui, repose sur la programmation orientée objet) peuvent trouver ce langage déroutant et difficile car il nécessite l'apprentissage de concepts différents si on veut pouvoir exploiter tout son potentiel. Néanmoins, il est tout à fait possible de l'utiliser dans un premier temps comme remplaçant de Java, en profitant alors de sa syntaxe épurée, puis d'utiliser les différents &quot;nouveaux&quot; concepts au fur et à mesure de leur apprentissage.

== Exemple Hello World ==
Le programme [[Hello world]] écrit en [[Scala]], à la manière de [[Java (langage)|Java]] :

&lt;source lang=scala&gt;
object HelloWorld {
  def main(args: Array[String]) {
    println(&quot;Hello, world!&quot;)
  }
}
&lt;/source&gt;

ou bien simplement sans déclaration de classe et de méthode statique, avec un simple objet singleton :

&lt;source lang=scala&gt;
object HelloWorld extends App {
  println(&quot;Hello, world!&quot;)
}
&lt;/source&gt;

Un de ces deux exemples peut être enregistré dans un fichier &lt;code&gt;HelloWorld.scala&lt;/code&gt; et compilé en ligne de commande :

&lt;code&gt;$ scalac HelloWorld.scala&lt;/code&gt;

puis exécuté :

&lt;code&gt;$ scala -classpath . HelloWorld&lt;/code&gt;

En utilisant [[Scala]] à la manière d'un [[langage de script]] :

&lt;source lang=scala&gt;
println(&quot;Hello, world!&quot;)
&lt;/source&gt;

est enregistré dans un fichier &lt;code&gt;HelloWorld2.scala&lt;/code&gt;, puis exécuté directement en ligne de commande :

&lt;code&gt;$ scala HelloWorld2.scala&lt;/code&gt;

Le [[code source]] peut aussi être fourni directement à l'[[interprète (informatique)|interpréteur]] avec l'option '''-e''' :

&lt;code&gt;$ scala -e 'println(&quot;Hello, World!&quot;)'&lt;/code&gt;
== Outils ==
=== Intégration IDE, éditeur de texte ===
* [http://scala-ide.org/ Plugin pour Eclipse]
* [http://www.jetbrains.com/idea/features/scala.html Plugin pour Intellij IDEA]
* [https://github.com/derekwyatt/vim-scala Vim Scala]
* [http://www.emacswiki.org/emacs/ScalaMode Emacs Scala]
* [http://www.scala-sbt.org/ Scala Build tool]
* [https://github.com/davidB/scala-maven-plugin Scala Maven Plugin]

=== Frameworks de Tests ===
* [http://www.scalatest.org/ ScalaTest]
* [http://etorreborre.github.com/specs2/ Specs2]
* [https://code.google.com/p/scalacheck/ ScalaCheck]
* [http://scalamock.org/ ScalaMock]

== Notes et références ==
&lt;references /&gt;

== Liens externes ==
=== Références ===
* {{en}} [http://scala-lang.org/ Site officiel] du langage.
* {{en}} [http://typesafe.com/ Typesafe], la société fondée par [[Martin Odersky]], le créateur de [[Scala]], qui propose un support pour les utilisateurs professionnels et offre un ensemble officiel de logiciels (''stack''), composé d'[[Akka platform|Akka]] et de [[Play framework|Play]] (voir ci-dessous).
** {{en}} [http://akka.io/ Site officiel d'Akka], [[plate-forme (informatique)|plateforme]] logicielle permettant la [[programmation concurrente]] à base d'[[modèle d'acteur|acteurs]] (Akka est inspiré par l'[[Open Telecom Platform|OTP]] d'[[Erlang (langage)|Erlang]]).
** {{en}} [http://www.playframework.org/ Site officiel de Play], [[framework|canevas]] [[Java (langage)|Java]]/[[Scala]] pour le développement de sites web.
* {{en}} [http://liftweb.net/ Site officiel de Lift], [[framework|canevas]] 100 % [[Scala]] pour le développement de sites web.
* {{en}} [http://www.scalatra.org/ Site officiel de Scalatra] micro-[[framework|canevas]] web inspiré de Sinatra (Ruby).

=== Outils de développement ===
* {{en}} [http://scala-ide.org/ Site officiel de Scala IDE], [[environnement de développement intégré]] (''IDE'') pour [[Eclipse (logiciel)|Eclipse]].
* {{en}} [http://www.scala-sbt.org/ Site officiel de Scala SBT], [[moteur de production]] (''build tool'').

{{Palette |Paradigme de programmation|Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage fonctionnel]]</text>
      <sha1>ku9jqjh2kr9ak1ely7c488cwc29ocqq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Sequential function chart</title>
    <ns>0</ns>
    <id>656050</id>
    <revision>
      <id>91213011</id>
      <parentid>85170782</parentid>
      <timestamp>2013-03-24T05:47:28Z</timestamp>
      <contributor>
        <username>Saehrimnir</username>
        <id>618633</id>
      </contributor>
      <comment>Retrait de 4 lien(s) interlangue(s), désormais fournis par [[WP:WD|Wikidata]] sur la page [[d:Q8143615]]</comment>
      <text xml:space="preserve" bytes="709">{{Ébauche|informatique}}

Le '''Sequential function chart (SFC)''' est un [[langage de programmation|langage]] graphique de programmation des [[Automate Programmable Industriel|Automates Programmable Industriel]] défini dans la norme [[CEI 61131-3]].

Ce langage est une interprétation assez libre et plus permissive du [[grafcet]] dont il est inspiré : le [[grafcet]] est dédié à la spécification, alors que SFC est plus appliqué à la programmation.

==Voir aussi==
{{Autres projets|wikiversity=Automatisme : norme 1131-3 et GRAFCET|wikiversity titre=Automatisme : norme 1131-3 et GRAFCET}}

{{Portail|programmation informatique}}

[[Catégorie:Automatisme]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>0w9tngb7d7eiapmfica6j1p3iz4z3r5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bytecode</title>
    <ns>0</ns>
    <id>347391</id>
    <revision>
      <id>99688132</id>
      <parentid>99124455</parentid>
      <timestamp>2013-12-29T19:35:11Z</timestamp>
      <contributor>
        <username>Ggal</username>
        <id>362597</id>
      </contributor>
      <minor/>
      <comment>pré, sans trait d'union</comment>
      <text xml:space="preserve" bytes="5598">Le '''''bytecode''''' (signifiant en [[anglais]], « code octal », en référence à l'[[octet]] informatique) est un code intermédiaire entre les [[Instruction machine|instructions machines]] et le [[code source]], il n'est pas directement exécutable. Le bytecode peut être créé à la volée et résider en mémoire ([[compilation à la volée]], JIT en anglais) ou bien résider dans un fichier, généralement [[fichier binaire|binaire]] qui représente le [[programme informatique|programme]], tout comme un fichier de [[code objet]] produit par un [[compilateur]].

Il est appelé ''bytecode'' du fait de son format où chaque [[Jeu d'instructions|instruction]] est codée en [[binaire]].

Puisque c'est un code qui n'est pas exécutable directement par un [[processeur]] (à l'exception de certains processeurs gérant le [[bytecode Java]] nativement), il est utilisé par les créateurs de [[Langage de programmation|langages de programmation]] en guise de code intermédiaire réduisant la dépendance vis-à-vis du [[Architecture Hardware|matériel]] et facilitant son [[Interprète (informatique)|interprétation]] sur plusieurs architectures.

Certains compilateurs, comme [[LLVM]], et langages de scripts, comme [[SmallTalk]], [[Java (langage)|Java]] ou certaines implémentations de [[Ruby]] (telles que [[JRuby]], Ruby.NET ou SmallRuby) utilisent le ''bytecode'' comme [[représentation intermédiaire]] avant la transformation en code machine vers l'architecture cible ([[x86]], amd64, [[Architecture ARM|ARM]], [[Architecture MIPS|MIPS]], [[PowerPC]], etc...)  

Certains systèmes, appelés « traducteurs dynamiques » ou « [[Compilation à la volée|compilateurs à la volée]] » (''JIT (just-in-time) compilers'' en anglais), traduisent le ''bytecode'' en code machine au fur et à mesure de l’exécution, cela permet d’accélérer l’exécution sur les boucles ou les fonctions appelées plusieurs fois tout en évitant de stocker sur disque ou de transférer via les réseaux des données précompilées. Cette technique est notamment utilisée dans le langage Java et dans les émulateurs de systèmes (ordinateurs ou consoles de jeu par exemple), retranscrivant les instructions d'un langage machine à un autre et plus généralement d'une architecture matérielle à une autre.

Un programme à base de ''bytecode'' est exécuté par un [[Interprète (informatique)|interpréteur]] appelé [[machine virtuelle]], car elle exécute le code tout comme un microprocesseur. L'avantage est la portabilité : le même ''bytecode'' peut être exécuté sur diverses [[plate-forme (informatique)|plates-formes]] ou [[Architecture informatique|architectures]] pour lesquelles un interpréteur existe. Un programme sous forme de ''bytecode'' peut donc être transmis d'une machine à une autre, et être interprété puis exécuté sans modification de celui-ci par différents types d'architectures matérielles. L'avantage est le même que pour les [[langage de script|scripts]], qui sont directement interprétés (et non compilés en ''bytecode''). Cependant, le ''bytecode'' est plus concret, plus compact et plus facile à manipuler qu'un script, prévu pour être intelligible par l'homme. Les performances des interpréteurs de ''bytecode'' sont généralement bien meilleures que celles des interpréteurs de scripts pour ces raisons.

Pour bénéficier de ces avantages, aujourd'hui de nombreux langages interprétés sont en fait compilés en ''bytecode'' avant d'être exécutés par un interpréteur. C'est le cas par exemple de [[PHP]] (lorsqu'il est utilisé pour des applications), de [[Tcl (langage)|Tcl]], de [[Python (langage)|Python]]. Un programme [[Java (langage)|Java]] est habituellement transmis sous forme de ''bytecode'' à une machine hôte qui utilisera une compilation à la volée pour traduire le ''bytecode'' en code machine avant exécution. Les implémentations actuelles de [[Perl (langage)|Perl]] et de [[Ruby]] utilisent non pas du ''bytecode'', mais une structure en arbre qui se rapproche de la représentation intermédiaire des compilateurs.

Les ''[[p-Code]]s'' diffèrent des ''bytecodes'' par le codage de leurs opérations, qui peut être de plusieurs octets avec une taille variable, tout comme les ''[[langage machine|opcodes]]'' de nombreux processeurs. Ils ont un plus haut niveau descriptif, comme « afficher cette chaine de caractères » ou encore « effacer l'écran ». Le [[BASIC]] et quelques versions de [[Pascal (langage)|Pascal]] utilisent un ''p-Code''.

== Exemples ==
*[[O-code]] de [[BCPL]];
*[[CLISP]], une implantation de [[Common Lisp]], ne compile qu'en bytecode;
*[[CMUCL]], une implantation de [[Common Lisp]], peut compiler en bytecode ou en code natif ; le code natif est bien plus compact;
*[[Objective Caml|OCaml]] peut compiler un bytecode compact, mais pas seulement; le bytecode d'OCaml et son interpreteur (''ocamlrun'') semblent former l'une des combinaisons les plus efficaces {{Référence nécessaire}} parmi tous les bytecodes existants. 
*[[Microsoft .NET]] [[Common Intermediate Language]], exécuté par le  [[Common Language Runtime]]; 
*[[Java (langage)|Java]] de [[Sun Microsystems]] (voir [[Bytecode Java]]);
*[[Python (langage)|Python]], où un module (fichier module.py) est '''compilé''' vers du [[bytecode]] (fichier module.pyc) à l'importation durant l'exécution, mais pas nécessairement à l'exécution.

==Voir aussi==
{{Autres projets|wiktionary = bytecode}}

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Compilateur]]</text>
      <sha1>6sylkmiw49125w47xs9oyua2ozmsk93</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Pro*C</title>
    <ns>0</ns>
    <id>176973</id>
    <revision>
      <id>99687855</id>
      <parentid>91877390</parentid>
      <timestamp>2013-12-29T19:26:37Z</timestamp>
      <contributor>
        <username>Ggal</username>
        <id>362597</id>
      </contributor>
      <minor/>
      <comment>pré, sans trait d'union</comment>
      <text xml:space="preserve" bytes="1414">{{ébauche|informatique}} 
Le '''Pro*C''' est un outil permettant d'inclure des commandes [[Structured Query Language|SQL]] dans un programme [[Langage C|C]]. Il s'agit en fait d'un [[précompilateur]] : le code source Pro*C est traduit en source C avec des appels aux bibliothèques [[Oracle (base de données)|ORACLE]].

La compilation complète se fait donc en plusieurs étapes:
# Le code source ''mon_bidule.pc'' est tout d'abord passé au précompilateur Pro*c, ce qui va créer le fichier source C ''mon_bidule.c''
# Le fichier source ''mon_bidule.c'' est passé au compilateur C, ce qui va créer le fichier objet ''mon_bidule.o''
# Le fichier objet ''mon_bidule.o'' est lié aux [[bibliothèque logicielle|bibliothèques]] ORACLE (et éventuellement aux autres fichiers objets s'il y en a) avec l'éditeur de liens, ce qui va créer l'exécutable final ''mon_bidule''

Un point important : lors de la première phase (précompilateur Pro*c), une connexion au serveur ORACLE est effectuée afin de valider les requêtes SQL du code Pro*C.

== Exemple ==
Exemple de syntaxe Pro*C :
&lt;code&gt;

EXEC SQL WHENEVER ERROR DO MaProcedureErreur(&quot;Mauvaise màj de ma_table!&quot;);

EXEC SQL WHENEVER NOT FOUND continue;

EXEC SQL UPDATE ma_table SET ma_colonne = 'abc' WHERE id=2 ;

&lt;/code&gt;

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel pour les bases de données]]</text>
      <sha1>jflkjo35gaga3dqsvwm25ez35syf5p4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Microsoft Macro Assembler</title>
    <ns>0</ns>
    <id>930169</id>
    <revision>
      <id>93069538</id>
      <parentid>92998070</parentid>
      <timestamp>2013-05-14T08:17:36Z</timestamp>
      <contributor>
        <username>Arbautjc</username>
        <id>1453191</id>
      </contributor>
      <minor/>
      <comment>/* Liens externes */</comment>
      <text xml:space="preserve" bytes="4650">{{à sourcer|date=avril 2009}}
Le [[logiciel]] &lt;dfn lang=&quot;en&quot;&gt;Microsoft Macro Assembler&lt;/dfn&gt; (Macro Assembleur de Microsoft, plus connu sous l'acronyme &lt;dfn&gt;MASM&lt;/dfn&gt;) est un [[Programme assembleur|assembleur]] pour la famille de [[processeur]]s [[x86]]. Il fut à l'origine développé par [[Microsoft]] pour le développement de leur [[système d'exploitation]] [[MS-DOS]].

MASM supporte une grande variété de [[macro]]s aidant à la programmation en langage [[assembleur]] ainsi que des idiomes de [[programmation structurée]], incluant des constructions de haut niveau pour les boucles, les appels de procédures, les branchements, etc. ce qui fait de MASM un assembleur à programmation de haut niveau. Les dernières versions de MASM ont la possibilité de produire des programmes pour le système d'exploitation [[Windows]]. MASM fut un des rares outils de développement de Microsoft pour lequel il n'y eut pas de versions 16 et 32 bits séparées.

== Compétition entre assembleurs ==
Dans les premières années de la décennie 1990 d'autres assembleurs alternatifs prirent une certaine part de marché à MASM, parmi lesquels [[TASM]] de [[Borland]], le [[partagiciel]] [[A86]] et [[NASM]] vers la fin de la décennie. Toutefois, deux évènements à la fin des [[années 1990]] permirent à MASM de garder un solide support de la communauté des programmeurs en assembleur : en premier lieu, MASM, qui était jusqu'alors un logiciel commercial, fut distribué gratuitement comme partie du ''Driver Development Kit'' ou [[DDK]]. Dans un deuxième temps, le ''pack'' MASM32 maintenu par Steve Hutchesson ainsi que les tutoriaux d'Iczelion apparurent permettant de programmer directement et relativement aisément des applications 32 bits fonctionnant sous Windows. Ces deux événements combinés assurèrent à MASM sa continuité dans le temps.

MASM reste encore aujourd'hui un assembleur phare de la communauté des programmeurs en assembleur pour la plateforme [[Win32]], mais d'autres assembleurs comme  GAS, [[NASM]], [[TASM]], [[FASM]], [[GoAsm]], [[RosAsm]] ou [[High Level Assembly|HLA]] rassemblent chacun une communauté importante.

== Versions de MASM ==
Bien que MASM ne soit plus un produit commercial, Microsoft continue à assurer son support du fait d'une utilisation assez importante du langage assembleur en développement interne chez Microsoft. Depuis que Microsoft a arrêté la vente de MASM, de nombreuses mises à jour ont été produites pour la lignée de MASM 6.x (la dernière mise à jour de cette lignée est la version 6.15 qui était incluse dans le ''Visual C++ 6.0 Processor Pack''). MASM 7.0 fut inclus avec [[Visual C++]] .NET 2002, MASM 7.1 avec Visual C++ .NET 2003 et MASM 8.0 avec Visual C++ .NET 2005 (cette dernière version est la première à pouvoir assembler du code 64 bits).
Pour les versions de MASM incluses avec Visual C++, l'exécutable de MASM s'appelle ''ml.exe'' et se situe dans le répertoire ''bin''. La version 64 bits de MASM incluse avec Visual C++ 2005 se nomme ''ml64.exe'' et se situe dans le même répertoire. La documentation de MASM pour ces versions est incluse avec la documentation de Visual C++.

== Projets reconnaissant MASM ==
De nombreux projets reconnaissant MASM ont vu le jour. Ainsi, des environnements de développement intégrés permettent un développement plus aisé avec MASM (qui s'utilise habituellement en ligne de commande) parmi lesquels Qedit, [[Radasm]] ou [[WinAsm Studio]]. On notera aussi des [[débogueur]]s comme [[OllyDbg]] qui reconnaît la syntaxe MASM, ou des désassembleurs comme [[IDA (logiciel)|IDA]].

De nombreux forums ou sites internet proposent des codes sources, de la documentation ou de l'aide concernant cet assembleur, qui reste un assembleur de référence.

La prise en charge officielle de MASM par Microsoft se résume aujourd'hui à ajouter des instructions lorsque de nouveaux processeurs voient le jour et à améliorer la prise en charge du 64 bits.

== Articles connexes ==
* [[Assembleur]]
* [[Programme assembleur]]
* [[GNU Assembler]]
* [[FASM]]
* [[Turbo Assembler]]
* [[NASM]]
* [[RosASM]]

== Liens externes ==
* {{en}} [http://www.microsoft.com/downloads/details.aspx?FamilyID=7A1C9DA0-0510-44A2-B042-7EF370530C64 Téléchargement de MASM pour Visual C++ 2005 Express Edition] - Sur le site de Microsoft
* {{fr}} [http://asm.developpez.com/cours/noteworthy/ Tutoriel MASM : Pas à Pas vers l'Assembleur]

{{Portail|Microsoft|logiciel}}

[[Catégorie:Compilateur]]
[[Catégorie:Freeware]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel Microsoft]]
[[Catégorie:Logiciel pour Windows]]</text>
      <sha1>p3t2bhrydr8w2y6fr11d95zzvzuxdu8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ponie</title>
    <ns>0</ns>
    <id>955582</id>
    <revision>
      <id>90120448</id>
      <parentid>61023861</parentid>
      <timestamp>2013-03-14T12:20:36Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1733877]]</comment>
      <text xml:space="preserve" bytes="947">'''Ponie''', acronyme de ''Perl On a New Internal Engine'', était un projet démarré par la société Fotango pour porter [[Perl (langage)|Perl 5]] au-dessus de la [[Parrot|machine virtuelle Parrot]]. Au départ gérée par Arthur Bergman, Ponie a ensuite été développé par Nicholas Clark, actuel pumpking de Perl 5.8, qui en a profité pour effectuer un travail de nettoyage remarquable dans les entrailles de Perl. 

Le projet Ponie a été interrompu en fin août 2006. Ses effets, le nettoyage de Perl 5, ont été bénéfiques même si le but escompté n'a pas été atteint. D'autres stratégies sont explorées pour l'exécution de code Perl 5 au-dessus de [[Perl 6]].

== Liens externes ==
* {{en}} [http://www.poniecode.org/ Ponie has been put out to pasture]


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Machine virtuelle]]
[[Catégorie:Perl]]</text>
      <sha1>kq8fjp4gynhrysik1rgok87jv1qlu78</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Pugs</title>
    <ns>0</ns>
    <id>951227</id>
    <revision>
      <id>95875524</id>
      <parentid>90148519</parentid>
      <timestamp>2013-08-17T13:04:15Z</timestamp>
      <contributor>
        <username>LeGrenadier</username>
        <id>804390</id>
      </contributor>
      <comment>/* Compatibilité avec Perl 5 */</comment>
      <text xml:space="preserve" bytes="7308">'''Pugs''' est une [[mise en œuvre]] expérimentale de [[Perl 6]] en langage [[Haskell]], et utilisant les spécificités les plus avancée de [[Glasgow Haskell Compiler|GHC]].
Selon le [[dorsal]] de génération et d'exécution de [[Code source|code]], Pugs peut être considéré soit comme un [[compilateur]], soit comme un [[interprète (informatique)|interprète]].

Les développeurs de Pugs se désignent comme ''lambda camels'' (chameaux lambda) pour marquer leur double appartenance : le chameau est la mascotte du langage [[Perl (langage)|Perl]], et le lambda (λ) est une référence au [[lambda calcul]] qui est à la base de la [[programmation fonctionnelle]].

La [[distribution]] Pugs contient du [[code source]] de diverses origines et donc sous différentes [[Licence de logiciel|licences]] [[Open Source]] :
La [[licence artistique]] 2.0b5, la licence du Glasgow Haskell Compiler [http://www.haskell.org/ghc/license.html], la [[Licence publique générale GNU|GPL]] 2, la [[LGPL]] 2.1 et la [[licence MIT]].
Conformément à la tradition du monde Perl, Pugs tourne sur de nombreuses plates-formes logicielles dont [[UNIX]], [[Mac OS X]] et [[Windows]].

== Vue d'ensemble ==

Le projet Pugs a pour but de [[Bootstrap (compilateur)|bootstrapper]] Perl 6 en mettant en œuvre la totalité de la spécification de Perl 6, détaillée à  [http://dev.perl.org/perl6/synopsis/ Synopses]. Il est écrit en [[Haskell]] et utilise les fonctionnalités les plus récentes du [[Glasgow Haskell Compiler]].
&lt;br&gt;Ainsi la mise en œuvre de la [[mémoire transactionnelle logicielle]] pour la [[programmation concurrente]] qui permet d'exploiter au mieux les architectures [[microprocesseur multi cœur|multi cœur]] ou [[multiprocesseur]]s.
&lt;br&gt;Ou les [[Type algébrique de données|types algébriques de données]] généralisés.

Pugs inclut deux [[exécutable]]s principaux :
* ''pugs'' est l'interprète avec un [[shell (informatique)|shell]] interactif ;
* ''pugscc'' peut compiler des programmes Perl 6 en code Haskell, en code Perl 5, en [[JavaScript]], ou en assembleur imcc destiné à être interprété par la [[machine virtuelle]] [[Parrot (machine virtuelle)|Parrot]].

== Numéros de version ==

Les numéros de version de Pugs convergent vers 2 &amp;times; ''π'' (cela rappelle [[TeX]] et [[METAFONT]], qui utilisent un système similaire); 
Chaque chiffre significatif de la version mineure représente une étape franchie avec succès. Les étapes anticipées sont :
* 6.0 : Version initiale
* 6.2 : Entrées-sorties et [[structure de contrôle|structures de contrôle]]; variables mutables, affectation.
* 6.28 : [[Classe (informatique)|classe]]s et traits.
* 6.283 : Règles et Grammaires.
* 6.2831 : Système de types et [[édition de liens]].
* 6.28318 : [[Macro]]s.
* 6.283185 : Port de Pugs vers Perl 6, si nécessaire.

La version actuelle de Pugs est la 6.2.13.11.

== Compatibilité avec Perl 5==

Depuis la version 6.2.6, Pugs peut inclure la machine virtuelle Perl 5 et donc utiliser les modules [[CPAN]].  
Le [[Just Another Perl Hacker|JAPH]] ci-dessous montre l'utilisation de [[Perl DBI]], un  module populaire, pour gérer une base de données [[SQLite]] :

 #!/usr/bin/pugs
 use v6;
 use perl5:DBI;
 
 my $dbh = DBI.connect('dbi:SQLite:dbname=test.db');
 $dbh.do(&quot;CREATE TABLE Test (Project, Pumpking)&quot;);
 
 my $sth = $dbh.prepare(&quot;INSERT INTO Test VALUES (?, ?)&quot;);
 $sth.execute(&lt;PGE Patrick&gt;);
 $sth.execute(&lt;Pugs Audrey&gt;);
 $sth.execute(&lt;Parrot Leo&gt;);
 
 my $res = $dbh.selectall_hashref('SELECT * FROM Test', 'Pumpking');
 
 # Just another Pugs hacker
 say &quot;Just another $res&lt;Audrey&gt;&lt;Project&gt; hacker&quot;;

== Modèle de développement ==

Pugs est un projet open source très productif.
Démarré en 2005, ses progrès ont été rapides pour les raisons suivantes :
* Pugs' utilise le système de [[typage statique]] de [[Haskell]]. Cela signifie qu'une palette plus large de [[Bug informatique|bugs]] est détectée au moment de la compilation. Dans la tradition des [[langage fonctionnel|langages fonctionnels]], quelques lignes de Haskell peuvent accomplir beaucoup de travail. Haskell est très adapté à l'analyse d'un langage grâce à la [http://www.cs.uu.nl/~daan/parsec.html bibliothèque Parsec], un analyseur [[monade (informatique)|monadique]] [[combinatoire]] écrit entièrement en Haskell. Les choses deviennent difficiles quand le code fonctionnel doit interagir avec le monde réel (entrées/sorties et environnement dépendant du temps). Pour cela, Pugs utilise intensivement les [[Monade (informatique)|monades]], qui sont des containers qui encapsulent les [[effet de bord (informatique)|effets de bord]] dans un monde par ailleurs purement fonctionnel. C’est-à-dire sans effets de bord et indépendant de l'ordre d'exécution des paramètres d'une fonction.
* Le développement est [[Développement piloté par les tests|piloté par les tests]], un principe de la [[programmation extrême]] dont le but est d'écrire les jeux de test si possible avant même que le code à tester soit écrit. L'état du projet  est alors apparent simplement en regardant quelle proportion de tests réussit. Cela rend plus facile de détecter les [[non-régression|régressions]]. On espérait originellement que l'important jeu de test de Pugs formerait la base du jeu de test de Perl 6 mais il semble que Pugs lui-même sera la première mise en œuvre de Perl 6. 
* [[Audrey Tang]] distribue généreusement le [[bit de commit]], spécialement aux personnes désireuses d'écrire des tests. Le développement de Pugs utilise un dépôt [[Subversion (logiciel)|Subversion]]. Grâce à cela, Pugs a accumulé une bibliothèque de tests considérable.
* L'enthousiasme d'Audrey est communicatif et ses communications relativement fréquentes. Son journal (lien ci-dessous) a attiré plusieurs personnes vers le projet, séduites par la vitesse de développement du projet. Cela contraste avec la réputation que s'était attiré Perl 6, projet commencé en l'an 2000, dont l'avancement avant Pugs était très lent. Il faut pourtant noter les retombées pourtant nombreuses dans la prochaine versions mineure 5.10 de Perl 5, et les modules Perl6:: de CPAN mettant en œuvre des fonctionnalités de Perl 6 dans Perl 5. La communication à court terme pour Pugs se fait sur le canal [[Internet Relay Chat|IRC]] #perl6 Freenode.

=== Voir aussi ===
* [[The Perl Foundation]] : La fondation chargée de la promotion et du développement de Perl.

=== Liens externes ===
* {{en}} [http://www.pugscode.org/ site officiel].
* {{en}} [http://run.pugscode.org/ Un shell Pugs dans votre butineur].
* {{en}} [http://spec.pugscode.org/ Annote  les Synopses (spécifications) avec les résultats de test].
* {{en}} [http://smoke.pugscode.org/ Annotations de tests plus détaillées].
* {{en}} [http://pugs.blogs.com Pugs Journal]
* {{en}} [http://www.oreillynet.com/pub/wlg/7996 -Ofun: Optimizing for Fun]
* {{en}} [http://search.cpan.org/~autrijus/Perl6-Pugs/ Perl6::Pugs on CPAN]
* {{en}} [http://www.nntp.perl.org/group/perl.perl6.language/19263 Kudos from Perl 6 Design Team]

{{Portail|programmation informatique|logiciels libres}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Machine virtuelle]]
[[Catégorie:Perl]]
[[Catégorie:Logiciel sous licence libre]]</text>
      <sha1>6smmuhqraht35kvkw2gwhpikwxfbohu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Clips (langage)</title>
    <ns>0</ns>
    <id>271474</id>
    <revision>
      <id>89884003</id>
      <parentid>75088054</parentid>
      <timestamp>2013-03-12T22:51:43Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 13 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q165372]]</comment>
      <text xml:space="preserve" bytes="4742">{{ébauche|informatique}}

'''CLIPS''' ''(C Language Integrated Production System)'' est un environnement et un langage de programmation créés en [[1985]], faisant partie du paradigme des langages déclaratifs et logiques.

Il s'agit avant tout d'un outil de construction de [[système expert|systèmes experts]] à base de règles et d'objets. Ses caractéristiques notables sont:
*La gestion de trois paradigmes à la fois: [[programmation procédurale]], [[programmation à objets]], et [[Programmation logique|programmation par règles]].
*Une grande flexibilité dans la [[représentation des connaissances]], grâce à ces trois paradigmes.
*Portabilité et rapidité: il est écrit en [[C (langage)|C]]
*Intégration: Clips peut être &quot;embarqué&quot; dans des logiciels écrits dans d'autres langages.
*Extensibilité: ces autres langages peuvent servir à étendre ses fonctionnalités, en respectant certains protocoles.
*Interactivité avec l'interpréteur de commandes.
*Fonctionnalités poussées de validation de systèmes experts, de vérification de contraintes.

== Historique ==

Les origines de CLIPS se situent en 1984 au Johnson Space Center de la [[NASA]]. À cette époque, les outils de [[système expert|systèmes expert]] étaient développés en [[LISP]], ce qui les rendait incompatibles avec les contraintes de le NASA. En effet, LISP n'était pas disponible pour toutes les architectures, ne s'intégrait pas bien avec les autres langages de programmation ; les coûts des outils LISP étaient élevés, et enfin le langage n'offrait pas les performances nécessaires en termes de rapidité d'exécution. Un langage tel que [[C (langage)|C]] semblait un bon candidat pour pallier ces problèmes. Malheureusement, le temps et le coût d'adaptation des outils existants annoncés par les fournisseurs étaient bien trop élevés. La section d'intelligence artificielle décida alors de développer son propre outil de système expert en C.

Un prototype de CLIPS apparut au printemps 1985, avec une syntaxe fortement inspirée de l'outil de système expert ART développé par Inference Corporation afin de le rendre compatible avec les autres outils existants. La version 1.0 de CLIPS prouva la faisabilité du projet, et seulement un an plus tard, en 1986,  sortit la version 3.0 qui fut rendue disponible en dehors de la NASA.

== Exemple ==

Prenons tout d'abord les faits suivants :
*Les hommes sont mortels
*Socrate est un homme
*Les chiens sont mortels
Que nous traduisons en CLIPS :

 (deffacts vérités
     (est homme mortel)
     (est Socrate homme)
     (est chien mortel)
  )

Et la règle suivante :
*si '''a''' est '''b''' et '''b''' est '''c''', alors '''a''' est '''c'''
Qui se traduit en CLIPS par:

 (defrule translation
     (est ?a ?b)
     (est ?b ?c)
      ⇒
     (assert (est ?a ?c))
  )

Avant la première exécution la base de faits contient donc ceci :

    1- (est homme mortel)
    2- (est Socrate homme)
    3- (est chien mortel)

En lançant la résolution, la règle est appliquée une fois avec les faits 1 et 2 :
* Socrate est un homme, or tout homme est mortel, donc Socrate est mortel.
La base de fait contient maintenant ceci :

    1- (est homme mortel)
    2- (est Socrate homme)
    3- (est chien mortel)
    4- (est Socrate mortel)

La règle ne peut plus être appliquée à aucun fait, l'exécution s'arrête. Nous remarquons qu'un seul nouveau fait a été introduit dans la base de faits (Socrate est mortel). En effet, on ne peut pas en déduire que ''Socrate est un chien'', comme dans le fameux [[sophisme]].

== Licence ==

CLIPS et sa documentation sont dans le [[Domaine public (propriété intellectuelle)|domaine public]]. 

Plus précisément, les sources, les exécutables et la documentation téléchargée
à partir de [http://www.ghg.net/clips/Download.html la page de téléchargement de CLIPS] sont soumis à la présente licence :

{{Début citation}}La permission est accordée, gratuitement, à tout personne obtenant une copie du logiciel et de sa documentation associée (le &quot;''Logiciel''&quot;), d'utiliser le ''Logiciel'' sans restriction, incluant sans aucune limitation, le droit d'utiliser, copier, modifier, inclure, publier, distribuer et/ou vendre des copies du ''Logiciel'', et de permettre à ceux à qui le Logiciel est fourni d'en faire autant.{{Fin citation}}

Attention, au 11 septembre 2010 à 21h52, la page http://www.ghgcorp.com/clips/Download.html n'existe plus.

==Liens externes==
*[http://clipsrules.sourceforge.net/ Site officiel] ''(en anglais)''
* [http://pyclips.sourceforge.net/web/ PyCLIPS (module Python)]

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>0vpwrd5ebhuqqk1r3u1wvaocnqge3et</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>OpenLaszlo</title>
    <ns>0</ns>
    <id>510228</id>
    <revision>
      <id>100346205</id>
      <parentid>89978613</parentid>
      <timestamp>2014-01-17T20:36:14Z</timestamp>
      <contributor>
        <username>JnRouvignac</username>
        <id>114137</id>
      </contributor>
      <comment>Remplacement de la liste d'interfaces utilisateurs par une page listant toutes les interfaces utilisateurs</comment>
      <text xml:space="preserve" bytes="3983">{{voir homonymie|Laszlo}}

'''OpenLaszlo''' est une plateforme de développement pour des applications web. Elle permet de créer des applications riches ([[Rich Internet Application]]s) comprenant une interface riche en fonctionnalités (drag &amp; drop, onglet, menu déroulant, animation etc.) tout en offrant un déploiement facilité par le biais du [[navigateur web]]. OpenLaszlo est compatible avec la majorité des navigateurs web et des systèmes d'exploitation disposant soit d'un plugin [[Macromedia Flash|Flash]], soit simplement du support Javascript. OpenLaszlo se base sur une grammaire [[Extensible Markup Language|XML]] appelée LZX.

Quelques compléments à propos de LZX et du serveur OpenLaszlo :

* LZX est une description [[Extensible Markup Language|XML]] et [[JavaScript]] de l'application identique, sur le principe de [[XUL]] et [[XAML]]. Cette description déclarative permet de construire une interface graphique très rapidement et de bénéficier d'un prototype dans un laps de temps réduit. 
* Le serveur OpenLaszlo est une [[servlet]] [[Java (langage)|Java]] qui compile l'application LZX en un binaire exécutable. L'application résultante est compilée au choix par l'utilisateur vers le format propriétaire Flash, ou vers le format ouvert [[Hypertext Markup Language|HTML]]/[[AJAX]].

== Historique du projet ==

OpenLaszlo était originellement appelé Laszlo Presentation Server (LPS). Le développement de LPS a débuté originellement en automne 2001. Les versions de démonstration sont mises sur pieds pour acquérir des partenaires, courant 2002. Plusieurs d'entre eux ont déployé des applications. La première version officielle sort dans le début 2002.

En octobre 2004, Laszlo Systems libère l'ensemble du code de Laszlo Presentation Server sous licence ''CPL open source license'' et démarre le projet OpenLaszlo. En 2005, parallèlement à la sortie de la version 3.0, le nom de Laszlo Presentation Server est changé en OpenLaszlo.

Jalons :
* 2000 premier prototype
* 2001 début du développement
* 2002 LPS pre-releases ; premier déploiement Laszlo application (Behr)
* 2003 LPS 1.0, 1.1 released ; déploiement applications (Yahoo, Earthlink)
* 2004 LPS 2.0, 2.1, 2.2 released ; LPS devient un projet open source
* 2005 OpenLaszlo 3.0 released ; changement de nom, Lazlo devient OpenLaszlo
* 2006 OpenLaszlo 4.0 released ; ajout de la compilation Ajax/DHTML

== Déploiement ==

Une application Laszlo peut être déployée comme un servlet Java traditionnel. Celui-ci est compilé et renvoyé au navigateur dynamiquement. Ce procédé exige que le serveur OpenLaszlo tourne sur le serveur web.

Une autre manière de faire est de compiler une application LZX en un [[bit|binaire]] [[ShockWave Flash|SWF]] ou en [[Hypertext Markup Language|HTML]]/[[AJAX]]. Cette méthode est appelée le déploiement SOLO. Les applications déployées de la sorte ont certaines fonctionnalités en moins, bien que les dernières versions ont essayé de remédier à ce problème.

== Licence ==
OpenLaszlo est proposé sous [[Common Public License]], érigée par IBM.

== Voir aussi ==

=== Liens internes ===
* [[Liste de bibliothèques d'interface utilisateur]]
* [[Silverlight]]

=== Liens externes ===
* [http://www.openlaszlo.org OpenLaszlo]
* [http://www.laszlodev.fr LaszloDev.fr] Site français contenant de nombreux tutoriels pour apprendre facilement OpenLaszlo
* [http://www.laszlosystems.com/demos/ Laszlo Demo], propose plusieurs applications de démonstrations
* [http://www.laszlomail.com LaszloMail], un [[client de messagerie]] basé sur OpenLaszlo
* [http://www.openlaszlo.org/lps/laszlo-explorer/index.jsp?navset=nav10.xml&amp;bookmark=Introduction Laszlo en 10 minutes], pour apprendre les rudiments en 10 minutes.

{{Portail|informatique|Internet}}

[[Catégorie:Langage de programmation]]
[[Catégorie:XML]]
[[Catégorie:Interface utilisateur]]
[[Catégorie:Technologie Flash]]
[[Catégorie:Interface riche|OpenLaszlo]]</text>
      <sha1>5vds675deznjpymc0hvl7uyb11d9cwf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Iota (langage)</title>
    <ns>0</ns>
    <id>358122</id>
    <revision>
      <id>97297104</id>
      <parentid>89922835</parentid>
      <timestamp>2013-10-07T19:05:52Z</timestamp>
      <contributor>
        <username>Jules78120</username>
        <id>903634</id>
      </contributor>
      <minor/>
      <comment>maintenance</comment>
      <text xml:space="preserve" bytes="358">{{ébauche|informatique}}
{{Voir homonymes|Iota (homonymie)}}
Le langage '''Iota''' est un [[langage de programmation]] [[Turing-complet]] conçu par [[Chris Barker]]. Il possède seulement deux symboles.

== Lien externe ==
* http://semarch.linguistics.fas.nyu.edu/barker/Iota/
{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>dsfn1tu644gkccc2h52xnmbjdnonabv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Alef (langage de programmation)</title>
    <ns>0</ns>
    <id>1006531</id>
    <revision>
      <id>97649186</id>
      <parentid>97649157</parentid>
      <timestamp>2013-10-21T14:52:06Z</timestamp>
      <contributor>
        <username>Rehtse</username>
        <id>759276</id>
      </contributor>
      <comment>typographie</comment>
      <text xml:space="preserve" bytes="1720">{{Voir homophone|Aleph}}
Le langage de programmation '''Alef''' a été conçu par  Phil Winterbottom des  [[Bell Labs]] dans le cadre du système d'exploitation [[Plan 9]].

Lors une présentation en février 2000, [[Rob Pike]] déclara : {{citation|… Alef était un langage intéressant, mais il s'est révélé trop difficile de maintenir un langage sur de multiples architectures, alors nous en avons retenu les leçons et construit la bibliothèque de [[processus léger]]s (threads) en [[C (langage)|C]]}}.{{ref nec}}

== Voir aussi ==
* [[Limbo (langage)|Limbo]] - Le langage du système d'exploitation [[Inferno (système d'exploitation)|Inferno]], le successeur direct d'Alef.
* [[Plan 9]] des Bell Labs - L'environnement dans lequel Alef a été développé.

== Références ==
&lt;!--
* {{cite book
 | first = Phil
 | last = Winterbottom
 | chapter = Alef Language Reference Manual
 | title = Plan 9 Programmer's Manual: Volume Two
 | publisher = AT&amp;T
 | location = Murray Hill
 | date = 1995
 | chapterurl = http://www.cs.bell-labs.com/who/rsc/thread/alef.pdf
 | format = PDF
 }}
* {{cite book
 | first = Bob
 | last = Flandrena
 | chapter = Alef Users' Guide
 | title = Plan 9 Programmer's Manual: Volume Two
 | publisher = AT&amp;T
 | location = Murray Hill
 | date = 1995
 | chapterurl = http://www.cs.bell-labs.com/who/rsc/thread/ug.pdf
 | format = PDF
 }}
* {{cite newsgroup
 | author = [[Phil Winterbottom]]
 | title = Plan9 VM
 | date = [[October 20]] [[1992]]
 | newsgroup = comp.os.research
 | id = 1c1denINN441@darkstar.UCSC.EDU
 | url = http://groups.google.com/group/comp.os.research/msg/a7dce2f02eb44ffd?&amp;hl=en
 }}
--&gt;

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>oavhu16t52tfop46j042ourleup9hzj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>COBOL</title>
    <ns>0</ns>
    <id>8234</id>
    <revision>
      <id>101891470</id>
      <parentid>101810176</parentid>
      <timestamp>2014-03-08T14:00:45Z</timestamp>
      <contributor>
        <username>BonifaceFR</username>
        <id>1169410</id>
      </contributor>
      <minor/>
      <comment>utilisation du [[Modèle:Lang]] dans un souci d'[[Wikipédia:Atelier accessibilité|accessibilité]] (pour que les lecteurs d'écran puissent reconnaître un mot ou une phrase en langue étrangère   ;-</comment>
      <text xml:space="preserve" bytes="15405">{{Infobox Langage de programmation
 | année = [[1959]]
 | développeurs = Short Range Committee
 | influencé par = [[FLOW-MATIC]], [[COMTRAN]]
}}

[[Fichier:COBOL-syntax.svg|vignette|Exemple de programme source COBOL]]
'''COBOL''' est un [[langage de programmation]] de troisième génération créé en [[1959]] (officiellement le 18 septembre 1959)&lt;ref&gt;{{en}} [http://www.microfocus.com/aboutmicrofocus/pressroom/releases/pr20090918708131.asp www.microfocus.com]&lt;/ref&gt;. Son nom est l'[[acronyme]] de '''''{{Lang|en|COmmon Business Oriented Language}}''''' qui révèle sa vocation originelle : être un langage commun pour la programmation d'applications de gestion.

Le langage COBOL était de loin le langage le plus employé des [[années 1960]] à [[Années 1980|1980]], et reste très utilisé dans des grandes entreprises, notamment dans les institutions financières qui disposent (et développent encore) de nombreux [[logiciel]]s et applications en COBOL&lt;ref&gt; «Les banques restent fidèles à Cobol, plus performant que Java» [http://www.lemondeinformatique.fr/actualites/lire-les-banques-restent-fideles-a-cobol-plus-performant-que-java-54032.html Le Monde Informatique] &lt;/ref&gt;.

== Histoire et spécifications ==
Le COBOL a initialement été créé en [[1959]] par le ''Short Range Committee'', un des trois comités proposés à une rencontre au [[Pentagone (États-Unis)|Pentagone]] en mai 1959 organisée par [[Charles Phillips]] du département de la défense des [[États-Unis]]. Le comité a été formé pour recommander une approche à court terme pour un langage commun, indépendant des constructeurs, pour les applications de gestion de l'administration américaine. Il était constitué de membres représentant six constructeurs d'[[ordinateur]]s et trois agences gouvernementales. Les six constructeurs informatiques étaient [[Burroughs Corporation]], [[International Business Machines Corporation|IBM]], [[Honeywell|Minneapolis-Honeywell]], [[Radio Corporation of America|RCA]], [[Sperry Corporation|Sperry Rand]], et [[Sylvania Electric Products]]. Les trois agences du gouvernement étaient le ''[[United States Air Force|US Air Force]]'', le ''[[David Taylor Model Basin]]'', et l'''[[National Institute of Standards and Technology|Institut national des standards]]''. Ce comité était présidé par un membre du [[National Institute of Standards and Technology|NBS]]. Des comités à moyen et long terme ont également été proposés au Pentagone. En revanche, même si le premier a été fondé, il n'a jamais été opérationnel, et le dernier n'a jamais été fondé. En fin de compte, un sous-comité du ''Short Range Committee'' a été formé avec six membres : 
* [[William Selden]] et [[Gertrude Tierney]] de IBM ;
* [[Howard Bromberg]] et [[Howard Discount]] de RCA ;
* [[Vernon Reeves]] et [[Jean E. Sammet]] de Sylvania Electric Products.

Ce sous-comité a terminé les spécifications de COBOL fin 1959. Elles étaient largement inspirées par le langage [[FLOW-MATIC]] inventé par [[Grace Hopper]], surnommée « la mère du langage COBOL »,
et par le langage ''Commercial Translator'' (COMTRAN) d'IBM, inventé par [[Robert Bemer|Bob Bemer]].

Ce langage ayant été conçu aux débuts de l'informatique, sa relative lourdeur rebutait nombre de programmeurs dès les années 70, ce qui a valu deux interprétations ironiques à son acronyme : ''Complies Only Because Of Luck'' (''fonctionne uniquement par chance'') et ''Completly Obsolete Business Oriented Language'' (''Langage orienté gestion complètement obsolète'')&lt;ref&gt;Basé sur : J.E. Sammet. « ''The Early History of Cobol.'' », dans ''ACM SIGPLAN Notices'', Volume 13, Issue 8 (août 1978) Numéro spécial : ''History of programming languages conference'', pp. 121-161, 1978. Également publié dans ''History of Programming Languages'', rk: ACM Monograph Series, 1981.&lt;/ref&gt;.

== Histoire des standards COBOL ==
Ces spécifications furent approuvées par le comité complet, puis par le comité exécutif ([[CODASYL]]) en janvier [[1960]] et envoyées au bureau d'impression du gouvernement qui les édita et imprima en les nommant COBOL 60. Le langage fut développé en moins de six mois de travail, et il est toujours utilisé aujourd'hui, après plusieurs révisions standardisées par l'[[American National Standards Institute|ANSI]] (American National Standards Institute), dont
* COBOL-68 ([[1968]]) : gestion des tables, [[accès séquentiel]], [[accès aléatoire]], random processing, tri, report writer, [[Segmentation (informatique)|segmentation]] et bibliothèque
* COBOL-74 ([[1974]])
* COBOL-85 ([[1985]]) qui témoigne d'un grand pas vers l'adoption de la programmation structurée par l'industrie informatique
* En 1989, les fonctions intrinsèques sont ajoutées au langage ; elles permettent des opérations mathématiques (&lt;tt&gt;ACOS&lt;/tt&gt;, pour calculer l'arc [[cosinus]] par exemple), logiques (&lt;tt&gt;MAX&lt;/tt&gt;, &lt;tt&gt;MIN&lt;/tt&gt;) ou sur des chaînes de caractères (&lt;tt&gt;UPPER-CASE&lt;/tt&gt;).
* COBOL [[2002]] introduit la [[Programmation orientée objet|programmation objet]], le support de l'[[Unicode]], du [[Extensible Markup Language|XML]], etc.

== Traits principaux ==

La totalité des variables et des structures de données utilisées sont définies au début du programme, avant la division procédurale contenant les instructions. La manière dont sont définies les variables, c'est-à-dire les espaces de stockage temporaire, est très particulière. C'est une structure arborescente définie par une suite de lignes de code. Chaque ligne commence par un nombre qui définit le niveau d'imbrication du champ ou du groupe de variables.

Par exemple :
&lt;source lang=&quot;cobol&quot;&gt;
 01 NomPrenom.
   05 Prenom PIC X(20).
   05 Nom    PIC X(20).&lt;/source&gt;
qui définit une structure &lt;tt&gt;NomPrenom&lt;/tt&gt; contenant les champs &lt;tt&gt;Prenom&lt;/tt&gt; et &lt;tt&gt;Nom&lt;/tt&gt; sur 20 caractères.

Autre exemple :
&lt;source lang=&quot;cobol&quot;&gt;
 01 CodePostal.
   02 Depart  PIC 99.
   02 Commune PIC 999.&lt;/source&gt;
qui définit un code postal de France, et qui permet d'utiliser le département sans aucun MOVE.

Comme défini dans la spécification originale, COBOL possédait déjà les nombreuses fonctionnalités qui ont fait son succès : d'excellentes capacités d'auto-documentation, des méthodes pratiques de gestion des fichiers et des types de données variés, dont le format est précisé par la clause &lt;tt&gt;PICTURE&lt;/tt&gt;. Comme la plupart des autres langages de l'époque, il ne permet pas de définir de variables locales, de fonctions récursives et d'allouer de la mémoire dynamiquement.

La gestion des décimales en COBOL (nombres en [[virgule fixe]]), et la maîtrise des arrondis et des dépassements, permettent d'éviter les nombreux problèmes qui arriveraient en utilisant des nombres à [[virgule flottante]] pour les calculs financiers. Ce sont ses  capacités arithmétiques en [[virgule fixe]], notamment pour les [[traitements par lots]] où il présente d'excellentes performances, qui ont rendu le COBOL particulièrement populaire pour les traitements comptables. 

Il intègre également un générateur de rapports, défini de la même manière que les autres structures de données. Sont intégrées des fonctions de [[Algorithme de tri|tri]], de fusion et de communication. Un module optionnel permettait également une forme de [[communication inter-processus]] par [[File (structure de données)|file de messages]].

Le parti-pris initial de définir un langage de programmation proche du langage naturel (comme pour FLOW-MATIC) devait faciliter, sinon la programmation, du moins l'[[Test (informatique)|audit des programmes]] COBOL par des gestionnaires non-informaticiens. Ce choix a eu pour conséquence une syntaxe complexe (le langage naturel n'est pas simple), avec de nombreux mots réservés, et de nombreuses options (les opérations de gestion ne sont pas simples non plus) qui valent à COBOL une réputation de verbosité, qui n'est pas forcément fondée sur des faits.

Par exemple en Cobol l'instruction
&lt;source lang=&quot;cobol&quot;&gt;ADD montant TO total-jour total-mois total-annee.&lt;/source&gt;
s'exprimerait, en C ou autres langages dérivés, par 
 total_jour += montant;
 total_mois += montant;
 total_annee += montant;

Comme d'autres langages de l'époque (par exemple [[Fortran|Fortran 2]]), COBOL offrait la possibilité de modifier du code pendant l'exécution à l'aide de la fameuse instruction &lt;tt&gt;ALTER X TO PROCEED TO Y&lt;/tt&gt; (altérer X pour aller vers Y). Cette possibilité dangereuse, qui transposait une technique courante de la programmation en [[langage machine]], a été éliminée des spécifications du langage. Rendant possible la modification à la volée de l'exécution d'un programme, cette commande permettait d'outrepasser des ordres &lt;tt&gt;GO TO&lt;/tt&gt;, complexifiant ainsi la maintenance.

Les versions successives du standard ont modernisé le langage, par exemple en ajoutant des [[Structure de contrôle|structures de contrôle]] améliorées et le support de la [[Programmation orientée objet|programmation objet]], tout en préservant au maximum la compatibilité avec les versions précédentes, de façon à éviter d'avoir à modifier l'énorme stock de programmes COBOL en service.

== Le poids de l'[[Système hérité|héritage]] ==

Le langage COBOL était de loin le langage le plus employé des [[années 1960]] à [[Années 1980|1980]], et reste toujours en utilisation dans des grandes entreprises (en 2010), notamment dans les institutions financières qui disposent d'une vaste bibliothèque d'applications COBOL. Écrites à une époque où les octets coûtaient cher, et où l'an 2000 était encore fort loin, ces applications ont fait craindre le fameux [[Passage informatique à l'an 2000|bogue de l'an 2000]]. Souvent, en effet, par mesure d'économie de mémoire, les services informatiques et programmeurs avaient codé les années et les tests d'année sur 2 chiffres plutôt que sur 4. De sorte que la préparation du passage à l'an 2000 coûta au final d'énormes moyens humains, matériels et financiers. Bien que, cependant, les banques, assurances et autres institutions financières gérassent depuis très longtemps des dossiers sur 10, 20 voire 30 ans (prêts, par exemple), mais sans systématiquement, toutefois, prendre en compte dans les tests de date la notion de siècle.

En 2005, le [[Gartner|Gartner Group]] estimait que 75 % des données du monde des affaires étaient traitées par des programmes en COBOL et que 15 % des nouveaux programmes développés le seraient dans ce langage{{Référence nécessaire}}.  On retrouve le COBOL en 27e position dans l'[[Index TIOBE]]&lt;ref&gt;Jan 2014, [http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html TIOBE Index]&lt;/ref&gt;. Ce dernier mesure 229 langages de programmation selon leur popularité. 

== Structure d'un programme en COBOL ==

Un programme comporte quatre divisions. La norme COBOL-85 ne rend obligatoire que la première.
* &lt;source lang=&quot;cobol&quot;&gt;IDENTIFICATION DIVISION.&lt;/source&gt; 
*:Contient des informations générales sur le programme (dont le nom).
* &lt;source lang=&quot;cobol&quot;&gt;ENVIRONMENT DIVISION.&lt;/source&gt; 
*:Contient des informations sur l'environnement (matériel et logiciel) dans lequel le programme s'exécute.
* &lt;source lang=&quot;cobol&quot;&gt;DATA DIVISION.&lt;/source&gt; 
*:Contient les descriptions de données (variables, fichiers, paramètres et parfois description d'écran).
* &lt;source lang=&quot;cobol&quot;&gt;PROCEDURE DIVISION.&lt;/source&gt; 
*:Contient la description des traitements effectués.

Chaque division est composée de 'sections', formées de 'paragraphes' composés de 'phrases' qui peuvent être des phrases impératives ou des clauses. Chaque phrase doit être terminée par un point.

Les six premières colonnes de chaque ligne de programme sont considérées comme une zone de [[Commentaire (informatique)|commentaire]], servant autrefois à numéroter les cartes perforées (en cas de chute du paquet, il suffisait de les passer sur une trieuse pour reconstituer la version correcte du programme).
La septième colonne contient un caractère de contrôle : espace pour les lignes actives, étoile pour les [[Commentaire (informatique)|commentaires]], tiret comme caractère de continuation.

La huitième colonne est le début des titres de paragraphes.

La douzième colonne est le début des instructions. 

Les compilateurs COBOL modernes permettent l'emploi d'un format libre qui n'impose plus le colonnage.

=== Exemple de programme ([[Hello world|Bonjour]] !) ===

Écrit dans le style typique des programmes sur cartes perforées (années 1960-70), avec lignes numérotées

&lt;source lang=&quot;cobol&quot;&gt;
000100 IDENTIFICATION DIVISION.
000200 PROGRAM-ID. SALUTTOUS.
000300 DATE-WRITTEN. 21/05/05 19:04.
000400 AUTHOR UNKNOWN.
000500 ENVIRONMENT DIVISION.
000600 CONFIGURATION SECTION.
000700 SOURCE-COMPUTER. RM-COBOL.
000800 OBJECT-COMPUTER. RM-COBOL.
000900
001000 DATA DIVISION.
001100 FILE SECTION.
001200
100000 PROCEDURE DIVISION.
100100
100200 DEBUT.
100300 DISPLAY &quot; &quot; LINE 1 POSITION 1 ERASE EOS.
100400 DISPLAY &quot;BONJOUR !&quot; LINE 15 POSITION 10.
100500 STOP RUN.&lt;/source&gt;

Note : ERASE EOS signifie « 'Erase End Of Screen' » La commande ligne 100300 a donc pour effet d'effacer l'écran.

=== Exemple en format libre ===

Autre version du même exemple en COBOL-85 format libre :

&lt;source lang=&quot;cobol&quot;&gt;
Identification division. 
 Program-id. Hello.
Procedure division.
 Display &quot;Hello world!&quot; line 15 position 10.
 Stop run.&lt;/source&gt;

=== Return codes à l'exécution ===
Return code 203: vérifier l'emplacement de l'ordre d'ouverture du fichier.

== Notes et références ==
{{Références}}

== Voir aussi ==
* [[Pacbase]] et [[TELON]] sont des [[atelier de génie logiciel|AGL]] qui génèrent du COBOL.
* [[CODASYL]] Conference On DAta SYstems Language

=== Liens externes ===
{{Autres projets
  | wikiversity = COBOL
}}
* {{fr}} [http://www.labri.fr/perso/billaud/travaux/COBOL/poly-cobol.html Cours] Un petit cours de COBOL 85.
* {{en}} [https://sites.google.com/site/cobolunit/ COBOLUnit] Framework opensource de tests unitaires en COBOL pour COBOL
* {{en}} [http://www.opencobol.org Open Cobol] compilateur libre pour Windows, Linux et MacOS X.
* {{fr/en}} [http://www.cobol-it.com/ COBOL-IT] Un compilateur open source pour Windows, Linux, AIX, HP Ux, Sun Solaris, zLinux. Offrant aussi un support commercial.
* [http://www8.hp.com/fr/fr/campaign/ptf/overview.html PTF est une offre HP de transformation applicative, complète et hautement automatisée. La migration s’effectue vers le code COBOL Structuré]
* [http://code.google.com/p/naca/ Naca] transcompile du code COBOL en code Java s'exécutant sur la bibliothèque NacaRT. Voir la serie d'articles décrivant [http://media-tech.blogspot.fr/2007/10/projet-naca-migration-mainframe-ibm.html l'historique, les motivations et la situation actuelle du projet Naca].
* {{en}} [http://cobos.metrixware.org/ Cobos Project] Environnement de développement Open Source Cobol / Mainframe / CICS / DB2 sur Eclipse
* {{en}} [http://www.cobug.com COBOL User Groups (COBUG)]
* {{fr}} [http://www.grandsysteme.com/TUTORIEL%20COBOL.htm Nombreux Cours et tutoriels sur grandsysteme.com]

{{Palette|Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Grand Système IBM]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Norme ISO]]</text>
      <sha1>o5738fs6dm26we9p7vlwcxjzewn26nz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Objective-C</title>
    <ns>0</ns>
    <id>22582</id>
    <revision>
      <id>100005010</id>
      <parentid>98252692</parentid>
      <timestamp>2014-01-07T13:25:41Z</timestamp>
      <contributor>
        <username>Jmax</username>
        <id>68688</id>
      </contributor>
      <comment>/* Liens  externes */ suppr. liens non encyclopédiques cf [[WP:LE]]</comment>
      <text xml:space="preserve" bytes="11851">{{Infobox Langage de programmation
| nom = Objective-C
| logo = 
| paradigme = [[Programmation orientée objet|orienté objet]], [[Réflexion (informatique)|réflexif]]
| année = 1983
| auteur = [[Brad Cox]] et [[Tom Love]]
| développeur = 
| dernière version stable = 
| typage = [[Typage dynamique|dynamique]], [[Typage statique|statique]], [[Typage faible|faible]]
| implémentations = [[OpenStep]], [[Cocoa (Apple)|Cocoa]], [[GNUstep]]
| normes =
| influencé par = [[C (langage)|C]], [[Smalltalk]]
| a influencé =  [[TOM (language)|TOM]], [[Java (langage)|Java]]
| système d'exploitation = UNIX, Mac OS
| licence = Libre
| site web = 
}}

L''''Objective-C''' est un [[langage de programmation]] [[Programmation orientée objet|orienté objet]] [[Réflexion (informatique)|réflexif]]. C'est une extension du [[C (langage)|C ANSI]], comme le [[C++]], mais qui se distingue de ce dernier par sa distribution dynamique des messages, son [[typage]] faible ou fort, son [[typage dynamique]] et son chargement dynamique. Contrairement au C++, il ne permet pas l'[[héritage multiple]] mais il existe toutefois des moyens de combiner les avantages de C++ et d'Objective-C.

Aujourd'hui, il est principalement utilisé dans les systèmes d'exploitation d'[[Apple, Inc.|Apple]] :  [[Mac OS X]]  et son dérivé [[iOS (Apple)|iOS]], basés sur la bibliothèque de classes [[Cocoa (Apple)|Cocoa]] mais il existe aussi  une [[Interface de programmation|bibliothèque de classes]] libre [[GNUstep]] sous [[GNU/Linux]]. Cocoa et GNUstep sont les successeurs de l'API [[OpenStep]], utilisée dans les systèmes d'exploitation [[NeXTSTEP]] et [[OPENSTEP]].

==Historique==

La fin des [[années 1970]] est marquée par la popularité naissante et rapide du langage C inventé plus tôt dans la décennie par [[Dennis Ritchie]] aux [[Laboratoires Bell|Laboratoires AT&amp;T Bell]]. Cette popularité est entretenue par une autre encore plus grande, celle du système d'exploitation [[UNIX]] totalement écrit en C&lt;ref&gt;{{Ouvrage|éditeur=O'reilly|langue=en|titre=Learning Cocoa with Objective-C|auteurs=James Duncan Davidson &amp; Apple Computer|année=2002|pages=382|isbn=9780596003012|passage=1}}&lt;/ref&gt;. À la charnière des décennies 1970-[[années 1980|1980]], la pratique courante du [[génie logiciel]] est basée sur la [[programmation structurée]]. L'implémentation de la programmation structurée est utilisée dans le but de scinder de gros programmes en des parties plus petites, de complexité moins grande et donc plus faciles à programmer. Cependant, alors que la résolution de problèmes devient de plus en plus grande et compliquée, la programmation structurée devient moins utile au fur et à mesure que de plus en plus de procédures doivent être écrites, ce qui mène à des structures de contrôle complexes et à une faible réutilisation de code. À l'époque, beaucoup voient dans l'orienté-objet une possible solution à ce problème. 

Plusieurs personnes créent alors des extensions au C pour y ajouter l'orienté-objet. C'est le cas de [[Bjarne Stroustrup]] qui développe le C++ en [[1979]] dans les mêmes laboratoires que ceux dans lesquels le C de Dennis Ritchie a vu le jour. La naissance de l'Objective-C arrive dans le même contexte. [[Brad Cox]] le met au point au début des années 1980. Le langage est basé sur un autre, le [[Smalltalk|Smalltalk-80]], et est destiné à être une couche supplémentaire au C pour permettre la création et la manipulation d'objets&lt;ref&gt;James Duncan Davidson, ''op. cit.''&lt;/ref&gt;.

Le code compilé Objective-C s'exécute dans un [[environnement d'exécution]] (runtime) léger écrit en C, qui ajoute peu à la taille de l'application.

Le premier [[système d'exploitation]] à utiliser Objective-C fut [[NeXTSTEP]], de la société [[NeXT]], fondée par [[Steve Jobs]].

Objective-C est beaucoup utilisé sur [[Macintosh]], notamment pour les API [[Cocoa (Apple)|Cocoa]] de [[Mac OS X]] et, plus récemment, pour le développement d'applications [[IPhone|iPhone]], le [[Smartphone|smartphone]] d'Apple.

Il existe également une implémentation libre du framework d'[[OpenStep]], appelée [[GNUstep]], qui est multiplateforme et fonctionne notamment sous [[GNU/Linux]], [[Microsoft Windows]] et la plupart des [[UNIX]].

==Descriptif du langage==

En Objective-C, tout est objet tout comme en [[Smalltalk]] dont il s'inspire fortement. C'est donc un langage fortement orienté objet. L'héritage simple induit un arbre d'héritage avec une racine : la classe NSObject, dans le cas de Cocoa/NeXTSTEP, ou Object dans le cas de GNUstep. C'est à partir d'elle que vont dériver toutes les classes. Par exemple, un objet de classe NSString, ou NSArray, dérive de la classe NSObject (indirectement). NSMutableArray dérive de la classe NSArray, qui est donc sa superclasse. D'après certains de ses utilisateurs, c'est là que la puissance d'Objective-C apparaît : au contraire de C++ ou autres langages ne l'incluant pas, le typage faible permet de manipuler plus simplement des données.

En effet, plutôt que de devoir manipuler de nombreux types, il n'y en a que quelques-uns, par exemple dans le cas de Cocoa :
* id qui est un pointeur vers n'importe quel ''type'' d'objet.
* BOOL qui est identique à char de C, mais utilisé comme une valeur booléenne. 0 est considéré comme faux, et tout ce qui n'est pas 0, est considéré comme vrai (A, a, 1, 2, etc.)
* YES qui vaut 1.
* NO qui vaut 0.
* IBOutlet est une macro qui ne sert qu'à indiquer à Interface Builder qu'il est en face d'un « Outlet ».
* IBAction qui équivaut à void, et qui indique à Interface Builder qu'il est une action (ou méthode de classe) devant être appelée par exemple par un bouton pressé.
* nil qui est identique à NULL. Il sera préféré à celui-ci, car un « message » envoyé à nil ne crée pas une exception, et donc un plantage du programme, mais ne renvoie « rien », donc « nil ».

De plus, toutes les variables d'instances de classe sont par défaut protégées, et les méthodes de classe publiques. Il permet donc aux programmeurs d'avoir une programmation plus rigoureuse, tout en étant plus rapide, et en respectant les concepts de la POO. 

Un autre aspect est celui du modèle de conception KVC (Key-Value Coding), lui aussi inspiré de [[Smalltalk]], qui définit l'accès à une variable par son nom. Par exemple, dans le cas d'une classe Personne, avec une variable d'instance Surname, de type NSString : 

&lt;div style=&quot;border:1px dashed #2fab6f;padding:1em;margin:1em 0;&quot;&gt;&lt;source lang=&quot;objc&quot;&gt;
@interface Personne : NSObject
{
     // variables d'instance
     NSString *surname;
}
// methodes
@property (copy) NSString *surname;
@end
&lt;/source&gt;&lt;/div&gt;

Objective-C permet la création rapide d'objet NSString grâce au @&quot;&quot;, de la même manière que le C avec les chaînes de caractères &quot;&quot;. Les NSString sont encodés en unicode, c'est-à-dire que, contrairement au C, les caractères ne sont pas limités aux codes ASCII. Nous pouvons donc fixer la valeur de la variable surname d'une instance de Personne de cette façon :

&lt;div style=&quot;border:1px dashed #2fab6f;padding:1em;margin:1em 0;&quot;&gt;&lt;source lang=&quot;objc&quot;&gt;
// On crée un pointeur vers un objet de la classe Personne, qu'on a d'abord alloué dans l'espace mémoire, et initialisé.
Personne *exemple = [[Personne alloc] init];
//On envoie un message au pointeur exemple qui va le rediriger vers l'objet vers lequel il pointe, pour fixer la valeur de la clef surname.
[exemple setValue:@&quot;Paul&quot; forKey:@&quot;surname&quot;];
&lt;/source&gt;&lt;/div&gt;

===Messages===

En Objective-C, tout appel de méthode d'une classe est un passage de message. Pour appeler un message sur un objet, on place entre crochet l'objet puis le message. On peut chaîner les appels très facilement. Ainsi dans l'exemple, ''methode'' renvoie un objet et sur cet objet on appelle ''methode2''.

&lt;div style=&quot;border:1px dashed #2fab6f;padding:1em;margin:1em 0;&quot;&gt;&lt;source lang=&quot;objc&quot;&gt;
// passage de message
[objet methode:argument];
// chaînage de message
[[objet methode:argument] methode2:argument2];
&lt;/source&gt;&lt;/div&gt;


La syntaxe des méthodes, un peu déroutante au premier abord, a été pensée pour qu'elle ressemble plus au langage humain. Chaque argument est séparé par « : » ainsi qu'un commentaire.

&lt;div style=&quot;border:1px dashed #2fab6f;padding:1em;margin:1em 0;&quot;&gt;&lt;source lang=&quot;objc&quot;&gt;
// déclaration d'une méthode
- (void)eatWith:(NSString*)name andSpeakAbout:(NSString*)subject;

// exemple d'appel de la méthode sur un objet
[Paul eatWith:Pauline andSpeakAbout:Subject];
&lt;/source&gt;&lt;/div&gt;


Chaque instance d'objet possède un pointeur isa, c'est-à-dire un pointeur sur un objet metaclass qui décrit les méthodes accessibles par l'objet. Une class ayant un parent, les metaclass représentent un arbre avec toute la hiérarchie des classes actuellement en mémoire. Ainsi lorsqu'on tente de passer un message, l'environnement Objective-C récupère le pointeur isa de l'objet, ensuite parcourt l'arborescence de la metaclass pour obtenir le pointeur de la méthode appelée. Ce mécanisme est évidemment coûteux mais un dispositif de mise en cache lors du premier appel le rend très performant.

&lt;div style=&quot;border:1px dashed #2fab6f;padding:1em;margin:1em 0;&quot;&gt;&lt;source lang=&quot;c&quot;&gt;
// définition du type id qui contient le pointeur isa
typedef struct objc_class *Class;
typedef struct objc_object {
    Class isa;
} *id;
&lt;/source&gt;&lt;/div&gt;

== Variantes du langage ==
=== Objective-C++ ===
Objective-C++ est un [[frontal (compilateur)|frontal]] pour [[GNU Compiler Collection|GCC]], lequel compile une combinaison de [[code source|code]] [[C++]] et Objective-C. Objective-C++ ajoute à C++ les extensions que le langage Objective-C ajoute au [[C (langage)|C]].

==Notes et références==

{{références}}

==Voir aussi==
=== Articles connexes ===

* [[Programmation objet]]
* [[ANSI C]]

===Liens externes===

* {{en}} [http://www.toodarkpark.org/computers/objc/ Object-oriented programming and the Objective-C language]
* {{fr}} [http://www.cocoalab.com/?q=BecomeAnXcoder-Francais BecomeAnXcoder-Francais]
* {{fr}} [http://www.siteduzero.com/tutoriel-3-200557-programmez-en-objective-c.html Apprenez l'objective C !]

===Bibliographie===

* {{Ouvrage|éditeur=ENI |collection=Epsilon |série=Informatique technique |titre=Objective-C Créez vos applications iPhone et iPad (Mac 0S, Linux, Windows) |langue=fr|auteur=Gaël Durand, Abdelhalim Rafrafi |lieu=|année=2011 |pages=578 |isbn=978-2-7460-6064-7}}
* {{Ouvrage|éditeur=O'reilly |collection=Précis &amp; concis |série=Fondamentaux du langage |titre=Objective-C |langue=fr|auteur=Andrew M. Duncan |trad=Guillaume Merck |lieu=Paris |année=2003 |pages=135 |isbn=2-84177-257-8}}
* {{Ouvrage|éditeur=Apple|titre=The Objective-C 2.0 Programming Language|langue=en|lieu=Cupertino|année=2008 | mois=07 | jour=08 |pages=147 | |lire en ligne=http://developer.apple.com/documentation/Cocoa/Conceptual/ObjectiveC/ObjC.pdf}}
* {{Ouvrage|éditeur=Addison-Wesley|langue=en| titre=Object-oriented Programming, An Evolutionary Approach |auteurs=Brad J. Cox, Andrew J. Novobilski | lieu=|année=1991 | pages=320 |isbn=978-0201548341}}
* {{Ouvrage|éditeur=O'reilly|langue=en| titre=Learning Cocoa with Objective-C |auteurs=James Duncan Davidson &amp; Apple Computer | lieu=|année=2002 | pages=382 |isbn=9780596003012}}
* {{Ouvrage|éditeur=Sams Publishing|langue=en|titre=Programming in Objective-C|auteur=Stephen G. Kochan|lieu=|année=2003|publi=2004|pages=576|isbn=978-0672325861}}
* {{Ouvrage|éditeur=Addison-Wesley|langue=en|titre=Programming in Objective-C 2.0|auteur=Stephen G. Kochan|lieu=|année=2008|pages=600|isbn=978-0321566157}}


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>3amfv5yu2uruyrk6mtup50yyvh2pwhu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Linotte (langage)</title>
    <ns>0</ns>
    <id>1050015</id>
    <revision>
      <id>101369118</id>
      <parentid>101276415</parentid>
      <timestamp>2014-02-18T15:01:35Z</timestamp>
      <contributor>
        <username>Julien1978</username>
        <id>363502</id>
      </contributor>
      <minor/>
      <comment>[[Projet:JavaScript/Notices/HotCatsMulti|HotCatsMulti]] :  + [[Catégorie:Produit lancé en 2005]]</comment>
      <text xml:space="preserve" bytes="9008">{{homon|Linotte}}
{{à sourcer|date=juin 2010}}
{{Infobox Langage de programmation
| nom                    = Linotte
| logo                   = 
| paradigme              = [[Programmation orientée objet|objet]], [[Programmation orientée prototype|prototype]], [[Programmation structurée|structurée]] et [[Programmation impérative|impérative]]
| année                  = {{Date|22|octobre|2005|en informatique}}
| système d'exploitation = [[Multiplateforme]]
|licence                 = [[Licence publique générale GNU|GNU GPL]]
| site web               = [http://langagelinotte.free.fr/ langagelinotte.free.fr]
}}


'''Linotte''' est un [[langage de programmation]] interprété de type [[L4G]]. Sa particularité est sa syntaxe en français. 

Ce langage est libre et a été créé dans le but de permettre aux enfants et aux personnes n'ayant pas une connaissance approfondie de l’informatique d’apprendre la [[programmation]] facilement. 
Comme sa devise l'indique : « Tu sais lire un livre, alors tu peux écrire un programme informatique », ce langage se veut très simple ; une variante de la devise dit aussi « tu sais écrire une phrase, donc tu sais écrire un programme ».
Il est adapté à l'apprentissage de l'[[algorithmique]] au lycée&lt;ref&gt;Éducation nationale, [http://media.education.gouv.fr/file/Programmes/17/8/Doc_ress_algo_v25_109178.pdf].&lt;/ref&gt;.

== Exemple de [[Hello world|Bonjour le monde]] ==
 BonjourLeMonde :
  début
    affiche &quot;Bonjour le monde !&quot;

== Le [[vocabulaire]] ==

Linotte a la particularité d'utiliser un vocabulaire non technique plutôt proche de termes utilisés, soit dans le monde cinématographique, soit dans la littérature. 

Un programme devient un livre, une variable, un acteur et l'écran, une toile. On n'exécute pas un livre, mais on le lit.

Linotte n'introduit pas de nouveaux concepts mais les renomme tout simplement.

===Le [[livre]]===

Le livre est la structure mère d'un programme écrit en Linotte. Un livre est représenté par un fichier texte dont l'extension est &quot;.liv&quot;.

La première fonction d'un livre est la première lue lors du lancement de la lecture d'un livre.

===Les [[acteur|acteurs]] et les [[R%C3%B4le_(th%C3%A9%C3%A2tre)|rôles]]===

L'association d'une valeur à un nom s'effectue par l'instanciation dans la mémoire de l'ordinateur d'un acteur. 
Chaque acteur est un objet caractérisé par une valeur, un nom et un rôle (son [[Type_(informatique)|type]]).
L'acteur porte la [[S%C3%A9mantique_des_langages_de_programmation|sémantique]] d'une expression en langage Linotte.

L'acteur peut être comparé au mot [[Variable_(informatique)|variable]] que l'on retrouve dans les autres langages de programmation.

Les rôles disponibles en Linotte sont : nombre, texte, drapeau, casier, espèce.

===Les actions===
Un [[Programme_(informatique)|programme informatique]] est une suite d'opérations, un livre en langage Linotte, une suite d'actions. Une action est constituée d'un [[verbe]] et d'acteurs ; elle est destinée à lancer un traitement particulier :

 '''demande''' acteur

 '''affiche''' acteur

 acteur '''vaut''' 5 * 5

==Caractéristiques du langage==

===[[Programmation_imp%C3%A9rative|Programmation impérative]]===

Historiquement implémentée dans le langage, elle offre un accès rapide à la compréhension des bases de la programmation.

  [[Programmation_spaghetti|spaghetti]] :
   début
    affiche &quot;Je suis là&quot;
    va vers deuxième
  
  deuxième :
   début
    affiche &quot;Je suis ici maintenant !&quot;

Exemple d'utilisation de paramètres et de fonctions : 

  nombre Fibonacci : 
   a est un nombre
   début
    questionne a sur &quot;Entrez un nombre :&quot; 
    affiche fibo(a)
  
  fibo : 	
   * n est un nombre 	
   début
    si n est &lt; 2, retourne n 		
    retourne fibo(n-1) + fibo(n-2) 
Il est également possible d'utiliser des acteurs locaux aux fonctions (n'étant visibles à l'exécution que dans cette fonction).

===[[Programmation_orient%C3%A9e_objet|Programmation objet]]===

Les espèces sont un type d'acteur complexe caractérisé par des attributs. Elles permettent au développeur de créer ses propres ''[[objet (informatique)|objet]]s'' :

 espèces
  patte est un nombre
  couleur est un texte
  repas est un texte
  espèce animal contient patte, couleur, repas
  
 principale :
  chat est un animal, patte vaut 4, couleur vaut &quot;noir&quot;, repas vaut &quot;souris&quot;
  début
   affiche repas de chat

===[[Programmation événementielle]]===

Les [[%C3%89v%C3%A9nement|événements]] sont attachés à des [[Swing_(Java)|composants graphiques]] lors de la construction d'[[IHM]] :

  globale      
   form est un formulaire, titre vaut &quot;La boite à texte&quot;, largeur vaut 400, hauteur vaut 260         
   boite est une boite,x vaut 30, y vaut 30, largeur vaut 200, hauteur vaut 100         
   b1 est un bouton, texte vaut &quot;Afficher le texte dans le tableau&quot;, x vaut 30, y vaut 150         
   l1 est une étiquette, texte vaut &quot;&quot;, x vaut 30, y vaut 200         		 
  
  principale :
   début
    ajoute boite &amp; b1 &amp; l1 dans form		         
    '''Fais réagir b1 à &quot;clic souris&quot; pour afficher valeur''' 		
    tant que 1 != 2, lis 			
     temporise	 		
    ferme  
  
  afficher valeur :
   *b est un bouton 	
   début
    affiche texte de boite 		
    reviens

===[[Thread_(informatique)|Traitement parallèle]]===
  
  traitements asynchrone :
   début
    appelle traitement 		
    affiche &quot;On attend 3 secondes&quot; 		
    attends 3 secondes 		
    affiche &quot;Fin des 3 secondes&quot; 		
  
  traitement :
   début
    attends 1 seconde 		
    affiche &quot;....moi, je ne veux pas attendre !&quot; 		
    reviens  

===Manipulation d'objets graphiques===
  
  globale
   centre est un cercle, x vaut 311, y vaut 285, couleur vaut &quot;rouge&quot;, plein vaut &quot;oui&quot;, rayon vaut 50 
   boule est un rectangle,  largeur vaut 40, hauteur vaut 20, couleur vaut &quot;noir&quot;, plein vaut &quot;oui&quot; 
   salle est une toile, couleur vaut &quot;blanc&quot;  
  
  collision :
   début
    efface toile 		
    projette salle &amp; centre &amp; boule 		
    va vers action  
  
  action :
   début
    temporise 		
    déplace boule vers sourisx et sourisy 		
    si boule est en collision avec centre, couleur de centre vaut &quot;jaune&quot; 		
    sinon, couleur de centre vaut &quot;rouge&quot; 		
    va vers action 

===Programmation réseau===

  client :
    connexion est un pont, adresse vaut &quot;localhost&quot; 
    début
     ouvre connexion avec &quot;&quot; depuis &quot;&quot; 	
     décharge message depuis connexion 	
     affiche &quot;Message du serveur&quot; + message 
     ferme connexion 	


===Programmation de [[Page_Web_dynamique|pages Web dynamiques]]===
À partir de la version 1.2.2, le concept de ''weblivre'' est introduit. Il mélange, dans un même fichier, du langage HTML et du langage Linotte. Ce dernier est intégré directement dans le HTML par un balisage précis à l'instar des langages [[PHP]] ou JAVA ([[JSP]]).

&lt;source lang=&quot;html4strict&quot;&gt;
&lt;%action est un texte %&gt;
&lt;%n est un nombre %&gt;
&lt;%durée est un nombre %&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;Suite de Syracuse en ligne&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Suite de Syracuse :&lt;/h1&gt;
&lt;% 
   demande action 
   si action == &quot;resultat&quot;, lis 
      demande n 
      tant que n &gt; 1, lis
		durée vaut durée + 1
		si (n mod 2) == 0, n vaut n / 2
		sinon, n vaut n * 3 + 1
	  ferme		
%&gt;
    La durée du vol est égale à &lt;%affiche durée%&gt;
    &lt;form action=&quot;syracuse.wliv&quot; method=&quot;post&quot;&gt;
	  &lt;input type=&quot;submit&quot; value=&quot;Recommencer&quot; /&gt;
    &lt;/form&gt;	
&lt;% 
   ferme 
   sinon, lis 
%&gt; 
    &lt;form action=&quot;syracuse.wliv&quot; method=&quot;post&quot;&gt;
	  &lt;input type=&quot;hidden&quot; name=&quot;action&quot; value=&quot;resultat&quot; /&gt;
	  Nombre de départ : &lt;input type=&quot;texte&quot; name=&quot;n&quot;  /&gt;
	  &lt;input type=&quot;submit&quot; value=&quot;Calculer la durée&quot; /&gt;
    &lt;/form&gt;
&lt;% 
   ferme 
%&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;/source&gt;

==L'[[Interpr%C3%A8te_(informatique)|interprète]] &quot;L'atelier Linotte&quot;==

Linotte est un langage interprété. Pour l'instant un seul interprète est disponible, mais il reste néanmoins libre. Il est développé en [[Java (langage)|Java]], son [[code source]] est distribué sous la licence GNU-GPL.
Il existe également en version packagée pour les [[plateforme|plateformes]] [[MS-Windows]], [[Ubuntu]], [[Fedora (Linux)|Fedora]], [[Archlinux]] et la clé USB [[Framakey]]

==Le webonotte==

Le Webonotte est un serveur [[HTTP]] intégré à l'Atelier Linotte basé sur [[Jetty]]. Il produit des pages web dynamiques développées en langage Linotte.

== Voir aussi ==
* [[Algobox]]
* [[Inform (programmation)]]

=== Notes et références ===
&lt;references /&gt;

===Liens externes===
*{{fr}} [http://langagelinotte.free.fr/ Site principal]
*{{fr}} [http://www.framasoft.net/article4274.html Présentation sur Framasoft]
*{{fr}} [http://code.google.com/p/langagelinotte/source/checkout Code source de l'Atelier Linotte]

{{Palette Langages de programmation}}
{{Portail|informatique|logiciels libres}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Plateforme Java]]
[[Catégorie:Produit lancé en 2005]]</text>
      <sha1>qybysldem8gjlcdto277j0vqiefmr56</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>RapidQ</title>
    <ns>0</ns>
    <id>1063042</id>
    <revision>
      <id>96444273</id>
      <parentid>90142441</parentid>
      <timestamp>2013-09-06T17:48:34Z</timestamp>
      <contributor>
        <ip>83.44.89.236</ip>
      </contributor>
      <text xml:space="preserve" bytes="5384">{{ébauche|logiciel}}
'''RapidQ''' (aussi connu sous le nom de ''Rapid-Q'') est une variante gratuite et semi-[[Programmation orientée objet|orientée objet]] du [[langage de programmation]] [[BASIC]]. 

Le compilateur est fourni avec des [[Interface de programmation|API]] permettant de développer aussi bien des applications console, [[interface graphique|graphiques]] ou des [[Common Gateway Interface|CGI]]. Il est également fourni avec un [[environnement de développement intégré]] qui permet la création d'interfaces utilisateur par [[glisser-déposer]] ou encore la [[coloration syntaxique]].

Il est désigné comme ''semi-orienté objet'' par son auteur parce qu'il ne supporte que deux types de classe : les classes primitives, intégrées au langage, et les classes dérivées de celles-ci. Il n'est pas possible de créer des classes non dérivées des classes primitives. Le langage intègre en revanche des fonctions peu communes aux langages BASIC, dont les [[Fonction de rappel|fonctions de rappels]] et la gestion des [[Bibliothèque logicielle|bibliothèques partagées]].

Le compilateur RapidQ génère un [[bytecode]] qu'il lie avec son [[Interprète (informatique)|interprète]] pour former un exécutable qui ne nécessite pas l'installation d'un autre logiciel. Ceci a pour conséquence que les programmes RapidQ ont une taille minimale d'environ 150 [[kibioctet]]s. 

RapidQ est disponible pour [[Microsoft Windows]], [[GNU/Linux]], [[Solaris (informatique)|Solaris]] et [[HP-UX]]. 

== Commandes de Rapid-Q ==
{{guide pratique}}
=== Création ===
La création des programmes s'effectue avec des IDE complets comme RQWork ou Easy-Rapid qui permettent de gérer aussi bien les fenêtres que tous les autres types d'objet.

==== DIM ====
* Syntaxe : 
            DIM {nom_valeur} AS {objet prédéfini à créer}
* Utilisation : DIM permet de créer des objets (fenêtre, boîte déroulante, texte...) avec leurs dimensions et autres informations prédéfinies.
* Exemple : 
            DIM listederoulante AS QCOMBOBOX (créer une liste déroulante nommée listederoulante)
==== CREATE ====
* Syntaxe : 
           CREATE {nom_valeur} AS {objet prédéfini à créer}
           {éventuelles dimensions et autres informations sur l'objet}
           {objets à créer (CREATE ou DIM inclus) dans l'objet (si c'est une fenêtre, par exemple)}
           END CREATE
* Utilisation : CREATE permet de créer des objets (fenêtre, boîte déroulante, texte...) en donnant leurs dimensions et autres informations ou en permettant de créer d'autres objets à l'intérieur de l'objet principal).
* Exemple : 
            CREATE fenetre AS QFORM (créer une fenêtre appelée fenetre)
            CREATE texte AS QLABEL (créer une zone de texte appelée texte)
            Caption=&quot;Ceci est un texte QLABEL de RAPID-Q&quot; (écrire le texte entre guillemets)
            END CREATE (texte est créé)
            END CREATE (fenetre est créé)
            fenetre.ShowModal (affiche fenetre)

=== Objets ===
==== QFORM ====
* Syntaxe : 
          DIM {nom de la fenêtre} AS QFORM
* Utilisation : créé une fenêtre du nom demandé.
* Exemple : 
           DIM MaFenetre AS QFORM (créer 'mafenetre' en tant que fenêtre)
           MaFenetre.ShowModal (afficher mafenetre)

==== QBUTTON ====
* Syntaxe : 
          DIM {nom du composant} AS QBUTTON
* Utilisation : créer un bouton tout simple.
* Exemple : 
          DIM MaFenetre AS QFORM (créer 'MaFenetre' en tant que fenêtre)
          DIM MonBouton AS QBUTTON (créer 'MonBoutton' en tant que bouton)
          MonBouton.Parent = MaFenetre (dire qui est le conteneur du bouton ici : MaFenetre)
          MonBouton.caption = &quot;&amp;Ok&quot; (donner un texte au bouton)
          fenetre.ShowModal (afficher mafenetre)

==== QLABEL ====
* Syntaxe : 
          DIM {nom du composant} AS QLABEL
* Utilisation : créer une zone de texte.
* Exemple : 
          DIM MaFenetre AS QFORM (créer 'MaFenetre' en tant que fenêtre)
          DIM MonBouton AS QBUTTON (créer 'MonBoutton' en tant que bouton)
          DIM monLabel AS QLABEL
                    
 '--- Propriétés de 'MonBouton'
          MonBouton.Parent = MaFenetre (dire qui est le conteneur du bouton ici : MaFenetre)
          MonBouton.caption = &quot;&amp;Ok&quot; (donner un texte au bouton)
          Monbouton.top = 8
          MonBouton.left = 60
          
 '--- Propriétés de 'MonLabel'
          MonLabel.Parent = MaFenetre
          MonLabel.caption = &quot;Blah blah blah&quot;
          MonLabel.left = 8
          MonLabel.top = 8
          
          MaFenetre.ShowModal (afficher mafenetre)

== Voir aussi ==
=== Articles connexes ===

* [[BASIC]] 
* [[FreeBasic]], une variante [[logiciel libre|libre]] de BASIC

=== Liens externes ===
* {{en}} [http://www.wildgardenseed.com/RQDP/ RapidQ Documentation Project]
* {{fr}} [http://www.rapidq-france.org/ RapidQ France], une communauté autour de ce langage
* {{en}} [http://rapidq.webcindario.com/ Miroir Rapidq]: copie du web originale de William Yu, qui n'existe plus ; déjà...
* {{en}} [http://rapidq.webcindario.com/Download.htm télécharger le compilateur rapidq et son EDI]


{{Palette Langages de programmation}}
{{Portail|programmation informatique|logiciel}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Compilateur]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour Unix]]</text>
      <sha1>odcr9qst8hrbetubi3cqe4t2bseq1b7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Boo (langage)</title>
    <ns>0</ns>
    <id>1073773</id>
    <revision>
      <id>90141745</id>
      <parentid>82861916</parentid>
      <timestamp>2013-03-14T15:33:08Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 15 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q892948]]</comment>
      <text xml:space="preserve" bytes="1805">{{Voir homonymes|Boo}}
{{Ébauche|informatique}}
{{Infobox Langage de programmation
|  nom                    = Boo
|  logo                   =
|  paradigmes             = [[Programmation orientée objet|Objet]]
|  année                  = [[2003]]
|  auteur                 =
|  développeurs           =
|  typage                 = [[Typage fort|Fort]], [[Typage statique|statique]]
|  implémentations        =
|  dialectes              = 
|  influencé par          = [[Python (langage)|Python]]
|  a influencé            =
|  système d'exploitation =
|  licences               = à la [[Licence MIT|MIT]]/[[Licence BSD|BSD]]
|  site web               = http://boo.codehaus.org/
}}
'''Boo''' est un langage de programmation [[Programmation orientée objet|objet]], avec [[typage statique]] dont le développement a commencé en 2003, cherchant à faire usage de la gestion de l'[[Unicode]], de l'[[Internationalisation de logiciel|internationalisation]] et des applications web de la [[Common Language Infrastructure]], tout en utilisant une syntaxe inspirée de [[Python (langage)|Python]] et en ayant une insistance sur l'extensibilité du langage et du compilateur. Parmi les caractéristiques du langage figurent l'[[inférence de types]], les [[générateur (informatique)|générateurs]], les [[multiméthode]]s, le ''[[duck typing]]'' optionnel, les [[macro-définition]]s, les vraies [[Fermeture (informatique)|fermetures]], la [[curryfication]] et les fonctions de [[Objet de première classe|première classe]].

Boo est sous une licence [[logiciel libre|libre]] à la [[Licence MIT|MIT]]/[[Licence BSD|BSD]].

Boo peut être utilisé avec [[Microsoft .NET]] et [[Mono (informatique)|Mono]].

{{Portail|programmation informatique|Logiciels libres}}
[[Catégorie:Langage de programmation]]</text>
      <sha1>tjy37p8hthtgs8a1xpl99hdqkdmfklm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>C-- (langage intermédiaire)</title>
    <ns>0</ns>
    <id>1111779</id>
    <revision>
      <id>101310503</id>
      <parentid>99094285</parentid>
      <timestamp>2014-02-16T15:45:00Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>trad. + syntaxe + bandeau ébauche (REM. : d. c. au m. de n. ??)</comment>
      <text xml:space="preserve" bytes="1439">{{Ébauche|informatique}}
'''C--''' est un [[langage intermédiaire]], conçu pour être émis par
un [[compilateur]] au lieu du [[langage C]] ou d'un [[langage assembleur]]. La syntaxe du langage emprunte beaucoup à C, d'où le
nom qui suggère que c'est essentiellement un sous-ensemble de C, de la
même manière que [[C++]] est un surensemble du C.

Le langage est conçu comme un langage intermédiaire entre des outils de compilation de haut niveau et des outils de bas niveau comme des
[[Optimisation de code|optimiseurs]]. Les fonctionnalités qui ont été changées ou omises comparé au C, comme les [[fonction variadique|fonctions variadiques]], les [[pointeur (programmation)|pointeurs]] et les parties « avancées » du [[Type (informatique)|système de types]], auraient entravé les fonctionnalités essentielles de C--, telles que la [[récursion terminale]] ou la facilité avec laquelle les outils de [[génération de code]] peuvent produire du code.

C-- est la cible du [[Glasgow Haskell Compiler]] (GHC) et sera finalement sa plate-forme principale. Certains des [[développeur]]s de C--, dont [[Simon Peyton Jones]], travaillent aussi sur GHC. Le développement a lieu à [[Microsoft]] Research à [[Cambridge]], bien que ce ne soit pas un projet Microsoft.

== Liens externes ==
* {{en}} [http://www.cminusminus.org/ Site du C--]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>lnvt8rhlhf4xy2x39i27xf7s4thv5yt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Csound</title>
    <ns>0</ns>
    <id>1117260</id>
    <revision>
      <id>90175200</id>
      <parentid>83585439</parentid>
      <timestamp>2013-03-14T18:51:22Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 9 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q259347]]</comment>
      <text xml:space="preserve" bytes="5278">{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                              = Csound
 | logo                             = 
 | paradigme                        = 
 | auteur                           = Barry Vercoe
 | développeur                      = 
 | date de première version         = 1986
 | dernière version stable          = 5.14
 | date de dernière version stable  = {{Date|13|octobre|2011|en informatique}}
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = 
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = MUSIC IV-BF, MUSIC 11
 | a influencé                      = 
 | système d'exploitation           = [[Multiplate-forme]]
 | licence                          = [[LGPL]]
 | site web                         = [http://www.csounds.com/ csounds.com]
 | date de mise à jour              = 
}}


'''Csound''' désigne un [[langage de programmation]] pour la création sonore, ainsi que son [[compilateur]] sonore. Le nom ''Csound'' provient du [[C (langage)|langage C]], avec lequel il fut écrit au [[Massachusetts Institute of Technology|MIT]] par [[Barry Vercoe]]. Ce langage est inspiré de MUSIC, une série de programmes plus anciens développés par [[Max Mathews]]. C'est un [[logiciel libre]] disponible sous la licence [[Licence publique générale limitée GNU|LGPL]]. Son développement s'est poursuivi durant les années 1990 et 2000 sous la conduite de John Fitch à l'[[université de Bath]], donnant ainsi naissance à la version Csound 5 en février 2005. Beaucoup de développeurs ont contribué à ce projet, notamment Istvan Varga, [[Gabriel Maldonado]] (qui a développé une variante ''[[CsoundAV]]''), Robin Whittle, Richard Karpen, [[Michael Gogins]], [[Matt Ingalls]], [[Steven Yi]] et [[Victor Lazzarini]].

Dans son utilisation la plus simple, le programmeur rédige deux [[fichier texte|fichiers texte]] selon un modèle spécifié et prédéfini : le fichier ''orchestra'' (orchestre) qui décrit la nature des [[Instruments de musique|instruments]] et le fichier ''score'' (partition) qui décrit les [[Note de musique|notes]], ainsi que d'autres paramètres temporels. Csound procède ensuite à la compilation de ces fichiers et génère un [[fichier audio]]. Les versions récentes de Csound peuvent recevoir, traiter et produire, éventuellement en temps réel, des flux audio et des flux [[Musical Instrument Digital Interface|MIDI]].

Les fichiers ''orchestra'' et ''score'' peuvent être réunis dans un seul et même fichier en utilisant une structure avec des balises [[Extensible Markup Language|XML]]. Voici un exemple très simple d'un fichier Csound unifié, lequel produit après compilation un [[WAVEform audio format|fichier Wave]] contenant un signal [[Fonction trigonométrique|sinusoïdal]] d'une durée de 1 seconde, et d'une fréquence de 1 [[Kilohertz|kHz]] à un taux d'échantillonnage de 44,1 kHz :

&lt;source lang=&quot;xml&quot;&gt;
&lt;CsoundSynthesizer&gt;;
  
  &lt;CsOptions&gt;
    csound -W -d -o tone.wav 
  &lt;/CsOptions&gt;
  
  &lt;CsInstruments&gt;
    sr     = 44100           ; Sample rate.
    kr     = 4410            ; Control signal rate.
    ksmps  = 10              ; Samples pr. control signal.
    nchnls = 1               ; Number of output channels.

    instr 1 
    a1     oscil p4, p5, 1   ; Simple oscillator. 
           out a1            ; Output.
    endin
  &lt;/CsInstruments&gt;

  &lt;CsScore&gt;
    f1 0 8192 10 1           ; Table containing a sine wave.
    i1 0 1 20000 1000        ; Play one second of one kHz tone.
    e
  &lt;/CsScore&gt;

&lt;/CsoundSynthesizer&gt;
&lt;/source&gt;

La dernière version, Csound 5, est disponible sous forme de [[fichier binaire]] ou  de [[code source]] pour Linux, Windows et MacOSX. Elle peut également être utilisée sous forme de [[bibliothèque logicielle]] ou d'[[Interface de programmation|API]],
pouvant donc être partie intégrante d'un autre logiciel. Les bibliothèques logicielles sont disponibles en [[C (langage)|C]], [[Python (langage)|Python]], [[Java (langage)|Java]], [[LISP]], [[Tool Command Language|Tcl]], et [[C++]].
 
==Voir aussi==
* [[Synthèse sonore]]
* [[Informatique musicale]]
* [[Musique assistée par ordinateur]]

== Liens externes ==
* [http://www.csounds.com/chapter1/french/ Introduction à la création sonore avec Csound] par Richard Boulanger.
* [http://csound.sourceforge.net/ Csound sur SourceForge] Page du projet sur Sourceforge
* [http://fggp.org/csound/manual-fr/html/ Manuel de référence canonique de Csound] enfin en français.
* [http://sourceforge.net/projects/csound Projet Sourceforge]
* [http://gomba.sourceforge.net/flavio/csound-editor.html Csound Editor] est un environnement de programmation pour CSound.  
* [http://winxound.codeplex.com/ WinXound] est un autre environnement de programmation pour Csound.
* [http://www.csounds.com/stevenyi/blue Blue], un environnement de composition musicale basé sur Csound.

{{Portail|musique|informatique}}

[[Catégorie:Format de données numériques]]
[[Catégorie:Informatique musicale]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>oyahrgsjz6llp61c6h1p3xsu8m5l1gi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Miva Script</title>
    <ns>0</ns>
    <id>272801</id>
    <revision>
      <id>94277410</id>
      <parentid>91106715</parentid>
      <timestamp>2013-06-21T14:43:55Z</timestamp>
      <contributor>
        <username>Romanc19s</username>
        <id>26084</id>
      </contributor>
      <minor/>
      <comment>pluriel de amélioration</comment>
      <text xml:space="preserve" bytes="8912">{{voir homonymes|Miva (homonymie)}}
{{Infobox Langage de programmation
 | nom = Miva Script
 | logo = 
 | paradigme = [[Programmation impérative]] &lt;br /&gt; [[Programmation fonctionnelle|fonctionnelle]]
 | développeur = Miva Merchant Corporation
 | typage = [[Typage dynamique]] &lt;br /&gt; [[Typage fort|faible]]
 | influencé par = [[C (langage)|C]]/[[C++]] 
 | système d'exploitation = [[Multiplate-forme]]
 | licence = Licence privée [http://www.mivamerchant.com/products/compiler/license.html source(en)]
 | site web = [http://www.mivamerchant.com/ www.mivamerchant.com]
}}
'''Miva Script''' est un [[langage de programmation]] propriétaire, et il est utilisé en grande partie pour des applications de [[commerce électronique]] (mais pas seulement). Il a été développé initialement par la société HTML Script Corporate, qui par la suite est devenue la Miva Corporation, basée à  San Diego, Californie. Miva Script a été rachetée par FindWhat Corporation en 2003 (réf.: [http://www.thewhir.com/web-hosting-news/fin090303 en]) qui a changé pour le coup le nom en Miva Corporation. Le 06/08/2007 FindWhat (nouvellement Miva Corporation) revend la société une équipe de management, dirigée par Russell Carroll et Rick Wilson (ancien executive de Miva Corporation) sous le nom de Miva Merchant (réf.: [http://www.mivamerchant.com/company/press/release.mv?Release_ID=95 en])

Malgré le fait que beaucoup de sociétés d’hébergement offrent Miva Script sur leurs serveurs, le langage n’est pas si populaire que son principal concurrent [[PHP]].

==Histoire==
Le langage a été développé initialement sous le nom de [[htmlscript]] par [[Joe Austin]] et autres en 1995 et tout de suite après au bout d’un an ils ont constitué la société HTML Script Corporation.

En 1997, John Burchmore a réécrit intensivement le langage pour lui rendre plus de consistance syntaxique. Le nouveau moteur allait supporter les deux versions de langage : l’ancien Html Script et le tout nouveau baptisé Miva Script.

Des sources non officielles indiquent que le nom (Miva) vient d’un hôtel en Tchéquie où les fondateurs auraient séjourné pendant leur vacances.

En 1998 la société devient Miva Corporation, et, fin 1998, la première version de l’application de commerce électronique [[Miva Merchant]] a été lancée. Cette application va développer très rapidement la corporation qui se voit augmenter considérablement le chiffre d’affaires au bout d’un an. [[Miva Merchant]] devient alors le produit phare de la corporation.

Au 1{{er}} janvier 2004 Miva Corporation a été rachetée par [[FindWhat]] par une transaction de 8 millions de dollars. Joe Austin reste alors le PDG de la société.

Une autre caractéristique de Miva c’est le soin qu’elle apporte à ses développeurs. Une très fidèle communauté tourne autour du langage Miva Script et des produits Miva depuis la création de HTML Script. Depuis 2000 Miva Corporation tient aussi une conférence internationale qui rassemble tous les partenaires Miva mais aussi les développeurs. Dernièrement plusieurs «  anciens » développeurs Miva se sont réunis et ont mis en ligne le site Internet de la communauté [http://www.mivascript.org www.mivascript.org] . Pour information, l’initiative part d’un développeur qui vit en France.

==Le langage==
Miva Script est souvent décrit comme étant « un langage de script basé sur le XML » ce qui est mal approprié. Miva Script est construit des tags qui sont proches du (x)html et qui commencent par le préfixe &lt;Mv.  Les deux langages ont une syntaxe quasiment identique et nous retrouvons aussi des expressions dites « vides ». À partir de la version 3.9 le HTML est « parsée » par le moteur et on peut ajouter des valeurs Miva dans le tags html (ex. : &lt;img src= &quot;{g.source}&quot;&gt; ).

Dans les versions antérieures de l’interprétateur Miva Script nous pouvions utiliser des macros (ex : &amp;[g.value] ). Suite a des nombreuses problèmes de sécurité, les macros ont été supprimés des versions suivantes (ex . : désormais on utilise {g.value} à la place de &amp;[g.value])

Une des plus importantes caractéristiques du langage est le support natif de la vénérable plate-forme de données : [[dBase]]. De plus, les index propriétaires ont rendu ces bases de données très rapides et solides.

Miva Script ne demande pas que les variables soient pré déclarées, ce qui facilite l’écriture des programmes. 

La programmation en Miva Script est très facile et l’apprentissage du langage est très rapide.

==Implémentations==
===Miva Empresa===
Dans les versions antérieures à la version 4.0, [[Miva Empresa]] était le moteur qui faisait fonctionner Miva Script sur le web. Ce moteur était disponible sur les serveurs *ix et [[Microsoft Windows|Windows]]. La dernière version de ce moteur s’arête à 3.96. Les versions suivantes (jusqu'à 4.0) ce sont des versions de transition vers le nouveau et puissant moteur qui va comprendre beaucoup plus de fonctionnalités (comme par exemple les arrays).

À partir de la version 4.0, [[Miva Empresa]] devient une Machine Virtuelle qui permet le fonctionnement du nouveau Miva Script compilé. Ce moteur est disponible pour les serveurs *ix, [[Microsoft Windows|Windows]], [[Bsdi]], [[FreeBSD]], [[solaris (informatique)|Solaris]] et [[Sgi]]. La nouveauté est que le moteur est gratuit (ce qui n’était pas le cas avant).

En 2005 Miva Corporation sort la version 5 du moteur Empresa (toujours gratuite). Ce nouveau né est désormais celui qui a souffert le plus de modification de toutes les versions et les plus attendues de tous les développeurs. Cette version  utilise des nouvelles basse de données : Miva-SQL, [[MySQL]] et DBFIII. À part les améliorations de la plate-forme des données, le langage a été amélioré et a reçu un set de nouvelles fonctions tant attendues par les développeurs (comme les structures par ex.)

===Miva Mia===
[[Miva Mia]] c’est la version locale du moteur Miva. Ce petit moteur a été développe pour une utilisation sous Windows. Très simple a installer, il met en place un petit serveur sur le port 80 (ou autre). Aucun autre logiciel est demandé pour faire fonctionner un site html ou miva sur l’ordinateur. Ce système est parfait pour le développement des sites Miva Script en interne.

Pour chaque version de moteur Empresa, il y a sa petite sœur Mia qui sort. À partir de la version 4 Miva va permettre que le fonctionnement des scripts compilés.

===Miva Script Compiler===
Le tant attendu [[Miva Script Compiler]] a vu le jour en 2002. Le compilateur a fait gagner énormément en vitesse et performance sans oublier qu’il a enlève l’éternel problème du vol de code source. La compilation demande un peu de reformatage du code. Ce dernier ne supporte plus les macros (ex : &amp;[g.value] ) considérés comme étant un risque de sécurité important. En faisant une petite parenthèse, une chose très intéressante est l’influence de la petite communauté Miva sur les décisions d’amélioration du langage par la Corporation. Le problème des macros a été évoqué à plusieurs reprises par les « gurus » de la communauté sans qu’il reste sans écho auprès de Miva. Cette petite victoire démontre aussi l’importance vitale pour Miva Corporation d’avoir une communauté solide autour du langage Miva Script.

Le compilateur est disponible sur *ix, Windows, BSDI, FreeBSD et Solaris. Le fichier compilé fonctionne sur tout serveur qui à le moteur Empresa VM (ou Mia VM ) installé. Son extension est .mvc.

Un geste important de la part de la corporation Miva pour les développeurs  est la version 5 du compilateur qui devient gratuit. Cela renforce l’importance que Miva donne à ses développeurs et à l’évolution du langage. Désormais écrire et utiliser Miva Script devient 100 % gratuit.

== Liens externes ==
* [http://www.mivamerchant.com Le site de Miva Merchant(en)] – site officiel
* [http://smallbusiness.miva.com/support/docs/api/ Ressources Miva pour les Développeurs(en)] - documentation pour le développement Miva Script
* [http://www.mivascript.org mivascript.org(en)] – Le site de la communauté Miva.

== Ressources Miva Script ==
* [http://mivo.truxoft.com mivo.truxoft.com Site de Ivo Truxa(en)] - LES ressources de Ivo .. un des gurus Miva Script
* [http://bytes.com/serversidescripting/mivascript/tutorials/introductiontomivascript/index.html Tutoriels Miva Script (en) ]
*[http://mrmoon.com/download/download.hts Ressources Miva MrMoon(en)] – pas de mise à jour mais toujours bon pour apprendre.

== Développeurs Miva en France ==
* [http://www.idea-graphics.com www.idea-graphics.com] - Idea Graphics
* [http://www.truxoft.com www.truxoft.com] - Truxoft (site en anglais)
{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>8ovhui1a1d18cd23bdgg7hglayzdcb1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>XLispStat</title>
    <ns>0</ns>
    <id>1159285</id>
    <revision>
      <id>96082522</id>
      <parentid>96082472</parentid>
      <timestamp>2013-08-24T17:36:52Z</timestamp>
      <contributor>
        <username>Arbautjc</username>
        <id>1453191</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="1435">{{Minuscule}}
{{Ébauche|informatique}}
'''xLispStat''' est un [[logiciel libre]] multi-plateformes d'[[Statistique|analyse statistique]]. Il a été réalisé par Luke Tierney à la fin des années 80. Luke Tierney s'est basé sur l'interpréteur [[Lisp]] de Thomas Almy [[xLisp-Plus]]. Il a connu un grand essor dans la communauté scientifique dans les années 90 et jusqu'à récemment. Plusieurs plateformes de statistique en sont issues comme Arc&lt;ref&gt;[http://www.stat.umn.edu/arc/]&lt;/ref&gt;. L'intérêt de la communauté scientifique semble s'être émoussé ces dernières années au profit de [[R (logiciel)|R]], lui-même en open source.

Ce logiciel permet de réaliser un grand nombre de traitements statistiques : [[régression linéaire|régressions linéaires]], [[anova]], modèle linéaire généralisé, détection des outliers, graphes dynamiques, etc.

C'est un [[logiciel libre]] distribué sous une licence de type [[Licence BSD|BSD]].

== Notes et références ==
{{références}}

== Liens externes ==
*[http://www.stat.uiowa.edu/~luke/xls/xlsinfo/ Site officiel]
*[http://forrest.psych.unc.edu/research/index.html Vista, logiciel basé sur le xLispStat]
*[http://almy.us/xlisp.html xLisp-Plus]
*[http://www.stat.ucla.edu/xlispstat/ Exemples de programmes]

{{Portail logiciels libres}}

[[Catégorie:Logiciel de statistiques]]
[[Catégorie:Logiciel libre sous licence BSD]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>tfjvzslx2hz2uhwyzjdfkc88xkv0r2y</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Visual Basic for Applications</title>
    <ns>0</ns>
    <id>33799</id>
    <revision>
      <id>101965882</id>
      <parentid>101939882</parentid>
      <timestamp>2014-03-11T09:00:58Z</timestamp>
      <contributor>
        <ip>192.54.144.229</ip>
      </contributor>
      <comment>/* Historique */ orthographe</comment>
      <text xml:space="preserve" bytes="13316">{{voir homonymes|VBA}}
'''Visual Basic for Applications''' (VBA) est une implémentation de Microsoft [[Visual Basic]] qui est intégrée dans toutes les applications de [[Microsoft Office]], dans quelques autres applications Microsoft comme [[Microsoft Office Visio|Visio]] et au moins partiellement dans quelques autres applications comme [[AutoCAD]], [[WordPerfect]], [[MicroStation]], [[Solidworks]] ou encore [[ArcGIS]]. Il remplace et étend les capacités des langages macro spécifiques aux plus anciennes applications comme le langage WordBasic intégré à une ancienne version du logiciel Word, et peut être utilisé pour contrôler la quasi-totalité de l'[[Interface Homme-machine|IHM]] des ''applications hôtes'', ce qui inclut la possibilité de manipuler les fonctionnalités de l'interface utilisateur comme les menus, les barres d'outils et le fait de pouvoir personnaliser les [[Boîte de dialogue|boîtes de dialogue]] et les formulaires utilisateurs.

Comme son nom l'indique, VBA est très lié à [[Visual Basic]] (les syntaxes et concepts des deux langages se ressemblent), mais ne peut normalement qu'exécuter du code dans une ''application hôte'' Microsoft Office (et non pas d'une application autonome, il requiert donc une licence de la suite bureautique Microsoft). Il peut cependant être utilisé pour contrôler une application à partir d'une autre (par exemple, créer automatiquement un document [[Microsoft Word|Word]] à partir de données [[Microsoft Excel|Excel]]).
Le code ainsi exécuté est stocké dans des instances de documents, on l'appelle également macros.

VBA est fonctionnellement riche et extrêmement flexible, mais il possède d'importantes limitations, comme son support limité des [[Fonction de rappel|fonctions de rappel]] (''callbacks''), ainsi qu'une gestion des erreurs archaïque, utilisation de [[wikt:handler|handler]] d'erreurs en lieu et place d'un mécanisme d'[[système de gestion d'exceptions|exceptions]].

Même si ces limitations rendent ce langage très peu utilisé par les développeurs informaticiens soucieux d'utiliser des outils avant tout performants, sa simplicité et sa facilité d'accès ont séduit certaines professions, notamment dans la finance.

== Obsolescence ==
Depuis le 1er juillet 2007, Microsoft ne distribue plus de licences VBA à ses nouveaux clients&lt;ref&gt;http://msdn.microsoft.com/vba/default.asp&lt;/ref&gt; car ils essayent de les remplacer par [http://msdn2.microsoft.com/en-us/vstudio/aa700828.aspx Visual Studio Tools for Applications] (VSTA), un toolkit de customisation d'application basé sur la plateforme [[Framework .NET]]. De [http://blogs.msdn.com/dr._ex/archive/2005/10/03/476435.aspx Dr Ex's article] :

&lt;blockquote&gt;''VSTA remplace maintenant VSA [Visual Studio for Applications] comme technologie [[Independent software vendor|ISVs]] utilisée pour fournir des fonctionnalités de customisation dans leurs  applications.  […] VSA était un [[client léger]], alternative gérée par serveur de  VBA compilé sous  Visual Studio.  L'approche  serveur a été vue par l'ISVs comme moins utile qu'un modèle de client riche, donc, en se basant sur leur retour, Microsoft a commencé le développement de VSTA.  Des ISVs utilisent VSA aujourd'hui, mais nous trouvons que son applicabilité était limitée.  Certaines des technologies développées pour VSA sont reprises dans VSTA.  VSTA application customisation tire un meilleur profit des fonctionnalités du client riche que VSA, offrant un environnement hautement optimisé pour la customisation d'application à la fois sur le  client et le serveur.''
&lt;/blockquote&gt;

&lt;blockquote&gt;{{en}}''VSTA now replaces VSA [Visual Studio for Applications] as the technology [[Independent software vendor|ISVs]] will use to provide customization capabilities in their applications.  […] VSA was a [[thin-client]], server-driven alternative to VBA built on Visual Studio.  The server approach was viewed by ISVs as less useful than a rich-client model, so based on their feedback, Microsoft began development of VSTA.  There are ISVs successfully using VSA today, but we found that its applicability was limited.  Some of the technology developed for VSA is incorporated within VSTA.  VSTA application customization takes better advantage of rich client functionality than VSA, offering a highly optimized environment for application customization on both the client and the server.''
&lt;/blockquote&gt;

[[Office 2007]] continue à utiliser l'ancien moteur VBA; cependant, Visual Studio Tool pour Office (VSTO) est disponible. La prise en charge de VBA dans Microsoft Office pour Mac a été abandonnée avec la distribution de la  version 12, en 2008&lt;ref&gt;{{Lien web|url=http://www.macworld.com/news/2006/08/07/msuniversal/index.php|date=2006-08-07|éditeur=[http://www.macworld.com Macworld]|titre=WWDC: Microsoft updates Universal status of Mac apps|consulté le=25-05-2007}}&lt;/ref&gt; puis réintroduit dans la version 2011&lt;ref&gt;http://www.presence-pc.com/actualite/office-2011-40826/&lt;/ref&gt;. Voir aussi VB.NET.
La première version de VSTA a été fournie en avril 2006 et a été intégrée dans différents  ISV, y compris [[infopath|InfoPath]] 2007 et ABB Robotics.  La prochaine version de VSTA (basée sur  Visual Studio 2008  connu sous le nom de  &quot;Orcas&quot;)  sera distribuée vers février 2008.  La seconde version de VSTA est très différente de la première, avec des fonctionnalités comme la programmation dynamique et la compatibilité  [[Windows Presentation Foundation|WPF]], [[Windows Communication Foundation|WCF]], [[Windows Workflow Foundation|WF]], [[Language Integrated Query|LINQ]], et [[.NET Framework|.NET]] 3.5.

Toutefois, en raison de la dépendance de certaines entreprises à VBA, VBA sera encore disponible dans Office 2007 et 2010 (Office 14)&lt;ref&gt;[http://mac.branchez-vous.com/archives/2008/05/antidote_office.html Antidote, Office 2008, le «SP1» et le retour de «VBA» - Mac+iPod - Logiciels&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;.

== Historique ==
La popularité incroyable de Visual Basic après son lancement amena Microsoft à inclure une version simplifiée dans ses applications de bureautique afin de remplacer les différents langages de macro. Cependant, comme le démontre la chronologie, ce changement s’est fait sur une longue période.&lt;ref&gt;Paul Lomax, ''VB &amp; VBA In a Nutshell'', O'Reilly &amp; Associates Inc, 1998, p. 635 , (ISBN 1-56592-358-8), p. 6&lt;/ref&gt;
* 1993 - Lancement de VBA avec Microsoft Excel 
* 1994 - Inclusion de VBA avec Microsoft Projet 
* 1995 - Inclusion de VBA avec Microsoft Access, remplaçant Access Basic 
* 1996 - Inclusion de VBA dans Microsoft Word, remplaçant Word Basic 
* 1997 - Lancement de VBA 5.0, couvrant la suite Microsoft Office 97 
* 1997 - Microsoft permet l'utilisation de VBA pour d'autres applications 
* 1998 - Lancement de VBA 6.0

== Interopérabilité ==
Une prise en charge minimale de VBA est également disponible dans [[OpenOffice.org]], à partir de la version 3.0&lt;ref&gt;[http://www.generation-nt.com/ooo-openoffice-opensource-bureautique-actualite-92421.html OpenOffice.org 3.0 disponible en version Beta&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;.

== Applications ==
=== Dans Excel ===
L'enregistreur de [[macro]] sous [[Microsoft Excel]] (Onglet Développeur / Enregistrer une Macro) permet de générer facilement du code VBA dans une procédure.

Toute la séquence d'action effectuée entre le début et la fin de l'enregistrement est enregistrée dans une procédure VBA, qui pourra être réexécutée à l'identique. Il est possible de modifier ce code ou de programmer directement dans la VBE (Onglet Développeur / Visual Basic).
C'est la meilleure méthode pour apprendre à se servir de VBA pour les programmeurs néophytes.
Tout d'abord on enregistre une séquence en appuyant sur le bouton d'enregistrement, et ensuite on peut l'exécuter pas à pas (touche F8) dans l'outil VBA afin de savoir les actions effectués par chaque ligne de code.

Les principales collections d'objets du tableur Excel sont '''WorkBook''' (classeur), '''Sheets''' ([[feuille de calcul]]) et '''Range''' ([[Tableur|cellules]]). Elles sont utilisables selon une hiérarchie descendante :
* Workbooks(&quot;Année 2012&quot;).Sheets(&quot;Mars&quot;).Range(&quot;B2&quot;) désigne la cellule B2 de la feuille Mars du classeur Année 2012
* Sheets(&quot;Mars&quot;).Range(&quot;B2&quot;) du classeur actif (ouvert et affiché)
* Range(&quot;B2&quot;) de la feuille active

Une fois un objet désigné :
* une '''méthode''' peut lui être appliquée (NomObjet.NomMéthode) : Range(&quot;B2&quot;).Select sélectionne la cellule B2...
* ses '''propriétés''' (NomObjet.Propriété) peuvent être consultées ou modifiées (affection NomObjet.Propriété=valeur) ; des propriétés courantes sont Visible (à utiliser avec True et False pour afficher ou masquer), Value (valeur d'une cellule), Count (nombre de cellules d'une page, de feuilles de classeur...).

Les '''références''' aux cellules peuvent être :
* '''absolues''' : Range(&quot;B2&quot;) désigne la cellule B2 de la feuille active
* '''relatives''' à la cellule d'origine : ActiveCell.Offset (2,-1) désigne la cellule située 2 lignes plus bas (- pour plus haut) et une colonne à gauche (+ pour à droite) de la cellule active.

[[Microsoft Excel]] permet de créer des '''fonctions personnalisées'''  programmées en code VBA et placées dans un module. Elles sont ensuite accessibles dans la bibliothèque de fonction (Insertion / Fonction / Personnalisée) :

''Function NomFonction (Argument1, Argument2 As TypeDonnées, Optional Argument3=valeur_defaut)
...(actions programmées)
NomFonction = valeur renvoyée
End Function''

Ces fonctions peuvent recevoir des arguments en entrée, dont le type peut être spécifié (Argument2 ci-dessus) ou qui peuvent être optionnels, avec une valeur par défaut (Argument3 ci-dessus).

=== Dans Word ===
Comme pour Excel, l'enregistreur de [[macro]] sous [[Microsoft Word]] (Onglet Développement / Nouvelle Macro) permet de générer facilement du code VBA dans une procédure.

Toute la séquence d'action effectuée entre le début et la fin de l'enregistrement est enregistrée dans une procédure VBA, qui pourra être réexécutée à l'identique. Il est possible de modifier ce code ou de programmer directement dans la VBE (Onglet Développement / Visual Basic Editor).
L'enregistreur de macro est la meilleure méthode pour d'apprentissage VBA pour les programmeurs néophytes.
Tout d'abord on enregistre une séquence en appuyant sur le bouton d'enregistrement, et ensuite on peut l'exécuter pas à pas (touche F8) dans l'outil VBA afin de vérifier les actions effectués par chaque ligne de code.

Les principales collections d'objets du traitement de texte Word sont '''Documents''' (les documents), '''BookMarks''' (les signets du document), '''Range''' (le contenu des signets). Elles sont utilisables selon une hiérarchie descendante :
* Documents(&quot;monDocument&quot;) le document choisi de l'ensemble des documents ouverts 
* BookMarks(&quot;monSignet&quot;) un signet du document actif
* BookMarks(&quot;monSignet&quot;).Range.Text  le texte attaché au signet du document actif

Une fois un objet désigné :
* une '''méthode''' peut lui être appliquée (NomObjet.NomMéthode) : ActiveDocument.SaveAs &quot;monfichier.docx&quot; enregistre le fichier WORD sous WINDOWS sous le nom monfichier.docx ...
* ses '''propriétés''' (NomObjet.Propriété) peuvent être consultées ou modifiées (affection NomObjet.Propriété=valeur) ; des propriétés courantes sont Visible (à utiliser avec True et False pour afficher ou masquer), Text(contenu de paragraphe, de signet ou de sélection), Count (nombre d'objets d'une collection ...).

=== Dans Access ===
Le VBA est grandement utilisé dans les macros et formulaires [[Microsoft Access]].

=== Dans AutoCAD (propriété d'Autodesk, Inc.) ===
{{...}}
=== Dans CATIA v5 (propriété de Dassault Systèmes) ===
{{...}}
=== Dans MicroStation (propriété de Bentley Systems International) ===
{{...}}

== Téléchargement ==
* [http://vb.developpez.com/srcvba Pages sources VBA]

== Liens externes ==
{{Autres projets
|wikibooks=Programmation VBA
|v=Visual Basic
}}
* [http://www.microsoft.com/france/msdn/office/default.mspx Office et XML - Centre de Développement] Site MSDN de Microsoft France
* [http://www.apprentissage-virtuel.com/excel-vba VBA Excel] - Apprentissage-virtuel rubrique VBA Excel
* [http://www.excel-pratique.com/fr/vba.php Cours VBA (Excel) gratuit - Excel-Pratique]
* [http://support.microsoft.com/default.aspx?kbid=163435 VBA: Programming Resources for Visual Basic for Applications]
* {{en}} [http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vbenlr98/html/vaoprAddressOf.asp Callback function limitations] Limitations des fonctions de rappels
* [http://vb.developpez.com developpez.com Club des développeurs VBA]
* [http://www.excel-downloads.com Excel-Downloads VBA sur Excel]Site de passionnés
* {{en}} [http://www.eraserve.com/tutorials/VBA.asp MS Access VBA Exemples]
* {{en}} [http://en.wikibooks.org/wiki/Visual_Basic/Coding_Standards Visual Basic Coding Standards]

== Références ==
&lt;references /&gt;

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Microsoft Office]]
[[Catégorie:Logiciel Microsoft]]</text>
      <sha1>cz5otw3gjhctdlawtqlsy34jrmwtyvl</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Limbo (langage)</title>
    <ns>0</ns>
    <id>934274</id>
    <revision>
      <id>90126293</id>
      <parentid>88236418</parentid>
      <timestamp>2013-03-14T13:12:51Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 12 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q544927]]</comment>
      <text xml:space="preserve" bytes="1947">{{Voir homonymes|Limbo}}
{{ébauche|informatique}}
Le [[langage de programmation]] '''Limbo''' a été créé vers [[1995]] par [[Rob Pike]], [[Sean Dorward]], [[Phil Winterbottom]] avec l'aide de [[Dennis Ritchie]] pour le [[système d'exploitation]] [[Inferno (Système d'exploitation)|Inferno]].

C'est un langage hybride empruntant des fonctionnalités au [[C (langage)|C]], au [[Pascal (langage)|Pascal]], au [[Alef (langage de programmation)|Alef]] de Winterbottom, au [[Communicating sequential processes| CSP]] de [[Tony Hoare]] et au [[Newsqueak]] de Robert Pike.

Le Limbo est un langage qui a été initialement conçu pour Inferno. Le compilateur Limbo génère des objets qui sont interprétés par la [[machine virtuelle]] Dis. Ces objets sont exécutables sur n'importe quelle plateforme disposant de Dis. À l'exception de la machine virtuelle, Inferno est intégralement écrit en Limbo.

Le Limbo est cité dans le livre de [[Dan Brown]] ''[[Forteresse Digitale]]''. Dans l'intrigue, il sert à écrire un pisteur pour retrouver l'adresse d'un compte de messagerie électronique.

== Un exemple de code : un [[Hello World]] ==

&lt;source lang=&quot;c&quot;&gt;
 implement Command;
 
 include &quot;sys.m&quot;;
     sys: Sys;
 
 include &quot;draw.m&quot;;
 
 include &quot;sh.m&quot;;
 
 init(nil: ref Draw-&gt;Context, nil: list of string)
 {
     sys = load Sys Sys-&gt;PATH;
     sys-&gt;print(&quot;Hello World!\n&quot;);
 }
&lt;/source&gt;

== Voir aussi ==

=== Liens externes ===
* {{en}} [http://doc.cat-v.org/inferno/4th_edition/limbo_language/descent A descent into Limbo de Brian W. Kernighan].
* {{en}} [http://doc.cat-v.org/inferno/4th_edition/limbo_language/limbo The Limbo Programming Language av Dennis M. Ritchie].

=== Livres ===
*''Programming in Limbo'' de Rob Pike et Sean Dorward, 1997.
*''Inferno Programming With Limbo'' de Phillip Stanley-Marbell, 2003.


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>g5w2y082zfrf276pknvji6bduekdhq6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rational Modeling Language</title>
    <ns>0</ns>
    <id>482832</id>
    <revision>
      <id>49521101</id>
      <parentid>47739986</parentid>
      <timestamp>2010-02-02T11:16:06Z</timestamp>
      <contributor>
        <username>Arnaud.Serander</username>
        <id>28216</id>
      </contributor>
      <text xml:space="preserve" bytes="10397">Ce langage est une abstraction et une [[Modèle mathématique|modélisation]] de [[langage de programmation]] libre sous licence GNU General Public License, se basant sur la [[théorie des graphes]] et la [[théorie des groupes]]. Il utilise également les travaux réalisés par le consortium OMG qui vient d'éditer UML2. Ce modèle utilise abondamment la notion de récursivité.

Ce langage, à la différence d'[[Unified Modeling Language|UML]], est basé sur la théorie des graphes et la relation entre chaque représentation. Il a une vocation pédagogique et mathématique.

Ce langage définit un système complet par ses représentations. Il définit en premier lieu la famille génératrice et les variables libres du système.
Les variables libres du système sont le temps, la structure, les états, les prédicats.
Pour définir une représentation il est nécessaire de combiner au moins deux dimensions (variables libres) du système : classe, objet, prédicat, temps, état, etc.

== Les vues ==
=== Vue tri-dimensionnelle ===

Pour définir une représentation tri-dimensionnelle, il est nécessaire de sélectionner trois variables libres du système.

Exemple une vue constitué des variables libres : temps, prédicat et classe.

[[Image:Vue3D 1.png]]

=== Vue matricielle ===

Pour définir une représentation matricielle, il est nécessaire de combiner deux dimensions du système.
Pour avoir une vue d'ensemble du système, il faut croiser toutes les combinaisons possibles de ces dimensions.

Le système doit être vu comme un système matriciel qui ne peut être vu que par des &quot;vues&quot;, c’est-à-dire des observables sur ce système. Il peut être intéressant de faire le lien avec les observables en mécanique quantique. 

{| border=&quot;1&quot;
|-----
|
 || classe || objet || prédicat || temps
| état
|-----
| classe
|-----
| objet
|-----
| prédicat
|-----
| temps
|-----
| état
|}

Le premier groupe défini est celui des objets. Il énumère les objets que le système comporte.

Le second groupe défini l'espace des prédicats. Il énumère les prédicats du système. En informatique un groupement de prédicats est appelé interface.

La gestion concurrente est déterminée par la variable libre &quot;temps&quot; et nécessite une projection.

== Les couches d'abstraction  (abstraction layers) ==

Pourquoi des couches d'abstraction ? Car il est impossible de définir un système par énumération. Toutes les fonctionnalités (prédicat ou objet) du système n'ont pas les mêmes valeurs et n'ont pas les objectifs. Il faut faire un tri abstrait.
Lorsque le système est défini, il se positionne dans un environnement spécifique. Les acteurs du système sont positionnés dans la couche N du modèle. 
La couche N défini tous les acteurs, objets et interactions qu'elle peut manipuler par ce niveau d'abstraction.

Nota : Ce concept de couche peut être apparenté à la notion de ''domain'' en [[executable UML]], mais sans la dimension récursive.

Nota2 : un prédicat est vu comme un ''use case'' en UML.

Définition : Un prédicat peut être public ou privé. Un prédicat privé n'est vu que par l'objet qui le manipule. Un prédicat public est vu des acteurs de la couche d'abstraction qui le définit. Un prédicat peut faire appel à un autre prédicat d'une autre couche d'abstraction. Le passage d'une couche d'abstraction N à une autre N-1 est vu comme un paradigme. 

Chaque couche à sa propre ontologie et tout l'art réside dans la connexion des couches entre elles.

Par exemple s'il faut modéliser un logiciel de gestion commerciale, il faut définir des prédicats orienté commerce (''business activity''). Dans ce type de système, une base de données régit les transactions et le stockage des informations. Le logiciel commercial utilise une base de données mais n'est pas là pour définir ce qu'est une base de données, c'est-à-dire la modéliser.

C'est notion d'utilisation est très importante car elle conduit à la notion d'interface. Cette Interface est proposée par une autre couche (N-1 par exemple).

S'il faut modéliser une base de données, il faut définir les prédicats orientés base de données. Elle définit comment est stocké logiquement l'information et non physiquement. Ici le logiciel utilisera le système d'exploitation pour le stockage physique des données.
Il est possible d'aller plus en profondeur pour voir que les fabricants de système d'exploitation modélisent les prédicats spécifiques à l'OS et se base sur les possibilités du micro-processeurs. Les fabricants de micro-processeurs se basent sur les possibilités physiques et mécaniques. Les physiciens étudient les siciles, etc.

Même si dans cet exemple la décomposition du système est simpliste, elle a le mérite de présenter objectivement le besoin de couches d'abstraction. Le périmètre d'une couche d'abstraction à l'heure actuelle ne peut pas être calculé (au sens calculabilité et preuve mathématique).

== Les groupes ==

RML repose sur quatre groupes :
* le groupe des classes
* le groupe des objets
* le groupe des prédicats
* le groupe des méthodes

=== Groupe des classes ===

Ce groupe identifie chaque élément comme une classe. Ce groupe est fini.

=== Groupe des objets ===

Ce groupe identifie chaque élément comme un objet. Ce groupe est infini.
Chaque objet est une instance d'une classe.

=== Groupe des prédicats ===

Ce groupe identifie chaque élément comme un prédicat. Ce groupe est fini.
Un prédicat regroupe les notions UML de cas d'utilisation et opération. Un cas d'utilisation est un prédicat. Une opération est un prédicat.

=== Groupe des méthodes ===

Ce groupe identifie chaque élément comme une méthode. Ce groupe est infini.
Chaque objet est une instance d'un prédicat.

== Portée des noms ==

Le nom des prédicats et des classes est lié à la couche d'abstraction. Le RML n'a pas de grammaire ambiguë. 
En Java comme en UML pour les classes, l'ambiguïté est levée grâce à la notion de ''package'' (ou paquetage). Chaque package à son propre ensemble de nom. Les noms des classes sont préfixés par le nom de package.

Pour les couches d'abstraction il faut bien 

Pour les prédicats en langage orienté objet, l'espace des noms est défini par la classe sur laquelle le prédicat porte. Un prédicat ne peut exister seul alors qu'une classe oui :
 
Classe1 c; // existe 

Classe2.prédicat1(); // existe

prédicat1(); // n'existe pas 

Pour pallier l'impossibilité de créer un prédicat seul, on passe par une interface, qui est une classe ne contenant que des prédicats.

Un nom hors de son contexte peut avoir plusieurs sens.

Exemple : un prédicat dans deux couches d'abstraction

predicat1 : définition 1 (dans la couche 1)

prédicat1 engendre 2 méthodes méthode1 (orienté temps de traitement) et méthode2 (orienté espace alloué).

méthode1 et méthode2 sont équivalentes.

predicat1 : définition 2 (dans la couche 2)

prédicat1 engendre 2 méthodes méthode3 (orienté temps de traitement) et méthode4 (orienté espace alloué).

méthode3 et méthode4 sont équivalentes.

méthode1 et méthode3 ne sont pas équivalentes.

méthode2 et méthode4 ne sont pas équivalentes.

== Les graphes ==

Les graphes se reposent en partie sur les concepts d'UML. Ce n'est pas une copie des diagrammes d'UML mais une reconstruction, brique par brique de façon rationnelle (d'où le terme ''Rational'') les dépendances entre arc et sommet.

Il faut prendre, a minima, deux variables libres pour constituer un graphe. L'ordonnée représentant les sommets et l'abscisse les arcs.
Par exemple, les graphes suivants :

* un graphe G1 (état, temps)
Assis ---10 secondes--→  Debout ---20 secondes--→  Assis

* un graphe G2 (état, prédicat)
Assis ---seLever()--→  Debout ---sassoir()--→  Assis

* un graphe G3 (prédicat, temps)
seLever() ---10 secondes--→  sassoir() ---20 secondes--→  seLever() 

* un graphe G4 (objet, temps)
Homme ---10 secondes--→ Femme ---20 secondes--→  Homme

* un graphe G5 (classe, prédicat)
Chapeau ---tranformer()--→  Chapeau de paille ---tranformer()--→  Casquette

Un des points à aborder est la dualité des graphes, comme on peut le voir dans le tableau ci-avant,  

Par exemple, les graphes suivants :

* un graphe G1 (état, temps)

Assis ---10 secondes--→  Debout ---20 secondes--→  Assis

* G1' (temps, état)
10 secondes ---Assis--→  20 secondes ---Debout--→  .

=== Récursivité ===

Notion de récursivité apparaît dans le fait qu'un graphe est constitué :

- d'un ensemble d'arcs

- d'un ensemble de sommets

Un sommet est soit une variable libre soit un graphe.
Un arc est soit une variable libre soit un graphe.

Pour les prédicats :

Par exemple, le graphe G1 &quot;ouvrir la porte&quot; est composé de la manière suivante : (les états et les arcs ne sont pas forcément nommés)

--- chercher clé -→ . --- insérer clé dans la serrure --→ . --- tourner clé --→

G2 &quot;rentrer chez soi&quot; 

--- prendre métro ---→ . --- arriver maison --→ . --- ouvrir porte --→ .  --- entrer maison --→

Pour les classes :

chien ---estun() --→ animal

labrador --estun() -→ chien

== Les itérations du système ==

Un système est &quot;vivant&quot; dans le sens où un programme informatique évolue sans cesse. Le système par de la première itération S(1) et est itéré jusqu'à n-ième itération S(n). Soit I(i) l'opérateur (au sens mathématique) qui fait passer de S(i) à S(i+1), on obtient :

&lt;math&gt;S(i+1) = I(i) x S(i)&lt;/math&gt;

La version v du système correspond à la n-ième itération pour laquelle le système est jugé correspondre aux spécifications définit.
&lt;math&gt;V(v) = S(n)&lt;/math&gt;

Plusieurs types de version existent : 
* version de développement et intégration : où pour chaque itération I(i), le nombre de classes et de prédicats évolue rapidement.
* version de recette (ou Release Candidate en anglais) : où pour chaque itération I(i), le nombre de classes et de prédicats n'évolue pas. Les versions restent à iso-fonctionnalité. Chaque Itération corrige les défauts du système constatés.
* version stable : cette version est la dernière itération de recette où le système est jugé stable et les défauts majeures et bloquants ont été corrigés.

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>t2npqth3idf3qpjbu4af74c0nomjer1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ROM BASIC</title>
    <ns>0</ns>
    <id>685803</id>
    <revision>
      <id>90037580</id>
      <parentid>80143600</parentid>
      <timestamp>2013-03-13T21:30:19Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q174841]]</comment>
      <text xml:space="preserve" bytes="377">'''ROM BASIC''' est un [[langage informatique]] contenu dans le [[Basic Input Output System|BIOS]] des [[ordinateurs]] (celui qui est conservé en [[mémoire morte|ROM]]), et qui permettait de programmer certaines fonctions de l'ordinateur au niveau du [[boot]] ou des entrées sorties physiques.

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>e1944kpinb2x6qej6c3yqynpvpey8b9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Graph Modelling Language</title>
    <ns>0</ns>
    <id>793098</id>
    <revision>
      <id>90066160</id>
      <parentid>78081329</parentid>
      <timestamp>2013-03-14T01:29:20Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1543319]]</comment>
      <text xml:space="preserve" bytes="412">{{ébauche|informatique}}
'''Graph Modelling Language''' (GML) est un format de fichier hiérarchique basé sur l'[[ASCII]] et décrivant les [[graphe (théorie des graphes)|graphes]].

Il est convertible en format [[graphviz]] (.dot, .gv) sous Linux avec la commande ''gml2gv''.

== Voir aussi ==
* [[GraphML]]
* [[DOT (langage)]]

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ar6tjp9to9p99okvaur453u9a0a6gvh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Run-time type information</title>
    <ns>0</ns>
    <id>107028</id>
    <revision>
      <id>89808401</id>
      <parentid>80296604</parentid>
      <timestamp>2013-03-12T16:39:50Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 9 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q684223]]</comment>
      <text xml:space="preserve" bytes="2810">{{Langue du titre|en}}
En [[informatique]], '''''{{lang|en|Run-Time Type Information}}''''' est utilisé pour signaler la capacité d'un [[langage de programmation]] à déterminer le type d'une variable pendant l'exécution d'un [[programme informatique|programme]].

Bien que disponible dans la plupart des langages de programmation, le terme RTTI est souvent utilisé en référence au [[C plus plus|C++]] qui par défaut, détermine le type à la [[Compilateur|compilation]]. Ce typage dynamique explicite en C++ –&amp;nbsp;déclaré par l'utilisation de l'opération &lt;code&gt;[[dynamic_cast]]&lt;&gt;&lt;/code&gt;&amp;nbsp;– diffère de celui automatique de l'[[Objective-C]] pour lequel le typage et l'[[édition de liens]] sont réalisés lors de l'exécution.

== Exemple ==
Voici un exemple d'utilisation de la RTTI en C++ :

&lt;source lang=&quot;cpp&quot;&gt;
 class point;

 class trait {
   public:
     virtual void dessine() = 0; // fonction virtuelle pure : la classe, abstraite, ne peut être instanciée
     virtual ~trait() {};
 };

 class segment : public trait {  // classe dérivée de trait : doit implémenter dessine()
   public:
     point intersection(segment T);
     point intersection(arc A);
 };

 class arc : public trait {     // classe dérivée de trait : doit implémenter dessine()
   public:
     point intersection(segment T);
     point intersection(arc A);
 };

 point intersection(trait &amp;T1, trait &amp;T2) { 
   segment S2 = dynamic_cast&lt;segment &amp;&gt;(T2);
   arc A2 = dynamic_cast&lt;arc &amp;&gt;(T2);
   if(S2) return T1.intersection(S2);
   if(A2) return T1.intersection(A2);
 } 
&lt;/source&gt;
Comme on peut le voir, le but de la dernière fonction est de trouver le point d'intersection de deux traits dont les types (arc ou segment) ne seront connus qu'à l'exécution du programme (c'est tout l'intérêt de l'[[Héritage (Informatique)|héritage]] : avoir des [[pointeurs]] de la classe mère sur des instances de classes filles). Le [[polymorphisme]] règle le problème pour la première variable (&lt;code&gt;T1&lt;/code&gt;) puisque &lt;code&gt;T1.intersection()&lt;/code&gt; appellera &lt;code&gt;arc::intersection()&lt;/code&gt; ou &lt;code&gt;segment::intersection()&lt;/code&gt; suivant le type de &lt;code&gt;T1&lt;/code&gt;. Il reste cependant le problème du type de l'argument &lt;code&gt;T2&lt;/code&gt; puisqu'un simple appel à &lt;code&gt;T1.intersection(T2);&lt;/code&gt; génère une erreur du compilateur ne sachant quelle [[fonction (informatique)|fonction]] utiliser à l'édition de lien.

Si le typage échoue (ce qui est forcément le cas dans cet exemple, soit pour &lt;code&gt;S2&lt;/code&gt;, soit pour &lt;code&gt;A2&lt;/code&gt;), le programme peut générer une [[exception]] &lt;code&gt;bad_cast&lt;/code&gt;.

== Voir aussi ==
* {{fr}} [http://cpp.developpez.com/cours/stl/#LII-E Un autre cours sur les RTTI, avec la STL]

[[Catégorie:Langage de programmation]]

{{portail programmation informatique}}</text>
      <sha1>et6el8oap7k5phikwn2n3yge63tid42</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Adobe Flex</title>
    <ns>0</ns>
    <id>1192867</id>
    <revision>
      <id>101899733</id>
      <parentid>101284133</parentid>
      <timestamp>2014-03-08T20:16:26Z</timestamp>
      <contributor>
        <username>Traroth</username>
        <id>551</id>
      </contributor>
      <comment>/* Liens externes */</comment>
      <text xml:space="preserve" bytes="9814">{{Voir homonymes|Flex}}

'''Flex''' est une solution de développement créée par [[Macromedia]] en 2004 puis reprise par [[Adobe Systems|Adobe]] en 2006, permettant de créer et de déployer des [[Rich Internet Application|applications Internet riches]] (RIA) [[multiplate-forme]]s grâce  à la technologie [[Adobe Flash|Flash]] et particulièrement son lecteur.  Son modèle de programmation fait appel à [[MXML]] (basé sur [[Extensible Markup Language|XML]]) et  [[ActionScript]] 3.0, reposant sur [[ECMAScript]].

La technologie Flex produit un fichier .swf intégré dans une page html. La richesse de l'interface graphique ainsi créée présente l'inconvénient, comme toute [[applet]], de créer ici un fichier .swf sur le serveur un peu long à télécharger sur le poste client lors du chargement de la page.

Le 26 avril 2007, Adobe annonçait choisir la [[licence libre]] [[Mozilla Public License|MPL 1.1]] pour sa solution de développement Flex&lt;ref name=&quot;La page de Flex&quot;&gt;{{en}} [http://labs.adobe.com/wiki/index.php/Flex:Open_Source Flex:Open Source - Adobe Labs&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;. [[Adobe Flash Player]], le [[lecteur multimédia]] sur lequel les applications Flex sont lues, et [[Adobe Flex Builder]], l'[[Environnement de développement intégré|IDE]] construit sur la plate-forme libre [[Eclipse (logiciel)|Eclipse]] utilisé pour développer des applications Flex, restent propriétaires.

Le 17 novembre 2011, Adobe place Flex sous l'égide de la [[Apache Software Foundation|Fondation Apache]]&lt;ref&gt;{{Lien web
|url=http://www.lemagit.fr/article/developpement-flash-adobe-apache/9882/1/adobe-soumet-flex-fondation-apache/
|titre=Adobe soumet Flex à la fondation Apache
|éditeur=LeMagIT
|consulté le=18 novembre 2011
}}.&lt;/ref&gt;.

== Vue d'ensemble ==

Il était difficile pour les développeurs d'applications traditionnelles de travailler avec la plate-forme Flash en elle-même. En effet, celle-ci sert à la base à créer des animations. Flex cherche à minimiser ce problème en fournissant un modèle de programmation qui est familier à ces développeurs. [[MXML]], un langage de description basé sur [[Extensible Markup Language|XML]], offre la possibilité de créer rapidement une interface utilisateur. L'interactivité est créée par l'utilisation d'[[ActionScript]] 3.0, reposant sur le standard [[ECMAScript]].

Le [[Kit de développement|SDK]] Flex fournit de nombreux composants graphiques, dont des boutons, des listes, des arbres, des tableaux de données, et plusieurs conteneurs utilisés pour la mise en page de l'interface. Les graphiques (Flex Charting) sont disponibles en tant qu'extension. D'autres fonctionnalités comme les [[services Web]], le glisser-déposer, les effets ou la validation de formulaires viennent compléter ce [[framework]] applicatif.

Dans une [[architecture trois tiers]], les applications Flex représentent la couche présentation. Contrairement aux applications HTML, les applications Flex fournissent un client &quot;stateful&quot;, c'est-à-dire que les changements de la vue ne requièrent pas le chargement d'une nouvelle page. De la même manière, Flex et le [[Flash Player]] offrent la possibilité d'envoyer et de recevoir des données depuis et vers un serveur sans que le client ne doive recharger la vue.

== Versions ==

=== Historique des versions ===

* Flex 1.0 - Mars 2004
* Flex 1.5 - Octobre 2004
* Flex 2.0 (Alpha) - Octobre 2005
* Flex 2.0 Bêta 1 - Février 2006
* Flex 2.0 Bêta 2 - Mars 2006
* Flex 2.0 Bêta 3 - Mai 2006
* Flex 2.0 Final- 28 juin 2006
* Flex 2.0.1 - 5 janvier 2007
* Flex 3.0 Bêta 1 - 11 juin 2007
* Flex 3.0 Bêta 2 - {{1er}} octobre 2007
* Flex 3.0 Bêta 3 - 12 décembre 2007
* Flex 3.0 - 25 février 2008
* Flex 3.1 - 15 août 2008
* Flex 3.2 - 17 novembre 2008
* Flex 3.5 - Décembre 2009
* Flex 4.0 - Mars 2010
* Flex 4.1 - Juillet 2010
* Flex 4.5 - Mai 2011
* Flex 4.5.1 - Juin 2011
* Flex 4.6 - Novembre 2011

=== Macromedia Flex Server 1.0 et 1.5 ===
Macromedia a au départ ciblé le développement d'applications entreprise avec ses versions de Flex 1.0 et 1.5. Dans ces premières versions qui ne sont désormais plus disponibles, la compilation des fichiers [[Adobe Flash|SWF]] se faisait au niveau serveur. La licence par [[processeur|CPU]] était de 15000$US et comprenait 5 licences pour l'IDE Flex Builder.

=== Adobe Flex 2 ===

Avec la sortie de Flex 2, Adobe a complètement modifié sa ligne de produit Flex. Le [[Kit de développement|SDK]] Flex 2 a été mis à disposition gratuitement. Il contient un compilateur en ligne de commande (mxmlc) ainsi qu'une bibliothèque de composants graphiques et d'utilitaires. Les applications Flex peuvent être construites et déployées uniquement avec le SDK Flex 2.

Adobe a basé sa nouvelle version de Flex Builder sur la plate-forme [[Eclipse (logiciel)|Eclipse]] open-source. Flex Builder 2 était distribué en deux versions: Standard et Professionnelle. La version Professionnelle contient la bibliothèque de composants Flex Charting, utilisée pour la création de graphiques.

La composante serveur reste encore disponible grâce à Flex Data Services 2. Contrairement à Flex 1.0 et 1.5, Flex Data Services n'est pas requis pour déployer des applications Flex.

Avec la sortie de Flex 2, Adobe a introduit la nouvelle version de son langage de programmation [[ActionScript]], ActionScript 3. L'utilisation d'ActionScript 3 et de Flex 2 requiert la version 9 ou ultérieure de [[Flash Player]].

=== Adobe Flex 3 ===

Le 25 février 2008, Adobe a annoncé la sortie du SDK Flex 3 sous licence [[Mozilla Public License]] ainsi qu'[[Adobe AIR]] 1.0, sa solution RDA. Dans le même temps, Adobe a sorti le nouveau Flex Builder 3, toujours basé sur Eclipse, permettant de développer des applications Flex et Air.

=== Adobe Flex 4 ===

Version disponible depuis décembre 2009. Cette version apporte une nouvelle bibliothèque de composants personnalisables nommée Spark ainsi que le support de fichiers FXG. Une nouvelle version du compilateur conçu par Adobe accompagne sa sortie, renommée en Flash Builder 4.

=== Adobe Flex 4.5 ===

Sortie début mai 2011, Flash Builder 4.5 intègre la version 4.5 du SDK Flex. La principale nouveauté réside dans la possibilité de compiler des applications mobiles pour Google Android, Apple iOS ou encore BlackBerry Tablet OS.
Une version d'évaluation de 60 jours est disponible en téléchargement sur le site officiel.

== Exemple ==

Voici un exemple d'application Flex 3 utilisant MXML et ActionScript :

&lt;code&gt;
 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
 &amp;lt;mx:Application xmlns:mx=&quot;http://www.adobe.com/2006/mxml&quot; layout=&quot;absolute&quot;&amp;gt;
   &amp;lt;mx:Script&amp;gt;
     &amp;lt;![CDATA[
       // Code ActionScript 3.0 directement intégré dans le fichier MXML
       // Ce code pourrait être placé dans un fichier séparé avec l'extension .as
       public function sayHello():void {
         lblResults.text = &quot;Hello &quot; + txtName.text;
       }
     ]]&amp;gt;
   &amp;lt;/mx:Script&amp;gt;
   &amp;lt;mx:Panel x=&quot;10&quot; y=&quot;10&quot; width=&quot;306&quot; height=&quot;200&quot; layout=&quot;absolute&quot; title=&quot;Say Hello&quot;&amp;gt;
     &amp;lt;mx:Label x=&quot;10&quot; y=&quot;10&quot; text=&quot;Entrez votre nom :&quot;/&amp;gt;
     &amp;lt;mx:TextInput x=&quot;10&quot; y=&quot;36&quot; id=&quot;txtName&quot;/&amp;gt;
     &amp;lt;mx:Button x=&quot;178&quot; y=&quot;36&quot; label=&quot;Dis Bonjour!&quot; click=&quot;sayHello()&quot;/&amp;gt;
     &amp;lt;mx:Label x=&quot;10&quot; y=&quot;66&quot; id=&quot;lblResults&quot;/&amp;gt;
   &amp;lt;/mx:Panel&amp;gt;
 &amp;lt;/mx:Application&amp;gt;
&lt;/code&gt;
Ce code dessine un formulaire permettant à un utilisateur de saisir son nom puis d'afficher &quot;Hello + [le nom saisi]&quot; lorsque l'on clique sur le bouton &quot;Dis Bonjour!&quot;.

Le même exemple avec Flex 4 et en utilisant les composants Spark:

&lt;code&gt;
 &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
 &amp;lt;s:Application xmlns:fx=&quot;http://ns.adobe.com/mxml/2009&quot;
                   xmlns:s=&quot;library://ns.adobe.com/flex/spark&quot;
                   xmlns:mx=&quot;library://ns.adobe.com/flex/mx&quot;&amp;gt;
   &amp;lt;fx:Script&amp;gt;
    &amp;lt;![CDATA[
    // Code ActionScript 3.0 directement intégré dans le fichier MXML
    // Ce code pourrait être placé dans un fichier séparé avec l'extension .as
    public function sayHello():void {
     lblResults.text = &quot;Hello &quot; + txtName.text;
    }
   ]]&amp;gt;
   &amp;lt;/fx:Script&amp;gt;
   &amp;lt;s:layout&amp;gt;
     &amp;lt;s:BasicLayout /&amp;gt;
   &amp;lt;/s:layout&amp;gt;
   &amp;lt;s:Panel x=&quot;10&quot; y=&quot;10&quot; width=&quot;306&quot; height=&quot;200&quot; title=&quot;Say Hello&quot;&amp;gt;
    &amp;lt;s:layout&amp;gt;
      &amp;lt;s:BasicLayout /&amp;gt;
    &amp;lt;/s:layout&amp;gt;
    &amp;lt;s:Label x=&quot;10&quot; y=&quot;10&quot; text=&quot;Entrez votre nom :&quot;/&amp;gt;
    &amp;lt;s:TextInput x=&quot;10&quot; y=&quot;36&quot; id=&quot;txtName&quot;/&amp;gt;
    &amp;lt;s:Button x=&quot;178&quot; y=&quot;36&quot; label=&quot;Dis Bonjour!&quot; click=&quot;sayHello()&quot;/&amp;gt;
    &amp;lt;s:Label x=&quot;10&quot; y=&quot;66&quot; id=&quot;lblResults&quot;/&amp;gt;
  &amp;lt;/s:Panel&amp;gt;
 &amp;lt;/s:Application&amp;gt;
&lt;/code&gt;

== Voir aussi ==

* [[Microsoft Silverlight]]
* [[Synchronized Multimedia Integration Language|SMIL]]
* [[JavaFX]]
* [[ActionScript Foundry]]
* [[FXG]], format de fichier graphique

== Liens externes ==
* {{fr}} [http://www.adobe.com/fr/products/flex/ Site officiel d'Adobe]
* {{en}} [http://flex.apache.org/ Site officiel de la fondation Apache]
* {{fr}} [http://www.flexx.fr/ Communauté française sur Flash, Flex et AIR]
* {{fr}} [http://flash.developpez.com/cours/?page=flex Cours et tutoriels sur Flex]
* {{en}} [http://livedocs.adobe.com/flex/3/langref/class-summary.html Documentation de l'API Flex 3]
* {{en}} [http://sites.google.com/site/reflexutil ReflexUtil] - une extension (open source) pour l'exécution d'essais et de conception de Flex

== Référence ==
&lt;references /&gt;


{{Palette|Langages de programmation|Apache Software Foundation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:XML]]
[[Catégorie:Interface utilisateur]]
[[Catégorie:Technologie Flash]]
[[Catégorie:Interface riche|Adobe Flex]]</text>
      <sha1>qsqzpskqlzybyhxxijxkzf0jea1ma6h</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Perl 6</title>
    <ns>0</ns>
    <id>896854</id>
    <revision>
      <id>100955088</id>
      <parentid>99967790</parentid>
      <timestamp>2014-02-06T05:15:49Z</timestamp>
      <contributor>
        <username>Grondilu</username>
        <id>336659</id>
      </contributor>
      <comment>/* Dispatch multiple */ suppr. mot anglais</comment>
      <text xml:space="preserve" bytes="40428">{{Infobox Langage de programmation
|  nom                    = Perl 6
|  logo                   = Camelia.svg
|  paradigmes             = [[Programmation orientée objet|Objet]], [[Programmation impérative|impératif]], [[Programmation fonctionnelle|fonctionnel]], [[Langage de programmation dynamique|dynamique]]
|  année                  = [[Spécification (informatique)|Spécification]] : 2001-présent, mise en œuvre partielle par Rakudo Star
|  auteur                 = [[Larry Wall]]
|  développeurs           = [[The Perl Foundation]]
|  dernière version       = 
|  typage                 = [[Typage fort|Fort]], [[Typage dynamique|dynamique]]
|  implémentations        = [[Pugs]], Rakudo (via [[Parrot (machine virtuelle)|Parrot]])
|  dialectes              = 
|  influencé par          = [[Perl (langage)|Perl]], [[Haskell]], [[APL (langage)|APL]], [[Ruby]], [[Python (langage)|Python]], [[SmallTalk]], [[Self (langage)|Self]]
|  a influencé            = 
|  système d'exploitation = [[Multi-plate-forme]]
|  licences               =
|  site web               = http://perl6.org
}}
'''Perl 6''' est la sixième [[version d'un logiciel|version majeure]] du [[langage de programmation]] '''[[Perl (langage)|Perl]]'''.   Il s'agit aussi d'une refonte profonde du langage, aussi bien dans sa conception que dans son implémentation, rompant avec l'exigence de [[rétrocompatibilité]] qui avait primé pour les versions majeures précédentes.

Cette refonte garde tout de même l'esprit du langage qui laisse une grande liberté au programmeur et lui permet une expression concise.  Perl 6 reste un langage générique et permet toujours de programmer des [[uniligne]]s, mais il facilite aussi l'écriture de programmes importants, grâce à des fonctionnalités telles que le typage statique des données et un meilleur support de la [[programmation orientée objet]].

Contrairement aux versions antérieures de Perl, Perl 6 n'est pas défini par une implémentation de référence, mais par des spécifications en langage naturel, dont la rédaction a commencé en avril 2001&lt;ref&gt;[http://www.perl6.org/archive/doc/design/apo/A01.html Apocalypse 1]&lt;/ref&gt;.  Ces spécifications sont publiques et par conséquent tout développeur est libre de créer son implémentation.  Perl 6 ne dispose donc pas d'une implémentation unique et en 2012, au moins trois projets tentent d'implémenter le langage.  En 2013, aucun d'entre eux n'implémente la totalité de la spécification.

La [[fondation Perl]] détient le ''[[copyright]]'' d'une de ces implémentations: ''rakudo'', ciblant la machine virtuelle [[Parrot (machine virtuelle)|Parrot]].  Rakudo  est elle-même en grande partie écrite en Perl 6, ce qui lui fait jouer un rôle particulièrement important au sein de la communauté de développeurs en Perl6.

Le logo de Perl 6 est appelé Camelia&lt;ref&gt;{{Lien web
   | url         =  http://svn.pugscode.org/pugs/misc/camelia.txt
   | titre        = camelia
   | année       =  2009
   | éditeur     = 
   | site        =  dépôt svn de pugs
   | consulté le =  1 septembre 2009
}}&lt;/ref&gt;. C'est un papillon, sur les ailes duquel on peut lire la lettre ''P'' et le chiffre ''6''.

&lt;!-- 
A RECYCLER  tout ce qui suit encombre l'intro.  A recycler dans le corps de l'article

Le langage permet toujours d'écrire des programmes très concis, notamment grâce aux
[[compositeur (informatique)|compositeurs]] et aux ''hyperopérateurs''. Ces derniers sont similaires aux opérateurs de manipulation de tableaux dynamiques du langage [[APL (langage)|APL]]. C'est un des aspects de la [[syntaxe concrète]] qui permet de [[Calcul parallèle|paralléliser]] l'exécution de portions de programmes.

Le langage est complexe mais il est toujours possible de programmer dans un sous-ensemble restreint du langage. Il inclut beaucoup de fonctionnalités qui, pour d'autres langages, appartiennent généralement à des bibliothèques logicielles. Ainsi le système d'[[expression rationnelle|expressions rationnelles]] a été entièrement refondu et constitue aussi un moteur d'[[analyse syntaxique]] puissant et rapide grâce à un contrôle très fin du [[retour sur trace]].
&lt;br /&gt;Il est complètement intégré au système objet.
&lt;br /&gt;Le système objet, minimaliste en Perl 5, supporte maintenant le [[dispatch multiple]], les [[trait (type abstrait)|rôles]]&lt;ref&gt;{{Lien web
   | url         =  http://perlcabal.org/syn/S14.html
   | titre       =  Roles and Parametric Types 
   | auteur      = [[Larry Wall]]
   | année       =  2010
   | éditeur     = 
   | site        =  perlcabal.org
   | consulté le =  5 avril 2010
}}&lt;/ref&gt; et la [[réflexion (informatique)|réflexion]] via un [[Protocole à méta-objets]] inspiré de [[CLOS]].
&lt;br /&gt;La [[programmation orientée prototype]] et la [[programmation orientée objet]] sont toutes deux possibles car le programmeur peut modifier le comportement par défaut des [[métaclasse]]s et du mécanisme de dispatch vers les méthodes et multiméthodes.
Les rôles sont un système de composition de code similaire aux [[mixin]] mais de [[granularité]] inférieure à la [[classe (informatique)|classe]].

Les concepteurs de Perl 6 ont apporté un soin tout particulier à la syntaxe du langage qui avait été notablement alourdie en Perl 5 avec l'ajout du support des [[Référence (informatique)|références]]. Les principes directeurs dans la conception du
langage sont : le [[principe de Huffman]], la lisibilité, l'extensibilité.
Chaque aspect du langage est hautement paramétrable via des constructions lexicales ou syntaxiques appelés adverbes ou modificateurs. Certains [[opérateur (informatique)|opérateurs]] sont des caractères [[Unicode]] mais souvent un alias plus verbeux en [[ASCII]] est disponible. L'interopérabilité avec les bibliothèques d'autres [[langage de haut niveau|langages dynamiques de haut niveau]] est un but à terme grâce à la mise en œuvre de ces langages par le même moteur ([[Pugs]] ou [[Parrot (machine virtuelle)|Parrot]]).

Le typage explicite du contenu d'une variable est optionnel. Le typage des données est donc [[typage statique|statique]] lorsqu'il est explicite ou [[inférence de types|inferré]], [[typage dynamique|dynamique]] sinon.
&lt;br /&gt;Le programmeur dispose donc d'un continuum entre la programmation lâche typique des [[langage de script|langages de script]] et la rectitude et les performances d'un langage à typage statique. Typiquement, un programme évoluera au cours du temps vers un typage plus &quot;serré&quot;.

Perl 6 devrait être un langage rapide car, outre le typage statique, le support de la parallélisation, ses implantations supportent la [[compilation à la volée]] en [[code natif]].

FIN &quot;A RECYCLER&quot;
--&gt;
==Motivations==
Le langage Perl était au départ très modeste et a grossi en respectant la [[Compatibilité ascendante et descendante|rétrocompatibilité]]. Créé en 1987, Perl a accumulé beaucoup de scories qui rendent son apprentissage difficile et complexifient inutilement l'interpréteur. Il fallait s'en débarrasser. Les comportements par défaut du langage étaient conçus pour des programmes de quelques lignes. Même si le langage avait évolué ([[Portée lexicale|variables lexicales]], orientation objet…) pour supporter de gros programmes, une grande partie des programmeurs n'avaient pas adapté leur style, ce qui a donné à Perl une réputation de langage sale.

L'interpréteur de Perl 5 n'utilise pas au mieux les architectures multiprocesseurs ou [[microprocesseur multi cœur|multi cœur]] dont la mémoire est lente par rapport au processeur. De plus, pour la programmation en grand, il est nécessaire d'avoir un système puissant de passage de paramètres. De même il était important de donner la possibilité au programmeur, mais non l'obligation, d'un typage statique des données. Ce typage constitue à la fois une documentation, une forme d'assertion exécutée à la compilation et une amélioration des performances par rapport au typage dynamique.

== Historique ==
Le processus de conception de Perl 6 a été annoncé pour la première fois le 19 juillet 2000, par [[Larry Wall]] le {{4e}} jour de la conférence annuelle [[OSCON]] dans son discours sur l'état de l’oignon 2000 (« State of the Onion 2000 »). À cette date, les principaux objectifs étaient de débarrasser le langage de verrues historiques (''historical warts'') et de nettoyer d'une manière générale la conception interne et les API.  Le tout était alors résumé par la phrase:  « les choses faciles doivent rester faciles, les choses difficiles doivent être plus faciles, et les choses impossibles ne devraient pas être difficiles ».

Le processus a commencé avec une série de demandes de changements ou « RFC » (par analogie aux ''[[Request for comments]]'' d'internet). Ce processus était ouvert à tous les contributeurs et ne laissait aucun aspect du langage à l’abri du changement. Alors que Larry Wall s'attendait à recevoir une vingtaine de RFC, 361 demandes de changements furent émises par les membres de la communauté PERL.

Une fois le processus des RFC terminé, Wall a revu et classé chaque demande. Il a alors commencé la rédaction de ce qu'il a alors appelé les Apocalypses. Bien que le but initial était d’écrire une Apocalypse pour chaque chapitre du manuel de référence en perl intitulé « Programmation en Perl », il est devenu évident à la rédaction de chacune des Apocalypses que les précédentes apocalypses devenaient invalides de par les derniers changements. Pour cette raison, un ensemble de synopsis ont été publiés, chacun relatif au contenu d’une Apocalypse, mais mis à jour suivant les modifications apparues. Aujourd’hui, les spécifications de Perl 6 continuent presque entièrement à travers les Synopsis.

Au fil des ans, Perl 6 a connu plusieurs changements de direction. L’introduction de concepts provenant de [[Python (langage)|Python]] et [[Ruby]] ont influé au début, mais lors de l’écriture de l’interpréteur pugs dans le langage [[Haskell]], on a pu noter une large influence de la programmation fonctionnelle sur l’équipe de conception de Perl 6.

[[Pugs]] est historiquement la première [[mise en œuvre]] expérimentale de Perl 6.  Pugs peut exécuter du code Perl 6 directement, ainsi que compiler du Perl 6 vers du [[JavaScript]], du [[Perl (langage)|Perl 5]] ou du [[bytecode]] Parrot. Écrit essentiellement par Audrey Tang, maintenant peu active, Pugs utilise des fonctionnalités avancées de Haskell, ce qui est un obstacle à la reprise du projet par d'autres programmeurs.

Durant 2006, [[Pugs]] était suffisamment avancée pour permettre d'écrire des jeux de tests, de valider, de corriger et d'affiner les spécifications.

== Mises en œuvre ==
En 2013, au moins deux projets implémentent un sous-ensemble conséquent de Perl 6.
===[[Niecza]]===
Niecza est un compilateur ciblant la machine virtuelle du [[Framework .NET]].
===[[:en:rakudo|Rakudo]]===
Rakudo est une implémentation utilisant la machine virtuelle [[Parrot (machine virtuelle)|Parrot]], et visant à terme l'[[Auto-hébergement (informatique)|auto-hébergement]] de Perl 6.
Parce qu'il est lui-même essentiellement écrit en Perl 6, Rakudo est susceptible d'être porté relativement facilement vers d'autres machines virtuelles.  Le portage vers la [[Machine virtuelle Java]] a commencé en 2013, ainsi que vers [[:en:MoarVM|MoarVM]], une machine virtuelle conçue spécialement pour faire tourner Rakudo.
La communauté Perl n'a pas la main d'oeuvre pour maintenir une machine virtuelle moderne avec des optimisations dynamiques de code telles que celles fournies par [[Crankshaft_(Moteur_Javascript)|CrankShaft]] de [[V8 (moteur JavaScript)|V8]], il est donc probable que d'autres machines virtuelles lui succéderont.

Rakudo, dont le copyright est détenu par la [[fondation Perl]], sera probablement la première mise en œuvre substantielle de Perl 6.  Pour le [[bootstrap (compilateur)|bootstrap]] de Perl 6, Rakudo utilise NQP (Not Quite Perl), un sous-ensemble de Perl 6 avec qui comporte le moteur d'analyse syntaxique.

Une distribution spéciale de rakudo, appelée ''Rakudo Star'', incluant divers modules afin de la rendre &quot;utile et utilisable&quot;&lt;ref&gt;« This is Rakudo Star, a useful, usable Perl 6 distribution for &quot;early adopters&quot;. » [http://github.com/rakudo/star/blob/master/README README du projet]&lt;/ref&gt; est publiée mensuellement depuis juillet 2006&lt;ref&gt;{{Lien web
   | url         =  http://rakudo.org/announce/rakudo-star/2010.07
   | titre       =  Annonce de Rakudo Star
   | auteur      =  Patrick Michaud
   | année       =  2010
   | éditeur     = 
   | site        =  rakudo.org
   | consulté le =  29 Juillet 2010
}}&lt;/ref&gt;.

== Changements incompatibles ==

Perl 6 est la première version majeure de Perl qui n'est pas rétrocompatible avec les versions précédentes.  Cela signifie qu'un code écrit en Perl5 échouera probablement à la compilation ou à l'exécution si on tente de l'exécuter ou de le compiler sans modification comme s'il s'agissait de code Perl6.

Les changements incompatibles sont nombreux, mais les plus notables sont l'invariance du sigil, les simplifications syntaxiques et le passage d'arguments.

&lt;!--   A RECYCLER
Perl 6 garde l'esprit de Perl 5.
La plupart des changements apportés ont pour but de rendre le langage plus
homogène, d'intégrer de nouvelles fonctionnalités et de mieux exploiter les
architectures matérielles modernes. 
Les nouvelles fonctionnalités 
sont un puissant système de passage de paramètres, la [[curryfication]]&lt;ref&gt;{{Lien web
   | url         =  http://perlcabal.org/syn/S06.html#Currying
   | titre       =  Currying
   | auteur      = [[Larry Wall]]
   | année       =  2010
   | éditeur     = 
   | site        =  perlcabal.org
   | consulté le =  5 avril 2010
}}&lt;/ref&gt;
, le support du [[typage statique]]
(mais son utilisation reste optionnelle),
l'[[évaluation paresseuse]],  l'expression du parallélisme dans le code source pour
utiliser au mieux les [[multiprocesseur]]s ou les [[microprocesseur multi cœur|processeurs multi cœur]], et, optionnellement, l'[[inférence de types]]. Le dispatch multiple et le mécanisme puissant de liage d'arguments permettent notamment de supporter des fonctionnalités similaires au [[filtrage par motif]] de la programmation fonctionnelle&lt;ref&gt;{{Lien web
   | url         =  http://use.perl.org/~pmichaud/journal/35400
   | titre       =  Functional-style pattern matching
   | auteur      = 
   | année       =  2010	
   | éditeur     = http://groups.google.com/group/perl.perl6.language/browse_thread/thread/afcf25a9c42f9765#
   | site        =  perl.perl6.language
   | consulté le =  11 mars 2010
}}&lt;/ref&gt;.

Le but est, selon Larry Wall, de rendre les choses simples plus simples et les choses compliquées plus facilement réalisables.
--&gt;
=== Invariance du sigil ===

En Perl 5, le [[Sigil (informatique)|sigil]] — le caractère non alphanumérique qui précède un nom de variable — pouvait changer selon son contexte d'utilisation
(scalaire ou tableau) :
&lt;source lang=&quot;perl&quot;&gt;
 # Perl 5 code
 my @array = 0, 1, 2, 3;
 my $element = $array[1]; # $element est égal à 1
&lt;/source&gt;
En Perl 6, l'abondance des contextes possibles nécessite un mécanisme différent
des sigils. Le sigil ne désigne plus le contexte d'accès. Perl 6 propose des opérateurs spécialisés pour ce faire. Le sigil d'une variable est donc invariant. Il est plus pédagogique d'avoir
deux mécanismes syntaxiques pour deux fonctions grammaticales différentes (le
typage faible de la variable et son contexte d'accès).
&lt;source lang=&quot;perl&quot;&gt;
 # Perl 6 code
 my @array = 0, 1, 2, 3;
 my $element = @array[1]; # $element est égal à 1
&lt;/source&gt;


=== Passage de paramètres ===

Les versions antérieures de Perl définissent les sous-routines sans liste formelle de [[paramètre]]s&lt;ref&gt;Cependant le système de prototypes, ajout tardif au langage Perl 5, est un moyen de vérification du nombre de paramètres et une faible vérification de type&lt;/ref&gt;.

Les arguments de sous-routines entrant dans une sous-routine devenaient des alias dans les éléments du tableau &lt;tt&gt;@_&lt;/tt&gt;. Si &lt;tt&gt;@_&lt;/tt&gt; était modifié, les changements étaient reflétés dans les données originales :
&lt;source lang=&quot;perl&quot;&gt;
 # Code Perl 5
 sub incr { $_[0]++ }
 my $x = 1;
 incr($x); # $x est maintenant 2
 incr(3); # erreur lors de l'exécution : &quot;Essai de modification d'une valeur en lecture seule&quot;
&lt;/source&gt;

Même en tenant compte de l'invariance du sigil, la plupart des déclarations de fonctions en Perl5 échoueront si on cherche à les exécuter comme du code Perl6, car Perl 6 utilise un système très différent de passage de paramètres, grâce à un formalisme dans le langage qui va au-delà des [[signature de type|signatures de types]]. &lt;!-- developper --&gt; En Perl 6, une déclaration de sous-routine ressemble à :
&lt;source lang=&quot;perl&quot;&gt;
 sub faire-quelquechose(Str $chose, Int $autre) { … }
&lt;/source&gt;
Comme en Perl 5, les paramètres formels (exemple, les pseudo-variables dans la liste de paramètres) sont aliasés en leurs paramètres effectifs (valeurs d'entrées), mais par défaut, les alias sont marqués &lt;tt&gt;is readonly&lt;/tt&gt; signifiant qu'ils sont en lecture seule et donc constants  :
&lt;source lang=&quot;perl&quot;&gt;
 sub incr(Num $x) {
   $x++; # compile-time error
 }
&lt;/source&gt;
Si un paramètre formel est suivi par &lt;tt&gt;is copy&lt;/tt&gt; ou &lt;tt&gt;is rw&lt;/tt&gt;, cependant, il ''peut'' être modifié. Dans le cas &lt;tt&gt;is copy&lt;/tt&gt;, Perl 6 copie les paramètres actuels plutôt que des les aliaser ; ainsi ils peuvent être modifiés, mais les changements restent locaux à la sous-routine. Dans le cas &lt;tt&gt;is rw&lt;/tt&gt; (&lt;tt&gt;rw&lt;/tt&gt; signifie lecture-écriture, ''read-write'' en anglais), l'alias n'est pas marqué readonly. Ce changement détecte aussi, lors de la [[Compilateur|compilation]], des erreurs telles que :
&lt;!--ne pas mettre ici de balise source...--&gt;
 sub incr(Num $x is rw) { $x++ }
 incr(3); # erreur au moment de la compilation
 sub incr-copy(Num $x is copy) { $x++ }
 incr-copy(3);  # Pas de problème

De nouvelles fonctionnalités de Perl 6 dans les listes de paramètres rendent le passage de paramètres beaucoup plus puissant qu'en Perl 5 :
* &lt;tt&gt;=&lt;/tt&gt; après un paramètre permet d'assigner des valeurs par défaut.
* &lt;tt&gt;?&lt;/tt&gt; après un paramètre indique des arguments optionnels.
* &lt;tt&gt;:&lt;/tt&gt; avant un paramètre indique un argument nommé (passé comme élément d'hash).
* &lt;tt&gt;where&lt;/tt&gt; peut fournir une condition que le paramètre doit respecter.

Par exemple :
&lt;source lang=&quot;perl&quot;&gt;
 sub mysplit(Rule $pat? = rx/\s+/, Str $expr? = $_, Int $lim? where $^lim &gt;= 0) { … }
&lt;/source&gt;
Perl 6 supporte aussi la [[curryfication]].

=== Simplification syntaxique ===

Les changements de syntaxe entre Perl5 et Perl6 sont nombreux et parfois subtils.  Par exemple une règle fondamentale en Perl6 est l'interdiction absolue d'avoir deux termes consécutifs.  C'est pourquoi la syntaxe d'une fonction telle que &lt;code&gt;map&lt;/code&gt; fait désormais apparaître une virgule.  Ainsi un code Perl5 tel que:

&lt;source lang=&quot;perl&quot;&gt;# Perl5
say $_ for map { $_**2 } 1 .. 3;
&lt;/source&gt;

échouera à la compilation si on cherche à l'exécuter comme du code Perl6.  Il faudra ajouter une virgule entre la fonction anonyme et la liste:

&lt;source lang=&quot;perl&quot;&gt;# Perl6
say $_ for map { $_**2 }, 1 .. 3;
&lt;/source&gt;

Pour les mêmes raisons, la notation objet indirecte (qui était de toute façon déconseillée par la communauté) a disparu.

== Nouveaux concepts et fonctionnalités ==

=== Syntaxe auto-hébergée ===
La syntaxe de Perl 6 est elle-même définie en Perl 6.  Ce point qui peut paraître anodin a des conséquences très profondes sur la structure et les possibilités offertes par le langage.

En particulier, cela signifie que Perl 6 obéit syntaxiquement aux même règles que celles imposées par les fonctionnalités d'analyse textuelle du language.  Ainsi, l'[[analyse lexicale]] satisfait aux mêmes priorités que celles imposées par le traitement des [[expressions régulières]] en Perl 6.  En l'occurrence, cette règle est, en simplifiant, celle de la plus longue unité lexicale (''longuest token matching'').  Cette règle est fondamentale en Perl 6 et possède une grande portée sur de nombreux aspects du langage.  Par exemple, la règle de la plus longue unité lexicale permet aux noms de variables de contenir le caractère '-', sans que celui-ci soit confondu avec la [[soustraction]].

Une autre conséquence est la possibilité pour le langage de modifier sa propre syntaxe en cours d'exécution, ce qui constitue une performance accomplie par de très rares langages de programmation, le plus emblématique étant [[Lisp]].

=== Types de données ===

Le système statique de typage de Perl 5 comporte peu de types. Lors de la déclaration d'une variable, son [[sigil (informatique)|sigil]] détermine si elle est de type [[scalaire]], [[tableau (structure de données)|tableau]] ou hash ([[métonymie|métonyme]] pour [[table associative]]). Un scalaire peut contenir un [[entier (informatique)|entier]], un [[nombre flottant|flottant]] ou
une [[chaîne de caractères]]. Puisque le type du contenant ne détermine que partiellement
le type du contenu, on parle de typage semi-dynamique.

En Perl 6, les sigils et le [[typage dynamique]] de Perl 5 ont été étendus par l'addition de [[typage statique|types statiques]]. Cela consiste en la déclaration explicite du type du
contenant. Par exemple :
&lt;source lang=&quot;perl&quot;&gt;
 my Int $i = 0;
 my Num $n = 3.141;
 my Str $s = &quot;Hello, world&quot;;
&lt;/source&gt;
Cependant, tout comme en Perl 5, les programmeurs peuvent se passer de typage explicite :
&lt;source lang=&quot;perl&quot;&gt;
 my $i = &quot;25&quot; + 10;
&lt;/source&gt;
Le typage statique est une forme de documentation et de tests intégrée au code source. Il améliore la maintenance, spécialement dans les grands projets logiciels. Mais le typage statique alourdit le code de [[langage de script|scripts]] courts ou d'[[uniligne]]s. Ce style concis sans déclaration explicite de type autre que par les sigils est une force du Perl lorsque utilisé pour l'écriture de code à usage
unique.

Perl 6 introduit aussi des sigils secondaires appelés [[twigil]]s.

=== Orientation objet ===

Perl 5 supportait l'[[orientation objet]] via un mécanisme propre à Perl et nommé
bénédiction. N'importe quelle [[référence (informatique)|référence]] pouvait être bénie comme étant un objet d'une [[classe (informatique)|classe]] particulière, comme :
&lt;source lang=&quot;perl&quot;&gt;
 # Perl 5 code
 my $object = bless $reference, 'Class';
&lt;/source&gt;
Un objet béni pouvait alors avoir des [[méthode (informatique)|méthodes]] invoquées en utilisant la « syntaxe flèche » :
&lt;source lang=&quot;perl&quot;&gt;
 # Perl 5 code
 $objet-&gt;méthode();
&lt;/source&gt;
L'invocation identifie la [[sous-routine]] appropriée de nom &lt;code&gt;méthode&lt;/code&gt;, et l'appelle avec &lt;code&gt;$objet&lt;/code&gt; comme premier argument.

Bien que très puissant — virtuellement n'importe quel autre modèle objet d'un autre langage pouvait être simulé en utilisant cette simple fonctionnalité — il rendait le cas le plus commun d'orientation objet, comme une
structure [[langage C|C]] associée à du code, inutilement difficile. De plus, Perl ne pouvant faire d'hypothèse sur le modèle objet utilisé, l'invocation de méthode ne pouvait pas être très bien optimisée.

Dans l'esprit de rendre les choses simples plus simples, et les choses compliquées faciles, Perl 6 garde le principe de bénédiction pour créer une instance pour les programmeurs qui désirent des fonctionnalités communes. Cela fournit un modèle objet plus robuste pour les cas communs. Par exemple, une classe pour encapsuler un [[point (géométrie)|point]] [[coordonnées cartésiennes|cartésien]] peut être écrite comme :
&lt;source lang=&quot;perl&quot;&gt;
 class Point is rw {
   has ($.x, $.y);
   method gist { &quot;Point a x=$.x y=$.y&quot; }
 }
&lt;/source&gt;
et utilisée :
&lt;source lang=&quot;perl&quot;&gt;
 say my Point $point .= new: :x(1.2), :y(-3.7);
 $point.x = 1.1;
 say $point;
&lt;/source&gt;
Le point remplace la flèche (propre à Perl 5) comme opérateur d'accès au membre d'une instance. C'est la syntaxe propre à
de nombreux langages dont [[C++]], [[Java (langage)|Java]], [[Python (langage)|Python]], et [[Ruby]].

Notez que les méthodes « &lt;code&gt;x&lt;/code&gt; » et « &lt;code&gt;y&lt;/code&gt; » ne sont pas déclarées explicitement. Elles sont appelées des auto-accesseurs. Le modificateur « is rw » 
dans la définition de la classe permet à tous ses attributs publics d'être écrits par défaut, en utilisant les auto-[[Méthode_(informatique)|accesseurs]].[http://dev.perl.org/perl6/doc/design/syn/S12.html]

Les données membres d'une instance sont appelés « attributs ». Elles peuvent être déclarées ainsi :
&lt;source lang=&quot;perl&quot;&gt;
 has $.a; # mode d'accès par défaut (généralement en lecture seule)
 has $.b is rw; # accès en lecture et en écriture
 has $!c; # membre privé; pas d'accesseur public
 has $d; # comme $!d
&lt;/source&gt;

=== Résolution multiple ===

Dans un même champ lexical, on peut définir plusieurs routines ou méthodes du même nom en les
préfixant par le mot-clé multi. On parlera de multi&lt;ref&gt;{{Lien web
   | url         =  http://perlcabal.org/syn/S06.html#Unpacking_tree_node_parameters
   | titre       =  Unpacking tree node parameters
   | auteur      = [[Larry Wall]]
   | année       =  2010
   | éditeur     = 
   | site        =  perlcabal.org
   | consulté le =  5 avril 2010
}}&lt;/ref&gt; pour désigner l'ensemble des routines
ou méthodes de même nom. Lors de l'appel d'une multi,
la routine ou méthode dont la signature correspond aux arguments passé sera appelé.
Le système de liage entre les arguments de l'appel et les paramètres de l'appelé est très pointu&lt;ref&gt;{{Lien web
   | url         =  http://use.perl.org/~JonathanWorthington/journal/39772
   | titre       =  The new Rakudo signature binder has landed
   | auteur      = Jonathan Worthington
   | année       =  2009
   | éditeur     = 
   | site        =  useperl.org
   | consulté le =  5 avril 2010
}}&lt;/ref&gt;.

Ainsi, pour traverser un arbre n-aire, l'argument attendu est soit un nœud de type Nary
dont les enfants sont un tableau commençant par l'$ainé et suivi éventuellement de @frères,
soit une $feuille. 
&lt;source lang=&quot;perl&quot;&gt;
    multi traverser ( NAry $noeud ( :enfants [$ainé, *@frères] ) ) {
        traverser($ainé);
        traverser(:enfants(@frères));  # (lie @frères à $sommet)
    }
    multi traverser ( $feuille) {…}
&lt;/source&gt;
Ce système de multiméthodes inclut donc la fonctionnalité de filtrage par motif propre à la programmation fonctionnelle.

=== Expressions rationnelles ===

Les expressions rationnelles
&lt;ref&gt;{{Lien web
   | url         =  http://perlcabal.org/syn/S05.html
   | titre       =  Regexes and Rules
   | auteur      = [[Larry Wall]]
   | année       =  2010
   | éditeur     = 
   | site        =  perlcabal.org
   | consulté le =  5 avril 2010
}}&lt;/ref&gt;
(en anglais, ''regex'', pour ''regular expression'') de Perl ont connu tellement de succès qu'elles ont été mises en œuvre par une bibliothèque appelée [[PCRE]] (Perl Compatible Regular Expressions). 
Via PCRE, les expressions rationnelles ont été incluses sans amélioration dans beaucoup d'autres langages.
Pourtant, comme le fait remarquer Larry Wall, ce sont les expressions rationnelles qui ont contribué à donner à Perl une réputation de langage peu lisible.
Elles sont trop compactes et trop malignes, les mêmes caractères sont utilisés pour des usages divers. Il y a peu de support pour les captures nommées, peu de support pour les grammaires, et une intégration pauvre avec les langages réels&lt;ref&gt;{{Lien web
   | url         =  http://dev.perl.org/perl6/doc/design/apo/A05.html
   | titre       =  Pattern Matching
   | auteur      = [[Larry Wall]]
   | année       =  2010
   | éditeur     = 
   | site        =  dev.perl.org
   | consulté le =  5 avril 2010
}}&lt;/ref&gt;.

Perl 6 fournit un sur-ensemble des fonctionnalités de Perl 5 concernant les expressions rationnelles.
Le mécanisme des regex fournit une puissance comparable aux analyseurs syntaxiques.
Ces regex agissent comme des [[fermeture]]s par rapport à leur champ lexical. 
Les regex sont introduites avec un des mots-clefs &lt;code&gt;rule&lt;/code&gt;, &lt;code&gt;regex&lt;/code&gt;, &lt;code&gt;token&lt;/code&gt;.
La définition d'une regex est similaire à une définition de sous-routine et peut admettre des
paramètres. Le choix du mot-clef permet de contrôler si les espaces sont significatifs
ou non dans la regex, et de spécifier s'il peut y avoir retour sur trace ou non.
Comme en Perl 5, on peut aussi définir des regex anonymes ou les utiliser directement dans les opérateurs &lt;code&gt;m&lt;/code&gt; (matching) ou &lt;code&gt;s&lt;/code&gt; (chercher et remplacer).

Seules six fonctionnalités n'ont pas été changées depuis les regex du Perl 5 :
* Littéraux : les caractères de mots tels que « A » et souligné seront reconnus littéralement.
* Capture : &lt;code&gt;(...)&lt;/code&gt;
* Alternatives : &lt;code&gt;|&lt;/code&gt;
* Séquences d'échappement par barre oblique inverse (backslash) : &lt;code&gt;\&lt;/code&gt;
* Les quantificateurs de répétition : &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, et &lt;code&gt;?&lt;/code&gt;
* Suffixe de reconnaissance minimale : &lt;code&gt;*?&lt;/code&gt;, &lt;code&gt;+?&lt;/code&gt;, &lt;code&gt;??&lt;/code&gt;
Quelques-uns des ajouts les plus efficaces sont :
* La possibilité de référencer des règles en utilisant &lt;code&gt;&lt;rulename&gt;&lt;/code&gt; pour construire des grammaires entières.
* Des opérateurs de commission permettent au programmeur de contrôler les [[retour sur trace|retours sur trace]] pendant la reconnaissance.
Les changements suivants ont grandement augmenté la lisibilité des regexes :
* Simplification des groupes non-capturant : &lt;code&gt;[...]&lt;/code&gt; qui sont les mêmes que ceux du Perl 5's : &lt;code&gt;(?:...)&lt;/code&gt;
* des codes assertions simplifiés : &lt;code&gt;&lt;?{...}&gt;&lt;/code&gt;
* Le &lt;code&gt;/x&lt;/code&gt; de Perl 5 est maintenant le défaut.

Exemples :
&lt;source lang=&quot;perl&quot;&gt;
 rx { a [ b | c ] ( d | e ) f : g }
 rx { ?( ab* ) &lt;{ $1.size % 2 == 0 }&gt; }
&lt;/source&gt;
La dernière ligne est identique à :
&lt;source lang=&quot;perl&quot;&gt;
 rx { ( ab[bb]* ) }
&lt;/source&gt;
=== Comparaisons chaînées ===

Les nouveaux programmeurs attendent souvent que les [[Relation d'ordre|comparaisons]] chaînées&lt;ref&gt;{{Lien web
   | url         =  http://feather.perl6.nl/syn/S03.html#Chained_comparisons
   | titre       =  Chained Comparaisons
   | auteur      = [[Larry Wall]]
   | année       =  2010
   | éditeur     = 
   | site        =  feather.perl6.nl
   | consulté le =  5 avril 2010
}}&lt;/ref&gt;

comme dans l'uniligne ci-dessous fonctionnent :
&lt;source lang=&quot;perl&quot;&gt;
 if 1 &lt;= $dé1 == $dé2 &lt;= 6 { say &quot;Doubles!&quot; }
&lt;/source&gt;
En Perl 6, ce code fonctionne maintenant naturellement, dans l'esprit du [[DWIM]] (''Do What I Mean''), et s'exécute comme :
&lt;source lang=&quot;perl&quot;&gt;
 if 1 &lt;= $dé1 and $dé1 == $dé2 and $dé2 &lt;= 6 { say &quot;Doubles!&quot; }
&lt;/source&gt;
=== Évaluation paresseuse ===
Perl 6 propose l'[[évaluation paresseuse]] de listes qui est une fonctionnalité de certains langages de [[programmation fonctionnelle]] tels que [[Haskell]].
L'évaluation paresseuse simplifie des tâches communes en Perl6 comme les opérations d'entrées/sorties, la
transformation de listes et le passage d'arguments à une routine :
&lt;source lang=&quot;perl&quot;&gt;
 my @integers = 0 .. *; # entiers de 0 à l'infini
&lt;/source&gt;
Le code ci-dessus ne [[crash (informatique)|crashera]] pas en essayant d'assigner une liste de taille infinie à la table &lt;code&gt;@integers&lt;/code&gt;.

===Meta-opérateurs===

Les méta opérateurs sont des opérateurs qui agissent sur un autre opérateur pour obtenir un opérateur au comportement différent.

====Opérateurs d'affectation====
Perl5 avait hérité de certains opérateurs emblématiques du langage C tels que '+=', '*=' etc.   Perl6 généralise cette notion avec le métaopérateur d'affectation '='.  

Ainsi, pour n'importe quel opérateur binaire ''Op'', on peut écrire:
&lt;source lang=perl&gt;$x Op= $y; # ou encore $x [Op]= $y&lt;/source&gt;
Pour:
&lt;source lang=perl&gt;$x = $x Op $y;&lt;/source&gt;
''Op'' peut très bien être un opérateur défini par l'utilisateur.

====hyper-opérateurs====
Les ''hyper-opérateurs'' sont similaires aux opérateurs de manipulation de tableaux dynamiques du langage [[APL (langage)|APL]].  Ils agissent sur un opérateur et le font opérer sur toutes les valeurs d'un tableau.  Ainsi, pour créer un tableau dont tous les éléments sont ceux d'un tableau @a auxquels on a ajouté 1, il suffit d'écrire :

&lt;source lang=&quot;perl&quot;&gt;my @a-plus-un = @A »+» 1;  # aussi noté @A &gt;&gt;+&gt;&gt; 1&lt;/source&gt;

====Opérateur de réduction====
{{...}}
&lt;source lang=&quot;perl&quot;&gt;say &quot;La somme des cent premiers entiers naturels est: &quot;, [+] ^100;&lt;/source&gt;

====Opérateur de produit cartésien====
{{...}}
&lt;source lang=&quot;perl&quot;&gt;say my @chessboard = 'a'..'h' X~ 1 .. 8;&lt;/source&gt;

====Opérateur ''Zip''====
{{...}}
&lt;source lang=&quot;perl&quot;&gt;say my @diagonal = 'a' .. 'h' Z~ 1 .. 8;&lt;/source&gt;

====Opérateur de permutation&lt;!-- traduction proposée pour &quot;reversed operator&quot;--&gt;====
{{...}}
&lt;source lang=&quot;perl&quot;&gt;say &quot;un tiers est égal à &quot;, 3 R/ 1;&lt;/source&gt;

====Imbrication de méta-opérateurs====
{{...}}
Les méta-opérateurs peuvent être imbriqués, quitte à utiliser des crochets ('[]') pour désambiguïser.
&lt;source lang=&quot;perl&quot;&gt;
@a &gt;&gt;&gt;&gt;&gt; $b        # huh?
@a &gt;&gt;[&gt;]&gt;&gt; $b      # oh yeah
&lt;/source&gt;

=== Jonctions ===

Perl 6 introduit le concept de ''jonctions''.
Nous choisissons ce terme pour le distinguer des [[Jointure (informatique)|jointures]], concept propre aux  [[base de données relationnelle|bases de données relationnelles]].
Les jonctions sont des valeurs scalaires composites.
Les jonctions ont été initialement appelées superpositions, par analogie au concept de [[physique quantique]] de [[superposition]]s quantiques — des courbes qui peuvent simultanément occuper plusieurs états jusqu'à ce que leur observation les ''effondre''. Un module Perl 5 réalisé en l'an [[2000]] par [[Damian Conway]] appelé &lt;code&gt;[http://search.cpan.org/dist/Quantum-Superpositions/lib/Quantum/Superpositions.pm Quantum::Superpositions]&lt;/code&gt; fournissait une preuve de concept initiale. D'abord une curiosité programmatique, les jonctions sont ensuite devenus un concept important de Perl 6.

Dans leur forme la plus simple, les jonctions sont créées par combinaison d'un ensemble de valeurs avec l'[[opérateur]] de jonction :
&lt;source lang=&quot;perl&quot;&gt;
 my $even_digit = 0|2|4|6|8; # any(0, 2, 4, 6, 8)
 my $odd_digits = 1&amp;3&amp;5&amp;7&amp;9; # all(1, 3, 5, 7, 9)
 my $not_zero = none(0);
&lt;/source&gt;
Ces valeurs peuvent être utilisées arithmétiquement :
&lt;source lang=&quot;perl&quot;&gt;
 my $jonction = 1|2|3;
 $jonction += 4; # jonction maintenant égale à 5|6|7
 $jonction += (1&amp;2); # jonction maintenant égale(6|7|8)&amp;(7|8|9)
&lt;/source&gt;
ou dans des comparaisons :
&lt;source lang=&quot;perl&quot;&gt;
 if $grade eq any('A'..'D') { say &quot;pass&quot; }
&lt;/source&gt;
ou même pour l'accès à un tableau :
&lt;source lang=&quot;perl&quot;&gt;
 if %person{any('first_name', 'nickname')} eq &quot;Joe&quot; { say &quot;What do you know, Joe?&quot; }
&lt;/source&gt;
Les jonctions peuvent aussi être utilisées pour étendre le système de types :
&lt;source lang=&quot;perl&quot;&gt;
 class RGB_Color is Tuple[int, 3] &amp; Color { … }
 sub get_tint (RGB_Color|CMYK_Color $color, num $opacity where 0 &lt;= $^opacity &lt;= 1) { … }
 sub store_record (Record&amp;Storable $rec) { … }
&lt;/source&gt;
Les jonctions ne sont pas ordonnées ; &lt;code&gt;1|2|3&lt;/code&gt; et &lt;code&gt;3|2|1&lt;/code&gt; représentent les mêmes valeurs. Cette absence d'ordre signifie que le compilateur Perl 6 peut choisir d'évaluer les expressions jonctives ''en parallèle''. En fait, plusieurs dans la communauté Perl 6 croient que les jonctions peuvent surpasser l'explicite [[multithreading]] comme manière ordinaire d'accomplir le [[parallélisme (informatique)|parallélisme]] en Perl 6.

=== Macros ===

Dans les langages de bas niveau, le concept de [[macro]]s a été synonyme de substitutions textuelles du code source à cause de la large utilisation d'un [[préprocesseur]] ignorant la syntaxe du langage.
Le [[langage C]] utilise la construction &lt;code&gt;#define&lt;/code&gt;.
Perl 5 utilise des systèmes de [[filtre (informatique)|filtres]] sources à cet effet. Ils sont notoirement peu fiables, car leur empilement a des effets aléatoires. En effet, chaque filtre suppose que le code qu'il filtre est du code Perl 5 alors qu'il reçoit du code modifié par ces prédécesseurs.
&lt;br /&gt;[[Lisp]] est privilégié, car il propose un système de macros qui manipulent directement l'arbre syntaxique correspondant au source du programme.  C'est facile car sa [[syntaxe concrète]] est identique à sa syntaxe abstraite.  A terme, Perl6 vise à intégrer un système de macro tout aussi puissant qu'en Lisp, ce qui constitue l'un des objectifs les plus ambitieux du langage.

Perl 6 proposera les deux types de macro&lt;ref&gt;{{Lien web
   | url         =  http://feather.perl6.nl/syn/S06.html#Macros
   | titre       =  Macros
   | auteur      = [[Larry Wall]]
   | année       =  2010
   | éditeur     = 
   | site        =  feather.perl6.nl
   | consulté le =  5 avril 2010
}}&lt;/ref&gt;: substitutions textuelles et manipulation de l'[[Abstract syntax tree|AST]].
&lt;br /&gt;Une définition de macro Perl 6 ressemblera à une définition de sous-routine ou méthode, et peut travailler sur des chaînes non analysées, un arbre de syntaxe abstrait [[Abstract syntax tree|AST]] représentant du code préanalysé, ou encore une combinaison des deux. Une définition de macro pourrait ressembler à :

 &lt;nowiki&gt;
 macro hello($what) {
    quasi { say &quot;Hello { {{{$what}}} }&quot; };
 }
 &lt;/nowiki&gt;
Dans cet exemple particulier, la macro n'est pas plus complexe qu'une substitution textuelle en C, mais parce que l'analyse du paramètre de la macro se produit avant que la macro n'opère sur le code appelé, les messages de diagnostic seront beaucoup plus informatifs. Cependant, parce que le corps de la macro est compilé à chaque lancement du programme, diverses techniques d' [[optimisation de code|optimisation]] peuvent être employées.

== Hello world ==

En Perl 6 comme en Perl 5, on peut écrire
&lt;source lang=&quot;perl&quot;&gt;
   print &quot;Hello world\n&quot;;
&lt;/source&gt;
En Perl 6, on préfèrera écrire le [[hello world]] ainsi :
&lt;source lang=&quot;perl&quot;&gt;
 say &quot;Hello world&quot;;
&lt;/source&gt;
&lt;code&gt;say&lt;/code&gt; est semblable au &lt;code&gt;say&lt;/code&gt; de [[Restructured Extended Executor|REXX]], au &lt;code&gt;writeln&lt;/code&gt; de [[Pascal (langage)|Pascal]] et au &lt;code&gt;puts&lt;/code&gt; de [[Ruby]] et [[C (langage)|C]].

== JAPH ==

Comme en Perl 5, les [[Just Another Perl Hacker|JAPH]]s (programmes qui impriment « Just another Perl hacker »), sont de bons moyens d'expérimentation avec Perl 6.
Ici un exemple de [[curryfication]] :
&lt;source lang=&quot;perl&quot;&gt;
 sub japh (Str $lang) { say &quot;just another $lang hacker&quot;; }
 my &amp;perl6Japh := &amp;japh.assuming(&quot;Perl6&quot;);
 perl6Japh();
&lt;/source&gt;

== Voir aussi ==

* [[Pugs]], la mise en œuvre en Haskell.
* [[Rakudo Perl|Rakudo]], la mise en œuvre par l'écriture d'une [[machine virtuelle]] ([[Parrot (machine virtuelle)|Parrot]]) en C.
* [[Perl (langage)|Perl]], Perl avant Perl 6.
* [[The Perl Foundation]], la fondation chargée de la promotion et du développement de Perl.

== Liens externes ==

* {{en}} [http://perl6.org/ Site officiel].
* {{en}} [http://perl6advent.wordpress.com/ Perl 6]  Conformément à la tradition des calendrier de l'[[avent]] qui dévoilent une nouvelle case chaque jour, un tutoriel sur un aspect de Perl 6 a été proposé chaque jour de l'avent de 2009 jusqu'à au moins 2012.
* {{en}} [http://feather.perl6.nl/syn/ Site plus pédagogique] avec plus de liens sur les documentations.
* {{en}} [http://www.programmersheaven.com/2/Perl6-FAQ FAQ sur Perl 6]. 
* {{en}} [http://rakudo.org/perl6/ Wiki dédié à Perl 6].
* {{en}} [http://perlcabal.org/syn/Differences.html Perl6::Perl5::Differences]
* {{en}} [http://planetsix.perl.org/ Planet Perl 6]

== Notes et références ==
{{Références}}

{{Portail|informatique|logiciels libres}}

[[Catégorie:Perl]]
[[Catégorie:Logiciel sous licence libre]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Langage fonctionnel]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]</text>
      <sha1>eea3ybbvmq4if99b4mzkzcdpmbjfus0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bistro (langage de programmation)</title>
    <ns>0</ns>
    <id>502479</id>
    <revision>
      <id>89975687</id>
      <parentid>62406481</parentid>
      <timestamp>2013-03-13T13:15:44Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2904843]]</comment>
      <text xml:space="preserve" bytes="1199">{{Voir homonymes|Bistro (homonymie)}}

'''Bistro''' est un [[Programmation orientée objet|langage de programmation orienté-objet]], [[typage dynamique|dynamiquement typé]] et [[réflexion (informatique)|réflectif]]. Il a été conçu par Nikolas S. Boyd en [[1999]]. Son langage reprend des concepts présents dans [[Smalltalk]] et [[Java (langage)|Java]]. Bistro se présente ainsi sous la forme d'une variante de Smalltalk s'exécutant grâce à une [[machine virtuelle]] Java. Cette dernière doit être en conformité avec les spécifications de [[Sun Microsystems]]. 

Selon le concepteur de Bistro, Smalltalk offre une modélisation plus expressive que Java. Le fait que le [[bytecode]] issu de Bistro se présente sous la forme de classe Java assure la portabilité des applications et la possibilité d'intégrer le code au sein d'applications Java. Bistro permet aussi de convertir à moindre frais une application en Smalltalk vers un environnement Java. 

==Liens externes==
* {{en}} [http://bistro.sourceforge.net/ Site officiel]
* {{Projet SourceForge|bistro|Bistro}}

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Dialecte Smalltalk]]</text>
      <sha1>cn2bxq3vyb6ewcv8w9y7yfqp19ihc8e</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Binary Format for Scene</title>
    <ns>0</ns>
    <id>1217631</id>
    <revision>
      <id>90190556</id>
      <parentid>88044447</parentid>
      <timestamp>2013-03-14T20:33:23Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q441715]]</comment>
      <text xml:space="preserve" bytes="942">{{Ébauche|informatique}}
'''BInary Format for Scene''' (BIFS)

Le langage BIFS est un format binaire pour du contenu multimédia en deux ou trois dimensions.

Le langage BIFS est basé sur le langage de description d'univers virtuels en 3 dimensions [[VRML]] auquel on a ajouté des particularités comme la gestion de la 2D et des notions de timing.

Dans le cadre d'une compression au format [[MPEG-4]], un fichier texte écrit en langage '''BIFS''' est adjoint aux objets médias. Les objets médias et ce fichier sont ensuite encapsulés dans un même fichier dont l'extension est .mp4.

Ainsi, le langage BIFS permet de gérer les interactions utilisateurs dans le cadre de vidéos au format [[MPEG-4]]. Il illustre la partie 11 de MPEG-4.

== Voir aussi ==
*[[MPEG]]
*[[MPEG-4]]
*[[VRML]]

{{portail|programmation informatique}}

[[Catégorie:Format de données numériques]]
[[Catégorie:Langage de programmation]]
[[Catégorie:MPEG]]</text>
      <sha1>e2f52vutsdibo5zm0i8yyqh1bxb4bmu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fonction de McCarthy n°91</title>
    <ns>0</ns>
    <id>1219287</id>
    <revision>
      <id>88284974</id>
      <parentid>75023589</parentid>
      <timestamp>2013-02-01T13:59:20Z</timestamp>
      <contributor>
        <ip>138.231.176.8</ip>
      </contributor>
      <text xml:space="preserve" bytes="803">{{Ebauche|informatique}}

== Définition ==

La fonction de McCarthy est une [[fonction (informatique)|fonction]] [[Récursivité|récursive]] définie pour &lt;math&gt;n \in \mathbb{N}&lt;/math&gt; par
&lt;math&gt;f(n)=\left\lbrace\begin{array}{l}n-10 {\rm\ si\ } n&gt;100\\f(f(n+11)) {\rm\ sinon}\end{array}\right.&lt;/math&gt;.

Elle est en fait constante égale à 91 pour &lt;math&gt;n \leqslant 101&lt;/math&gt;.

== Implémentation ==

=== [[Pascal (langage)|Pascal]] ===
&lt;source lang=&quot;pascal&quot;&gt;
FUNCTION f91 (n : integer) : integer;
  BEGIN
    IF n &gt; 100 THEN
      f91 := n - 10
    ELSE
      f91 := f91 (f91 (n + 11));
  END;
&lt;/source&gt;

=== [[Caml]] ===
&lt;source lang=&quot;ocaml&quot;&gt;
let rec f91 n = if n &gt; 100 then n - 10 else f91 (f91 (n + 11));;
&lt;/source&gt;

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>aadp4bz2ld9nzocgmadtr2twyx47gr4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ESRI-Avenue</title>
    <ns>0</ns>
    <id>1177999</id>
    <revision>
      <id>62406538</id>
      <parentid>18068412</parentid>
      <timestamp>2011-02-18T10:22:31Z</timestamp>
      <contributor>
        <username>Léna</username>
        <id>29802</id>
      </contributor>
      <minor/>
      <comment>portail informatique -&gt; portail programmation informatique, replaced: {{Portail informatique}} → {{portail|programmation informatique}} using [[Project:AWB|AWB]]</comment>
      <text xml:space="preserve" bytes="431">'''ESRI-Avenue''' était un [[langage de programmation]] du logiciel [[ArcView]] de la société [[Environmental Systems Research Institute, Inc.|ESRI]] jusqu'à sa version 3.3. Ce langage servait à personnaliser le logiciel ou développer de nouvelles fonctionnalités.
&lt;br&gt;Il est remplacé aujourd'hui par le [[Visual Basic for Applications|VBA]].

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ak9yg41hq0q3hcmcbtz3a2wul2koev8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>C sharp</title>
    <ns>0</ns>
    <id>60102</id>
    <revision>
      <id>101052571</id>
      <parentid>100792245</parentid>
      <timestamp>2014-02-08T20:49:10Z</timestamp>
      <contributor>
        <username>OrlodrimBot</username>
        <id>1055871</id>
      </contributor>
      <minor/>
      <comment>[[Wikipédia:Outil de retour des lecteurs/Retrait de l'outil|Retrait]] de l'outil de retour des lecteurs</comment>
      <text xml:space="preserve" bytes="24231">{{Titre incorrect|C♯}}
{{Voir homonymes|Sharp|.cs}}
{{Infobox Langage de programmation
| nom                    = C#
| logo                   = C Sharp wordmark.svg
| paradigme              = [[Programmation structurée|structuré]], [[Programmation impérative|imperatif]], [[Programmation orientée objet|orienté objet]]
| année                  = [[2001 en informatique|2001]] (dernière révision en [[2010 en informatique|2010]])
| auteur                 = [[Microsoft]]
| typage                 = [[Typage statique|statique]], [[Typage fort|fort]], [[Système nominatif de types|nominatif]]
| influencé par          = [[Eiffel (langage)|Eiffel]], [[Java (langage)|langage Java]]
| implémentations        = [[Microsoft .NET]], [[Mono (informatique)|Mono]]
| dialectes              = 1.0, 1.5 &lt;!--this is the version of the ECMA spec, not Visual C♯--&gt;, 2.0 (ECMA), 3.0, 3.5, 4.0
}}

Le '''C♯''' (prononcé [{{API|siː.ʃɑːp}}]) est un [[langage de programmation]] [[Programmation orientée objet|orienté objet]] à [[typage fort]], créé par la société [[Microsoft]], et notamment un de ses employés, [[Anders Hejlsberg]], le créateur du langage [[Embarcadero Delphi|Delphi]].

Il a été créé afin que la plate-forme [[Microsoft .NET]] soit dotée d'un langage permettant d'utiliser toutes ses capacités. Il est très proche du [[Java (langage)|Java]] dont il reprend la syntaxe générale ainsi que les concepts (la syntaxe reste cependant relativement semblable à celle de langages tels que le [[C++]] et le [[C (langage)|C]]). Un ajout notable au C# est la possibilité de [[surcharge des opérateurs]], inspirée du C++. Toutefois, l'implémentation de la redéfinition est plus proche de celle du [[Pascal Objet]].

== Plate-forme d'exécution ==

* La plate-forme [[Microsoft .NET]] (possibilité de mixage avec des modules d'autres langages)
* Des implémentations libres de ce langage et de sa plate-forme d'exécution sont en cours de finalisation, comme le projet [[Mono (informatique)|Mono]] maintenu par Novell, ou [[dotGNU]] maintenu par la {{lang|en|''[[Free Software Foundation]]''}}. L'idée fondatrice de ces projets est qu'une application en C# puisse s'exécuter sans modification sur une plate-forme propriétaire comme Windows ou libre comme Linux.

== Capacités du langage ==
Le C♯ est, d’une certaine manière, le langage de programmation qui reflète le mieux l’architecture [[Microsoft .NET]] qui fait fonctionner toutes les applications .NET, et en est par conséquent extrêmement dépendant. Les types natifs correspondent à ceux de .NET, les objets sont automatiquement nettoyés par un [[ramasse-miettes (informatique)|ramasse-miettes]] (''garbage collector'' en anglais), et beaucoup de mécanismes comme les classes, interfaces, délégués, exceptions, ne sont que des moyens explicites d’exploiter les fonctionnalités de la bibliothèque .NET. Pour achever de marquer cette dépendance, le CLR ({{lang|en|''[[Common Language Runtime]]''}}) est obligatoire pour exécuter des applications écrites en C♯, comme l’est la JVM ({{lang|en|''Java Virtual Machine''}} ou [[Machine virtuelle Java]]) pour des applications [[Java (langage)|Java]].

Le langage compte un certain nombre de changements par rapport au C/C++ ; On notera particulièrement les points suivants :
* La manipulation directe de pointeurs ne peut se faire qu’au sein d’un code marqué {{lang|en|''unsafe''}}, et seuls les programmes avec les permissions appropriées peuvent exécuter des blocs de code {{lang|en|''unsafe''}}. La plupart des manipulations de pointeurs se font via des références sécurisées, dont l’adresse ne peut être directement modifiée, et la plupart des opérations de pointeurs et d’allocations sont contrôlées contre les dépassements de mémoire. Les pointeurs ne peuvent pointer que sur des ''types de valeurs'', les types ''objets'', manipulés par le [[ramasse-miettes (informatique)|ramasse-miettes]], ne pouvant qu’être référencés.
* Les objets ne peuvent pas être explicitement détruits. Le [[ramasse-miettes (informatique)|ramasse-miettes]] s’occupe de libérer la mémoire lorsqu’il n’existe plus aucune référence pointant sur un objet. Toutefois, pour les objets gérant des types non managés, il est possible d’implémenter l’interface &lt;code&gt;IDisposable&lt;/code&gt; pour spécifier des traitements à effectuer au moment de la libération de la ressource.
* L’héritage multiple de classes est interdit, mais une classe peut implémenter un nombre illimité d’interfaces, et une interface peut hériter de plusieurs interfaces.
* Le C♯ est beaucoup plus [[Sûreté du typage|typé]] que le C++ ; les seules conversions implicites sont celles entre les différentes gammes d’entiers et celles d’un type dérivé à un type parent. Aucune conversion implicite n’a lieu entre booléens et entiers, entre membres d’énumération et entiers, ni de pointeurs sur un type {{lang|en|''void''}} (quoique pour ce dernier point l’utilisation de références sur le type Object permette d’obtenir le même effet). Les conversions définies par l’utilisateur peuvent être définies comme implicites ou explicites.
* La syntaxe pour la déclaration des [[Tableau (structure de données)|tableaux]] n’est pas la même : &lt;code&gt;int[] a = new int[5]&lt;/code&gt; remplace &lt;code&gt;int a[5]&lt;/code&gt;. Car il s'agit d'une allocation dynamique, &lt;tt&gt;int[] a&lt;/tt&gt; étant la déclaration d'une référence (nulle si non initialisée). L'allocation manuelle d'un tableau sur la pile reste cependant possible avec le mot clé &lt;code&gt;stackalloc&lt;/code&gt;&lt;ref&gt;{{fr}} [http://msdn.microsoft.com/fr-fr/library/cx9s2sy4(v=VS.80).aspx Site MSDN]&lt;/ref&gt;.
* Les membres d’une énumération sont rassemblés dans leur propre [[espace de noms]].
* Le C♯ ne gère pas les {{lang|en|''templates''}}, mais cette fonctionnalité a été remplacée par les [[Programmation générique|types génériques]] apparus avec C♯ 2.0.
* Les propriétés ont été introduites, et proposent une syntaxe spécifique pour l’accès aux données membres (ainsi que la facilitation de l’accès simultané par plusieurs {{lang|en|''threads''}}).
* La [[Réflexion (informatique)|réflexion]] totale des types est disponible.
* Les délégués, qui sont des listes de pointeurs sur fonctions, sont utilisés notamment pour la programmation événementielle.

=== Capacités introduites avec C♯ 2.0 ===

[[Microsoft]] mit à disposition du public en {{date||octobre|2005|en informatique}}, après une longue période de beta-tests, la version 2.0 de la bibliothèque .NET, accompagnée d’une nouvelle version de la quasi-totalité des outils associés. C♯ ne fait pas exception à la règle et sort donc en version 2.0, avec les ajouts suivants :
* Les classes partielles, permettant de répartir l’implémentation d’une classe sur plusieurs fichiers.
* Les [[Programmation générique|types génériques]], qui ne sont pas une simple copie des {{lang|en|''templates''}} C++. Par exemple, on trouvera dans les génériques C♯ la restriction de types (pour spécifier les types utilisables dans une généralisation). Par contre, il est impossible d’utiliser des expressions comme paramètres pour la généralisation.
* Un nouvel itérateur qui permet l’utilisation de [[coroutine]]s via le mot-clé &lt;code&gt;yield&lt;/code&gt;, équivalent du &lt;code&gt;yield&lt;/code&gt; que l’on trouve en [[Python (langage)|Python]].
* Les méthodes anonymes avec des règles de [[fermeture (informatique)|fermeture]] configurables.
* Les types « nullables », c'est-à-dire la possibilité de spécifier qu’un type de valeur peut être nul. Ceux-ci sont déclarés avec le caractère point d'interrogation « ? » suivant le nom du type, comme ceci : &lt;code&gt;int? i = null;&lt;/code&gt;.
* Le nouvel opérateur double point d'interrogation « ?? » utilise deux opérandes et retourne le premier non nul. Il a été introduit pour spécifier une valeur par défaut pour les types « nullables ».

À titre de référence, les spécifications complètes des nouveautés introduites dans la version 2.0 sont disponibles dans les [[#Liens externes|liens externes]].

[[Anders Hejlsberg]], le père de Delphi, s’est exprimé sur l’implémentation des génériques dans C♯, Java et C++ dans [http://www.artima.com/intv/generics2.html cette interview] {{en}}.

La fonctionnalité des types nullables fut fixée quelques semaines seulement avant la sortie publique de la version 2.0, car il a été mis en lumière que si la valeur de la variable était bien nulle, cette variable n’était pas nulle au sens traditionnel du terme, c'est-à-dire qu’il ne s’agit pas d’une référence vide. Ainsi, la conversion d’un type primitif de valeur nulle en objet donnait une référence non nulle vers une valeur nulle. Il fallut donc, pour corriger ce problème, corriger le noyau du CLR et effectuer de nombreuses vérifications et corrections sur tous les produits de la gamme .NET 2.0 (Visual Studio 2005, SQL Server 2005, C♯ et VB.NET).

=== Capacités introduites dans C♯ 3.0 ===

Le C♯ 3.0 fut présenté au salon PDC 2005. La version finale est disponible depuis le {{date|19|novembre|2007|en informatique}} au téléchargement sur le [http://msdn2.microsoft.com/en-us/vstudio/default.aspx site de Microsoft] {{en}} . Les principales nouveautés sont les suivantes :
* L’ajout des mots-clefs &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;from&lt;/code&gt; et &lt;code&gt;where&lt;/code&gt; pour permettre la formation et l’exécution de requêtes SQL, XML, ou directement sur des collections. Cette fonctionnalité fait partie du programme [http://msdn2.microsoft.com/fr-fr/netframework/aa904594.aspx Language Integrated Query (LINQ)] {{en}}.
* Nouvelle possibilité d’initialisation d'un objet : À la place de &lt;code&gt;Client c = new Client(); c.Nom = &quot;Dupont&quot;;&lt;/code&gt;, on peut utiliser &lt;code&gt;Client c = new Client{ Nom = &quot;Dupont&quot; };&lt;/code&gt;
* [[Fonction anonyme|Expressions lambda]] : &lt;code&gt;ListeTrucs.Where( delegate(Truc x) { return x.Size &gt; 10; } );&lt;/code&gt; devient &lt;code&gt;ListeTrucs.Where( x =&gt; x.Size &gt; 10 );&lt;/code&gt;
* Inférence du type des variables locales : &lt;code&gt;string s = &quot;Dupont&quot;&lt;/code&gt; peut être remplacé par &lt;code&gt;var s = &quot;Dupont&quot;&lt;/code&gt;
* Introduction des types anonymes : &lt;code&gt;var x = new { Nom = &quot;Dupont&quot; }&lt;/code&gt; peut être utilisé à la place de &lt;code&gt;class __anonymous { private string _nom; public string Nom { get { return _nom; } set { _nom = value; } } } __anonymous x = new __anonymous(); x.Nom = &quot;Dupont&quot;;&lt;/code&gt;
* Les arbres d'expressions (expression trees) : permettent la compilation du code sous formes d'arbres d'objets facilement analysables et manipulables.
* Méthodes étendues : permet d'ajouter des méthodes à une classe en y ajoutant un premier paramètre &lt;code&gt;this&lt;/code&gt;.

Une présentation du C♯ 3.0 et de LINQ peut être trouvée sur la page du [http://msdn2.microsoft.com/fr-fr/netframework/default.aspx centre de développement de .NET Framework].

Le code compilé en C♯ 3.0 est entièrement compatible avec celui du 2.0, étant donné que les améliorations apportées ne sont que purement syntaxiques ou ne consistent qu’en des raccourcis compensés au moment de la compilation. Les nouveautés introduites dans les bibliothèques de la version 3.5 (LINQ…) ne sont cependant pas utilisables avec les versions précédentes de C♯.

Cette version exige [[Windows XP]] ou une version supérieure ([[Microsoft Windows Vista|Vista]] ou [[Windows 7]]). Elle n'est pas disponible pour [[Windows 2000]].

=== C♯ 4.0 ===

La version 4 du langage apporte plusieurs nouveautés:
* le typage dynamique des variables à l'aide du mot clé dynamic;
* les arguments nommés et facultatifs&lt;ref&gt;http://msdn.microsoft.com/fr-fr/library/vstudio/dd264739(v=vs.100).aspx&lt;/ref&gt;;
* le support de la covariance et de la contravariance pour les interfaces et les délégués génériques ;

Le framework .NET 4.0 est sorti le {{date|12|avril|2010|en informatique}}, accompagné de [[Visual Studio]] 2010&lt;ref&gt;{{en}} [http://code.msdn.microsoft.com/Project/Download/FileDownload.aspx?ProjectName=cs2010samples&amp;DownloadId=10177 Site MSDN]&lt;/ref&gt;.
Il propose entre autres :
* la nouvelle bibliothèque parallèle : Task Parallel Library ;
* une version optimisée de la plateforme entité d'accès aux Bases de Données (Entity Framework) via l'utilisation de LINQ ;
* la version parallèle de LINQ appelée PLINQ.

=== C♯ 5.0 ===
La version 5 du langage permet de programmer plus simplement des programmes asynchrones grâce à l'ajout des mots clés async et await.

Le comportement des closures dans la boucle foreach a été modifié. Il n'est désormais plus nécessaire d'introduire une variable locale dans une boucle foreach pour éviter les problèmes de closure&lt;ref&gt;http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx&lt;/ref&gt;.

À noter également les informations relatives à l'appelant&lt;ref&gt;http://msdn.microsoft.com/fr-fr/library/hh534540.aspx&lt;/ref&gt; permettent de connaître le nom de la méthode qui a appelé une propriété.

== Différences entre Java et C♯ ==

Bien que le C♯ soit similaire à Java, il existe des différences notables, par exemple :

* Java n'autorise pas la [[surcharge des opérateurs]] ;
* Java n'a pas de mode {{lang|en|''unsafe''}} permettant l'arithmétique de pointeurs ;
* Java a des exceptions vérifiées, alors que les exceptions du C♯ ne sont pas vérifiées, comme en C++ ;
* Java permet la génération automatique de la documentation HTML à partir des fichiers sources à l'aide des descriptions Javadoc-syntax, tandis que le C♯ utilise des descriptions basées sur le XML ;
* C♯ supporte {{lang|en|''indexers''}} (indexeurs), {{lang|en|''delegates''}} (délégué ou liste de pointeurs sur fonctions) et {{lang|en|''events''}} (événements) ;
* C♯ supporte les structures en plus des classes (les structures sont des types ''valeur'' : on stocke le contenu et non l'adresse) ;
* C♯ utilise une syntaxe intégrée au langage (DllImport) et portable pour appeler une bibliothèque native, tandis que Java utilise {{lang|en|''[[Java Native Interface]]''}} ;
* C♯ intègre la notion de '''generics''', et la machine [[Microsoft .NET|.NET]] a été modifiée pour permettre cela (contrairement à Java, où le support des generics a été implémenté dans le compilateur [[javac]] sans changer le [[bytecode]] Java). Plus de détails sur l'aspect théorique de cette réalisation peuvent être trouvés dans la référence &lt;ref&gt;{{en}} [http://www.pps.univ-paris-diderot.fr/~gc/slides/subtyping.pdf Support du cours de sous-typage du MPRI], diapositives 73 à 80.&lt;/ref&gt;, slides 70 à 89.

== Standardisation ==

Le C♯ a été normalisé par l'[[Ecma International|ECMA]] (ECMA-334) en {{date||décembre|2001|en informatique}} et par l'[[Organisation internationale de normalisation|ISO]]/[[Commission électrotechnique internationale|CEI]] (ISO/CEI 23270) en [[2003 en informatique|2003]].

Les modifications survenues dans la [[#Capacités introduites avec C♯ 2.0|Version 2.0]] ont été normalisées par l'[[Ecma International|ECMA]] (ECMA-334) en {{date||juin|2006|en informatique}} et par l'[[Organisation internationale de normalisation|ISO]]/[[Commission électrotechnique internationale|CEI]] (ISO/IEC 23270:2006) en {{date||septembre|2006|en informatique}}.

Microsoft a ouvert le code source de certaines bibliothèques utilisées par le C♯ en {{date||octobre|2007|en informatique}} sous la licence [http://www.microsoft.com/resources/sharedsource/licensingbasics/referencelicense.mspx Microsoft Reference License (MS-RL)].

=== Nom du langage ===

C♯ est une note de musique dans le [[Désignation des notes de musique suivant la langue|système de notation musical américain]] (cette note correspond à &quot;Do dièse&quot; dans la notation française). Le [[Dièse|symbole ♯]] signifie en musique que la note doit être augmentée, l'idée de &quot;C augmenté&quot; rappelle la manière dont le langage [[C++]] a été nommé (++ étant l'opérateur d'incrémentation).

Usuellement, un croisillon (#) est utilisé comme second caractère à la place du dièse (♯) car ce dernier est moins accessible sur le clavier et non reconnu dans certaines polices de caractères.

On peut aussi voir dans ce croisillon # quatre signes +, d'où le fait que certains codeurs disent que le nom du C# est en fait C++++ : ce serait une version sur-améliorée du C (C++ étant une première amélioration, C++++ serait la seconde). Cependant, on peut remarquer que l'instruction i++++; est illégale. Cela peut conduire à penser que cette hypothèse est fausse.

== Le langage ==
Voici un exemple d'un programme {{lang|en|''[[Hello world]]''}} typique, écrit en C♯ :

&lt;source lang=&quot;csharp&quot;&gt;
using System;

class HelloWorld
{
    public static void Main()
    {
        Console.WriteLine(&quot;Hello World!&quot;);
    }
}
&lt;/source&gt;
=== Gestion des exceptions ===
C♯ possède les instructions ''try'' et ''catch'' permettant de gérer les exceptions (comportement non attendu des instructions du programme), similaires dans la syntaxe à celles du [[C++]].
&lt;br /&gt;Exemple de code tentant de créer un fichier &quot;document.txt&quot; sur le serveur &quot;Toto&quot;:

&lt;source lang=&quot;csharp&quot;&gt;
try
{
    // Tentative de création du fichier 'document.txt' sur le serveur 'Toto'
    File.Create(@&quot;\\toto\document.txt&quot;);

}
catch
{
    // Impossible de contacter le server Toto
    MessageBox.Show(&quot;L'application n'arrive pas à créer le fichier 'document.txt' sur le serveur 'Toto' !&quot;, &quot;Alerte&quot;);
}
&lt;/source&gt;
Notez l'utilisation d'une chaîne de caractères verbatim : le caractère arobase précède le guillemet donc l'anti-slash n'est pas doublé. Ce genre de chaîne de caractères est pratique pour les chemins sous Windows.

Dans cet exemple, la fonction &lt;tt&gt;File.Create&lt;/tt&gt; retourne un flux (FileStream), ou elle peut lancer une exception si une erreur s'est produite (problème de connexion par exemple).

Dans cet exemple, aucune information sur l'exception n'est obtenue : on cherche juste à savoir si le programme ne s'est pas comporté normalement, auquel cas on arrive dans le bloc catch.

À l'instar de [[C++]] qui a un type d'exception de base (class exception dans l'en-tête &lt;exception&gt;) et dont les autres exceptions héritent, toute exception C# est héritée (ou une instance) du type System.Exception. Ainsi, si on cherche à savoir ce qui s'est passé, une solution simple reste d'obtenir une référence vers l'exception de la manière suivante :
&lt;source lang=&quot;csharp&quot;&gt;
try
{
    // Tentative de création du fichier 'document.txt' sur le serveur 'Toto'
    File.Create(@&quot;\\toto\document.txt&quot;);

}
catch(Exception err)
{
    // Impossible de contacter le server Toto
    MessageBox.Show(&quot;L'application n'arrive pas à créer le fichier 'document.txt' sur le serveur 'Toto' ! Erreur:&quot; + err.Message, &quot;Alerte&quot;);
}
&lt;/source&gt;
Ainsi, une information complète sera retournée, décrivant la nature de l'exception qui s'est produite.

En fonction des fonctions appelées, le framework .NET fournit la liste des exceptions que l'appel est susceptible de retourner en cas d'erreur. Dans le cas de la fonction 'Create', voici la liste des exceptions possibles:

* System.UnauthorizedAccessException
* System.ArgumentException
* System.ArgumentNullException
* System.IO.PathTooLongException
* System.IO.DirectoryNotFoundException
* System.IO.IOException
* System.NotSupportedException

&lt;source lang=&quot;csharp&quot;&gt;
try
{
    // Tentative de création du fichier 'document.txt' sur le serveur 'Toto'
    File.Create(@&quot;\\toto\document.txt&quot;);

}
catch(System.ArgumentException ArgumentErr)
{
    // L'argument n'est pas valable. Le nom de fichier 'document.txt' n'est pas valable
    MessageBox.Show(&quot;L'argument n'est pas valable. Le nom de fichier 'document.txt' n'est pas valable ! Erreur:&quot; + ArgumentErr.Message, &quot;Alerte&quot;);
}
catch(Exception err)
{
    // Impossible de contacter le server Toto
    MessageBox.Show(&quot;L'application n'arrive pas à créer le fichier 'document.txt' sur le serveur 'Toto' ! Erreur:&quot; + err.Message, &quot;Alerte&quot;);
}
&lt;/source&gt;

De la même manière qu'en [[C++]], l'envoi d'une exception se fait avec le mot-clef throw :
&lt;source lang=&quot;csharp&quot;&gt;
public uint Divide(uint num, uint div) //Fonction de division dans N
{
    if(div == 0)
        throw new Exception (&quot;Division par 0 !&quot;);
    if(num &lt; div)
        throw new Exception (&quot;num est strictement inférieur à div : le résultat de la division ne sera pas un entier naturel !&quot;);
    return num / div;
}
//Code ailleurs :
try
{
    Divide(12, 6); //Retourne 2, aucune exception
    Divide(10, 20); //Exception, cette division ne donne aucun résultat dans N
    Divide(10, 0); //Exception, division par zéro impossible
}
catch (Exception e)
{
    MessageBox.Show(&quot;L'erreur suivante a été retournée :\n&quot; + e.Message, &quot;Alerte&quot;);
}
&lt;/source&gt;
L'envoi d'une exception (via throw) ou la levée d'une exception (dans un bloc try/catch) met immédiatement fin au bloc en cours. Ainsi, si div est nul, le code de la fonction Divide s'arrêtera à la ligne 2. De même, dans l'exemple précédent, la troisième fonction Divide ne sera jamais exécutée à cause de la levée d'une exception lors du deuxième appel à Divide.
Une exception non attrapée (''catchée'') - c'est-à-dire que l'application n'a pas encadré le code lançant l'exception par un bloc catch approprié - met fin à l'application immédiatement sous la forme d'une exception de type UnhandledException (exception non gérée en français).

Comme en [[Java (langage)|Java]], il est possible d'ajouter un bloc &lt;tt&gt;finally&lt;/tt&gt; pour exécuter une série d'instructions, quoi qu'il se passe (exception lancée ou non). Cela est utile pour libérer des ressources quel que soit ce qui peut se passer entre la prise de ressource et la libération. Exemple typique : lecture de fichiers

&lt;source lang=&quot;csharp&quot;&gt;
FileStream fs = new FileStream(@&quot;C:\Fichier.txt&quot;, FileMode.OpenOrCreate, FileAccess.ReadWrite);
// arrivé ici, le fichier est ouvert
try
{
    // ... opérations de lecture / écriture pouvant lancer des exceptions ...
}
finally
{
    // fermer le fichier quoi qu'il se passe :
    fs.Close();
}
&lt;/source&gt;

== Notes et références ==
{{Références}}

== Liens externes ==
{{clr}}
{{Autres projets
  | wikibooks = Programmation C sharp
  | wikiversity = Langage C Sharp
}}
* {{fr}} [http://www.microsoft.com/france/msdn/outils/vcsharp.mspx Centre de Développement C# - Site MSDN]
* {{fr}} [http://www.csharpfr.com Exemple de programmation en C♯]
* {{en}} [http://www.iso.org/iso/en/CatalogueDetailPage.CatalogueDetail?CSNUMBER=36768 Page du standard ISO]

== Quelques Livres ==

* {{fr}} ''C♯ et .NET'' - ''Gérard Leblanc'' - 2002 - Éditions Eyrolles - {{ISBN|2-212-11066-9}}
* {{fr}} ''C♯ et .NET Version 2'' - ''Gérard Leblanc'' - 2006 - Éditions Eyrolles - {{ISBN|2-212-11778-7}}
* {{fr}} ''C♯ Tête la première'' - ''Andrew Stellman, Jennifer Greene'' - 2008 - Éditions Digit Books - {{ISBN|978-2-81500-001-7}}
* {{fr}} ''Introduction à C♯'' - ''Pierre-Yves Saumont, Antoine Mirecourt'' - 2001 - Éditions Eyrolles - {{ISBN|2-7464-0301-3}}
* {{fr}} ''Le guide de survie C♯'' - ''Gilles Tourreau'' - 2010 - Éditions Pearson Education - {{ISBN|978-2-7440-2432-0}}
* {{en}} {{lang|en|''C# 2005 Programmer's Reference''}} - ''Adrian Kingsley-Hughes, Kathie Kingsley-Hughes'' - &lt;!-- novembre 2006
d'après le site de Wrox --&gt;2006 - Édition Wrox - {{ISBN|0-470-04641-4}}
* {{en}} {{lang|en|''C♯ Essentials, 2nd Edition''}} - ''Ben Albahari, Peter Drayton, Brad Merrill'' - 2002 - Édition O'Reilly Media - {{ISBN|0-596-00315-3}}
* {{en}} {{lang|en|''Professional C♯, 3rd Edition''}} - ''Simon Robinson, Christian Nagel, Karli Watson, Jay Glynn, Morgan Skinner, Bill Evjen'' - 2004 - Édition Wrox - {{ISBN|0-7645-5759-9}}

{{Palette|Microsoft|Normes ISO|Langages de programmation}}
{{Portail|programmation informatique|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Norme ISO]]
[[Catégorie:Norme ECMA]]
[[Catégorie:.NET Framework]]</text>
      <sha1>gggnoujm82fvb3k88cujrbazoc4jidd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Game Maker Language</title>
    <ns>0</ns>
    <id>1253888</id>
    <revision>
      <id>99861656</id>
      <parentid>90203115</parentid>
      <timestamp>2014-01-03T19:19:13Z</timestamp>
      <contributor>
        <username>Acer11</username>
        <id>104736</id>
      </contributor>
      <minor/>
      <comment>typographie ; wikification</comment>
      <text xml:space="preserve" bytes="993">Le GML ('''Game Maker Language''') est le [[langage de programmation]] intégré du logiciel [[Game Maker]], créé par [[Mark Overmars]]. Le GML peut être vu comme un dérivé du [[C plus plus|C++]] avec des influences issue du [[Embarcadero Delphi|Delphi]], (lui-même est un dérivé du C), en version très simplifiée : seulement deux types de données (réel et chaîne de caractères), aucune possibilité de créer de nouveaux types de données, une manipulation peu ergonomique des tableaux et autres structures de données, etc...

Le GML est utilisé avec ce qu'on pourrait appeler sa « bibliothèque standard » : un ensemble assez complet de fonctions utiles à la réalisation de jeux vidéo. Celles-ci touchent à tous les aspects de la réalisation ; manipulation des sons, des images, de l'affichage, fonctions mathématiques, fonctions de dessin, etc...

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation]]

[[fi:Game Maker#Game Maker Language]]</text>
      <sha1>3qoda37jki09opfl369vfyin2pe6w5d</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Turbo Assembler</title>
    <ns>0</ns>
    <id>1304733</id>
    <revision>
      <id>93391338</id>
      <parentid>93389387</parentid>
      <timestamp>2013-05-23T15:59:53Z</timestamp>
      <contributor>
        <username>Zuikeyit</username>
        <id>1568060</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="1175">{{ébauche|logiciel}}
'''Turbo Assembler''' ou '''TASM''', est un [[assembleur]] pour la famille de processeurs [[x86]], créé par [[Borland]]. Il est toujours distribué par Embarcadero, dans sa version 32 bits, avec [[Embarcadero Delphi|Delphi]] et [[C++Builder]]&lt;ref&gt;On trouve par exemple {{code|tasm32}} dans la version d'essai proposée par Embarcadero. Noter que le lieur {{code|ilink32}} est fourni avec C++Builder, mais pas avec Delphi, qui dispose de son propre lieur intégré.&lt;/ref&gt;.

{{...}}

== Notes et références ==
{{références}}

== Voir aussi ==
* [[Turbo C]]
* [[Turbo Pascal]]
* [[Turbo Basic]]
* [[Assembleur]]
* [[Programme assembleur]]
* [[Microsoft Macro Assembler]]
* [[GNU Assembler]]
* [[FASM]]
* [[Netwide Assembler]]
* [[RosASM]]

== Liens externes ==
* {{en}} [http://www.bitsavers.org/pdf/borland/ Manuels des logiciels de Borland] sur le site BitSavers
* {{en}} [http://www.faqs.org/faqs/assembly-language/x86/borland/ FAQ Tasm]

{{Portail|Programmation informatique|logiciel}}

[[Catégorie:Borland]]
[[Catégorie:Compilateur]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour DOS]]</text>
      <sha1>3a7zi8gxknysm48vvjglcfefo69igi1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Server Side Includes</title>
    <ns>0</ns>
    <id>1333755</id>
    <revision>
      <id>90223696</id>
      <parentid>71024198</parentid>
      <timestamp>2013-03-15T01:10:40Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 14 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1411939]]</comment>
      <text xml:space="preserve" bytes="2500">Les '''''Server Side Includes''''', abrégés '''SSI''', sont un [[langage de programmation]] fait pour être [[Interprète (informatique)|interprété]] par un [[serveur HTTP]] lorsqu'il sert un document [[Hypertext Markup Language|HTML]]. Ce langage tire son nom de sa principale utilisation : inclure plusieurs [[fichier (informatique)|fichier]]s pour construire et servir à la demande un document HTML.

==Rôle==
Les SSI facilitent la maintenance des [[site web|sites web]] en permettant de conserver dans un seul fichier les parties de [[page web]] qui se retrouvent à l'identique dans toutes les pages du site. Il s'agit souvent de l'en-tête et du pied de page, qui contiennent des informations comme le nom du site, les coordonnées de son auteur, etc.

==Syntaxe==
Les directives SSI ont la syntaxe suivante : &lt;code&gt;&amp;lt;!--#&lt;var&gt;directive&lt;/var&gt; &lt;var&gt;paramètre&lt;/var&gt;=&quot;&lt;var&gt;valeur&lt;/var&gt;&quot; --&gt;&lt;/code&gt;.
&lt;pre&gt;
&amp;lt;!--#include file=&quot;entete.html&quot; --&gt;
&amp;lt;p&gt;Le répertoire contient les fichiers suivants&amp;amp;nbsp;:&amp;lt;/p&gt;
&amp;lt;pre&gt;&amp;lt;!--#exec cmd=&quot;ls&quot;--&gt;&amp;lt;/pre&gt;
&amp;lt;!--#include file=&quot;pied.html&quot; --&gt;
&lt;/pre&gt;

On remarque que ces directives sont des [[commentaire (informatique)|commentaire]]s [[Standard Generalized Markup Language|SGML]].

==Support des serveurs HTTP==
Les SSI sont apparues rapidement dans l'histoire du [[World Wide Web]]. Depuis, elles ont été éclipsées par les langages comme [[PHP: Hypertext Preprocessor|PHP]] et [[Active server pages]].

Le module &lt;code&gt;mod_include&lt;/code&gt; du [[Apache HTTP Server]] est fréquemment utilisé pour interpréter les SSI. L'[[extension de nom de fichier]] &lt;code&gt;.shtml&lt;/code&gt; est fréquemment utilisée pour identifier les fichiers que le serveur HTTP doit interpréter. Un autre moyen d'identifier les fichiers HTML à interpréter sans changer leur nom consiste à les marquer comme exécutables (directive &lt;code&gt;XBitHack&lt;/code&gt; de &lt;code&gt;mod_include&lt;/code&gt;).

==Voir aussi==
===Articles connexes===
*[[Apache HTTP Server]]
*[[Site web]]
*[[PHP: Hypertext Preprocessor]], [[Active server pages]]

===Liens externes===
*{{en}} [http://httpd.apache.org/docs/2.2/mod/mod_include.html Apache Module mod_include], documentation Apache 2.2
*{{en}} [http://httpd.apache.org/docs/1.3/howto/ssi.html Apache Tutorial: Introduction to Server Side Includes], tutoriel pour Apache 1.3

{{portail|informatique}}

[[Catégorie:Technologie web]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Langage de script]]</text>
      <sha1>pcrzsscdh3l1chk6zy1zgha2yvhwtmj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fortress (langage)</title>
    <ns>0</ns>
    <id>1396703</id>
    <revision>
      <id>93600051</id>
      <parentid>90236735</parentid>
      <timestamp>2013-05-30T11:59:58Z</timestamp>
      <contributor>
        <username>Caron</username>
        <id>34032</id>
      </contributor>
      <text xml:space="preserve" bytes="1313">{{Voir homonymes|Fortress}}
{{Ébauche|informatique}}
'''Fortress''' est un langage de programmation conçu et développé par [[Sun Microsystems]], visant à remplacer le langage [[Fortran]] dans le domaine du calcul scientifique. La spécification a été élaborée dans le cadre d'un projet financé par le [[DARPA]]. Une implémentation partielle basée sur la [[machine virtuelle Java]] (JVM) est sortie en avril 2008.

Le langage ne ressemble pas à Fortran. Sa syntaxe est proche de [[Scala_(langage)|Scala]], [[ML (langage)|ML]] et [[Haskell]]. Elle est largement basée sur la notation mathématique traditionnelle. Il est possible d'utiliser les caractères [[Unicode]]. Il est possible d'effectuer un rendu du code source à l'aide de diverses [[feuille de style|feuilles de style]], par exemple en [[ASCII]], en Unicode, ou bien en utilisant la notation mathématique via [[LaTeX]].

Fortress est conçu pour être extrêmement parallèle. Par exemple, la [[Structure de contrôle#Boucles|boucle « for »]] est parallèle par défaut : elle n'agit pas toujours de manière linéaire, en fonction du logiciel et du matériel utilisé. Fortress propose également des bibliothèques standards riches en fonctionnalités.

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>sdc2n757mry6zt84jst63pn4xgr7uvv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Communicating sequential processes</title>
    <ns>0</ns>
    <id>1351387</id>
    <revision>
      <id>101103567</id>
      <parentid>96745790</parentid>
      <timestamp>2014-02-09T22:04:03Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>typographie</comment>
      <text xml:space="preserve" bytes="17346">En [[programmation concurrente]]&lt;ref name=&quot;roscoe&quot;&gt;{{Ouvrage|langue= anglais |prénom1= A. W. |nom1= Roscoe |lien auteur1=|titre= The Theory and Practice of Concurrency |sous-titre=|lien titre=|numéro d'édition=|lien éditeur= Prentice Hall |éditeur= Prentice Hall |lieu= New York |année= 1997 |tome=|volume=|pages totales=|format= poche |isbn= 978-0-13-674409-2 |lccn= 97031217 |passage=|lire en ligne=|consulté le=}}&lt;/ref&gt;, '''Communicating sequential processes''' ('''CSP''')  est une [[algèbre de processus]] permettant de modéliser l'interaction de systèmes.

CSP intègre un mécanisme de synchronisation basé sur le principe du rendez-vous (détaillé plus loin au travers de la commande d'entrée/sortie). Combinant ce mécanisme à une syntaxe simple et concise, CSP permet alors l'implémentation rapide des paradigmes classiques de la concurrence, tels que producteurs/consommateurs ou lecteurs/écrivains. Ce n'est pas un langage de programmation complet.

CSP fut décrit en premier par [[C. A. R. Hoare]] dans un article de 1978&lt;ref name=&quot;hoare1978&quot;&gt;{{article |langue=en|nom1=Hoare
|prénom1=C. A. R.
|lien auteur1=C. A. R. Hoare
|titre=Communicating sequential processes
|périodique=Communications of the ACM
|volume=21
|numéro=8
|pages=666–677
|année=1978
|doi=10.1145/359576.359585}}
&lt;/ref&gt;, mais a depuis évolué de façon substantielle. CSP a été mis en pratique industriellement comme un outil de [[Méthode formelle (informatique)|spécification formelle]] de l'exécution concurrente de systèmes variés — tels que le T9000 [[Transputer]]&lt;ref name=&quot;barrett&quot;&gt;
{{article |langue=en |nom1=Barrett
|prénom1=G.
|titre=Model checking in practice: The T9000 Virtual Channel Processor
|lien périodique=Institute of Electrical and Electronics Engineers 
|journal=IEEE Transactions on Software Engineering
|volume=21
|numéro=2
|pages=69–78
|année=1995
|doi=10.1109/32.345823}}.&lt;/ref&gt; ou un système informatique de transaction commerciale sécurisé 
&lt;ref name=&quot;hall&quot;&gt;{{article |langue=en |nom1 = Hall
|prénom1=A
|prénom2=R. |nom2=Chapman
|url texte=http://www.anthonyhall.org/c_by_c_secure_system.pdf
|format=PDF
|titre=Correctness by construction: Developing a commercial secure system
|lien périodique=Institute of Electrical and Electronics Engineers 
|journal=IEEE Software
|volume=19
|numéro=1
|pages=18–25
|année=2002
|doi=10.1109/52.976937}}
&lt;/ref&gt;. C'est un champ de recherche toujours actif.

== Généralités ==
=== Structure d'un programme ===
Un programme CSP se présente sous la forme d'une suite de commandes et de déclarations de
variable séparées par des points-virgule :
 x : integer;
 y : integer;
 x := 4;
 ...

Hoare distingue alors deux types de commandes :
* les commandes simples : commande nulle (skip), commande d'affectation et commande d'entrée/sortie ;
* les commandes structurées : commande parallèle, commande répétitive et commande alternative.

Les commandes d'entrée/sortie, parallèle, répétitive et alternative seront détaillées par la suite. La commande nulle, par définition, ne fait rien. Elle permet juste de combler les blocs d'instructions vides. La commande d'affectation a quant à elle une syntaxe classique ''variable := valeur'' :
 x := 5

=== Échec de commande, terminaison de programme ===
L'échec d'une commande (par exemple, dans le cas d'une commande d'entrée/sortie, si le processus visé n'existe pas) entraîne l'échec du processus ou de la commande structurée qui la contient (l'échec d'une commande peut donc entraîner la fin du programme). Notons le cas particulier d'une répétitive dont l'échec d'une commande interne entraîne la terminaison et non la faillite (cf. partie La commande répétitive). 

Un échec n'est donc pas une erreur en soi.

=== Les signaux ===
Une notion de signal a aussi été introduite en CSP. Un signal est en quelque sorte une variable
complexe (ou structurée) composé d'un constructeur (un identifiant libre) ainsi que d'un ensemble
de valeurs. Les valeurs peuvent être soit de type élémentaire (entier, chaîne de caractères, etc.) soit
d'autres signaux.

Exemples :
* p(3,5) (le constructeur est p et contient les valeurs 3 et 5)
* p(q(3), 5)
* p() (ici, on dit que p() est un signal pur puisqu'il ne contient aucune valeur)

Notons aussi qu'un signal peut être affecté à une variable (exemple : x := p (4)), et peut aussi être la cible
d'une affectation. Cela permet alors des affectations du type (x, y) := (y, x).

== Détails sur les commandes ==
=== La commande parallèle ===
Elle permet la mise en concurrence de processus par la syntaxe suivante :
 [
   proc1 :: liste de commandes
 ||
   proc2 :: liste de commandes
 ||
   ...
 ]

Une telle commande ne se termine que lorsque tous les processus qu'elle définit sont terminés,
l'échec d'un seul entraînant l'échec de la commande parallèle.
Précisons qu'une variable définie avant une commande parallèle est visible par les
processus qu'elle contient. Ceci implique nécessairement que tous les processus définis devront 
avoir accès aux variables déclarées avant la commande parallèle. On assiste donc ici à un partage de ressources, 
dont les contraintes soulevées (accès exclusif, etc.) sont à la charge du programmeur.

On note aussi la possibilité de déclarer plusieurs processus pour une même liste de commandes,
comme le montre l'exemple suivant :
 proc1 [i:1..10] :: liste de commandes

Ici, dix processus ayant la même liste de commandes seront mis en concurrence.

=== La commande d'entrée/sortie ===
Les communications entre processus reposent sur cette commande. Pour expliciter son fonctionnement,
partons du cas simple de deux processus producteur et consommateur, le premier voulant
transmettre une variable x au second. Une telle communication s'effectuera alors au travers des
commandes suivantes :
 consommateur!x 
permettra au processus producteur d'envoyer x au processus consommateur
 producteur?x 
permettra au processus consommateur de recevoir x depuis le processus producteur

Du point de vue de la syntaxe, on remarque que le ! indique une commande de sortie, tandis
que le ? indique une commande d'entrée. Plus formellement, une commande d'entrée se présentera
sous la forme :
 processus_source?variable_cible
et une commande de sortie sous la forme :
 processus_cible!expression_source.

De plus, pour que la communication soit possible entre deux commandes d'e/s, CSP impose que :
# l'une soit une commande d'entrée, l'autre une commande de sortie ;
# les deux processus se nomment mutuellement ;
# les typages de la variable cible et de l'expression source soient identiques.

Dans ces conditions, la transmission peut avoir lieu, et le contenu de l'expression source est copié
vers la variable cible. Si l'une de ces conditions n'est pas respectée, les processus sont mis en attente,
entraînant par conséquent un interblocage. Si l'un des processus est mort, alors toute commande
d'entrée/sortie impliquant ce processus doit échouer. Enfin, le premier processus demandant la communication
doit être mis en attente jusqu'à ce que le second le rejoigne. On retrouve ici le principe
du rendez-vous.
Notons aussi le cas particulier d'une synchronisation simple, c'est-à-dire sans transmission de
valeur, possible grâce à l'utilisation d'un signal pur.
Exemple :
 [
  producteur :: ... consommateur?p(); ...
 ||
  consommateur :: ... producteur!p(); ...
 ]

=== La commande alternative ===
Une commande alternative se présente sous la forme d'un ensemble de sélectives, chacune étant
composée d'une garde ainsi que d'une liste de commandes. Une garde est quant à elle composée
d'une partie expression booléenne et d'une partie commande d'entrée, l'une ou l'autre pouvant
être omise.
Syntaxiquement, une commande alternative se présente sous la forme suivante :
 [
   garde1 → liste de commandes
 []
   garde2 → liste de commandes
 []
   ...
 ]
Où ''garde1'' et ''garde2'' sont de la forme :
 expression_booleenne ; commande_entrée
Ce qui donne par exemple :
 [
     i &lt; 5 ; processus?p(x) → ...
 []
     console!write(msg) → ...
 []
     i &gt; 5 → ...
 ]
Lors de l'exécution d'une commande alternative, chacune de ses gardes est testée, afin de déterminer sa 
valeur selon une logique trivaluée (c'est-à-dire qu'une garde peut être vraie, fausse, ou
neutre) :
* Une expression booléenne peut évidemment prendre les valeurs vrai ou faux
* Une commande d'entrée prend la valeur :
** vrai si la communication est possible immédiatement ;
** neutre si le processus nommé par la commande n'est pas encore prêt ;
** faux si le processus nommé par la commande est mort (i.e. a fini son exécution).
* Dans le cas d'une garde contenant à la fois une partie ''expression booléenne'' et une partie ''commande entrée'', l'expression booléenne est d'abord évaluée. Si elle est à faux, la garde est évaluée à faux. Si elle est à vrai, la commande d'entrée est alors évaluée, et donne la valeur à la garde.

Ainsi, si une ou plusieurs commandes gardées sont vraies, un choix indéterministe (i.e. aléatoire)
doit être effectué pour n'en sélectionner qu'une. Si aucune n'est vraie mais que certaines sont
neutres, le processus se met en attente des commandes d'entrées correspondantes. Et si toutes les
commandes gardées sont fausses, la commande alternative échoue.

Si une garde est sélectionnée, la liste de commande correspondante doit alors être exécutée.

Il est aussi important de noter que la contrainte d'ordre syntaxique limitant les commandes
d'e/s dans les gardes aux simples commandes d'entrée, provient d'un choix fait par HOARE dans
le but d'éviter les incohérences.

Pour illustrer ce propos, partons de l'exemple suivant (qui suppose possible l'utilisation de
commande de sortie dans les gardes) :
 [
  proc1 ::
       [
         proc2?p() → ...
       []
         proc2?q() → ...
       ]
 ||
  proc2 ::
       [
         proc1!p() → ...
       []
         proc1!q() → ...
       ]
 ]

Supposons que les deux processus soient chacun arrivés sur leur commande alternative. Les deux
commandes vont donc être évaluées parallèlement :
* le premier processus va évaluer chacune des gardes de l'alternative, puis, les deux étant vraies, il va effectuer un choix aléatoire entre l'une ou l'autre ;
* de même, le second processus va se retrouver à devoir faire un choix entre l'une ou l'autre des gardes de son alternative.

Si les deux choix sélectionnent la même communication, aucun problème n'est soulevé. Par contre, si chacun sélectionne une communication différente, on assiste à un cas d'incohérence entraînant nécessairement un interblocage.

Ainsi, la communication entre commandes d'entrée/sortie gardées posant des problèmes, HOARE a décidé de l'empêcher en autorisant uniquement les commandes d'entrée dans les gardes.

Précisons cependant que le compilateur proposé en fin de cet article autorise les commandes de sortie dans les gardes, mais ajoute en contrepartie la condition suivante :
* Pour qu'une communication soit établie entre deux processus, il faut qu'au moins une des deux commandes d'e/s soit hors-garde.

On évite alors bien le problème cité ci-dessus.

=== La commande répétitive ===
La commande répétitive est composée d'une unique commande alternative, dont l'échec entraîne
la fin de la répétition. On peut donc considérer qu'une répétitive ne peut se terminer qu'avec
succès.
Syntaxiquement, elle se présente sous la forme d'une étoile suivie d'une alternative :
 *commande alternative

Par exemple :
 i := 0;
 *[
   i &lt; 10 → i := i + 1
 ]

Ici, la commande répétitive se terminera lorsque i aura atteint la valeur 10.

== Conventions, pratiques usuelles ==
=== Définition de processus ===
On retrouve souvent la syntaxe ''PROCESSUS == liste d'instructions'' pour définir un processus à l'extérieur d'une commande
parallèle, dans le seul but de clarifier le code. Exemple :
 PREMIER ==
     x : integer := 5;
     ...
 SECOND ==
     msg : string;
     ...
 MAIN ==
     [
        premier :: PREMIER
     ||
        second :: SECOND
     ]

La liste d'instructions ''MAIN'' est alors celle executée au lancement du programme.

=== Commande d'affichage (print) ===
Pour afficher un message à l'écran, on utilise usuellement la commande :
 print (message)

=== Commande aléatoire (random) ===
 x := random (debut, fin)

Permet de prendre un nombre au hasard compris dans l'intervalle [debut, fin]

=== Commande sleep ===
 sleep (tps)

Stoppe le processus qui l'exécute pendant ''tps'' millisecondes. Permet de simuler des temps d'attente, etc.

=== Définition de constantes ===
On utilise communément la syntaxe :
 define CONSTANTE valeur

Exemple :
 define PI 3.1415

== Exemple de programmes de type producteur/consommateur ==
=== Un producteur, deux consommateurs ===

&lt;pre&gt;
 PRODUCTEUR ==
		nb : integer := 0;
		*[
				nb &lt; 100 -&gt; delegueur!nb; nb := nb + 1
		]

 DELEGUEUR ==
		nb : integer;
		*[
			true -&gt;
				producteur?nb;
				[
					consommateur[1]!nb -&gt; skip
				[]
					consommateur[2]!nb -&gt; skip
				]
		]

 CONSOMMATEUR ==
		nb : integer;
		*[
			true -&gt; delegueur?nb; print (nb)
		]

 MAIN ==
		[
			producteur :: PRODUCTEUR
		||
			consommateur[i:1..2] :: CONSOMMATEUR
		||
			delegueur :: DELEGUEUR
		]
&lt;/pre&gt;

Un producteur envoie une suite de nombre à un processus ''délégueur'' qui les transmet à deux consommateurs. L'utilisation d'une commande alternative dans le délégueur permet :
* de se mettre en attente si aucun des deux consommateurs n'est prêt ;
* d'envoyer le nombre à l'un s'il est le seul prêt ;
* de choisir aléatoirement entre les 2 consommateurs si les deux sont prêts.

=== Plusieurs producteurs, plusieurs consommateurs ===

&lt;pre&gt;
 define NP 10 // Nombre de producteurs
 define NC 10 // Nombre de consommateurs
 define TL 5 // Taille du tampon intermédiaire

 CONSOLE == 
		msg : string;
		*[
			true-&gt;
			[
				(i:1..NP) producteur[i]?write (msg) -&gt; print (msg)
			[]
				(i:1..NC) consommateur[i]?write (msg) -&gt; print (msg)
			]
		]

 PRODUCTEUR ==
		nb : integer := 0; message : string;
		*[
			true -&gt;
				message := &quot;objet num &quot; + nb;
				liste!prod(message);
				console!write (&quot;producteur &quot; + i + &quot; : &quot; + message + &quot;\n&quot;);
				nb := nb + 1
		]
		
		
 LISTE ==
		tab : [0..TL-1] string := [0..TL-1] &quot;&quot;;
		used,mark : integer := 0;
		message : string := &quot;&quot;;
		*[
			(i:1..NP) used &lt; TL; producteur[i]?prod(tab[(mark + used) mod TL]) -&gt;
				used := used +  1
		[]
			(i:1..NC) used &gt; 0; consommateur[i]!cons(tab[mark]) -&gt;
				mark := (mark + 1) mod TL;
				used := used - 1
		]		

 CONSOMMATEUR ==
		message : string;
		*[ 
			true -&gt;
				liste?cons(message);
				console!write (&quot;consommateur &quot; + i + &quot; : &quot; + message + &quot;\n&quot;)
		]

 MAIN ==
		[
			producteur[i:1..NP] :: PRODUCTEUR
		||
			consommateur[i:1..NC] :: CONSOMMATEUR
		||
			liste :: LISTE
		||
			console :: CONSOLE
		]
&lt;/pre&gt;

== Références ==
{{références|colonnes=2}}

== Liens externes ==

;Général
* {{pdf}} [http://www.cs.virginia.edu/crab/hoare1978csp.pdf Article originel dans lequel C.A.R. Hoare définit CSP]
* [http://vl.fmnet.info/csp/ Une archive en ligne sur ce sujet]
* [http://www.wotug.org/ WoTUG], est un forum dédié aux utilisateur du langage CSP.
* [http://citeseer.org/cs?q=Communicating+and+Sequential+and+Processes Citations référencées par le portail CiteSeer]

;Outils d'analyse
* [http://www.fsel.com/ Formal Systems Europe, Ltd.] développe des outils CSP, dont certains sont en téléchargement libre.
* [http://www.cs.adelaide.edu.au/~esser/arc.html ARC], propose un outil de vérification.
* [http://www.stups.uni-duesseldorf.de/ProB/overview.php ProB] est un animateur et vérificateur de modèle pour la [[Méthode B]], mais permet aussi la vérification de programmes CSP.
* [http://www.comp.nus.edu.sg/~pat/ PAT] est un vérificateur et simulateur de modèle CSP, plus diverses extensions du langage (par exemple, variables partagées, tableaux,  [[équité (informatique)|équité]]).

;Aide à l'implémentation
* [http://www.ce.utwente.nl/javapp/Default.htm CTJ] est une implémentation en Java de CSP avec support réseau/distribué.
* [http://www.cppcsp.net/ C++CSP] est une implémentation des idées de CSP/[[occam]]/[[JCSP]] en C++, d'un style semblable à JCSP.
* [http://www.axon7.com/ Jibu] (connu précédemment sous le nom [http://www.cspdotnet.com/ CSP.NET]) est une bibliothèque [[Microsoft .NET]] de style CSP.
* [http://www.uoguelph.ca/%7Egardnerw/csp++/index.html CSP++] est un outil de synthèse logicielle qui rend les spécifications écrite en CSPm exécutable via C++.
* [http://www.cliki.net/csp csp] est une bibliothèque [[Common Lisp]] qui utilise un modèle d'exécution concurrente inspiré de CSP.
* [http://www.cs.kent.ac.uk/projects/ofa/chp/ CHP] est une bibliothèque [[Haskell]] implémentant un modèle de concurrence inspiré de CSP.
* [http://lebozec.free.fr/CTJ CTJ (CSP to JAVA), un compilateur de CSP avec interface graphique], ce compilateur accepte toutes les conventions définies précédemment. Les exemples cités ci-dessus fonctionnent correctement avec ce compilateur.

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Méthode formelle]]</text>
      <sha1>sjvxdmp42nf35m36va4rgixak5fx51d</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PANORAMIC</title>
    <ns>0</ns>
    <id>1422225</id>
    <revision>
      <id>93123556</id>
      <parentid>93123427</parentid>
      <timestamp>2013-05-15T20:23:18Z</timestamp>
      <contributor>
        <ip>83.202.210.236</ip>
      </contributor>
      <comment>/* Références externes */</comment>
      <text xml:space="preserve" bytes="4076">'''PANORAMIC''' est un langage [[BASIC]] sous [[Microsoft Windows|Windows]] permettant de manipuler des objets Windows (Button, Edit, Combo, Picture, Scene3D, Movie, Track_bar, Scroll_bar, ...) des [[Sprite (jeu vidéo)|sprites]] (dans l'objet SCENE2D) et des objets [[Trois dimensions|3D]] (dans l'objet SCENE3D), des [[Fichier texte|fichiers textes]], des [[Fichier binaire|fichiers binaires]], des sons [[Musical Instrument Digital Interface|MIDI]] ...etc...

== Description ==
PANORAMIC est complètement gratuit et l'éditeur possède une documentation intégrée bilingue (anglais - français).
Il n'a besoin d'aucune [[Dynamic Link Library|DLL]] ni d'aucune [[bibliothèque logicielle]] externe pour fonctionner, c'est un logiciel portable qui peut être emporté partout sur une clé [[Universal Serial Bus|USB]] et qui fonctionne sur la plupart des configurations. Il fonctionne sous Windows XP, Windows 7 et Windows 8.

Il utilise les instructions BASIC classiques.

Le but de l'auteur est de développer un langage pour l'utilisateur, un langage qui est utilisable de la façon la plus simple possible.

La manipulation d'objets est simple : pour créer un objet, il suffit de taper son type suivi d'un numéro. Ce numéro est ensuite utilisé pour toute action sur cet objet, c'est l'identifiant de l'objet.

== Exemples ==
=== Création d'un bouton ===
* Pour créer un bouton : &lt;code&gt;button 1&lt;/code&gt;
 
* Pour lui donner une largeur de 100 [[pixel]]s : &lt;code&gt;width 1,100&lt;/code&gt;
 
* Pour qu'il affiche un texte : &lt;code&gt;caption 1,&quot;Bonjour !&quot;&lt;/code&gt;

=== Gestion 3D ===
- Pour créer un monde 3d : &lt;code&gt;scene3d 1&lt;/code&gt;

- Pour y mettre une théière : &lt;code&gt;3d_teapot 1&lt;/code&gt;
(car les objets 3D ont leur propre numérotation)

- Pour la faire pivoter de 30 degrés sur son axe Z : &lt;code&gt;3d_z_rotate 1,30&lt;/code&gt;

== Caractéristiques ==
Il gère des évènements : &lt;code&gt;on_click, on_change, on-timer, on_key_up, on_key_down, on_close&lt;/code&gt;.

Il possède actuellement (en 2011) environ 500 mots-clés, et est en constante et régulière évolution. Une nouvelle version sort environ tous les 2 mois.

Il peut aussi piloter [[Microsoft Excel|Excel]], dessiner, gérer des fichiers, la souris, utiliser des objets 3D en format 3DS ou MD2, créer des mélodies musicales en MIDI ...

Il peut créer des exécutables et des applications (une application est un exécutable qui contient tous les fichiers nécessaires à son exécution, comme les fichiers textes, les images, les sons, ...). 
Les logiciels créés avec PANORAMIC sont '''portables''' (besoin d'aucune DLL ni d'aucune bibliothèque externe)
 
Ce langage est présent dans 2 logiciels :

- un [[environnement de développement intégré]] pour créer son application avec une interface utilisateur: avec la souris, on place des objets sur une feuille et on les redimensionne. Ensuite on tape le code correspondant aux événements sur ces objets.

- un '''EDITOR''' pour créer son application à partir de rien (from scratch). 

Il existe un [[Forum (informatique)|forum]] français très actif (plus de 11000 messages) et un forum anglais.

== Versions ==
La dernière version officielle (0.9.24) date du 28 mars 2013.

Les versions antérieures à la 0.9.13 étaient volontairement limitées dans le nombre d'objets qu'elles pouvaient gérer, mais à partir de la version 0.9.13 (du 15 août 2009) il n'y a plus aucune limite.

Des versions instantanées sont mises périodiquement à disposition, afin de faire bénéficier tout de suite des améliorations et des corrections de bug, sans devoir attendre la sortie de la version officielle.

Il faut noter que l'auteur de ce langage s'efforce de répondre aux demandes des utilisateurs en développant des fonctionnalités qui sont demandées sur le forum.

== Références externes ==
* [http://panoramic-language.pagesperso-orange.fr/index.html / Site sur le langage de programmation Panoramic (version française et anglaise)]
 
{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ihdqytzogru4yn4zmcekywrq7z0bo3m</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gambas (langage)</title>
    <ns>0</ns>
    <id>103102</id>
    <revision>
      <id>99094426</id>
      <parentid>92910688</parentid>
      <timestamp>2013-12-10T17:29:30Z</timestamp>
      <contributor>
        <username>Esnico30</username>
        <id>741675</id>
      </contributor>
      <minor/>
      <comment>typographie, résolution homonymie.</comment>
      <text xml:space="preserve" bytes="5715">{{Voir homonymes|Gambas}}
{{Infobox Langage de programmation
| nom                    = Gambas
| image                  = Gambas screenshot.png
| description            = Capture d'écran.
| paradigme              = [[Programmation orientée objet]], [[Programmation structurée|structurée]] et [[Programmation impérative|impérative]]
| année                  = 1999
| auteur                 = [[Benoît Minisini]]
| dernière version stable= 3.3.4
| dernière version en développement = 
| typage                 = [[Typage statique|Statique]], [[Typage fort|fort]], [[Sûreté du typage|sûr]], [[Système nominatif de types|nominatif]]
| implémentations        = 
| dialectes              = 
| influencé par          = [[Visual Basic]]
| a influencé            = 
| système d'exploitation = [[Linux]], [[Unix]]
|licence                 = [[GNU General Public License]]
| site web               = [http://gambas.sourceforge.net gambas.sf.net]
}}

'''Gambas''' est un [[langage de programmation]] interprété orienté objet utilisant la syntaxe du [[BASIC]], disponible pour [[GNU/Linux]] et autres systèmes [[Unix]] ou assimilés. Il est accompagné d'un [[Interprète (informatique)|interpréteur]] et d'un [[environnement de développement intégré|IDE]], lui-même écrit en Gambas.

Gambas se donne pour objectif de reproduire la ''facilité d'utilisation'' de [[Visual Basic]] en améliorant ses fonctionnalités. Bien que son interpréteur ne soit pas compatible avec les programmes dont le [[code source]] est écrit en Visual Basic, Gambas est lui aussi dérivé du BASIC et orienté objet. Il n'est pas un clone de Visual Basic, son auteur insiste sur ce point, mais constitue une solution pertinente pour les utilisateurs du Visual Basic souhaitant créer des applications pour Linux/Unix sans passer à un environnement totalement différent.

Gambas est un [[logiciel libre]] diffusé sous la [[licence publique générale GNU|licence GNU GPL]], développé  principalement à [[Paris]] depuis 1999 par Benoît Minisini.

Gambas est l'[[acronymie récursive|acronyme récursif]] de '''''G'''ambas '''a'''lmost '''m'''eans '''Bas'''ic'' (en français, « Gambas veut presque dire Basic »). C'est aussi le nom espagnol d'une crevette de mer, l'[[Aristeidae]], dont provient le logo du projet.

La version stable actuelle (5 avril [[2013]]) est la version 3.4.1, qui succède à la précédente version 3.3.4 (18 avril [[2012]] ). Gambas est amélioré continuellement et peut être conseillé à tous les utilisateurs de Linux/Unix qui souhaitent mettre à profit leurs connaissances BASIC sous licence GNU.

Gambas est disponible sous forme de paquets RPM ou Deb pour de nombreuses distributions Linux, notamment [[Debian]], [[Ubuntu]], [[SuSE]] ou encore [[Mandriva]].

== Fonctionnalités ==
Avec Gambas, il est notamment possible de :
* développer une application en ligne de commande,
* développer une [[interface graphique]] utilisant indifféremment [[Qt]] ou [[GTK+]],
* utiliser des bases de données [[MySQL]], [[PostgreSQL]], [[SQLite]], [[Firebird (base de données)|Firebird]] ou toute base de données utilisant [[ODBC]],
* piloter des applications KDE avec [[DCOP]],
* internationaliser les applications,
* adapter (il ne suffit pas de les copier, même si un module aide la transposition) des programmes Visual Basic sous Linux,
* créer des applications réseaux, et utiliser directement les protocoles HTTP, FTP, DNS, SMTP,
* réaliser des programmes utilisant [[Simple DirectMedia Layer|SDL]] ou [[OpenGL]] (ce qui permet par exemple de réaliser des jeux),
* créer des applications Web avec gestion de sessions.

== Particularités ==
* Gambas possède un faible nombre de classes et de symboles comparativement au nombre de fonctionnalités, ce qui facilite son apprentissage,
* L'interface graphique est presque complètement indépendante du [[toolkit]] (QT ou GTK+) utilisé.

== Exemple de programme en Gambas ==
Simple programme [[Hello world]] écrit en Gambas.

 PUBLIC SUB Main()
 PRINT &quot;Hello world !&quot;
 END

== Alternatives ==
* [[Hbasic]] pour Linux ([http://hbasic.sourceforge.net/ Site officiel])
* [[Visual Basic]] pour Windows

== Portage vers d'autres plates-formes/architectures ==

Gambas est théoriquement portable vers d'autres plates-formes. Son auteur principal, Benoît Minisini, a déclaré : {{Citation|En pratique, le portage vers Windows est relativement compliqué, il ne m'intéresse pas, mais je suis prêt à aider quiconque veut se lancer là-dedans}}&lt;ref&gt;[http://linuxfr.org/2007/11/18/23368.html DLFP: Première 'Release Candidate' de Gambas 2&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;. Les applications Gambas en ligne de commande fonctionnent sous Windows avec [[Cygwin]].

Gambas fonctionne sous [[FreeBSD]] et [[Mac OS X]]. 

Gambas fonctionne sur les architectures 64 bits.

== Notes et références ==
{{Références}}

== Voir aussi ==
=== Liens externes ===
* {{en}} [http://gambas.sourceforge.net/ Site officiel]
* {{Projet SourceForge|gambas|Gambas}}
* {{en}} [http://www.kudla.org/ Kudla] : Paquetages RPM pour Mandrake
* {{de}} [http://www.madeasy.de/7/prgmini.htm Petits programmes en Gambas]
* {{Note autre projet|wikibook|Gambas|langue=de|début=Le tutoriel|rôle=lien externe}}
* [http://gambasforge.org/ GambasForge.org] : Site comprenant des exemples, un forum ainsi qu'un wiki Gambas.
* [http://www.gambaslinux.eg2.fr/ Gambas Basic]: Aide aux utilisateurs, tutoriels, logiciels téléchargeables.

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Logiciel pour Unix]]
[[Catégorie:Compilateur BASIC]]</text>
      <sha1>iblymcs273wnratswxet2jxpcsfuwwl</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>XL (langage)</title>
    <ns>0</ns>
    <id>1599709</id>
    <revision>
      <id>95203517</id>
      <parentid>90265385</parentid>
      <timestamp>2013-07-23T09:00:19Z</timestamp>
      <contributor>
        <username>BeBot</username>
        <id>809686</id>
      </contributor>
      <comment>Restructuration du [[Projet:Traduction]] : Traduction abandonnée</comment>
      <text xml:space="preserve" bytes="16142">{{Voir homonymes|XL}}

{{Infobox Langage de programmation
 | nom = XL (eXtensible Language) 
 | logo = 
 | date de première version         = 2000
 | dernière version stable          = 0.1 (2010)
 | paradigmes = [[Programmation impérative]]
 | développeur = [[Christophe de Dinechin]]
 | typage =  [[Typage_fort|Fort]]
 | influencé par = [[Ada (langage)|Ada]], [[C++]]
 | système d'exploitation = [[Type Unix]]
 | licence = [[Licence_publique_générale_GNU|GPL]]
 | site web = [http://xlr.sourceforge.net/ XLR]
}}

'''XL''', dont les lettres proviennent de ''e'''X'''tensible '''L'''anguage'', est un [[langage de programmation]], basé sur la [[programmation par concepts]]&lt;ref&gt;{{article |langue=en |url=http://www.theregister.co.uk/2008/01/16/concept_programming |nom1=Manchester |titre=Dip into Concept Programming |prénom1=Phil |périodique=The Register |jour=16 |mois=1 |année=2008 |accessdate=3 fév. 2010}}&lt;/ref&gt;, développé depuis [[2000]] par [[Christophe de Dinechin]].

XL offre la possibilité de modifier et programmer la [[syntaxe]] et la [[Sémantique des langages de programmation|sémantique du langage]]. Des [[plugin]]s compilés peuvent être utilisés pour ajouter de nouvelles fonctionnalités au langage. On peut par exemple noter un ensemble de plugins permettant la mis en œuvre d'un [[Programmation impérative|langage impératif]]. Les utilisateurs peuvent écrire eux-mêmes leurs propres plugins pour permettre l'utilisation de syntaxe spécifiques, par exemple pour la [[dérivée]], qui pourront être utilisés de la même manière que les fonctionnalités originales.

== Langage ==

XL est défini en quatre niveaux différents :
* XL0 définit comment le texte entré est converti en un [[Arbre syntaxique abstrait|arbre syntaxique]]
* XL1 définit un langage de base avec des possibilités comparables au [[c++]]
* XL2 définit la bibliothèque standard qui inclut les types de données communs ainsi que les opérateurs
* XLR définit un [[Moteur d'exécution]] dynamique pour XL basé sur XL0

XL n'a ni [[Type (informatique)#Types pr.C3.A9d.C3.A9finis|type primitif]] ni [[Variable (informatique)|mot-clé]]. Tous les opérateurs et les types de données, tels que les entiers ou les additions, sont définis dans la bibliothèque standard ''XL2''. ''XL1'' est portable dans différents environnements d'exécution. Ce qui n'est pas garanti pour ''XL2'' qui n'offre pas de tels garanties : si un [[processeur]] particulier n'implémente pas la multiplication en [[virgule flottante]], la définition de l'opérateur correspondant peut être manquante de la bibliothèque standard, et l'utilisation de cette fonctionnalité peut générer une erreur de compilation.

En XL, le programme [[Hello World]] peut s'écrire ainsi :

  use XL.TEXT_IO
  WriteLn &quot;Hello World&quot;

Une manière plus convenable pour des programmes plus importants serait :

  import IO = XL.TEXT_IO
  IO.WriteLn &quot;Hello World&quot;

Une implémentation par récurrence de la fonction [[factorielle]] : 

  0! → 1
  N! → N * (N-1)!

== Syntaxe ==

La syntaxe est définie au niveau ''XL0''. La phase ''XL0'' du compilateur peut être configurée en utilisant un fichier de description de la syntaxe, où sont définies des propriétés telles que la représentation du texte et les priorités des opérateurs. Un fichier de syntaxe basique définit les notations mathématiques communes tel que + pour l'addition, ainsi que la [[Ordre des opérations|priorité des opérations]].

L'''arbre syntaxique'' est composé de 7 types de nœuds : 4 types de feuilles (entier, réel, texte et symbole) et 3 types de nœuds internes ([[Notation infixée|infixe]], préfixe et bloc).
* un nœud ''entier'' est la représentation littérale d'un entier, comme &lt;code&gt;2&lt;/code&gt;. Le signe &lt;code&gt;#&lt;/code&gt; peut indiquer une base différente de 10, par exemple (&lt;code&gt;2#1001&lt;/code&gt;). Un [[Tiret bas|caractère souligné]] (ou ''underscore'') comme séparateur peut aider la lecture, par exemple &lt;code&gt;1_000_000&lt;/code&gt;.
* un nœud ''réel'' représente un nombre non entier, comme &lt;code&gt;2.5&lt;/code&gt;. Les notations de base et les séparateurs peuvent être utilisés de la même façon pour les entiers, par exemple &lt;code&gt;16#F.FFF#E-10&lt;/code&gt; est une représentation littérale valide d'un réel.
* un nœud ''texte'' représente un contenu textuel. Il est classiquement entouré par un guillemet simple ou double, comme &lt;code&gt;&quot;Salut&quot;&lt;/code&gt; ou &lt;code&gt;'a'&lt;/code&gt;, mais le fichier syntaxique peut être utilisé pour ajouter d'autres séparateurs, dont ceux dédiés aux textes à lignes multiples. 
* un nœud ''symbole'' représente un nom ou un opérateur. Un nom est un séquence de caractères alpha-numériques commençant par une lettre, par exemple &lt;code&gt;Salut&lt;/code&gt;. ''XL0'' préserve la casse, mais ''XL1'' ignore la casse et le caractère souligné ce qui fait que &lt;code&gt;MonsieurDupont&lt;/code&gt; et &lt;code&gt;Monsieur_Dupont&lt;/code&gt; sont le même nom. Un symbole est une séquence de caractères non alpha-numériques, par exemple &lt;code&gt;*&lt;/code&gt; ou &lt;code&gt;=/=&lt;/code&gt;.
* un nœud ''infixe'' représente deux nœuds liés par une [[notation infixée]], par exemple &lt;code&gt;A+1&lt;/code&gt; ou &lt;code&gt;2 and 3&lt;/code&gt;. En particulier, un nœud ''infixe'' combiné à un infixe &quot;nouvelle-ligne&quot; permet de séparer deux lignes.
* un nœud ''préfixe'' représente deux nœuds consécutifs, par exemple &lt;code&gt;Write &quot;Salut&quot;&lt;/code&gt;. Ceci est aussi utilisé dans le notation ''postfixe'', par exemple &lt;code&gt;3!&lt;/code&gt; ou &lt;code&gt;Open?&lt;/code&gt;. 
* un nœud ''bloc'' représente un nœud entouré par des [[Parenthèse|symboles isolants]], par exemple &lt;code&gt;(A)&lt;/code&gt; ou &lt;code&gt;[Index]&lt;/code&gt;. Une [[indentation]] est représentée en interne par un nœud ''bloc''.

Avec le fichier de syntaxe par défaut, le code suivant est valide pour ''XL0'', indépendamment de la sémantique :

 A = B + &quot;Salut&quot;

Il est décomposé en :

 infix(&quot;=&quot;,
       symbol(&quot;A&quot;),
       infix(&quot;+&quot;,
             symbol(&quot;B&quot;), text(&quot;Salut&quot;)))

== Sémantique de ''XL1'' ==
Le niveau ''XL1'' est défini comme une séquence d'opérations sur l'arbre syntaxique du niveau ''XL0''. Ces opérations sont effectuées par divers plugins du compilateur qui sont appelés suivant la forme de l'arbre syntaxique.

Des constructions particulières, &lt;code&gt;translate&lt;/code&gt; et &lt;code&gt;translation&lt;/code&gt;, sont fournies par un plugin destiné à faciliter l'écriture d'autres plugins. La construction &lt;code&gt;quote&lt;/code&gt; génère un arbre syntaxique. Voici comment ces constructions peuvent être utilisées pour implémenter un plugin nommé &lt;code&gt;ZeroRemoval&lt;/code&gt;, qui supprime les additions et multiplications par zéro : 

 translation ZeroRemoval
   when
     'X' + 0
   then
     return X
   when
     'X' * 0
   then
     return parse_tree(0)

Un plugin peut être invoqué sur un fichier complet à partir de la ligne de commande, ou plus localement dans le source du code en utilisant la notation ''pragma'', comme ici : 

 X := {Differentiate} d(sin(omega * T) * exp(-T/T0)) / dT

Le niveau ''XL1'' contient un grand ensemble de plugins, notamment &lt;code&gt;XLSemantics&lt;/code&gt; qui donne les abstractions communes telles que [[fonction]], [[Type (informatique)|type de données]] et [[Déclaration (informatique)|déclaration]] de [[Variable (informatique)|variable]] et  [[définition]], et aussi les ordres de base de la [[programmation structurée]] que sont les boucles et les conditions.

=== Système de typage ===
''XL1'' contrôle le type statique, avec des possibilités de programmation générique qui vont au-delà de celles de C++ ou Ada. Les types comme les tableaux ou les pointeurs, qui sont des types primitifs en C++, sont déclarés dans une bibliothèque dans XL. Par exemple, le type d'un tableau d'une dimension peut être définit par : 

 generic [Item : type; Size : integer] type array

Un ''type générique validé'' est un type générique où une condition indique comment le type peut être utilisé. De tels types ne doivent pas avoir de paramètres génériques. Par exemple, on peut déclarer un type comme &lt;code&gt;ordered&lt;/code&gt; (ordonné) si un opérateur ''inférieur'' est présent :

 // Un type est ordonné en présence d'un opérateur inférieur
 generic type ordered if
   A, B : ordered
   Test : boolean := A &amp;lt; B

Il est alors possible de déclarer une fonction qui est implicitement générique puisque le type &lt;code&gt;ordered&lt;/code&gt; est lui-même ordonné.

 // Function générique pour au moins un élément
 function Min(X : ordered) return ordered is
   return X

Ceci s'applique aussi aux types génériques qui ont des paramètres, comme &lt;code&gt;array&lt;/code&gt;. Une fonction calculant la somme des éléments dans un tableau peut s'écrire : 

 function Sum(A : array) return array.Item is
   for I in 0..array.Size-1 loop
     result += A[I]

=== Type protégé de liste de variable d'arguments ===
Les fonctions peuvent être [[Polymorphisme (informatique)|surchargées]]. Une fonction peut être déclarée avec un nombre variable d'arguments grâce au mot &lt;code&gt;other&lt;/code&gt; dans la liste des paramètres. Dans une telle fonction, &lt;code&gt;other&lt;/code&gt; permet de passer un nombre variable d'arguments à une autre fonction :

 // Fonction générique pour le minimum de N éléments
 function Min(X : ordered;…) return ordered is
   result := Min(…)
   if X &amp;lt; result then
     result := X

Quand ce genre de fonction est appelée, le compilateur invoque les fonctions de manière récursive pour correspondre à la liste :

 // Exemple d'utilisation de la fonction Min précédente
 X : real := Min(1.3, 2.56, 7.21)
 Y : integer := Min(1, 3, 6, 7, 1, 2)

=== Réduction d'expression (surcharge d'opérateur) ===
Les opérateurs peuvent être définis en utilisant la forme &lt;code&gt;written&lt;/code&gt; de déclaration de fonction. Voici un code qui déclare l'addition d'entiers :

 function Add(X, Y: integer) return integer written X+Y

De telles ''formes écrites'' peuvent avoir plus de deux paramètres. Par exemple, une transformation de matrice linéaire peut s'écrire :

 function Linear(A, B, C : matrix) return matrix written A+B*C

Une forme écrite peut utiliser des constantes, et ce type de forme est plus spécialisée que sans constantes. Par exemple :

 function Equal(A, B : matrix) return boolean written A=B
 function IsNull(A : matrix) return boolean written A=0
 function IsUnity(A : matrix) return boolean written A=1

Ce mécanisme est utilisé pour décrire tous les opérateurs de base. Une expression est progressivement réduite à des appels utilisant des formes écrites. Pour cette raison, ce mécanisme est appelé ''réduction d'expression'' plutôt que surcharge d'opérateur.

=== Itérateurs ===
Les itérateurs de XL permettent de programmer à la fois des [[Générateur (informatique)|générateurs et]] des [[Itérateur (patron de conception)|itérateurs]].

&lt;source lang=&quot;Pascal&quot;&gt;
import IO = XL.UI.CONSOLE

iterator IntegerIterator (var out Counter : integer; Low, High : integer) written Counter in Low..High is
    Counter := Low
    while Counter &lt;= High loop
        yield
        Counter += 1

// I doit être déclaré, car indiqué comme 'var out' dans l'itérateur
// Une déclaration implicite de I comme entier est alors faite ici
for I in 1..5 loop
   IO.WriteLn &quot;I=&quot;, I
&lt;/source&gt;

== Sémantique de ''XLR'' ==
''XLR'' est un langage dynamique, conçu dès l'origine comme un exécutant ''(back-end)'' pour le compilateur ''XL1'' (d'où le nom, qui représente le [[Moteur d'exécution|runtime]] de XL). Il partage la syntaxe de base ''XL0'' avec ''XL1'', mais son comportement est plus proche de celui d'un langage fonctionnel, même si ''XL1'' est censé ressembler plus à un langage impératif. ''XLR'' n'a pratiquement qu'un seul opérateur de construction, &quot;→&quot;, qui indique une réécriture. La notation à gauche de la notation de la réécriture est transformée en notation à droite de la réécriture.

Ce mécanisme est utilisé pour implémenter les notations standards : 

  si vrai alors PartieVraie sinon PartieFausse → PartieVraie
  si faux alors PartieVraie sinon PartieFausse → PartieFausse

== État du développement et historique ==

Le design de XL a commencé aux alentours de [[1992]], sous le nom LX (Langage eXpérimental). Le projet a été mis dans le domaine du logiciel libre en [[2000]], dans le cadre du projet &quot;Mozart&quot; qui visait à fournir des capacité de [[métaprogrammation]] [[multi-langage]]. Les premiers compilateurs étaient écrits en C++, mais cela rendait l'écriture d'extensions de compilateurs compliquée, car C++ ne permettait pas d'offrir le niveau d'abstraction voulu (par exemple un équivalent de &lt;code&gt;translate&lt;/code&gt;). Les aspects multi-langage rendaient les arbres syntaxiques difficile à manipuler en respectant la sémantique de chaque langage.

Une réécriture complète du compilateur a  commencé en [[2003]], abandonnant l'idée de support multi-langage qui avait montré ses limites, et focalisant sur la facilité d'écriture des extensions. L'[[arbre syntaxique abstrait]] a été réduit à sept types de nœud seulement pour représenter tous les programmes. Ce nouveau compilateur s'est auto-compilé en [[2004]] (bien qu'avec des capacités réduites et une dépendance à C++ dans le code généré). Depuis, tout le développement se fait en XL.

En [[2007]], le langage offre un grand nombre de fonctionnalités avancées, mais manque encore d'une bibliothèque fonctionnelle.

=== Prédécesseurs ===

XL a été inspiré par un grand nombre d'autres langages. Dans l'ordre alphabétique :

* [[Ada (langage)|Ada]] a inspiré quelques fonctionnements appliqués sur la totalité d'un programme, comme la [[Système de gestion d'exceptions|gestion d'exception]], les tâches, la portabilité. 
* [[BASIC|Basic]], principalement dans les versions modernes qui s'affranchissent des numéros de lignes et permettent la programmation structurée, a montré combien un langage de programmation peut être simple. Basic est un des premiers langages modernes ne nécessitant pas la présence de parenthèse autour des appels de routine.
* [[C (langage)|C]] a servi comme standard pour l'exécution (runtime) et le niveau machine. XL ne tourne pas sur une machine virtuelle.
* [[C++]] par ses bibliothèques de modèles standards a montré le besoin d'une bonne implémentation des types génériques, incluant implicitement les instanciations des génériques (ce qui fait défaut à Ada).
* [[Fortran]] poursuit et dépasse les performances de C et C++ sur les applications de calcul intensif, aidant l'identification des constructions de langage qui préviendrait des optimisations utiles.
* [[Java (langage)|Java]] démontre l'importance d'un système de bibliothèques portables. Les conteneurs Java montrent aussi les limitations d'une approche non basée sur une programmation générique. L'interfaçage avec le code Java reste un défi intéressant pour XL.
* L'extensibilité de [[Lisp]] a été vue comme un facteur clé de sa survie et de son intérêt jusqu'à aujourd'hui. Lisp a été le premier langage à introduire les fonctionnalités de l'orienté objet, même s'il a été conçu des années avant que la programmation orientée objet ne soit inventée. 
* [[Prolog]] a démontré que les paradigmes de programmation alternatifs sont parfois utiles et hautement productifs. Tout a été fait pour s'assurer qu'un plugin dans le style de Prolog puisse être écrit pour XL. 
* [[Visual Basic]] a montré comment la représentation de l'[[arbre d'analyse]] peut être séparée de sa présentation visuelle. Peu de gens éditent des formulaires VB sous forme textuelle. On peut espérer que les [[plugin]]s d'édition XL fourniront un jour des fonctionnalités similaires, en manipulant directement l'arbre d'analyse.

== Références ==
 &lt;references/&gt; 
== Liens externes ==

* [http://xlr.sf.net Site SourceForge]
* [http://mozart-dev.sf.net Version historique multi-langage]
* [http://www.byte.com/heller/2003 Article Byte]

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>nu526qnx6qf9bdypivlrr6lcj6ybgfa</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Clarion (langage)</title>
    <ns>0</ns>
    <id>396817</id>
    <revision>
      <id>89935205</id>
      <parentid>78314665</parentid>
      <timestamp>2013-03-13T07:29:43Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 9 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1095608]]</comment>
      <text xml:space="preserve" bytes="1525">{{Voir homonymes|Clarion}}
'''Clarion''' est un [[L4G|langage de quatrième génération]] et un [[environnement de développement intégré]] [[Logiciel propriétaire|propriétaire]] développé par Softvelocity, facilitant le développement d'applications de gestion (orientés principalement sur la manipulation des [[Base de données|bases de données]]).

La dernière version de Clarion est la 7.2

==Particularités==

C'est un [[Programmation procédurale|langage procédural]] et [[Programmation orientée objet|orienté objet]]. Clarion fournit un [[environnement de développement intégré]] (IDE).

Il permet à la fois d'écrire des applications 16 et 32-bits. La manipulation des données peut se faire à travers des fichiers [[Extensible Markup Language|XML]] ou des bases de données [[Structured Query Language|SQL]] ou autres (comme [[Microsoft Excel|Excel]]).

==Exemple de code==

&lt;pre&gt;! Ceci est un commentaire
MAC:Id= LIG:IdMachine 
GET(Machines,MAC:Id_Key)
IF ~ERRORCODE()
 LIG:NomMachine = CLIP(MAC:Reference)&amp; ' - ' &amp; CLIP(MAC:Description)
END
! Fin du Code&lt;/pre&gt;

== Articles connexes ==

* [[Environnement de développement intégré]]
* [[WinDev]] qui utilise le [[WLangage]]
* [http://clarion-net.narod.ru/Clarion-and-Net/ Clarion Integrator .Net]

==Lien externe==

* {{en}} [http://www.softvelocity.com Site officiel]
{{portail|programmation informatique}}

[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Environnement de développement intégré]]</text>
      <sha1>nhcmpxt1q3pvr2pq8eae3nkymsod6by</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>XProc</title>
    <ns>0</ns>
    <id>1666164</id>
    <revision>
      <id>90279312</id>
      <parentid>87987091</parentid>
      <timestamp>2013-03-15T10:28:31Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 4 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1571494]]</comment>
      <text xml:space="preserve" bytes="2477">{{Infobox Format de données
|nom=XProc Pipeline
|image=
|extension=.xpl
|mime=application/xproc+xml&lt;ref&gt;[http://www.w3.org/TR/xproc/#xproc-media-type XProc: An XML Pipeline Language Version 1.0]&lt;/ref&gt;
|développeur= {{lang|en|[http://www.w3.org/ World Wide Web Consortium]}}
|genre=[[Pipeline XML]]
|conteneur de=
|contenu par=
|extension de=[[Extensible Markup Language|XML]]
|origine de=
|standard=[http://www.w3.org/TR/xproc 1.0 (Recommandation du 11 mai 2010)]
}}

'''XProc''' est une [[recommandation]]  du [[World Wide Web Consortium|W3C]] qui vise à définir un [[langage de transformation XML]] permettant de construire des [[Pipeline XML|pipelines XML]].

== Implémentations ==
Il existe déjà des implémentations de la norme :
* '''Calabash''', une implémentation en [[Java (langage)|Java]] par [[Norman Walsh]] disponible en [[Open Source]]. Calabash est construit sur l'API de Saxon et utilise XPath 2.0 comme langage par défaut.
* '''Calumet''', une implémentation en Java par [[EMC]] et est disponible gratuitement pour les développeurs.
* '''QuiXProc''', une implémentation en Java par [[Innovimax]] disponible en [[Open Source]] intégrant le parallélisme et le streaming.
* '''Tubular''', une implémentation en Java disponible en Open Source basée sur des objets immuables de façon à faciliter l'ajout du parallélisme et à minimiser les interblocages
* '''xprocxq''', une implémentation en [[XQuery]] en Open Source développée sur [[eXist]], la base de données XML


== Ouvrage ==
Un livre disponible librement est en cours d'écriture en anglais sur le site http://xprocbook.com/

== Liens ==
* [[XSLT]]
* [[XPath]]
* [[Pipeline XML]]

== Références ==
&lt;references/&gt;
== Externes ==
* [http://xproc.org/implementations/ '''en anglais''' liste des implémentations connues]
* [http://www.w3.org/XML/Processing/ le site officiel du W3C ''en anglais'']
* [http://xproc.org le site '''en anglais''' maintenu par Norman Walsh]
* [http://www.w3.org/TR/xproc/ lien vers la recommandation  '''en anglais''']
* [http://code.google.com/p/quixproc le site '''en anglais&quot;&quot; de QuiXProc]
* [http://www.data2type.de/xml-xslt-xslfo/xproc/xproc-einfuehrung XProc-Tutorial] (german)
* [http://www.data2type.de/xml-xslt-xslfo/xproc/xproc-referenz XProc-Reference] (german)
{{portail|programmation informatique}}

[[Catégorie:Standard du web]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Dialecte XML]]
[[Catégorie:Langage de transformation XML]]</text>
      <sha1>a786kp67vcq4pp9j3ky7mpho7f7rxk7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Phrogram</title>
    <ns>0</ns>
    <id>1561554</id>
    <revision>
      <id>90259175</id>
      <parentid>89091337</parentid>
      <timestamp>2013-03-15T07:19:41Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2722952]]</comment>
      <text xml:space="preserve" bytes="5723">'''Phrogram''' (anciennement nommé '''Kid's Programming Language''' ou '''KPL''') est un langage de programmation informatique conçu afin d'être compréhensible et accessible pour les débutants et les enfants. La première version est sortie en août 2005. L'actuelle version 2, conçue et publiée par Morrison Schwartz inc, est sortie en mai 2007.

== Survol technique ==

Phrogram est un langage de [[programmation procédurale]] ayant quelques similitudes avec le [[Visual Basic]]. Les codes sources en Phrogram peuvent aussi être portés automatiquement en [[VB.NET]] ou en [[C Sharp|C#]] par l'intermédiaire d'un [[Environnement de développement intégré|IDE]] particulier. Le langage gère de nombreuses données de type : [[scalaire]]s ou [[complexe]], incluant leurs structures. 

Phrogram est pour le moment supporté uniquement par les systèmes d'exploitation [[Windows]], à partir de [[Windows 2000]]. 

Un programme en Phrogram se présente sous la forme de blocs imbriqués les uns dans les autres.

Phrogram est organisé sous forme d'un unique bloc, où les blocs de méthodes et fonctions sont définis. Lesdites fonctions et méthodes en KPL sont réutilisables. Les fonctions renvoient toujours une valeur, tandis que les méthodes n'en renvoient pas forcément. Les structures de données sont définies par l'intermédiaire du ''Program scope''. Les variables doivent quant à elles, être définies et typées au moment de leur déclaration. 

Le langage est étroitement liée à Microsoft [[Framework .NET]], et fournit beaucoup de fonctions et méthodes [[runtime]] pour communiquer avec cette plate-forme. {{refnec|La facilité à porter le Phrogram en d'autres langages .NET a mené Microsoft à annoncer Phrogram comme le successeur du [[Visual Basic]]}}. La compagnie qui distribue le langage ([[Morrison-Schwartz]]), est en partie possédée par [[Jon Schwartz]], un ancien gestionnaire de programmes pour Microsoft.

=== Hello, World! en KPL ===

 Program Hello_World
 
    Method Main()
       PrintLine (&quot;Hello, World&quot;)
    End Method
 
 End Program

=== Graphismes en KPL ===

Le KPL est un langage éloigné du langage machine. Pour créer un jeu par exemple, KPL dispose d'une [[bibliothèque logicielle|bibliothèque]] graphique de manipulation de [[sprites]]. Un grand nombre de format d'images y sont supportés, seuls 65 images sont fournies par défaut avec KPL.

Un moteur 3D succinct est aussi à disposition.

== Historique ==

[[Jonah Stagner]] a commencé le développement de KPL quand il a voulu enseigner à ses enfants la programmation, insatisfait des solutions disponibles. Dès lors, [[Jon Schwartz]] et [[Walt Morrison]] ont pris en main le projet. 

Le but premier de KPL a été de créer un langage neuf pour faire des programmes ludiques et petits. Phrogram a immédiatement attiré l'intérêt de novices grâce à la facilité d'écriture de programmes aux interfaces, musiques et animations attirantes. 
Le second but pour Phrogram est de fournir un nouveau langage avec quelques recettes de grands langages (comme le [[C++]], le [[Java (langage)|Java]], [[Visual Basic]] ou encore le [[C Sharp|C#]]) et une syntaxe similaire à Visual Basic pour permettre un changement vers ces langages le plus facilement possible. 

En 2007, la version 2 est créée, et le langage renommé Phrogram. Il se base sur la seconde version du [[Framework .NET]]. Phrogram prétend être totalement compatible avec les autres langages qui utilisent .NET Framework, ainsi les bibliothèques compilées peuvent être utilisés par des applications .NET, et inversement. Il supporte donc la [[Programmation orientée objet]] (POO), permettant la définition de classes, leurs propriétés et les méthodes associées, ce qui donne aux débutants une introduction à la Programmation Orientée Objet.

== Utilisateurs ==

L'interface Utilisateur de Phrogram est disponible en 18 langues : anglais, espagnol, russe, chinois, allemand, français, italien, néerlandais, suédois, thaïlandais, grec, polonais, roumain, norvégien, portugais, danois, tchèque et catalan.
Toutes les traductions de l'anglais ont été faite par des volontaires et la compagnie continue à les encourager à continuer les traductions.

Bien que le KPL a été créé pour les 8-14 ans (d'où le nom Kid's Programming Language), il est approprié pour les débutants en programmation de tout âge, c'est pourquoi le nom a changé. Il est actuellement utilisé par des personnes plus âgées l'ayant téléchargé pour eux-mêmes plutôt que pour leurs enfants ou élèves. Phrogram est proposé pour les premiers cours de programmation à tous niveaux scolaires et est utilisé ou a été utilisé par des collèges, lycées et universités dans plusieurs pays, comme les États-Unis, la Grande Bretagne, le Canada, le Mexique, la Colombie, la Russie, l'Islande, la Suède, la République Tchèque, la Slovaquie, le Portugal, le Brésil, la Chine, Guam, les Philippines et la Nouvelle Zélande.

== Phrogsoft, LLC ==
La version 2 du KPL a été réalisée et renommée Phrogram, maintenue par The Phrogram Company sur le site du même nom, puis Phrogsoft, LLC. 

L'environnement de développement, qui inclut le compilateur, est [[logiciel propriétaire|propriétaire]] et vendu dans de multiples versions et modules complémentaires.

== Liens externes ==
* {{en}} [http://www.phrogram.com Site officiel]
* {{en}} [http://www.kidsprogramminglanguage.com/ The old Kid's Programming Language website]
* {{fr}} [http://www.pcinpact.com/actu/news/Le_KPL_la_programmation_pour_les_enfants_de_Billou.htm Article PCInpact]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>8ajumfms7fkkhymc8pcluvq6utlmmhd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>AT&amp;T (assembleur)</title>
    <ns>0</ns>
    <id>1578286</id>
    <revision>
      <id>90261658</id>
      <parentid>89158661</parentid>
      <timestamp>2013-03-15T07:44:18Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2819526]]</comment>
      <text xml:space="preserve" bytes="3459">{{Ébauche|informatique}}
AT&amp;T est le nom donné à une forme de codage en assembleur pour l'architecture [[x86]]. Cette forme de codage est apparue avec les {{Référence nécessaire|premiers [[UNIX]]}}&lt;!-- pour moi (AntoineL), cette syntaxe apparaît dans System V, et fut reprise par ISC dans les specifs qu'ils firent de l'assembleur 386, vers mai 86. Il est clair que la syntaxe V7/32V/BSD ou même System III est différente. ~~~~ --&gt; ([[AT&amp;T]] est la société à l'origine d'UNIX). Cette forme est surtout utilisée sous UNIX. Cette syntaxe est utilisée par [[GNU Assembler|GAS]], l'assembleur du projet [[GNU]].

== Concepts ==
Par opposition à la syntaxe Intel, la syntaxe AT&amp;T place les opérandes dans l'ordre ''Source'' avant ''Destination''.

Les principales caractéristiques de cette syntaxe sont :
* L'assembleur fait toujours la différence entre majuscules et minuscules
* Les constantes sont écrites avec la notation habituelle en [[C (langage)|C]]
* Les opérandes immédiats (constantes) sont préfixés d'un dollar &lt;code&gt;'$'&lt;/code&gt;
* Les registres sont préfixés d'un &lt;code&gt;'%'&lt;/code&gt;
* Les sauts (jmp/call) absolus sont préfixés d'un astérisque &lt;code&gt;'*'&lt;/code&gt;
* L'indirection (déférenciation) est marquée par des parenthèses : un opérande basé sur EBX+table donne &lt;code&gt;table(%ebx)&lt;/code&gt;
* Ordre des opérandes : Source avant Destination (ordre choisi pour des raisons de compatibilité avec d'autres assembleurs UNIX)&lt;!--TAUTOLOGIE ; cela ne s'applique bien sûr qu'aux instructions attendant deux opérandes ou plus--&gt;
* La taille des opérandes peut être précisée grâce au dernier caractère de l'opération (en syntaxe Intel, jusqu'au Pentium inclus, des opérateurs spécifiques sur les opérandes sont utilisés, par exemple l'opérateur &lt;code&gt;PTR&lt;/code&gt; avec [[MASM]]) :
** &lt;code&gt;b&lt;/code&gt; → ''byte'' (8 bits - 1 octet)
** &lt;code&gt;w&lt;/code&gt; → ''word'' (16 bits - 2 octets)
** &lt;code&gt;s&lt;/code&gt; → ''short'' (32 bits - 4 octets, pour les opération en [[virgule flottante]])
** &lt;code&gt;l&lt;/code&gt; → ''long'' (32 bits - 4 octets pour les entiers, 64 bits - 8 octets pour les flottants)
&lt;!--** &lt;code&gt;ll&lt;/code&gt; -&gt; ''long long'' (64 bits - 8 octets), entiers 64 bits pour certaines instructions flottantes; je ne crois pas que cela ait été réellement implémenté--&gt;
** &lt;code&gt;q&lt;/code&gt; → ''quad'' (64 bits - 8 octets)
** &lt;code&gt;t&lt;/code&gt; → ''ten bytes'' (80 bits - 10 octets)
** &lt;code&gt;o&lt;/code&gt; → ''octo'' (128 bits - 16 octets), pour l'architecture [[x86-64]]
* Les sauts « longs » (ljump/lcall) absolus ont la syntaxe suivante : &lt;code&gt;$sélecteur, $offset&lt;/code&gt;, et non pas &lt;code&gt;section:offset&lt;/code&gt; comme dans la syntaxe des manuels Intel
* Pas de support pour de multiples [[Mémoire virtuelle#Segmentation|segments]], les programmes utilisent un unique [[Adressage mémoire|adressage]] [[mémoire virtuelle|virtuel]] linéaire

== Exemples ==
Par exemple, une instruction en norme Intel :
  mov eax, 0FFh
Donnera en norme AT&amp;T
  movl $0xFF, %eax

L'équivalent en AT&amp;T de
  mov byte ptr [ebx], 0FFh
Est
  movb $0xFF, (%ebx)

== Voir aussi ==
=== Articles connexes ===
* [[Assembleur]]
* [[GNU Assembler]]
* [[AT&amp;T]]
=== Lien externe ===
* [http://sourceware.org/binutils/docs-2.23.1/as/i386_002dVariations.html#i386_002dVariations gas manual - 9.15.3.1 AT&amp;T Syntax versus Intel Syntax]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]</text>
      <sha1>p8fmipncuw91wduwnr33ynizzacgxuv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Parrot (machine virtuelle)</title>
    <ns>0</ns>
    <id>29305</id>
    <revision>
      <id>92616862</id>
      <parentid>89779087</parentid>
      <timestamp>2013-04-30T12:17:05Z</timestamp>
      <contributor>
        <ip>80.93.83.20</ip>
      </contributor>
      <comment>typo: implantation --&gt; implémentation</comment>
      <text xml:space="preserve" bytes="6452">{{Voir homonymes|Parrot}}
{{Infobox Logiciel
 | couleur boîte            = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                      = Parrot
 | logo                     = 
 | image                    = 
 | description              = 
 | développeur              = [[Fondation Perl]]
 | date de première version = 
 | langage de programmation = 
 | environnement            = [[GNU/Linux]], [[FreeBSD]], [[NetBSD]], [[OpenBSD]], [[Mac OS X]], [[Microsoft Windows|MS Windows]], [[UNIX]]
 | langue                   = 
 | type                     = [[Machine virtuelle]]
 | licence                  = [[Artistic License]]
 | site web                 = {{Site officiel|en|http://www.parrot.org/}}
}}

'''Parrot''' est une [[machine virtuelle]] à base de [[Registre (informatique)|registre]]s développée par la communauté [[Perl (langage)|Perl]]. Parrot sera la cible de l'[[interprète (informatique)|interpréteur]] de [[Perl 6]] en cours de spécification.
La plupart des autres machines virtuelles sont à base de [[Pile (informatique)|pile]]s. Les développeurs de Parrot considèrent comme un
avantage la ressemblance avec l'architecture des processeurs actuels. Cela permettra d'utiliser la littérature sur ce sujet pour le développement de la machine virtuelle Parrot. Parrot est aussi destiné à supporter d'autres langages dynamiques tels que
[[Ruby]], [[Python (langage)|Python]], [[Tool Command Language|Tcl]] ou [[JavaScript]].

Conformément à la tradition de cette communauté, Parrot est un [[logiciel libre]] distribué sous [[Artistic License|licence artistique (Perl)]] et sur de nombreuses plates-formes logicielles, parmi lesquelles [[GNU/Linux]].

==Historique==

Le projet a commencé comme un poisson d'avril. Simon Cozens a annoncé que [[Larry Wall]] et [[Guido van Rossum]] (les auteurs respectifs de Perl et de [[Python (langage)|Python]]) unifiaient leurs efforts pour créer Parrot un langage synthèse de Perl et de Python. Ce nom fut ensuite adopté pour un projet au but similaire. Déjà, des petits langages sont supportés par Parrot et permettent de tester ses capacités.

Il est probable que Parrot vient du Sketch &quot;Dead '''Parrot'''&quot; des &quot;Monty '''Python'''&quot; (Comme le langage)

==Techniques==
Parrot utilise des techniques éprouvées mais peu répandues en dehors du monde [[Lisp]] telles que le COW (ou Copy-On-Write), les [[continuation]]s.
Le [[Copy-On-Write]], c’est-à-dire copie sur écriture, permet de partager la mémoire d'objets différents tant qu'ils gardent la même valeur.

==Extensibilité==
Parrot est conçu pour être extensible et pour être la cible de divers langages. On peut inclure l'[[interprète (informatique)|interpréteur]] Parrot dans du code C. On peut appeler du code C de l'interpréteur. On pourra étendre dynamiquement les opérateurs. Parrot supportera l'objet.

==Parrot Polymorphic Containers==
Parrot supporte dynamiquement et de manière efficace de nouveaux types grâce aux PMC (''Parrot Polymorphic Containers''). Lorsqu'on crée un type nouveau que l'on veut implémenter en [[langage C|C]], on implémente les méthodes nécessaire pour ce type supportées par l'interface PMC. Certaines méthodes ont un nom et interface prédéfini. Elles sont accessibles rapidement car
le PMC se comporte alors comme une [[vtable]] à la [[C++]]. Mais un PMC peut avoir des méthodes qui lui sont propres et définir des
attributs. Chaque instance d'un PMC contiendra lesdits attributs.
Il ne faut pas confondre les PMC avec le support objet de plus haut niveau dont l'implémentation sera spécifique à tel ou tel langage  utilisant Parrot mais qui utilisera des PMC prédéfinis par Parrot ou chargés dynamiquement.

==Assembleurs==
Parrot comprend actuellement deux assembleurs : PASM (''Parrot ASseMbly'' - Assembleur Parrot) et PIR (''Parrot Intermediate Representation'' - [[Représentation intermédiaire|Représentation Intermédiaire]] Parrot). Ces [[Langage Assembleur|assembleur]]s sont partiellement orientés objet pour permettre de supporter nativement un nombre indéfini de types.
Historiquement, le premier assembleur sur Parrot, PASM est destiné à terme à devenir une représentation lisible du format binaire PBC (Parrot Bytecode).
PIR, un macro assembleur est l'assembleur de choix.

PIR est de plus haut niveau que PASM car il expose la fiction d'un nombre illimité de registres soulageant le programmeur qui n'a plus à associer manuellement [[variable (informatique)|variable]]s et [[registre (informatique)|registre]]s. Les registres peuvent être de type entier, numérique, chaîne de caractères ou PMC.

== Exemples ==
'''Opérations arithmétiques''':
 set I1, 10
 inc I1        # I1 is now 11
 inc I1, 2     # I1 is now 13
 set N1, 42.0
 dec N1        # N1 is now 41.0
 dec N1, 2.0   # N1 is now 39.0
 print I1
 print &quot;, &quot;
 print N1
 print &quot;\
 &quot;
 end

==Chaîne de compilation==

Parrot supporte une chaîne de [[Compilateur|compilation]] assez complète. La classe HLLCompiler pilote cette compilation. Le programmeur peut définir les passes de la compilation.  Une passe peut être appelée plusieurs fois de manière consécutive.

===Passes typiques de compilations===

Patrick Michaud a écrit un moteur d'analyse syntaxique appelé PGE (''Parrot/Perl Grammar Engine'') qui implante l'essentiel des règles Perl 6 telles que spécifiées dans le synopsis 6. PGE génère typiquement un arbre syntaxique en format PAST (''Parrot Abstract Syntax Tree''). Cet arbre sera typiquement  transformé par TGE (''Tree Grammar Engine''), outil de manipulation d'arbre. Finalement du code PIR sera émis.

== Articles connexes ==
{{colonnes|nombre=2|
* [[Perl 6]] : le langage pour lequel Parrot est développé.
* [[PGE (Perl)|PGE]] : le moteur d'analyse de grammaire de Parrot.
* [[Pugs]], une implémentation de Perl 6 en [[Haskell]].
* [[Rakudo]], le compilateur Perl 6 (en cours de développement).
* [[NQP]], le compilateur de bootstrap de Rakudo.
* [[The Perl Foundation]] : la fondation chargée de la promotion et du développement de Perl.
}}

== Notes et références ==
{{Références}}

== Liens externes ==
* {{en}} [https://github.com/parrot/parrot Code source]
* {{en}} [http://planet.parrotcode.org/ Planet Parrot]

{{Portail|informatique|logiciels libres}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Machine virtuelle]]
[[Catégorie:Perl]]
[[Catégorie:Logiciel sous licence libre]]</text>
      <sha1>ks6gu62uo59bolb4t50b7tturolsrch</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Urbi</title>
    <ns>0</ns>
    <id>1874735</id>
    <revision>
      <id>92501130</id>
      <parentid>90311395</parentid>
      <timestamp>2013-04-26T19:37:20Z</timestamp>
      <contributor>
        <username>Bub's wikibot</username>
        <id>373944</id>
      </contributor>
      <minor/>
      <comment>Robot : Mise en forme du logo et de l'image</comment>
      <text xml:space="preserve" bytes="8305">{{Infobox Logiciel
 | couleur boîte = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom = Urbi
 | logo = Urbi.2.0.cube.lightbg.png
 | image = 
 | description = 
 | développeur = [[Gostai]]
 | date de première version = 2003
 | dernière version = 2.7.3
 | date de dernière version = {{Date|7|octobre|2011|en informatique}}
 | version avancée = 
 | date de version avancée = 
 | langage de programmation = [[C++]], [[urbiscript]]
 | environnement = [[Microsoft Windows]], [[Mac OS X]], [[Linux]]
 | langue = 
 | type = 
 | licences = [[Licence BSD]]
 | site web = [http://www.urbiforge.org www.urbiforge.org]
}}
'''Urbi'''&lt;ref&gt;À l'origine pour ''Universal Real-time Behavior Interface'' ou « Interface Universelle pour Systèmes Interactifs » en français&lt;/ref&gt; est une plate-forme logicielle, sous licence libre [[Licence BSD |BSD]], utilisée pour le développement d'applications dans les domaines de la [[robotique]] et des [[systèmes complexes]].

Urbi intègre une architecture distribuée de composants en [[C++]] appelée UObject, ainsi qu'un langage de script parallèle et événementiel appelé urbiscript. UObject facilite l'intégration d'objets C++ ou Java dans le langage, et permet leur exécution locale ou distante, tandis qu'urbiscript agit comme un outil d'orchestration pour coordonner les différents composants et leurs interactions.

== Le langage urbiscript ==
{{ Infobox Langage de programmation
|  nom                    = urbiscript
|  paradigmes             = [[Programmation_orientée_prototype|Orienté objet (prototypes)]], [[Programmation_fonctionnelle|fonctionnel]], [[Programmation_événementielle|événementiel]], [[Programmation_concurrente|concurrent]] [[Réflexion_(informatique)|réflexif]]
|  année                  = 2003
|  auteur                 = [[Jean-Christophe Baillie]]
|  influencé par          = [[C++]], [[Self (langage)|Self]], [[Io_(langage)|Io]]
}}
Urbi a été initialement développé depuis 1999 par [[Jean-Christophe Baillie]] au laboratoire de Robotique Cognitive de l'[[ENSTA ParisTech]], à Paris. Il est maintenant développé par la société [[Gostai]], fondée en 2006.

Le langage urbiscript est un langage de script qui peut être décrit comme un langage d'''orchestration'' : de même que Lua dans le domaine du jeu vidéo, Urbi peut intégrer des composants C++, les parties algorithmiques gourmandes en CPU étant allouées aux composants C++/Java, tandis que la description des modèles comportementaux généraux restent du domaine du langage de script, qui est plus flexible, plus facile à maintenir, et qui permet des interactions dynamiques durant l'exécution du programme. Le langage urbiscript apporte de nouvelles abstractions utiles lors du développement, les concepts de programmation parallèle et de programmation évènementielle faisant partie intégrante du langage. La spécification de comportements concurrents et la réaction à des évènements étant des exigences clefs de la plupart des applications de robotique et d'intelligence artificielle, Urbi est de fait particulièrement adapté à ce type d'applications.

Outre sa flexibilité et sa modularité, le point fort du langage urbiscript est sa simplicité, offrant une interface intuitive aux débutants, mais également des fonctions avancées aux développeurs confirmés.

== Fonctions ==

* Programmation parallèle et événementielle
* Programmation par prototypes
* Syntaxe proche du C++
* Architecture de composants C++/Java (UObject) avec possibilité de lier des objets ou de les exécuter à distance
* Architecture Client/Serveur
* Interfaces clients avec Java et Matlab (Urbi SDK)
* Plates-formes multiples : Linux, Mac, Windows, et environnements embarqués (x86, ARM, mips, powerPC...)
* Marquage de commandes permettant leur contrôle de façon asynchrone
* Intégration de [[ROS]] directement accessible depuis urbiscript (version 2.1)

== Exemples ==

L'exemple ci-dessous montre comment écrire une boucle vision/action de suivi de balle en Urbi : ''headYaw'' et ''headPitch'' représentent deux objets moteurs (des composants matériels, c'est-à-dire des drivers), ''ball'' est l'objet (composant logiciel) représentant la balle détectée :

&lt;source lang=&quot;C&quot;&gt;
  whenever (ball.visible) 
  {
    headYaw.val   += camera.xfov * ball.x
    &amp;
    headPitch.val += camera.yfov * ball.y
  };
&lt;/source&gt;

''whenever'' est utilisé pour déclencher un bloc de code de façon répétée tant que la condition associée reste vraie. Le signe « &amp; » est utilisé pour spécifier que deux commandes (ou groupes de commandes) doivent être lancées exactement au même instant et exécutées en parallèle.

Un autre mot-clef événementiel est ''at'', qui déclenche le code associé une fois seulement, lorsque la condition invoquée devient vraie :

&lt;source lang=&quot;C&quot;&gt;
  at (speech.hear(&quot;Bonjour&quot;))
  {
    voice.say(&quot;Comment vas-tu ?&quot;)
    &amp;
    robot.standup;
  }
&lt;/source&gt;

Toute commande (ou groupe de commandes) est « marquable », ce qui permet plus tard si besoin de l'annuler, de la bloquer ou de la geler :

&lt;source lang=&quot;C&quot;&gt;
  myTag:
    every (2s)
      echo (&quot;Boucle sans fin&quot;),
  at (button.pressed)
    myTag.stop;
&lt;/source&gt;

Dans l'exemple ci-dessus, la virgule à la fin de la commande permet l'exécution en tâche de fond de la commande qui la précède, entrainant la poursuite de l'exécution du programme et en particulier à la commande 'at' qui suit de s'exécuter sans attendre la fin de la boucle infinie.

== Architecture de composants UObject ==

L'architecture de composants UObject, actuellement basée sur la [[bibliothèque logicielle|bibliothèque]] C++ UObject, permet d'interfacer n'importe quel objet C++/Java avec Urbi/urbiscript, rendant les méthodes et les attributs sélectionnés du code C++ visibles directement depuis le [[langage de script]]. Des indicateurs peuvent être positionnés pour permettre de prévenir le composant C++ de tout changement effectué sur les attributs de l'objet par le langage urbiscript. 

Un UObject peut être utilisé localement, soit en le liant statiquement lors de la compilation, soit par chargement dynamique ultérieur. L'objet C++ partage alors directement la mémoire du noyau Urbi, permettant une intégration efficace. Il s'agit d'une utilisation typique pour les composants critiques tels que les drivers de moteurs ou de capteurs. Ce même objet C++ peut également être utilisé sans modifications en tant que composant distant. Dans ce cas, il devient un programme autonome qui est exécuté avec comme paramètre l'adresse IP du moteur Urbi. Dans les deux cas, l'objet apparaitra et sera traité dans Urbi comme s'il était un objet natif.

Les composants développés par la communauté peuvent être trouvés et échangés sur le site web communautaire [http://www.urbiforge.com/ Urbiforge].

== Robots et simulateurs compatibles Urbi ==

Livrés :
* [[Jazz_(robotique)|Jazz]] ([[Gostai]])
* [[Parrot_AR.Drone|ARDrone]] ([[Parrot_(entreprise)|Parrot]])
* [[Webots]] (simulateur)
* [[Aibo|Aibo ERS7/ERS2xx]]
* [[Bioloid]]
* [[iRobot]] [[iRobot Create|Create]]
* [[Lego Mindstorm NXT]]
* [[HRP-2]] (livraison restreinte)
* [[Nao (robotique)|Nao]] (Aldebaran Robotics)
* [[Pioneer]]
* RMP ([[Segway]])
* Spykee ([[Meccano]])
* Reeti

Non maintenus :

* [[e-puck]]
* [[Surveyor]]
* [[Khepera III]]

== Environnement de développement ==

Urbi permet d'utiliser Gostai Studio qui intègre un éditeur de comportements pour créer graphiquement des machines à états finies hiérarchiques. Gostai Lab est une autre application permettant de réaliser rapidement des interfaces utilisateur par simple glisser-déposer de widgets sur une page de composition.

== Notes ==
&lt;references /&gt;

== Liens externes ==
* {{en}} [http://www.gostai.com Site officiel de la société Gostai]
* {{en}} [http://www.urbiforge.org Site officiel de la communauté open source Urbi]
* {{en}} [http://www.gostai.com/support/documentation/ Documentation]
* {{fr}} [http://www.naoforge.fr/ Naoforge]
* {{fr}} [http://mathieupassenaud.fr/index.php?option=com_content&amp;view=article&amp;id=104:programmez-en-urbi&amp;catid=59:urbi&amp;Itemid=66 Tutoriel sur Urbi]

[[Catégorie:Robotique]]
[[Catégorie:Langage de programmation]]

{{Portail|robotique|informatique}}</text>
      <sha1>6xguwb8huvay192lc76wxpq1fpsu8ed</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>X++</title>
    <ns>0</ns>
    <id>1876473</id>
    <revision>
      <id>97117223</id>
      <parentid>91212992</parentid>
      <timestamp>2013-09-30T12:43:03Z</timestamp>
      <contributor>
        <username>Hilarion</username>
        <id>69767</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="1698">{{Ébauche|informatique}}
{{Infobox Langage de programmation
| nom                    = X++
| logo                   = 
| paradigme              = [[Généricité|générique]], [[Programmation orientée objet|orienté objet]], [[Programmation procédurale|procédural]]
| année                  =
| auteur                 = [[Microsoft]]
| typage                 = 
| implémentations        = Microsoft Dynamics AX
| dialectes              = 
| influencé par          = [[C++]], [[Java (langage)|Java]]
| a influencé            = 
}}

'''X++''' est un [[langage de programmation]] [[Programmation orientée objet|orienté objet]] proche du [[C++]] et du [[Java (langage)|Java]].

[[Microsoft Dynamics AX|MorphX]] est une plateforme pour construire les systèmes complexes de gestion de comptabilité et d'entreprise, la langue X++ inclut un certain nombre de commandes communes de [[Structured Query Language|SQL]] comme partie intégrée du langage.

Les programmeurs employant X++ peuvent accéder aux classes existantes de Dynamics AX de [[Microsoft]] qui fournit la fonction qui s'étend de l'entrée-sortie de base et de la demande de transferts aux commandes de modification dans le temps d'exécution graphique de l'interface utilisateur. Ces classes peuvent être prolongées pour fournir le nouveau comportement.

X++ fournit la vérification étendue, suivie d'un deuxième niveau de la vérification d'exécution. Si aucune référence ne se rapporte à un objet particulier, cet objet est supprimé.

{{Références}}

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]

[[en:Microsoft Dynamics AX#MorphX and X++]]</text>
      <sha1>71zaxied7iqrt9zoel8ywoo03i2bx7n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>HAL/S</title>
    <ns>0</ns>
    <id>1884878</id>
    <revision>
      <id>90321274</id>
      <parentid>79662513</parentid>
      <timestamp>2013-03-15T16:59:31Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q667290]]</comment>
      <text xml:space="preserve" bytes="367">{{voir homonymes|HAL}}
{{Ébauche|informatique}}
'''HAL/S''' (High-order Assembly Language/Shuttle) est un [[langage de programmation]] [[temps réel]] utilisé par la [[National Aeronautics and Space Administration|NASA]] pour la [[navette spatiale]].

{{portail|astronautique|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Système embarqué]]</text>
      <sha1>mgf0vaky29g4qfmy7us7x5cislgtjeb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>YaBasic</title>
    <ns>0</ns>
    <id>6824</id>
    <revision>
      <id>97741118</id>
      <parentid>91088794</parentid>
      <timestamp>2013-10-25T00:30:44Z</timestamp>
      <contributor>
        <ip>78.244.213.243</ip>
      </contributor>
      <comment>/* Exemple de programme */ Petite restructuration</comment>
      <text xml:space="preserve" bytes="3012">{{ébauche|informatique}}
'''YaBasic''', qui signifie ''[[Yet Another]] Basic'', est un [[interprète (informatique) |interprète]] du langage [[BASIC]] pour les plateformes [[Unix]], [[Microsoft Windows|Windows]] et [[PlayStation 2]]. Similaire au Commodore BASIC du [[Commodore 64]], il supporte le mode graphique couleur et a des possibilités d'impression. Il est aussi relativement petit : environ 200 [[octet|kilooctets]].

== Variables ==

=== Types ===
Le langage yabasic utilise deux types de variables :
* les variables [[numérique|numériques]]
* les variables [[alphanumérique|alphanumériques]]

On notera aussi les choses suivantes :
* les variables numériques peuvent faire office de variables [[booléen|booléennes]] (ou logiques)
* les variables alphanumériques peuvent servir à représenter des [[image|images]]
* les noms de variables alphanumériques se terminent toujours par le caractère &quot;[[$]]&quot; alors que les noms de variables numériques ne contiennent jamais ce caractère

=== Déclarations ===

En règle générale, les variable ne sont pas déclarées  en yabasic mais il y a des exceptions :
* les tableaux
* les variables locales
* les variables statiques

Un tableaux global se déclare avec '''dim''' ou '''redim''' (ces deux mots-clés sont synonymes).

Qu'il s'agisse ou non d'un tableau, une variable locale se déclare avec '''local'''.

Qu'il s'agisse ou non d'un tableau, une variable statique se déclare avec '''static'''.

== Exécutables ==

Yabasic permet la création d'exécutables mais, lors d'une telle action, le fichier n'est pas compilé mais combiné à l'interpréteur. Par conséquent, le code source ne peut pas être caché et peut toujours être visualisé à l'aide d'un éditeur de texte adapté (comme [[SciTE]] ou [[Notepad++]]).

== Exemple de programme ==

Un programme de type &quot;[[Hello world]]&quot; en YaBasic :

&lt;code&gt;input &quot;What is your name&quot; name$&lt;br /&gt;
print &quot;Hello &quot; + name$&lt;/code&gt;

== Versions ==
YaBasic fut créé par [[Marc-Oliver Ihm]], qui a annoncé en août 2007 que la version 2.763, sortie deux ans plus tôt, serait probablement la dernière version du logiciel. Cela dit, ce logiciel étant open source, une version 2.764 a été publiée depuis et une version 3 est en cours de développement.

=== La version PlayStation 2 ===

La version pour PlayStation 2 est incluse gratuitement avec les consoles vendues en Europe, Asie et Océanie. Le disque de démo contenant l'interprète YaBasic est un disque PAL et n'est pas prévu pour les marchés américains et japonais. Les programmes peuvent être enregistrés sur des cartes mémoires et ainsi échangés entre amis.

== Liens externes ==
* {{en}} [http://www.yabasic.de/ Site officiel du Yabasic]
* {{en}} [http://www.yabasic.de/yabasic.htm notice Du Yabasic]

* {{en}} [http://basicprogramming.org/wiki/index.php?title=Yabasic Yabasic sur basicprogramming.org] (site des versions 2.764 et 3)

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>2xz6b42k9wsvk5zxh9pneck2d87ak0o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>General algebraic modeling system</title>
    <ns>0</ns>
    <id>1997055</id>
    <revision>
      <id>90334875</id>
      <parentid>82712058</parentid>
      <timestamp>2013-03-15T18:15:29Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q646446]]</comment>
      <text xml:space="preserve" bytes="1026">{{voir homonymes|GAMS}}
{{sources secondaires}}
{{ébauche|logiciel}}

'''General Algebraic Modeling System (GAMS)''' est un logiciel de [[Modèle mathématique|modélisation mathématique]].

GAMS a été le premier langage de modélisation algébrique (Algebraic modeling language ou [[AML]]) et est formellement similaire aux langages de programmation utilisés communément.

Les modèles sont décrits en formulations algébriques concises qui sont lisibles à la fois par les humains et par les machines.

GAMS est largement utilisé en [[Modèle (économie)|modélisation économique]] et en particulier pour implémenter des modèles d'[[équilibre général calculable]], tel que [[Global Trade Analysis Project|GTAP]].

== Lien externe ==
* [http://www.gams.com/ Site officiel]

{{portail|mathématiques|informatique théorique|programmation informatique|logiciel}}

[[Catégorie:Logiciel de calcul formel]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Optimisation]]
[[Catégorie:Recherche opérationnelle]]</text>
      <sha1>m2z03f7mwnu2gfic7cenf775ch8rp9o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lustre (langage)</title>
    <ns>0</ns>
    <id>2007625</id>
    <revision>
      <id>97679291</id>
      <parentid>97679208</parentid>
      <timestamp>2013-10-22T16:30:33Z</timestamp>
      <contributor>
        <username>Akli-wiki</username>
        <id>1566119</id>
      </contributor>
      <text xml:space="preserve" bytes="1742">{{Ébauche|informatique}}
{{voir homonymes|lustre}}

'''Lustre''' est un langage de programmation [[Programmation synchrone|synchrone]], [[Programmation déclarative|déclaratif]], et par flots. Il possède une [[Méthode formelle (informatique)|définition formelle]], et est utilisé pour la programmation des systèmes réactifs. Son développement a commencé au début des [[années 1980]], dans le cadre d'un projet de recherche. Il est entré dans le monde industriel en 1993, lorsque la société [[Esterel Technologies]] a publié l'environnement commercial SCADE, dont il constitue le cœur. Lustre est désormais utilisé pour la conception de logiciel critique dans l'[[aéronautique]] ([[Airbus]], [[Eurocopter]], [[Dassault]], [[Pratt &amp; Whitney]]), le ferroviaire ([[Eurostar]]) et les [[centrale nucléaire|centrales nucléaires]] ([[Schneider Electric]]).

== SCADE ==
SCADE est un environnement de développement intégré diffusé par [[Esterel Technologies]], dont le nom signifie ''Safety Critical Application Development Environment''. Il est destiné à la conception de [[systèmes critiques]].

Il est basé sur le langage Lustre, et permet de générer du code en [[C (langage)|langage C]] ou [[Ada (langage)|Ada]].

Il peut être qualifié [[DO-178B]] niveau A par ses utilisateurs, ce qui explique sa popularité en aéronautique.

== Voir aussi ==
* [[Esterel (langage)]], un langage cousin
* [[Paul Caspi]]
* [[Nicolas Halbwachs]]

== Liens externes ==
* [http://www-verimag.imag.fr/SYNCHRONE/ Site web du laboratoire Synchrone]
* [http://www.esterel-technologies.com/products/scade-suite/overview.html Page du produit SCADE]

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation|Lustre]]</text>
      <sha1>orqh2a8eyybafvhpt26gf2kwq5dltpr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>C Intermediate Language</title>
    <ns>0</ns>
    <id>2093132</id>
    <revision>
      <id>90343123</id>
      <parentid>55145805</parentid>
      <timestamp>2013-03-15T19:25:49Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2932182]]</comment>
      <text xml:space="preserve" bytes="1003">{{voir homonymes|CIL}}
{{Ébauche|informatique}}
'''C Intermediate Language''' (CIL) est un [[langage intermédiaire]], sous-ensemble simplifié du langage de programmation [[C (langage)|C]].

C'est également un ensemble d'outils [[logiciel libre|libre]]s publiés sous [[licence BSD]] pour:
* analyser et transformer ce langage intermédiaire
* transformer des programmes écrits en C de et vers ce langage.


CIL est utilisé par [http://hal.cs.berkeley.edu/ccured/ CCured], un [[compilateur]] qui compile un programme écrit en C en un code offrant un typage sûr en analysant l'utilisation des pointeurs et en insérant des vérifications à l'exécution là où le typage ne peut pas être [[analyse statique de programmes|déterminé statiquement]].

== Liens externes ==
*[http://hal.cs.berkeley.edu/cil/ Documentation du projet CIL] à l'[[Université de Californie (Berkeley)|université Berkeley]]
*{{Projet SourceForge|cil}}

{{Portail|Informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>2e3jgvkhhl7buhmf6tgucv464974v9t</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>CLU (langage)</title>
    <ns>0</ns>
    <id>1153870</id>
    <revision>
      <id>90170313</id>
      <parentid>86009792</parentid>
      <timestamp>2013-03-14T18:25:30Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 11 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q775159]]</comment>
      <text xml:space="preserve" bytes="1196">{{voir homonymes|CLU}}
{{Ébauche|informatique}}
{{Infobox Langage de programmation
|  nom                    = CLU
|  paradigmes             = [[Programmation orientée objet|Objet]], [[Programmation impérative|impératif]]
|  année                  = [[1974]]
|  auteur                 = [[Barbara Liskov]] et ses étudiants au [[Massachusetts Institute of Technology|MIT]]
|  développeurs           = Barbara Liskov et ses étudiants au MIT
|  dernière version stable=
|  typage                 = [[Typage fort|Fort]]
|  implémentations        = [ftp://ftp.lcs.mit.edu/pub/pclu/ Portable CLU], [http://pmg.csail.mit.edu/~dcurtis/clu/ Native CLU], [http://www.din.or.jp/~ushijima/clu2c.html clu2c]
|  dialectes              = 
|  influencé par          = [[Pascal (langage)|Pascal]]
|  a influencé            = [[Ruby]], [[Ada (langage)|Ada]]
|  système d'exploitation = 
|  licences               = 
|  site web               = 
}}
'''CLU''' est un [[langage de programmation]] créé au [[Massachusetts Institute of Technology]] (MIT) par [[Barbara Liskov]] et ses étudiants entre [[1974]] et [[1975]].

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>2othed96hbs008roofdifkh68ljnjqc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Algol 68</title>
    <ns>0</ns>
    <id>2181596</id>
    <revision>
      <id>93384955</id>
      <parentid>90347176</parentid>
      <timestamp>2013-05-23T12:35:48Z</timestamp>
      <contributor>
        <username>Lf69100</username>
        <id>906897</id>
      </contributor>
      <comment>consolidation / extension des références</comment>
      <text xml:space="preserve" bytes="3584">{{Ébauche|informatique}}

'''Algol 68''' est un [[langage de programmation]] universel dérivé du langage [[Algol (langage)|Algol 60]], principalement conçu par des Européens.

== Principe ==

Au-delà d'[[Algol 60]], l'objectif des concepteurs d'Algol 68 était d'offrir un langage de programmation universel, résolument innovant, dérivant sa puissance d'une conception orthogonale.

En Algol 68,
* le programmeur peut définir de nouveaux types de données, de nouveaux opérateurs, la surcharge et l'extension des opérateurs prédéfinis ; il peut ainsi adapter le langage au domaine de l'application ;
* des processus peuvent s'exécuter en parallèle, et se synchroniser à l'aide de sémaphores ;
* les entrées/sorties exploitent des volumes organisés en livres, pages et lignes.

[[Niklaus Wirth]] qui faisait à l'origine partie du groupe de travail a refusé l'innovation extrême d'Algol 68 et a fait sécession pour proposer [[Algol W]] qui deviendra par la suite [[Pascal (langage)|Pascal]].

=== Syntaxe ===
La syntaxe a été définie à l'aide d'une [[Grammaire non contextuelle|grammaire indépendante du contexte]], à deux niveaux, qui porte le nom de son concepteur [[Adriaan van Wijngaarden]]. Le Rapport Révisé (1973) a montré que la grammaire d'Algol 68, proposée par van Wijngaarden, reconnaît tout programme Algol 68 valide. En effet, elle formalise aussi les contraintes contextuelles et/ou sémantiques du langage, décrites antérieurement en langue naturelle de façon plus ou moins ambiguë. 

== Réalisation ==

L'analyse syntaxique d'Algol 68 a été implantée dans les premiers compilateurs par du code ''ad hoc'' ajouté à un analyseur lexical traditionnel. 

Algol 68R est le dialecte traité par le premier compilateur, réalisé en 1970 au Royal Radar and Signal Establishment de Malvern (UK).

== Voir aussi ==
=== Bibliographie ===
Groupe Algol de l'[[AFCET]]. ''Définition du langage algorithmique ALGOL 68'' ; présent. et trad. française du &lt;cite lang=en&gt;Report on the algorithmic language Algol 68&lt;/cite&gt; éd. par J. Buffet, P. Arnal, A. Quéré - 1972 - Hermann (Actualités scientifiques et industrielles) - VII-222 p. ; 24&amp;nbsp;cm

[http://www.softwarepreservation.org/projects/ALGOL/book/Lindsey_van_der_Meulen-IItA68-Revised.pdf Lindsey C.H., ''Informal Introduction to Algol 68'', 1977, North Holland Publishing Cy.] 

Woodward P.M. and S. G. Bond S. G., ''Algol 68-R Users Guide'', (2nd  Second edition), 1974, Her Majesty's Stationary Office.

Cleveland &amp; Uzgalis ''Grammars for Programming Languages'', 1977,  Computer Science Library, Elsevier.  

=== Liens externes ===
* {{en}} [http://vestein.arb-phys.uni-dortmund.de/~wb/RR/rr.pdf Revised Report on the Algorithmic Language ALGOL 68] Le manuel de référence officiel pour les utilisateurs et développeurs de ce langage. (version [http://vestein.arb-phys.uni-dortmund.de/~wb/RR/rrTOC.html html]).
* {{en}} [http://portal.acm.org/citation.cfm?id=155365 A history of Algol 68]
* {{en}} [http://en.wikipedia.org/wiki/Van_Wijngaarden_grammar grammaire de van Wijngaarden]
* {{fr}}[http://tel.archives-ouvertes.fr/docs/00/04/85/97/PDF/tel-00010530.pdf P.Y. Cunin, M. Simonet, J. Voiron, ''Méthodologie d'écriture de compilateurs - une expérience du langage ALGOL 68'', thèse INPG, 1976 ]
* {{en}} [http://www.softwarepreservation.org/projects/ALGOL/algol68impl Algol 68 implementations and dialects]
* {{en}} [http://algol68.sourceforge.net/ Open source Algol 68 implementations]
{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>j4d32csncxagzun8i34fh3f4vprylxc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ATLAS Transformation Language</title>
    <ns>0</ns>
    <id>733518</id>
    <revision>
      <id>90050424</id>
      <parentid>75702338</parentid>
      <timestamp>2013-03-13T23:09:53Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q667812]]</comment>
      <text xml:space="preserve" bytes="1566">{{voir homonymes|ATL}}
'''ATLAS Transformation Language''' (ATL) est un langage de transformation de modèles plus ou moins inspiré par le standard [[QVT]] de l'[[Object Management Group|OMG]]. Il est disponible en tant que [[plugin]] dans le projet [[Eclipse (logiciel)|Eclipse]] &lt;ref&gt;[http://www.eclipse.org/m2m/ M2M]&lt;/ref&gt;. On peut trouver plus d'informations sur le langage ATL, sur son environnement de développement ainsi que sur les bibliothèques de transformations sur le site de l'université de Nantes&lt;ref&gt;[http://www.sciences.univ-nantes.fr/lina/atl/ ATL univ-nantes.fr]&lt;/ref&gt;.

ATL est un prototype académique de composant de transformation de modèles du projet Eclipse Modeling&lt;ref&gt;[http://www.eclipse.org/m2m/atl ATL eclipse]&lt;/ref&gt;. Sont également annoncés deux autres composant, l'un en provenance de [[Compuware]], l'autre de [[Borland]]. Des ponts entre ces trois composants sont prévus.

Pour toute information sur la transformation de modèles à modèles, on consultera le groupe de news suivant:  [news://news.eclipse.org/eclipse.modeling.m2m M2M newsgroup] qui donne les dernières informations sur l'évolution de la pratique dans ce domaine. Rappelons que la fondation Eclipse est désormais (janvier 2007) membre de l'[[Object Management Group|OMG]].

Les plugins Eclipse sont distribués sous la  [[licence libre]] [[Eclipse Public License|EPL]].

== Notes et références ==
&lt;references /&gt;

{{Palette|Fondation Eclipse}}
{{Portail|programmation informatique}}

[[Catégorie:Génie logiciel]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>fqwffhi3z5ssgv4j64rn225fjwouk5i</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>High Level Assembly</title>
    <ns>0</ns>
    <id>2481026</id>
    <revision>
      <id>94178417</id>
      <parentid>87639462</parentid>
      <timestamp>2013-06-18T14:32:03Z</timestamp>
      <contributor>
        <username>Ske</username>
        <id>875</id>
      </contributor>
      <comment>ébauche, ménage interwiki</comment>
      <text xml:space="preserve" bytes="1525">{{ébauche|informatique}}
{{Infobox Logiciel
| nom = High Level Assembly (HLA)
| logo = 
| image = 
| description = 
| développeur = Randall Hyde
| version actuelle = 1.106
| date de la version actuelle = 02/07/2009
| environnements = [[Microsoft Windows|Windows]], [[Mac OS X]], [[Linux]], [[FreeBSD]]
| type = [[Langage de programmation]] [[informatique]], [[Assembleur]] de haut niveau
| licences = [[Open Source]], [[Domaine public (propriété intellectuelle)|Domaine public]]
| site web = [http://web.mac.com/randyhyde/HighLevelAsm/index.html http://web.mac.com/randyhyde/HighLevelAsm/index.html]
}}


'''HLA''' est un [[programme assembleur]] pour l'architecture [[IA-32]]. Le nom signifie ''High Level Assembly''. HLA est écrit en [[langage assembleur]] et existe pour les systèmes [[Microsoft Windows|Windows]], [[Mac OSX]], GNU/[[Linux]], et [[FreeBSD]].
Il a été écrit par [[Randall Hyde]] dans le but d'enseigner l'assembleur dans les meilleures conditions possibles, aujourd'hui c'est un assembleur qui n'a pas à envier aux équivalents commerciaux.

==Liens externes==

* [http://web.mac.com/randyhyde/HighLevelAsm/index.html HLA] (''source ouverte'', assembleur [[IA-32]])
* [http://www.systranet.fr/turl/?systranpopupmode=1&amp;systrangui=/web&amp;systranuid=aHR0cC13ZWIubWFjLmNvbS9yYW5keWh5ZGUvSGlnaExldmVsQXNtL0hMQURvYy9IVE1MRG9jL2hsYWZhcS50eHQvZW5fZnI=&amp;systranbanner=1 Foire aux Questions] (Traduction française par SYSTRANet)
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>cc9gh4r088bir43xo1fl9437bd7opi1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>LCM (langage)</title>
    <ns>0</ns>
    <id>2244544</id>
    <revision>
      <id>94393898</id>
      <parentid>65113269</parentid>
      <timestamp>2013-06-25T10:34:33Z</timestamp>
      <contributor>
        <username>Piku</username>
        <id>14751</id>
      </contributor>
      <comment>voir homonymes</comment>
      <text xml:space="preserve" bytes="341">{{homon|LCM}}
{{Ébauche|informatique}}

'''LCM''' (Logic Control Modeler) est un langage de programmation de type synchrone. Il est développé par la société [[Dassault Systèmes]].

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Programmation concurrente]]
[[Catégorie:Dassault Systèmes]]</text>
      <sha1>o1m4wm38mir0789axhciimp6bqlljau</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>JRuby</title>
    <ns>0</ns>
    <id>2727558</id>
    <revision>
      <id>101688790</id>
      <parentid>101688767</parentid>
      <timestamp>2014-03-01T09:27:54Z</timestamp>
      <contributor>
        <username>Dadu</username>
        <id>55405</id>
      </contributor>
      <text xml:space="preserve" bytes="2206">{{ébauche|logiciels libres}}

{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                              = JRuby
 | logo                             = 
 | paradigme                        = 
 | auteur                           = 
 | développeur                      = Charles Nutter, Thomas Enebo, Ola Bini and Nick Sieger
 | date de première version         = 2001
 | dernière version stable          = 1.7.10
 | date de dernière version stable  = {{Date|9|janvier|2014|en informatique}}
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = 
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = 
 | a influencé                      = 
 | système d'exploitation           = [[Multiplate-forme]]
 | licence                          = [[Common Public License|CPL]]/[[GNU GPL]]/[[GNU LGPL]]
 | site web                         = [http://jruby.org/ jruby.org]
 | date de mise à jour              = 01/03/2014
}}

'''JRuby''' est une implémentation de l'interpréteur de [[Ruby]] en [[Java (langage)|Java]] développé par la JRuby team. C'est un [[logiciel libre]] à [[open source|sources ouvertes]], sous la triple licence [[Common Public License|CPL]]/[[GNU GPL]]/[[GNU LGPL]].

Il permet d'améliorer les applications existantes en Java en y apportant la souplesse et rapidité du prototypage et du developpement du langage Ruby. Il est utilisé notamment dans le [[secteur bancaire]], dans lequel Java a eu un fort impact&lt;ref&gt;[http://www.lemagit.fr/actualites/2240197471/Ruby-et-Rails-draguent-la-communaute-Java-a-Paris Ruby et Rails draguent la communauté Java à Paris]&lt;/ref&gt;.

== Voir aussi ==

===Note et références ===
{{Références}}

=== Lien externe ===
* {{en}} [http://jruby.org/ Site officiel du projet JRuby]

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]
[[Catégorie:Ruby|*]]
[[Catégorie:Java]]</text>
      <sha1>f77gtck73r5oq9diiqno5dugxi8wwwy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Qi (langage)</title>
    <ns>0</ns>
    <id>2802173</id>
    <revision>
      <id>54824018</id>
      <parentid>54159557</parentid>
      <timestamp>2010-07-01T13:28:08Z</timestamp>
      <contributor>
        <username>Yodaspirine</username>
        <id>173343</id>
      </contributor>
      <minor/>
      <comment>Ajout rapide de {{portail}} : + Informatique ; avec [[Projet:JavaScript/Notices/BandeauxPortails|BandeauxPortails]]</comment>
      <text xml:space="preserve" bytes="2989">{{Infobox Langage de programmation
|  nom                    = Qi
|  paradigmes             = [[Programmation fonctionnelle|fonctionnel]], [[Programmation logique|logique]]
|  auteur                 = Mark Tarver
|  développeurs           = Mark Tarver et al.
|  typage                 = [[Typage statique|statique]], [[Typage dynamique|dynamique]]
|  influencé par          = [[Haskell]], [[ML_(langage)|ML]], [[Lisp]], [[Prolog]]
|  système d'exploitation = [[Multi-plate-forme]]
|  site web               = http://www.lambdassociates.org/
}}

Qi est un langage de [[programmation fonctionnelle]] créé par Mark Tarver, introduit en avril 2005 et 
distribué sous licence GPL. Qi est écrit en [[Lisp]]. Il inclut la plupart des fonctionnalités communes 
à la programmation fonctionnelle: le filtrage, la [[curryfication]], [[inférence de types]], [[typage statique]], 
[[typage dynamique]], la [[garde (informatique)|garde]] et l'application partielle.
Ce langage a remporté en 2003, le prix ''Promising Invention Award'' de l'[[Université d'État de New York]].

==La base du langage Qi==

Par certains côtés, Qi se veut une simplification du langage [[Lisp]]. Les fonctions utilisent la notation préfixée.  

Un programme qui affiche ''Hello World'' sur la sortie standard :

 (output &quot;Hello, world~%&quot;)

Les listes se construisent avec [ .... ] et les éléments sont séparés par un espace.

 [76 trombones]

La fonction [[factorielle]] définie en utilisant le ''filtrage'' :

 (define factorial
   0 -&gt; 1
   N -&gt; (* N (factorial (- N 1))))

Une fonction ''anonyme'' qui multiplie par 2.

 (/. X (* X 2))

Une fonction ''membre'' utilisant le filtrage sur les listes. (Qi suit la syntaxe conventionnelle 
du Edinburgh [[Prolog]] pour le filtrage, sauf que des espaces sont utilisées au lieu de la virgule pour 
séparer les éléments.)

 (define member
  _ [] -&gt; false
  X [X | _] -&gt; true
  X [_ | Y] -&gt; (member X Y))

Une fonction utilisant la [[garde (informatique)|garde]] qui cherche le premier nombre plus grand que N dans une liste.

 (define find_greater
   N [] -&gt; (error &quot;no number greater than ~A.~%&quot; N)
   N [M | _] -&gt; M where (&gt; M N)
   N [_ | Ns] -&gt; (find_greater N Ns))

==Qi Prolog ==

Qi Prolog est une version du langage [[Prolog]] mise en œuvre en Qi, en utilisant la syntaxe standard d'Edinburgh. 
Voici un exemple de base en Qi Prolog:

 (defprolog
   &quot;dog(snoopy).
    man(socrates).
    man(plato).
    mortal(X) :- man(X).&quot;)

Et pour interroger la base de connaissance Prolog:

 (ask [ man plato ] )
 (ask [ man snoopy ] )
 (ask [ dog X ] )
 (ask [ man M ] )

==Liens externes==

* La site officiel de Qi sur [http://www.lambdassociates.org/ Lambda Associates].
* Le cours [http://www.lambdassociates.org/FPQi.pdf Functional Programming in Qi].
* Le [http://groups.google.co.uk/group/Qilang groupe de discussion sur Qi].

{{Portail|Informatique}}

[[Catégorie:Langage de programmation|Fonctionnel]]
[[Catégorie:Programmation fonctionnelle]]</text>
      <sha1>6fbelb4aac93xkyg3zv1pfpria8uecr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>DialogOS</title>
    <ns>0</ns>
    <id>2817965</id>
    <revision>
      <id>100049140</id>
      <parentid>92501977</parentid>
      <timestamp>2014-01-08T17:11:31Z</timestamp>
      <contributor>
        <username>Ltrlg</username>
        <id>791461</id>
      </contributor>
      <minor/>
      <comment>typographie</comment>
      <text xml:space="preserve" bytes="1944">{{ébauche|informatique}}
{{Infobox Logiciel
 | couleur boîte = 
 | nom = DialogOS
 | logo = DialogOS.jpeg
 | image = DialogOS.jpg
 | description = L'environnement de programmation graphique de DialogOS
 | taille image = 
 | développeur = [http://www.clt-st.de/ CLT Sprachtechnologie]
 | date de première version = 
 | dernière version = 
 | date de dernière version = 
 | version avancée = 
 | date de version avancée = 
 | langage de programmation = 
 | environnement = 
 | langue = [[Allemand]], [[anglais]]
 | type = 
 | licence = 
 | site web = {{de}} [http://www.clt-st.de/produkte-losungen/dialogos/ www.clt-st.de]&lt;br /&gt;{{en}} [http://www.clt-st.de/en/produkte-losungen/dialogos/ www.clt-st.de/en]
}}
'''DialogOS''' est une plateforme de développement pour système informatique capable de parler avec l’utilisateur. DialogOS utilise un [[organigramme de programmation]], il est donc possible d'utiliser DialogOS sans avoir de profondes connaissances informatiques. Le programme comprend aussi une extension pour commander les robots de type [[Lego Mindstorm NXT]] avec la voix. Actuellement l'anglais et l'allemand sont directement supporté par DialogOS.

DialogOS est principalement utilisé dans les cours informatiques des écoles ou dans des universités, pour apprendre la programmation ainsi que les principes de la création d'un dialogue électronique.

== Lego Mindstorm NXT == 
DialogOS supporte directement les robots de la gamme [[Lego Mindstorm NXT]]. Les capteurs suivants fonctionnent directement avec le système:
* capteur ultrasonique
* capteur sonore
* capteur de contact
* capteur de lumière

Il est également possible « d'émuler » d'autre capteurs, comme le capteur de couleurs, en les utilisant par exemple en tant que capteur ultrasonique.

{{Portail|informatique}}

[[Catégorie:Jeu de construction]]
[[Catégorie:Lego Mindstorms]]
[[Catégorie:Robotique]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>t7n8pt3izj8ka57dax09woqjtj41k24</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Vala (langage de programmation)</title>
    <ns>0</ns>
    <id>2843208</id>
    <revision>
      <id>90400367</id>
      <parentid>87077714</parentid>
      <timestamp>2013-03-16T04:17:52Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 16 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1138939]]</comment>
      <text xml:space="preserve" bytes="2861">{{ébauche|informatique}}
{{Infobox Langage de programmation
| nom                    = Vala
| logo                   = 
| paradigme              = [[Programmation structurée|structuré]], [[Programmation impérative|imperatif]], [[Programmation orientée objet|orienté objet]]
| année                  = [[2006]]
| auteur                 = [[Jürg Billeter]]
| développeur            = [[Jürg Billeter]] &amp; [[Raffaele Sandrini]]
| typage                 = [[Typage statique|statique]], [[Typage fort|fort]], [[Système nominatif de types|nominatif]]
| influencé par          = [[C sharp|C#]], [[C++]], [[C (langage)|C]], [[Java (langage)|Java]]
}}
'''Vala''' est un [[langage de programmation]] [[compilateur|compilé]], dont l'objectif est de fournir les bénéfices des langages de programmation modernes (comme la [[Programmation orientée objet|POO]]) aux [[développeur]]s de la plateforme [[GNOME]] qui utilisent [[GLib]] et son système [[GObject]].

Sa syntaxe est basée sur celle de [[C sharp|C#]] mais il ne nécessite pas d'[[Machine virtuelle|environnement d'exécution]]. Vala est transformé en code [[C (langage)|C]], lui-même compilé en code machine natif. Les avantages d'une telle chaîne de compilation sont de produire des logiciels qui requièrent moins de [[mémoire vive]] et qui s'exécutent plus rapidement.

De plus, ce passage par l'étape C rend possible l'utilisation des bibliothèques C au moyen d'interfaces définies dans les fichiers Vapi. Des fichiers Vapi sont fournis avec Vala pour une grande partie de la plateforme [[GNOME]], ainsi que pour d'autres bibliothèques.

Par exemple, le logiciel [[Shotwell]] ou le greffon Arte+7 pour [[Totem (logiciel)|Totem]]&lt;ref&gt;{{en}} [http://foregroundnoise.wordpress.com/2009/12/30/arte-totem-plugin/ Totem Arte+7 Plugin], 30 décembre 2009&lt;/ref&gt; sont écrits en Vala.

==Exemple de code==

Le programme « [[Hello World]] » :
&lt;source lang=&quot;csharp&quot;&gt;
void main () {
  print (&quot;Hello World\n&quot;);
}
&lt;/source&gt;

Le programme « [[Hello World]] » programmation orientée objet :
&lt;source lang=&quot;csharp&quot;&gt;
public class Main
{
  public static int main (string[] args)
  {
    stdout.printf(&quot;Hello, World\n&quot;);
    
    return 0;
  }
}
&lt;/source&gt;

== Notes et références ==
{{Références}}

==Voir aussi==
* [[Quine (informatique)#Vala|Quine en Vala]]

==Liens externes==
* {{en}} [http://live.gnome.org/Vala The Vala Programming Language], sur GNOME Live!
* {{en}} [http://code.google.com/p/vala-benchmarks/ Benchmark of Vala versus C# and C]
* {{en}} [http://rodney.id.au/dev/vala/hackers.html Hackers' Guide to Vala]
* {{fr}} [http://nicolasj.developpez.com/gtk/vala/ Présentation du langage Vala]
* {{fr}} [http://www.siteduzero.com/tutoriel-3-264159-le-langage-vala.html Tutoriel sur le langage Vala]

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ivte5s0lgqusgxvtwt50mtho5x959xv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>A-0 System</title>
    <ns>0</ns>
    <id>2882346</id>
    <revision>
      <id>101104763</id>
      <parentid>90405923</parentid>
      <timestamp>2014-02-09T22:30:55Z</timestamp>
      <contributor>
        <username>Roll-Morton</username>
        <id>1333940</id>
      </contributor>
      <minor/>
      <comment>Changement rapide de {{portail}} : - Informatique théorique , + Informatique ; avec [[Projet:JavaScript/Notices/BandeauxPortails|BandeauxPortails]]</comment>
      <text xml:space="preserve" bytes="1404">{{Homonyme|A0}}
{{ébauche|informatique}}
'''A-0 System''' est le premier [[compilateur]] développé pour un [[ordinateur]]&lt;ref&gt;''History of Programming Languages'', Richard L. Wexelblat, [[Academic Press]], New York, 1981, ISBN 978-0-12-745040-7&lt;/ref&gt;. Il a été écrit par [[Grace Hopper]] en 1951 et 1952 pour l'[[UNIVAC I]] (celle-ci fut plus tard à l'origine de [[COBOL]]).

== Description ==
A-0 était plus un « chargeur de programme » ou un [[édition de liens|éditeur de liens]] que ce que l'on appelle aujourd'hui un compilateur. Il permettait de décrire un programme comme une séquence de [[sous-programme]]s ayant des [[paramètre]]s. Les sous-programmes étaient identifiés par un code numérique et leurs paramètres étaient écrits directement après le code de chaque sous-programme. Le « système A-0 » convertissait cette description en [[langage machine|code machine]] exécutable sur l'ordinateur cible.

== Évolution ==
A-0 fut suivi de A-1, A-2, A-3 ([[ARITH-MATIC]]), AT-3 ([[MATH-MATIC]]) et B-0 ([[FLOW-MATIC]]).

== Voir aussi ==
=== Notes et références ===
&lt;references /&gt;

=== Articles connexes ===

* [[Fortran]] (1954)
* [[COBOL]] (1959)

=== Liens externes ===
* {{es}} [http://www.cimacnoticias.com/noticias/05may/s05051705.html Grace Hopper] sur cimacnoticias.com

{{Portail|programmation informatique|Informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>4c6bas21j6h5vx385ezzuq1e71p00am</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>AspectJ</title>
    <ns>0</ns>
    <id>2898489</id>
    <revision>
      <id>90407815</id>
      <parentid>82615911</parentid>
      <timestamp>2013-03-16T05:35:33Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 11 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q735604]]</comment>
      <text xml:space="preserve" bytes="3731">{{ébauche|informatique}}
'''AspectJ''' est une extension [[Programmation orientée aspect|orientée aspect]], créée à [[Xerox PARC]], pour le langage de programmation [[Java (technologie)|Java]]. Cette extension est disponible dans les projets open-source [[Eclipse (fondation)|Eclipse]], de manière autonome ou sous forme d'extension pour [[Eclipse|l'environnement de développement Eclipse]]. AspectJ est devenu le standard, du fait de son utilisation répandue, pour la [[Programmation orientée aspect]] en mettant l'accent sur la simplicité et la facilité de mise en œuvre pour les utilisateurs finaux. AspectJ se base sur la syntaxe du langage [[Java (technologie)|Java]] et s'intègre aux [[Environnement de développement intégré|IDE]] pour afficher  sa structure transversale depuis sa première publication en 2001.

Le tissage des aspects est réalisé sur les classes compilées. Ce tissage peut être établi au moment de la compilation du code source ou lors de l'exécution, lors du chargement des classes par la machine virtuelle&lt;ref&gt;http://www.eclipse.org/aspectj/doc/next/devguide/ltw.html&lt;/ref&gt;.

==Langage de description simple==
Tout programme [[Java (technologie)|Java]] est compatible AspectJ. Toutefois, AspectJ permet également aux programmeurs de définir des constructions spéciales nommées ''&quot;aspects&quot;''. Les &quot;aspects&quot; peuvent contenir plusieurs entités inutilisables par des classes standard.
On trouve :

*[[Déclaration inter-types]] - permet au programmeur d’introduire des méthodes, champs ou interfaces à des classes existantes depuis l'&quot;aspect&quot;. L'exemple suivant ajoute une méthode &lt;code&gt;acceptVisitor&lt;/code&gt; (voir [[Visiteur (motif de conception)]]) à la classe &lt;code&gt;Point&lt;/code&gt; :
::&lt;code&gt;aspect VisitAspect {&lt;/code&gt;
:::&lt;code&gt;void Point.acceptVisitor(Visitor v) {&lt;/code&gt;
::::&lt;code&gt;v.visit(this);&lt;/code&gt;
:::&lt;code&gt;}&lt;/code&gt;
::&lt;code&gt;}&lt;/code&gt;

*&quot;[[Pointcut]]&quot; - non traduit par convention ; pourrait se traduire par &quot;Point de césure&quot; - permet au programmeur de spécifier des &quot;[[Join point]]s&quot; - non traduit par convention ; pourrait se traduire par &quot;Point de jonction&quot; - (définis à des moments clés de l'exécution d'un programme, comme l'appel à une méthode, l'instanciation d'objet ou l'accès à une variable). Tout &quot;poincut&quot; est une expression vérifiant la correspondance d'un &quot;join point&quot;.
Par exemple, ce &quot;pointcut&quot; fait correspondre l'exécution de n'importe quelle méthode d'instance d'un objet de type &lt;code&gt;Point&lt;/code&gt; dont le nom commence par &lt;code&gt;set&lt;/code&gt; :
::&lt;code&gt;pointcut set() : execution(* set*(..) ) &amp;&amp; this(Point);&lt;/code&gt;

*&quot;[[Advice]]&quot; - non traduit par convention; pourrait se traduire par &quot;Greffon&quot; - permet au programmeur de spécifier le code à exécuter au &quot;[[Join point]]&quot; remplissant la condition d'un &quot;[[pointcut]]&quot;. Les actions peuvent être exécutées ''avant'', ''après'' ou ''autour'' du &quot;[[Join point]]&quot; spécifié. Ici, l'&quot;advice&quot; rafraîchit l'affichage à chaque fois que quelque chose de l'objet &lt;code&gt;Point&lt;/code&gt; est &lt;code&gt;set&lt;/code&gt;, grâce au &quot;pointcut&quot; définis plus tôt :
::&lt;code&gt;after () : set() {&lt;/code&gt;
:::&lt;code&gt;Display.update();&lt;/code&gt;
::&lt;code&gt;}&lt;/code&gt;

AspectJ supporte également des formes statiques limitées de vérification et réutilisation d'aspect basées sur les &quot;pointcuts&quot; (par héritage).

== Voir également ==

* {{en}} [http://www.eclipse.org/aspectj/doc/released/progguide/index.html Guide de programmation AspectJ] pour une description plus détaillée du langage.

==Références==
{{Traduction/Référence|en|AspectJ|216847648}}
&lt;references/&gt;

{{Palette|Fondation Eclipse}}
{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Eclipse]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>3yh6byyap4yvjbuuo50y8sqxwrix99f</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NQP</title>
    <ns>0</ns>
    <id>2931108</id>
    <revision>
      <id>98774944</id>
      <parentid>44299557</parentid>
      <timestamp>2013-11-29T20:32:34Z</timestamp>
      <contributor>
        <username>Cymbella</username>
        <id>316223</id>
      </contributor>
      <comment>ébauche informatique</comment>
      <text xml:space="preserve" bytes="684">{{Ébauche|informatique}}
'''NQP''' signifie Not Quite Perl (Pas Vraiment Perl). Ce composant de [[Parrot (machine virtuelle)| Parrot]] est un sous ensemble de [[Perl 6]] destiné à l'écriture de [[compilateur]]s. Il utilise [[Parser Grammar Engine|PGE]] pour l'[[analyse syntaxique]].
Il est utilisé pour le [[Bootstrap (compilateur)|bootstrap]] de [[Rakudo]], un compilateur [[Perl 6]].
{{...}}
{{Portail|informatique|logiciels libres}}
[[Catégorie:Perl]]
[[Catégorie:Logiciel sous licence libre]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Langage fonctionnel]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]</text>
      <sha1>cizg4ikq6l6uaf28czol86oafphxvlj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>BBj Language</title>
    <ns>0</ns>
    <id>2950251</id>
    <revision>
      <id>77536999</id>
      <parentid>74379549</parentid>
      <timestamp>2012-04-10T16:33:11Z</timestamp>
      <contributor>
        <username>Isaac Sanolnacov</username>
        <id>188230</id>
      </contributor>
      <minor/>
      <comment>Homonymie résolue à l’aide du robot : Java - Modifications du (des) lien(s) pour [[Java (langage)]]</comment>
      <text xml:space="preserve" bytes="1271">'''BBj''', sigle de Business [[BASIC|Basic]] on [[Java (technologie)|Java]], est un [[langage de programmation]] édité par [[Basis International|Basis international]]

C'est un langage issu de la famille [[Business Basic]]. Il est écrit en [[Java (langage)|Java]] pour assurer un maximum de portabilité sur différentes plateformes ([[Windows]], Unix/[[Linux]], [[Solaris (système d'exploitation)|Solaris]], [[Macintosh|Mac]], etc.) et assure une compatibilité ascendante avec les versions précédentes de Business Basic ([[BBx]], [[Pro5]], [[OpenBasic]]).

Sa syntaxe permet de mélanger la syntaxe Business Basic traditionnelle, la [[programmation orientée objet]] et du code Java. Cette double syntaxe le rend accessible aux développeurs de Business Basic, tout en ouvrant la possibilité aux développeurs formés à Java de l'appréhender.

Son système de données est basé sur un système natif de fichiers ou sur une [[base de données]] (ex. [[MySQL]]) via des pilotes [[ODBC]] et [[JDBC]]. De plus, on peut accéder à ce système de données depuis des applications tierces par un syntaxe SQL.

== Liens externes ==
* http://www.basis.com/
* http://www.basis-europe.eu/

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>cbpe9g5jsz1j4vqgyhkgqcat2qf43qn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Processing.js</title>
    <ns>0</ns>
    <id>2976380</id>
    <revision>
      <id>96203271</id>
      <parentid>96203014</parentid>
      <timestamp>2013-08-28T12:14:36Z</timestamp>
      <contributor>
        <username>Popolon</username>
        <id>505</id>
      </contributor>
      <text xml:space="preserve" bytes="2269">{{ébauche|informatique}}
{{Infobox Langage de programmation
| nom                    = '''Processing.js'''
| logo                   = 
| année                  = 2008
| auteur                 = John Resig
| système d'exploitation = [[Multiplate-forme]]
| licence                = MIT Licensed
| site web               = [http://www.github.com/jeresig/processing-js/tree/master Processing.js] sur [[GitHub]]
}}
'''Processing.js''' est le portage par John Resig du [[langage de programmation]] [[Processing]] en [[JavaScript]] (au lieu de [[Java (langage)|Java]]). Processing.js repose sur la [[Canvas (balise html)|balise canvas]] et les applications conçues avec Processing.js ne requièrent donc pas la [[machine virtuelle Java]] pour fonctionner. Le [[code source]] de Processing.js tient en en seul fichier compressé de moins de 10 [[Octet|Kio]]. 
 
Les programmes réalisés avec Processing.js peuvent être affichés de manière optimum par les [[navigateur web|navigateurs web]] compatibles [[HTML 5]], tels que les versions des [[Moteur de rendu HTML|moteurs de rendu]] [[Gecko (moteur de rendu)|Gecko]] (version 1.9), [[WebKit]] et [[Presto (moteur de rendu HTML)|Presto]] (version 9.5). 

Il existe également une version de processing.js appelée [[Node-processing]], pouvant donc être déployé sur un serveur d'application [[node.js]]&lt;ref&gt;{{en}}[https://npmjs.org/package/processing Node-processing]&lt;/ref&gt;.

Processing.js peut permettre de créer et de déployer facilement des [[Rich Internet Application|applications Internet riches]] (RIA) [[Multi-plates-formes|multi plates-formes]].

==Voir aussi==
=== Liens internes ===
* [[Processing]]
* [[Canvas (balise html)|Balise canvas]]
* [[JavaScript]]
* [[NodeBox]] autre logiciel de processing en python.

=== Notes et références ===
{{Références}}

===Liens externes===
* {{en}} [http://www.ejohn.org/blog/processingjs L'annonce de la sortie de Processing.js sur le blogue de l'auteur]
* {{en}} [http://www.ejohn.org/blog/processingjs-aftermath L'auteur revient sur le buzz occasionné par la sortie de Processing.js]
* {{en}} [https://github.com/uniba/node-processing Node-processing], Processing.js pour Node.js


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>fldcd1s584zt4m613hwznpe5gtx4gg5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Visual Basic .NET</title>
    <ns>0</ns>
    <id>260294</id>
    <revision>
      <id>101689002</id>
      <parentid>101688866</parentid>
      <timestamp>2014-03-01T09:38:26Z</timestamp>
      <contributor>
        <username>Dadu</username>
        <id>55405</id>
      </contributor>
      <comment>/* Évolutions : de VB6 à VB7 (non-exhaustif) */</comment>
      <text xml:space="preserve" bytes="15421">{{Ébauche|informatique}}
{{Infobox Langage de programmation
| nom                    = Visual Basic .NET
| logo                   = Logo VB.PNG
| paradigme              = [[Programmation orientée objet|Orienté objet]], [[Programmation structurée|Structuré]] et [[Programmation impérative|Impératif]]
| année                  = [[2001]] (VB10 : [[2010]])
| auteur                 = [[Microsoft]]
| typage                 = [[Typage statique|Statique]], [[Typage fort|Fort]] et [[Système nominatif de types|nominatif]]
| implémentations        = [[.NET Framework]], [[Mono (informatique)|Mono]]
| dialectes              = VB7 (VS2003), VB8 (VS2005), VB9 (VS2008), VB10 (VS2010)
| influencé par          = [[Visual Basic]], [[C Sharp|C#]]
}}
'''Visual Basic .NET''' est un langage de programmation à la syntaxe similaire à celle de [[Visual Basic|Visual Basic 6]]. 

Néanmoins, ces deux langages sont assez peu comparables dans la pratique tant l'évolution entre ceux-ci est énorme. Le principal changement étant sans conteste l'introduction de l'[[programmation orientée objet|orientation objet]] dans le langage.

VB.NET permet de développer en [[Microsoft .NET|.NET]] via [[Visual Studio]], c'est-à-dire seulement sur les systèmes d'exploitation Windows (98, 2000, XP, Vista, 7). Il existe cependant un projet visant à porter la plateforme DotNet (et donc VB.NET) sous [[Linux]], [[MacOS]] et [[OpenBSD]]. Ce projet s'appelle [[Mono (logiciel)|Mono]] et il permet déjà de faire tourner nativement des applications .NET 2.0.

Il est important de rappeler que tout programme VB.NET est compilé dans le même langage intermédiaire (IL) que C# ou tout autre langage de la plateforme DotNet.

== Les IDE (environnements de développements) ==
[[Fichier:MonoDevelop.png|thumb|Capture d'écran de MonoDevelop]]

L'IDE commun et incontournable de tous les langages DotNet est [[Visual Studio]], mais celui-ci est payant.

Un IDE gratuit basé sur Visual Studio existe : [[Microsoft Visual Studio Express|Visual Basic Express]].

D'autres IDE gratuits existent, comme [[SharpDevelop]] ou [[MonoDevelop]], mais ceux-ci sont moins évolués que Visual Studio.

== Versions ==

=== Évolutions : de VB6 à VB7 (non-exhaustif) ===
Qu'est-ce qui différencie VB6 ([[Visual Basic]] 6) par rapport à VB7 ([[Visual Studio]] 2003) ? :

* L'orientation objet fait son apparition avec notamment l'intégration de la technologie de l'[[Héritage (Informatique)|héritage]], qui jusqu'à ce jour limitait l'industrialisation du code Visual Basic (VB6 n'était pas un langage orienté objet à proprement parler).

* L'intégration de l'environnement de développement (IDE) dans la suite Visual Studio permettant d'utiliser d'autres langages comme Visual [[C plus plus|C++]] ou [[C sharp|Visual C#]]. Une bibliothèque de fonction faite en C# sera totalement compatible et utilisable dans une application VB.NET.

* Le code produit par VB.NET est compilé dans un même langage intermédiaire qu'on appelle le [[Common Intermediate Language|CIL]] (Common Intermediate Language) ou [[MSIL]] (Microsoft Intermediate Language). Ce langage est le même que le résultat d'une compilation de C#.

* La connexion aux [[bases de données]] est facilitée par l'amélioration des outils de [[glisser-déposer]] et l'utilisation de la dernière technologie [[ActiveX Data Object|ADO]], ADO.NET.

* La technologie [[Extensible Markup Language|XML]] est intégrée nativement dans DotNet, ce qui permet la création plus facile d'application en ligne ou de sauvegarde de données.

* Le générateur de code [[Structured Query Language|SQL]] est beaucoup plus performant.

* L'écriture de gestionnaires d'erreurs tient compte du [[Multithreading]] via des blocs TRY/CATCH.

* La portée des instructions [[GOTO]] est limitée (les sauts ne peuvent se faire qu'au sein d'une même fonction). Ce comportement est dû au fonctionnement-même de la plateforme DotNet et est commun à tous les langages DotNet (C#, J#, ...).

* La déclaration des variables est rendue obligatoire par défaut (contrairement au [[Visual Basic|Visual Basic 6]] où cette fonctionnalité était désactivée par défaut).

* L'intégration de nouvelles [[Classe (informatique)|classes]] d'objet .NET s'est faite tout en permettant pour les versions intermédiaires de réutiliser les objets .COM rendant la migration plus facile de [[Visual Basic|Visual Basic 6]] à VB Net. VB.NET est le seul langage de DotNet à avoir une intégration &quot;en profondeur&quot; des objets COM.

* Les &quot;pointeurs&quot; vers des fonctions peuvent et doivent (dans 99 % des cas) désormais être typés (notion de délégués).

=== Évolutions : VB7 à VB8 (non-exhaustif) ===
Quelques nouveautés ont fait leurs apparitions entre VB7 et VB8, mais c'est surtout le passage du DotNet FrameWork 1.1 au 2.0 qui marque cette évolution. 

En voici tout de même un résumé :
* Les classes partielles, permettant de répartir l’implémentation d’une classe sur plusieurs fichiers.
* Les types génériques, évolution typée des templates C++.
* Les types « nullables », c'est-à-dire la possibilité de spécifier qu’un type de valeur peut être nul. Ceux-ci sont déclarés avec le caractère point d'interrogation « ? » suivant le nom du type, comme ceci : &lt;code&gt;Dim X as Integer? = Nothing&lt;/code&gt; (VB9) ou avec une classe particulière (VB8+). Cette valeur « Nothing » serait, si le « ? » n'était pas spécifié, converti en 0 dans ce cas-ci. Dans le nouveau système, (X+10) vaudrait « Nothing » (Nothing est absorbant dans tous les opérateurs), et pas 10 comme cela aurait été le cas autrement. Tout membre d'une valeur « vide » est « vide ».
* La documentation est automatiquement générée depuis des commentaires spéciaux dans le code.

=== Évolutions : VB8 à VB9 (non-exhaustif) ===
VB9 a évidemment implémenté toutes les nouvelles fonctionnalités de C#, ainsi que quelques autres :
* LINQ, XLINQ, DLINQ…
* Expression Trees (fonctions anonymes)
* Assouplissement des conversions entre délégués
* [http://blogs.codes-sources.com/playtime/archive/2008/05/21/vb9-xml-literal-les-d-veloppeurs-c-vont-tre-jaloux.aspx XML Littéral]
* Introduction du IF ternaire (équivalent de bool?truePart:falsePart), optimisé par rapport à IIF()
* La migration du code VB6 vers .NET, et la rétro-compatibilité avec ce langage (Classe VB6) ont été retirés.

=== Évolutions : VB9 à VB10 ===
VB10 (aussi appelé VBx) marque un tournant majeur dans l'évolution de VB. Outre le fait qu'il sera intégré dans le Framework 4, il devrait surtout combler totalement son &quot;retard&quot; par rapport à C# sur certains points (tout comme C# comblera son retard envers VB), vu que la &quot;coévolution&quot; des langages C# et VB.NET a été officiellement annoncée. Cela assure non seulement un futur stable à VB.NET, qui ne pourra pas être délaissé par Microsoft mais aussi une garantie que tout ce qui est faisable en C# le sera toujours aussi sous VB.NET (même si c'est d'une autre façon).

Les fonctionnalités prévues pour VBx :
* Objets dynamiques (permet notamment la [[Programmation orientée prototype]] et la communication entre des langages dynamiques ([[JScript]]…) et les langages de la plateforme DotNet)
* Gestion implicite des interfaces (comme C#)
* Gestion des méthodes anonymes
* Simplification de l'écriture des tableaux, collections, listes et dictionnaires.

== Quelques différences entre C# et VB.NET (non-exhaustif)==
Voici les différences les plus flagrants entre VB.NET et C# (VB.NET et C# évoluant, les éléments de cette liste peuvent être obsolètes):
* VB supporte les paramètres optionnels (C# ne le supporte que depuis sa version 4)
* VB supporte le &quot;late-binding&quot; (appel d'une propriété/fonction avec son nom, sans connaitre le type de l'objet (pour les objets COM))
* L'espace de nom Microsoft.VisualBasic donne une compatibilité par rapport à VB6. Il est à éviter si une solution plus performante existe.
* L'espace &quot;My&quot; implémente de nombreux appels WMI ou d'IO, ainsi que plusieurs &quot;raccourcis&quot; dans la gestion des ressources et paramètres d'applications. (VB8+)
* VB supporte la structure With
* Gestion des évènements simplifiée dans les fenêtres et contrôles
* On peut définir une méthode d'interface avec un nom différent que celui proposé au départ (si on veut redéfinir une fonction dans la classe avec un même nom mais une action différente)
* Support du mot-clé When dans le bloc Catch (exemple : &lt;code&gt;Catch ex as ComException When ex.ErrNumber = 30&lt;/code&gt;)
* XML Litéral n'est pas implémenté en C#.
* Les Custom Events ne sont pas implémentés en C#.

Une liste des différences (en 2005) entre C# et VB.NET plus complète existe [http://www.codeproject.com/KB/dotnet/vbnet_c__difference.aspx ici].

== Quelques exemples de code en VB.NET==
=== Hello World en VB.NET (Mode Console)===
&lt;source lang=&quot;vbnet&quot;&gt;
Public Module HelloWorld

    ' Les lignes qui suivent sont toutes facultatives, mais conseillées
    ' Elles sont automatiquement transformées en documentation
    ''' &lt;summary&gt;Point d'entrée du programme&lt;/summary&gt;
    ''' &lt;param name=&quot;Args&quot;&gt;Les arguments en ligne de commande passé au programme&lt;/param&gt;
    Public Sub Main(ByVal Args As String())

        ' Écrire dans la console
        Console.WriteLine(&quot;Hello World!&quot;)

        ' Attendre que l'utilisateur appuie sur une touche
        Console.ReadKey(True)

    End Sub

End Module
&lt;/source&gt;

=== Hello World en VB.NET (Mode Windows Forms)===
&lt;source lang=vbnet&gt;
Public Class Form1
    Public Sub AfficheMessage()
        '1ère solution (Fonctionne aussi en VBScript)
        MsgBox(&quot;Hello World!&quot;)
        '2ème solution
        MessageBox.Show(&quot;Hello World!&quot;)
    End Sub
End Class
&lt;/source&gt;

=== Boucles et conditions ===
&lt;source lang=&quot;vbnet&quot;&gt;
'
' Une simple condition IF
'
If XCondition = 3 Then
   ' XCondition vaut 3
ElseIf YCondition &lt;&gt; 4 Then
   ' XCondition ne vaut pas 3
   ' YCondition ne vaut pas 4
ElseIf ZCondition Is AnotherObject
   ' XCondition ne vaut pas 3
   ' YCondition vaut 4
   ' ZCondition et AnotherObject renvoient vers le même objet
Else 
   ' Aucune des conditions précédentes n'a été rencontrée
End If

'
' Un Select Case optimisé (Switch en C#)
'
Select Case X
   Case 0
      ' X = 0
   Case 1
      ' X = 1
   Case 2
      ' X = 2
   Case Else
      ' X &lt;&gt; 1
End Case

'
' Un SELECT CASE translaté en IF/ELSE IF à la compilation
'
Select Case Y
   Case Is &lt; 3
     ' Y &lt; 3
   Case 3
     ' Y = 3
   Case Else
     ' Y &gt; 3 dans ce cas
End Case

'
' Boucle WHILE
'
While ImTrue
   ' ImTrue est vrai
   ' Ici on change la valeur de ImTrue
   ImTrue = False
End While
' ImTrue n'est plus vrai

'
' Boucle Do...Loop
'
ImFalse = False
Do
   ' Aucune condition n'a été appliquée si c'est la première fois
   ' Sinon, c'est que ImFalse n'est pas faux 
   ' Dans cet exemple, le code n'est pas relancé une 2e fois
Loop Until ImFalse = False
' ImFalse est bien faux

'
' Boucles For et For Each
'
For X As Integer = 0 to 9
   ' Ce code sera exécuté 10 fois
Next

For X As Integer = 10 To 1 Step -1
   ' Ce code sera exécuté 10 fois en sens inverse
Next

For Each Element As ElementType In Array
   ' Ce code sera exécuté autant de fois qu'il y a d'éléments de type ElementType dans Array
Next
&lt;/source&gt;

===Gestion des exceptions===
VB.NET possède les instructions ''try'' et ''catch'' permettant de gérer les exceptions (comportement non attendu des instructions du programme).

Exemples :
&lt;source lang=&quot;vbnet&quot;&gt;
Try
    My.Computer.FileSystem.FileReadBytes(&quot;C:\Chemin\Fichier.ext&quot;)
Catch Ex as FileNotFoundException 'Pour l'erreur Fichier introuvable
    MessageBox.Show(&quot;Impossible trouver le fichier&quot;, &quot;Erreur&quot;)
Catch Ex as Exception 'Pour les autres erreurs.
    MessageBox.Show(&quot;Une erreur inconnue s'est produite. Erreur renvoyée: &quot; &amp; ex.Message, &quot;Erreur&quot;)
End Try
'Remarquez que ex récupère les données
'de l'erreur, permettant de les traiter.
'Il y a d'autres options que Message. Consultez la documentation Visual Basic .NET pour en savoir plus.

Try
    SomeUnknownCOMObject.DoSomething()
Catch Ex as COMExcpetion When Ex.ErrorCode = 4
    ' The object was of the excpected type but he throwned
    ' an error with HRESULT 4, which is possible as the 
    ' documentation of the object says (it's an exemple).
    MessageBox.Show(&quot;L'objet n'était pas prêt&quot;)
    ' Throw some new Application-Specific error.
    Throw new Exception (&quot;The object was not ready.&quot;)
Catch Ex as Exception
    ' Display some message
    MessageBox.Show(&quot;Une erreur inconnue s'est produite&quot;, &quot;Erreur&quot;)
    ' But throw the (same) exception
    Throw
Finally
    ' Quoiqu'il se passe, on fait cela
    ' Même si une erreur est survenue, ce code sera lancé
    Try : SomeUnkwnowCOMOBject.DoSomethingAnyWay() : Catch ex as Exception : End Try
End Try
&lt;/source&gt;

=== Exemple d'utilisation de [[LINQ]] ===
&lt;source lang=&quot;vbnet&quot;&gt;
' Retourne un énumérateur qui renvoie tous les noms des fenêtres enfants qui sont des éditeurs de texte
' Visual Studio 2008 trouve le type de la variable automatiquement, similaire au &quot;var&quot; du C#
Dim AllText = From CW in MyFormInstance.ChildWindows
  Where CW.GetType() is GetType(MyTextEditorWindow)
  Select CW.Text

' Crée un objet XML (un Document XML, pas une chaine de caractère)
' Visual Studio 2008 trouve le type de la variable automatiquement, similaire au &quot;var&quot; du C#
Dim XMLDoc = _
    &lt;root&gt;&lt;% For Each Item in Items %&gt;
        &lt;item name=&quot;&lt;%= Item.Name %&gt;&quot; /&gt;
    &lt;% Next %&gt;&lt;/root&gt;
' Sauvegarde dans un fichier le document XML
XMLDoc.Save(&quot;FileName.xml&quot;)
&lt;/source&gt;

=== Exemple d'un événement simple ===
&lt;source lang=&quot;vbnet&quot;&gt;
' Déclaration des objets (fonctions, événements, ...) pour la fenêtre Form1
Public Class Form1

    ' Lorsque l'utilisateur clique sur l'objet Button1
    Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click
        Me.Close() ' On ferme la fenêtre parente (grâce à Me) donc l'application
    End Sub
End Class
&lt;/source&gt;

=== Exemple d'un code appelant une fonction ===
&lt;source lang=&quot;vbnet&quot;&gt;
Public Class Form1
    ' Création de la fonction Quitter avec un Private Sub
    Private Sub Quitter()
        Me.Close()
    End Sub

    ' Lorsque l'utilisateur clique sur l'objet Button1
    Private Sub Button1_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button1.Click
        Call Quitter() ' On appelle Private Sub Quitter()
    End Sub

    ' Lorsque l'utilisateur clique sur l'objet Button2
    Private Sub Button2_Click(ByVal sender As System.Object, ByVal e As System.EventArgs) Handles Button2.Click
        Call Quitter() ' L'avantage de ce code, c'est qu'on peut appeler Quitter() autant de fois que l'on souhaite
    End Sub

End Class
&lt;/source&gt;

== Voir aussi ==
{{Autres projets|b=Visual Basic .NET}}
=== Articles connexes ===
* [[Microsoft .NET]]
* [[Visual Studio]]
* [[C sharp]]
* [[Visual Basic]]
* [[BASIC]]

=== Liens externes ===

* {{fr}} [http://www.microsoft.com/france/msdn/vbasic/default.mspx Centre de Développement Visual Basic, Site MSDN de Microsoft] 


{{Palette|Microsoft}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Environnement de développement intégré]]
[[Catégorie:.NET Framework]]</text>
      <sha1>7e3xghswgd4dtvsc89ki4f7rjb0mra0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>QBasic</title>
    <ns>0</ns>
    <id>96036</id>
    <revision>
      <id>89794125</id>
      <parentid>88278012</parentid>
      <timestamp>2013-03-12T15:33:37Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 27 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q381247]]</comment>
      <text xml:space="preserve" bytes="1914">{{ébauche|informatique}}

{{Infobox Langage de programmation
|  nom = QBasic
|  logo =
|  paradigmes =
|  dernière version stable = QBasic 1.1
|  année = [[1987]] - [[1993]]
|  auteur =
|  développeurs = [[Microsoft|Microsoft Corporation]]
|  typage =
|  implémentations =
|  dialectes = 
|  influencé par = [[QuickBASIC]], [[GW-BASIC]], [[BASIC]]
|  a influencé = 
|  système d'exploitation = [[PC-DOS]], [[MS-DOS]], [[OS/2]], [[Windows 95]], [[Windows 98]], [[Windows Me]]
|  licence = [[Microsoft|MS]]-[[EULA]]
|  site web = [http://www.microsoft.com/ www.microsoft.com]
}}

'''QBasic''' est un [[environnement de développement intégré]] pour une variante du langage de programmation [[BASIC]], basé sur [[Quick Basic]].

Il s'agit en réalité d'une version bridée de QuickBasic 4.5, dans le sens où elle ne permet que d'exécuter des [[Langage interprété informatique|programmes interprétés]], la [[Compilation (informatique)|compilation]] étant rendue impossible.

D'autres différences mineures subsistent cependant au niveau du langage, notamment la disparition de certaines commandes. À l'inverse, les instructions permettant l'utilisation du [[langage machine]] (telles que &lt;code&gt;CALL ABSOLUTE&lt;/code&gt;) ont été intégrées à l'environnement, car il n'était plus possible de les lier au moment de la compilation.

L'exécutable de QBasic contient également les fonctionnalités de la commande ''[[EDIT]]'' de MSDOS, accessibles en tapant &lt;code&gt;qbasic /editor&lt;/code&gt; dans la ligne de commande.

== Liens externes ==

* [ftp://ftp.microsoft.com/Softlib/MSLFILES/OLDDOS.EXE Téléchargement de QBasic 1.1 sur le site de Microsoft]
* {{en}} L'[http://www.qbasicnews.com/qboho/qck-9997.shtml index de l'aide de QuickBASIC], très proche du langage QBasic.

{{portail|informatique}}

[[Catégorie:Logiciel pour DOS]]
[[Catégorie:Langage de programmation]]
[[Catégorie:BASIC Microsoft]]</text>
      <sha1>0cwqgo6lseg7dz1va56nrft3gt0t3ld</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>JMathLib</title>
    <ns>0</ns>
    <id>3172055</id>
    <revision>
      <id>92502486</id>
      <parentid>90452843</parentid>
      <timestamp>2013-04-26T20:25:23Z</timestamp>
      <contributor>
        <username>Bub's wikibot</username>
        <id>373944</id>
      </contributor>
      <minor/>
      <comment>Robot : Mise en forme du logo et de l'image</comment>
      <text xml:space="preserve" bytes="1301">{{Infobox Logiciel
 | nom = JMathlib
 | image = 
 | description = 
 | développeur = Stefan Mueller
 | dernière version = v0.9.4
 | date de dernière version = 
 | version avancée = 
 | date de version avancée = 
 | environnement = [[Multiplate-forme]] ([[Linux]], [[Microsoft Windows|Windows]])
 | langue = anglais
 | type = ([[Calcul numérique]], [[:en:List of numerical analysis software|Liste (en anglais) de logiciels d’analyse numérique]])
 | licence = [[GNU General Public License|GNU GPL]]
 | site web = [http://www.jmathlib.de/ www.jmathlib.de]
}}
'''JMathLib''' est un environnement de calcul informatisé et un langage de programmation, sous forme d'un logiciel libre, relativement compatible au niveau des sources avec [[MATLAB]] et [[GNU Octave]] et [[FreeMat]]. Il supporte nombre des fonctions de [[MATLAB]] et quelques fonctionnalités d'[[IDL (langage)|IDL]]. Et il possède quelques capacités de rendu volumique et de visualisation 3D.

== Liens externes ==
* {{en}} [http://www.jmathlib.de Site officiel]
* {{Projet SourceForge|mathlib}}

[[Catégorie:Logiciel de calcul scientifique]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel pour Linux]]
[[Catégorie:Logiciel pour Windows]]

{{Portail logiciels libres}}</text>
      <sha1>bxbzqxx3mv1baggvdf61mzpgu7o10qz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>QuickPascal</title>
    <ns>0</ns>
    <id>3185298</id>
    <revision>
      <id>88819381</id>
      <parentid>88765507</parentid>
      <timestamp>2013-02-15T16:17:09Z</timestamp>
      <contributor>
        <username>MerlIwBot</username>
        <id>1019240</id>
      </contributor>
      <minor/>
      <comment>robot Ajoute : [[es:Microsoft Pascal]], [[pt:Microsoft Pascal]], [[ru:Microsoft Pascal]]</comment>
      <text xml:space="preserve" bytes="643">'''QuickPascal''' était un compilateur de [[Pascal (langage)|Pascal]] pour [[MS-DOS]], compatible avec Turbo Pascal et commercialisé par [[Microsoft]] en 1989&lt;ref&gt;[http://www.danielsays.com/ss-gallery-dos-ms-quickpascal-100.html Captures d'écran de QuickPascal]&lt;/ref&gt;.

== Voir aussi ==
* [[Turbo Pascal]]

== Notes et références==
{{références}}

{{Portail|programmation informatique}}

[[Catégorie:Microsoft]]
[[Catégorie:Environnement de développement intégré]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage Pascal]]

[[en:Microsoft Pascal]]
[[es:Microsoft Pascal]]
[[pt:Microsoft Pascal]]
[[ru:Microsoft Pascal]]</text>
      <sha1>ixcwahvoldo413dap94t6mrh1e5sumz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>High Performance Fortran</title>
    <ns>0</ns>
    <id>581888</id>
    <revision>
      <id>90004856</id>
      <parentid>81428843</parentid>
      <timestamp>2013-03-13T17:06:42Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 4 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3091025]]</comment>
      <text xml:space="preserve" bytes="587">{{ébauche|informatique}}
'''High Performance Fortran''' est un langage de programmation pour les machines parallèles.

Ce langage, est basé sur [[Fortran 90]] avec l’ajout de directives de placement des données (align, distribute), de boucles parallèles (directive independent, construction forall) et quelques autres extensions.

== Liens externes ==
* [http://www.lifl.fr/west/courses/cshp/hpf.pdf#search='hpf%20exemple%20distribution'] : Cours d'introduction à HPF.
{{portail|programmation informatique}}

[[Catégorie:Langage Fortran]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>pei2g8xxzovnkh5s1obkq6a955jljt4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Langage CLP</title>
    <ns>0</ns>
    <id>3268991</id>
    <revision>
      <id>97392021</id>
      <parentid>91710570</parentid>
      <timestamp>2013-10-11T18:19:49Z</timestamp>
      <contributor>
        <username>Zetud</username>
        <id>25495</id>
      </contributor>
      <minor/>
      <comment>Orth., Typo., remplacement: La grammaire du langage est basé → La grammaire du langage est basée, typos fixed: Language → Langage, elle même → elle-même avec [[Wikipédia:AutoWikiBrowser|AWB]]</comment>
      <text xml:space="preserve" bytes="3252">Le '''Langage CLP''' (Control Language Procedure) est un langage de programmation du système d'exploitation OS/400.

Apparu sous ce nom sur les systèmes 38 (ancêtres de l'[[AS/400]]), il intègre les fonctions d'un langage OS traditionnel.
Il s'appuie sur les commandes de l'OS400 et il a pour particularité d'être compilé.

==Description==
La grammaire du langage est basée sur les commandes CL de l'OS400

==Les commandes==
La plupart des commandes sont une combinaison d'un verbe (représentant une action) suivi d'un nom ou une phrase qui identifie le destinataire de l'action (l'objet concerné par l'action). Les différents &quot;mots&quot; de la combinaison sont en général sur trois lettres pour faciliter la mémorisation des commandes. Exemple : WRKJOB ⇒ Work + Job ⇒ Gérer un travail (ou tâche), celui en cours par défaut.

On peut utiliser une aide à la saisie (ou invite), on l'obtient en pressant la touche de fonction F4 qui propose tous les paramètres disponibles et leur valeurs possibles pour chaque commande. Cette aide à la saisie est elle-même accompagnée d'un texte d'explication pour chaque paramètre, accessible par la touche F1.

* Le langage possède toutes les fonctionnalités d'un langage de gestion d'OS.
** Traitement de fichier.
** Gestion des erreurs.
** Manipulation de chaines de caractères.
** Gestion des Sauvegardes.
** Gestion des travaux.
** Commande RTV* pour extraire des infos existantes sur le système. 

==La création de procédures==
L'éditeur natif est SEU (Source Editor Utility), désormais on peut éditer ses sources depuis MS-Windows surcouche à [[Eclipse (logiciel)|Eclipse]], fournie par [[International Business Machines Corporation|IBM]] sous le nom de WDSC ([[Websphere]] Development Studio Client).

Contrairement au RPG, ou au COBOL, il n'est pas colonné. 

Ce langage peut sauf interdiction exclusive être décompilé simplement ce qui facilite la lecture des chaines d'exploitation. 

* on peut créer des modules et les lier avec des modules d'autres langages.

==Futur==
Les évolutions sont liées aux versions de l'OS/400, et les vrais changements arrivent à partir des versions 5.x   
* 5.3 : Plusieurs fichiers, programmation structurée ...
* 5.4 : Bandes virtuelles ...
* 6.1 : Possibilité de mettre des points de synchronisation globaux, possibilité de relire des fichiers ...

==Voir aussi==

[[System_i]], [[iSeries]], [[OS/400]] 

=== Références ===

Se reporter aux références indiquées dans l'article [[System_i]]

===Liens externes===
* [http://publib.boulder.ibm.com/iseries/v5r2/ic2924/books/sm14/c4157215.pdf CL Programming]
* [http://www-03.ibm.com/systems/i/ La page d'accueil System i]
* [http://www.redbooks.ibm.com/ Documentation technique]
* {{fr}} [http://www-1.ibm.com/servers/fr/eserver/iseries/ La gamme iSeries sur le site d'IBM]
* {{fr}} [http://www.commentcamarche.net/as400/as400-intro.php3 Introduction à l’AS/400]
* [http://www.softhelp.it/modules.php?name=News&amp;file=article&amp;sid=1&amp;mode=&amp;order=0&amp;thold=0 Full Commands List AS400]
* [http://www.ibm.com/eserver/iseries/infocenter IBM eServer iSeries Information Center]
 {{Portail|Informatique}}

[[Catégorie:Langage de programmation|CLP]]
[[Catégorie:Grand Système IBM|CLP]]</text>
      <sha1>baaebnf1fi2xigxupudq3m26jeifqz2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MicroMondes (logiciel)</title>
    <ns>0</ns>
    <id>3285835</id>
    <revision>
      <id>58987858</id>
      <parentid>33408775</parentid>
      <timestamp>2010-11-09T12:05:29Z</timestamp>
      <contributor>
        <username>Goliadkine</username>
        <id>6551</id>
      </contributor>
      <comment>/* Syntaxe */ typographie</comment>
      <text xml:space="preserve" bytes="3752">{{ébauche|informatique}}

''MicroMondes Pro, [[:en:MicroWorlds|MicroWorlds JR]] et [[:en:MicroWorlds|MicroWorlds EX]]'' sont des [[micromondes]], descendants directs de [[Logo (langage)]]. Il s'agit de versions commerciales plus finies et avec un meilleur support pour les fonctions multimédia (particulièrement la version anglaise, plus récentes).

== Présentation générale ==
L'élément le plus connu de MicroMondes (et de Logo) est la tortue, qui peut être manipulée à l'aide d'instructions de manière à tracer des graphiques, exécuter des animations, des jeux interactifs ou d'autres types de simulations.

Les développements technologiques ont ensuite permis à la tortue de migrer vers un écran graphique (distinct de l'écran de commande (texte)), puis vers un écran mixte (avec une zone texte et une zone graphique). Les versions modernes combinent sans problèmes le texte et les graphiques.

MicroMondes est produit par [http://www.microworlds.com LCSI] et peut être utilisé sur un PC ou un Macintosh. Il existe dans plusieurs langues dont l'anglais, le français, l'espagnol, l'italien, le portugais, etc. 

== Syntaxe ==
Le vocabulaire original de MicroWorlds (ou Logo) est constitué de primitives. Celles-ci comportent quelques dizaines de commandes:

&lt;code&gt;avance&lt;/code&gt;, &lt;code&gt;recule&lt;/code&gt;, &lt;code&gt;droite&lt;/code&gt;, &lt;code&gt;gauche&lt;/code&gt;, &lt;code&gt;écris&lt;/code&gt;, &lt;code&gt;fpos&lt;/code&gt; (fixe position), &lt;code&gt;fcoul&lt;/code&gt; (fixe couleur), &lt;code&gt;vt&lt;/code&gt; (vide texte)...

et quelques dizaines de rapporteurs:

&lt;code&gt;couleur&lt;/code&gt; (rapporte la couleur actuelle), &lt;code&gt;pos&lt;/code&gt; (rapporte la position), &lt;code&gt;texte1&lt;/code&gt; (rapporte le contenu le la boîte de texte portant ce nom)...

Certaines primitives requièrent une ou plusieurs données :

&lt;code&gt;bc&lt;/code&gt; (baisse crayon, ne requiert aucune donnée)&lt;br&gt;
&lt;code&gt;avance 50&lt;/code&gt; (requiert un nombre qui indique la distance à parcourir)&lt;br&gt;
&lt;code&gt;saufpremier [ceci est une liste]&lt;/code&gt; (requiert un mot ou une liste dont le premier élément sera retiré)

Ce vocabulaire peut être augmenté par l'utilisateur à l'aide de « procédures » dont voici un exemple :

&lt;code&gt;
pour cabriole&lt;br&gt;
droite hasard 360&lt;br&gt;
avance hasard 1000&lt;br&gt;
fin
&lt;/code&gt;

Les procédures sont créées dans un espace réservé à cet effet : la page ou l'onglet &quot;procédures&quot;. Dans les versions les plus récentes de MicroMondes (spécifiquement MicroWorlds EX, MicroMundos EX, MicroMondi EX) les procédures peuvent aussi être intégrées à l'intérieur du &quot;sac à dos&quot; de l'objet tortue. 

Une procédure comporte trois parties: la ligne titre (le mot &lt;code&gt;pour&lt;/code&gt; suivi du nom de la procédure, au choix de l'utilisateur), le corps (la liste des instructions) et la ligne de &lt;code&gt;fin&lt;/code&gt;. Dans l'exemple précédent, l'exécution de la commande &quot;cabriole&quot; revient à exécuter les instructions contenues dans la procédure: tourner à droite à un angle déterminé au hasard entre 0 et 359, et avancer une distance choisie au hasard entre 0 et 999.

Outre les procédures, les instructions peuvent être tapées dans le Centre de Commandes pour être exécutées &quot;en mode direct&quot;.

MicroMondes est un logiciel d'usage général qui constitue une excellente introduction dans le monde de la programmation. Une version &quot;junior&quot;, qui permet aux enfants en pré-lecture ou lecteurs novices de programmer à l'aide d'icônes plutôt qu'avec des instructions textuelles, existe dans d'autres langues. Une autre version permet, à l'aide de quelques primitives supplémentaires, de contrôler des éléments robotiques.

== Voir aussi ==

* {{Article principal|Micromonde}}
* [[Logo (langage)]]

{{portail|informatique}}

[[Catégorie:Micromonde]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>l047l7qva8m362p9rnrj7xiqw2axxrd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Objective-J</title>
    <ns>0</ns>
    <id>3306898</id>
    <revision>
      <id>90474050</id>
      <parentid>86771357</parentid>
      <timestamp>2013-03-16T15:04:55Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1443431]]</comment>
      <text xml:space="preserve" bytes="3935">{{Infobox Langage de programmation
| nom 			= Objective-J
| logo 			= 
| paradigme 		= [[Programmation orientée objet|orienté objet]], [[Réflexion (informatique)|réflexif]], [[Programmation impérative|impératif]], [[Programmation fonctionnelle|fonctionnelle]], [[Langage de script|Script]]
| année 		= 2008
| auteur 		= [[280 North, Inc.]]
| développeur 		= 
| dernière version stable= 0.6
| typage 		= [[Typage dynamique|dynamique]], [[Typage faible|faible]], [[Duck typing|duck]]
| implémentations	=[[Cappuccino (framework)|Cappuccino]]
| normes 		=
| influencé par		= [[Objective-C]], [[JavaScript]]
| système d'exploitation= 
| licence 		= [[GNU Lesser General Public License|LGPL]]
| site web 		= http://cappuccino.org/
}}


'''Objective-J''' est un langage de programmation développé en même temps que le ''{{lang|en|framework}}'' [[Cappuccino_(framework)|Cappuccino]]. Sa syntaxe est sensiblement identique à celle de [[Objective-C]]. Par ailleurs il partage avec Javascript la même relation qu'il y a entre l'Objective-C et le langage [[C_(langage)|C]] : il s'agit d'une sorte de sur ensemble ajoutant la notion d'[[Héritage (informatique)|héritage]] ainsi que le typage dynamique du style [[Smalltalk]]/Objective-C au JavaScript. 

Les programmes écrits en Objective-J ont besoins d'être compilés avant de pouvoir être lancés dans un [[navigateur web]]. Cette compilation peut être effectuée directement dans le navigateur au moment de l'exécution par un [[compilateur]] qui compile les programmes Objective-J en pur code Javascript. Le compilateur Objective-J est écrit en JavaScript, de ce fait le déploiement de programme écrit en Objective-J ne nécessite pas de ''{{lang|en|plugin}}'' attaché au navigateur.

== Application ==
La première utilisation connue de l'Objective-J a été faite avec le ''{{lang|en|[[framework]]}}'' Cappuccino pour le développement de l'application web [[280Slides]]. Bien que l'Objective-J peut être utilisé (et a été conçu) indépendamment du ''{{lang|en|framework}}'' Cappuccino, Objective-J a été, à la base, inventé pour supporter le développement web avec Cappuccino.

== Syntaxe ==
Objective-J est un sur-ensemble du Javascript, cela implique que n'importe quel code JavaScript valide est aussi valide dans du code Objective-J. L'exemple suivant montre la déclaration en Objective-J d'une [[Classe (informatique)|classe]] nommée {{lang|en|''Address''}}, cette classe est une sous classe de l'objet de base CPObject qui joue le même rôle que le NSObject en Objective-C/Cocoa. Même si ce n'est pas le même nom pour l'objet de base, ce code pourrait être aussi un exemple pour une déclaration de classe en Objective-C.

&lt;pre&gt;
@implementation Address : CPObject
{
   CPString name;
   CPString city;
}
- (id)initWithName:(CPString)aName city:(CPString)aCity
{
    self = [super init];

    name = aName;
    city = aCity;

    return self;
}
-(void)setName:(CPString)aName
{
      name = aName;
}
-(CPString)name
{
      return name;
}  
+(id)newAddressWithName:(CPString)aName city:(CPString)aCity
{
      return [[self alloc] initWithName:aname city:aCity];
}

@end

&lt;/pre&gt;
Tout comme en Objective-C, la déclaration des méthodes de classes et des méthodes d'instances commencent respectivement par '+' (plus) et '-' (moins).

== Gestion de la mémoire ==
Contrairement à l'Objective-C, les objets en Objective-J n'ont pas besoin d'être libéré étant donné qu'ils sont automatiquement libérés par le [[Ramasse-miettes (informatique)|ramasse-miettes]] {{en en|Garbage Collector}} de JavaScript.

==Voir aussi==
=== Article connexe ===
* [[Cappuccino (framework)]]

=== Liens externes ===
*{{en}} [http://cappuccino.org/learn/tutorials/objective-j-tutorial.php Apprendre l'Objective-J]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:JavaScript]]</text>
      <sha1>0pwku5ct3eo7pl9zxjkepggj2dsyx47</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fenix</title>
    <ns>0</ns>
    <id>664176</id>
    <revision>
      <id>99176422</id>
      <parentid>98181290</parentid>
      <timestamp>2013-12-12T20:36:14Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>/* Fonctions */ typographie (REM. : p.-ê. d. c.)</comment>
      <text xml:space="preserve" bytes="3045">{{ébauche|jeu vidéo|logiciels libres}}
'''Fenix''' est un [[compilateur]] gratuit pour le [[projet GNU]]. Il s'agit d'un projet de compilateur pour un [[langage de script]] dérivé de celui créé par [[Hammer Technologies]] pour le [[Game Development Suite]] « DIV Games Studio. » Cependant, quelques fonctionnalités ont été ajoutées le rendant incompatible avec beaucoup de jeux programmés avec DIV.

== Fonctions ==
Fenix est un langage interprété concentré sur le développement de jeux vidéo en 2 dimensions. Sa principale caractéristique, héritée de DIV, est la programmation pseudo-parallèle, c'est-à-dire qu'il donne la possibilité aux créateurs de programmer les différents processus (ennemis, personnages, etc.) séparément, le moteur se chargeant de les synchroniser. Ceci rend le développement de jeux vidéo à plusieurs beaucoup plus simple. La majeure partie des dispositifs est maintenant basée sur [[Simple DirectMedia Layer|SDL]]. Ceci fait de Fenix un projet vraiment portable sur divers systèmes. D'autres fonctions incluent le support complet de la 2D (étirements, transparences, ''blendops''…), la couleur en 16 bpp, le son ([[ogg]], [[Module (musique)|mod]], it, s3m, [[wav]]), le support de [[Joystick (jeu vidéo)|joystick]], le [[mode 7]] et des extensions via les [[Dynamic Link Library|DLL]].

Fenix est surtout un langage très simple et puissant. Il est un très bon outil de programmation pour les débutants et les professionnels.

== Ports ==
Officiels : [[Win32]], [[Linux]], [[Mac OS X]], [[Berkeley Software Distribution|BSD]], [[BeOS]]

Non officiel : [[GP32]], [[GP2X]], [[Dreamcast]], [[PlayStation 2]]

== État ==
La version actuelle officielle est la 0.92a, mais la version la plus récente (en version beta) est la 0.93 preview 9.

Le projet est actuellement en cours de réécriture complète, ainsi que le noyau nu auquel d'autres fonctions peuvent être liées. De cette façon, tous les graphismes ou bibliothèques de son peuvent être liés à ce noyau, tirant profit de son dispositif de programmation pseudo-parallèle.
Ce compilateur (nommé Bennu) plus optimisé mais aussi plus compliqué à utiliser est entièrement compatible avec l'interpréteur 0.92a de Fenix.

== Fonctionnement ==
Fenix est présenté comme un logiciel passant par une console. Il existe divers IDEs disponible, dont le plus populaire [[FlameBirds2]]. Beaucoup d'autres IDEs peuvent être facilement adaptés pour l'utiliser.

== Références externes ==
*[http://fenix.divsite.net Site officiel espagnol et anglais] (actuellement mort)
*[http://sourceforge.net/projects/fenix/ Site officiel du projet] (souvent mis à jour)

*[http://fenixworld.se32.com Ressources]
*[http://div.france.free.fr Site officiel français]
*[http://fenixpack.blogspot.com/ Blog officiel de Colombian Developers]
*[http://fenixdocs.com Wiki Anglais]

{{Portail|jeu vidéo|logiciels libres}}

[[Catégorie:Développement de jeu vidéo]]
[[Catégorie:Jeu vidéo libre]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>fhclwe940zf8b7qonzrpnao8n0rg5bd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PL/SQL</title>
    <ns>0</ns>
    <id>22579</id>
    <revision>
      <id>101148908</id>
      <parentid>96559377</parentid>
      <timestamp>2014-02-10T22:16:59Z</timestamp>
      <contributor>
        <username>OrlodrimBot</username>
        <id>1055871</id>
      </contributor>
      <minor/>
      <comment>[[Wikipédia:Outil de retour des lecteurs/Retrait de l'outil|Retrait]] de l'outil de retour des lecteurs</comment>
      <text xml:space="preserve" bytes="6611">{{Infobox Logiciel
 | logo = 
 | nom = PL/SQL
 | développeur = [[Oracle Database|Oracle]]
 | dernière version = 11.1
 | date de dernière version = 2009
 | date de première version = 1991
 | environnement = [[Multiplate-forme]]
 | type = [[Système de gestion de base de données|SGBD]]
 | licence = [[Logiciel propriétaire|propriétaire]]
 | site web = [http://docs.oracle.com/cd/B10501_01/index.htm oracle.com]
}}
'''PL/SQL''' (sigle de '''''Procedural Language / Structured Query Language''''') est un [[Langage de programmation|langage]], conçu aux paradigmes [[Programmation procédurale|procédural]] et [[Programmation structurée|structuré]]. Il est [[Logiciel propriétaire|propriétaire]], créé par [[Oracle Database|Oracle]] et utilisé dans le cadre de [[Base de données relationnelle|bases de données relationnelles]]. Sa syntaxe générale ressemble à celle des [[Langage de programmation|langage]]s [[Pascal (langage)|Pascal]] et  [[Ada (langage)|Ada]].

PL/SQL est disponible dans Oracle Database (depuis la version 7), TimesTen In-Memory Database (depuis la version 11.2.1) et [[IBM DB2]] (depuis la version 9.7).

Il permet de combiner des requêtes [[Structured Query Language|SQL]] et des instructions procédurales (boucles, conditions...), dans le but de créer des traitements complexes destinés à être stockés sur le serveur de base de données (objets serveur), comme des [[procédure stockée|procédures stockées]] ou des [[déclencheur]]s.

Les dernières évolutions proposées par Oracle reposent sur un moteur permettant de créer et gérer des [[programmation orientée objet|objets]] contenant des méthodes et des propriétés.

À la base, PL/SQL est un [[Langage_interprété|langage interprété]], mais depuis la version 9i RC1, le code peut être compilé en [[Langage machine|code machine]]&lt;ref&gt;http://www.dbspecialists.com/files/presentations/native_plsql.html&lt;/ref&gt;. Dans la version 9i d'Oracle database, le code est converti en [[langage C|C]] puis doit être compilé en [[Bibliothèque_logicielle|librairies partagées]] ([[Dynamic_Link_Library|DLL]] sous windows), dans la version 10g le code machine est stocké dans le catalogue&lt;ref&gt;http://www.scribd.com/doc/16654335/Plsql-New-in-11gr1&lt;/ref&gt; et depuis la version 11g il est stocké dans le ''tablespace'' système après compilation directe&lt;ref&gt;http://swervedba.wordpress.com/2011/07/&lt;/ref&gt;.

== Comparaison avec les autres bases de données ==
[[MySQL]] et Mimer SQL proposent un langage analogue dans le principe mais plus limité, le SQL/PSM de la norme SQL:2003, et plusieurs [[SGBD]] en utilisent un dérivé (IBM DB2 avec SQL-PL, [[PostgreSQL]] avec [[PL/pgSQL]] et [[PL/pgPSM]]). Quant à [[Microsoft]] et [[Sybase]], ils utilisent un concurrent développé par [[Sybase]], le [[T-SQL]] nettement plus limité que PL/SQL&lt;ref&gt;http://www.mssqlcity.com/Articles/Compare/sql_server_vs_oracle.htm#part_5_1&lt;/ref&gt;.

== Concepts ==

=== Blocs ===
Tout programme PL/SQL doit se présenter sous forme de blocs. Voici la forme générale d'un bloc.

&lt;source lang=&quot;sql&quot;&gt;DECLARE
déclarations
BEGIN
implémentation
EXCEPTION
gestion des exceptions
END;&lt;/source&gt;

Un bloc PL/SQL comprend d'abord une partie dédiée à la définition de toutes les variables employées dans le bloc. Elle commence par l'instruction ''DECLARE'' et est facultative. La section principale commence avec l'instruction ''BEGIN''. Elle contient les instructions du programme. Si une variable est utilisée dans cette section alors qu'elle n'a pas été déclarée dans la section de déclaration, le compilateur générera une erreur. Enfin, la dernière section est appelée en cas d'erreur dans la section précédente. Elle commence par l'instruction ''EXCEPTION'' et on y traite l'ensemble des exceptions levées dans la section principale.

=== Structure du code ===
PL/SQL permet de grouper les instructions dans des [[procédure (informatique)|procédures]] et des [[fonction (informatique)|fonctions]], ces termes ont la même signification qu'en [[Pascal (langage)|Pascal]] : une '''fonction''' est un bloc de code prenant des paramètres et qui effectue des traitements pour obtenir un résultat retourné, une '''procédure''' recouvre la même notion sauf qu'une procédure ne retourne pas de résultat. Les [[paramètre|arguments]] passés aux procédures et fonctions peuvent lui être donnés en lecture seule (''IN''), en écriture (''OUT'') ou en lecture-écriture (''IN OUT'') ; le développeur peut également choisir le passage par valeur (comportement normal) ou par référence (''NO COPY'').

Des fonctions et procédures peuvent être regroupées dans des unités nommées '''paquetages''', elles sont alors accessibles sous le même espace de noms. D'une manière similaire aux modules de Pascal, la création d'un paquetage requiert l'écriture d'une spécification exposant le prototype des fonctions et procédures du paquetage, ainsi que des variables et [[type (informatique)|types]] publics. En second lieu, l'implémentation du paquetage est faite séparément ; elle contient le code des procédures et fonctions ainsi que la déclaration d'éléments privés.

La version 8i a introduit le concept d'[[Objet_(informatique)|objet]] et les implémentations depuis la version 9i supportent la [[Programmation_orientée_objet|programmation orientée-objet]]&lt;ref&gt;http://lrc.surcollege.net/ebooks/Arabic_Books/Oracle/Books/Oracle9i%20New%20Features%20for%20Application%20Developers%20-%20Volume%20I.pdf&lt;/ref&gt; avec notamment l'[[héritage_(informatique)|héritage]]. Une [[Classe_(informatique)|classe]] PL/SQL est décrite comme un type. Elle a une structure analogue à celle d'un package PL/SQL : d'abord la déclaration des méthodes, ensuite leur implémentation dans le ''body''.

=== Variables ===
Les premiers types de variables à disposition sont les types SQL supportés par le serveur Oracle (''INTEGER'', ''VARCHAR'', ...), mais il est possible de définir des types personnalisés.

== Voir aussi ==

== Notes et références ==
{{Références}}

=== Articles connexes ===
* [[Base de données relationnelle]]
* [[Système de gestion de base de données]]
* [[Structured Query Language]]
** [[PL/pgSQL|PL/pgSQL (PostgreSQL)]]
** [[Transact-SQL]]

=== Liens externes ===
{{Autres projets|wikibooks=Programmation PL/SQL}}
* {{en}} [http://download.oracle.com/docs/cd/B10501_01/appdev.920/a96624/toc.htm PL/SQL User's Guide and Reference]

{{Portail|bases de données}}

{{DEFAULTSORT:Plsql}}

[[Catégorie:Système de gestion de base de données]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>mxgwy1nmkg348qy8hgnvgguk4un4rhc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Xlogo</title>
    <ns>0</ns>
    <id>3163905</id>
    <revision>
      <id>95731953</id>
      <parentid>45252092</parentid>
      <timestamp>2013-08-11T18:14:27Z</timestamp>
      <contributor>
        <username>Anedja</username>
        <id>1307846</id>
      </contributor>
      <minor/>
      <comment>(minimineure) orthographe ; typographie</comment>
      <text xml:space="preserve" bytes="1805">[[Image:XLogo.jpg|thumb|300px|right|Aperçu du logiciel]]
'''XLogo''' est un interpréteur [[Logo (langage)|Logo]] écrit en [[Java (langage)|Java]]. C'est un [[logiciel libre]] distribué selon les termes de la licence [[GNU GPL]].

XLogo supporte actuellement dix langues : le [[français]], l'[[anglais]], l'[[espagnol]], le [[portugais]], l'[[allemand]], l'[[arabe]], l'[[espéranto]], le [[galicien]], le [[grec moderne|grec]] et l'[[italien]].

== Le langage Logo ==
{{Article détaillé|Logo (langage)}}

Le principe majeur du langage Logo consiste à déplacer sur l'écran un objet généralement sous la forme d'une tortue, à l'aide de commandes élémentaires telles que :
* « avance » abrégée ''av'' ;
* « tournedroite » abrégée ''td'' ;
* « repete ».

À chaque fois que la tortue se déplace, elle laisse un trait derrière elle et on peut ainsi très vite réaliser de très jolis dessins.

XLogo est un langage de programmation capable non seulement de dessiner des formes, mais aussi de manipuler les mots, les fichiers, etc.

== Galerie d'images réalisées avec XLogo ==

&lt;gallery&gt;
Image:xlogo_croix.png|Croix
Image:xlogo_dee.png|[[Dé]]
Image:xlogo_flowers.png|[[Fleurs]]
Image:xlogo_foghouse.png|Maison dans le [[brouillard]]
Image:xlogo_hilbert3D.png|[[Courbe de Hilbert]]
Image:xlogo_menger4.png|[[Eponge de Menger]]
Image:xlogo_sierpinski.png|[[Triangle de Sierpinski]]
Image:xlogo_squares.png|[[Spirale]]
Image:xlogo_water.png|Bulles d'eau
&lt;/gallery&gt;

== Liens externes ==

* {{mul}} [http://xlogo.tuxfamily.org Site officiel]
** {{fr}} [http://downloads.tuxfamily.org/xlogo/downloads-fr/manual-fr.pdf Manuel complet]
** {{fr}} [http://xlogo.tuxfamily.org/fr/examples-fr.html Exemples]

{{Portail|informatique|logiciels libres}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>d50z71saun269t16uzuqb3nf698oh5c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Factor (langage)</title>
    <ns>0</ns>
    <id>3442598</id>
    <revision>
      <id>90498091</id>
      <parentid>87085014</parentid>
      <timestamp>2013-03-16T17:53:13Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 7 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1391724]]</comment>
      <text xml:space="preserve" bytes="2408">{{Infobox Langage de programmation
|nom = Factor
|logo = Factor-logo.png
|paradigme = langage de pile
|année = 2003
|auteur = {{Lien|fr=Slava Pestov|lang=en|trad=Slava Pestov|texte=Slava Pestov}}
|développeurs     = {{Lien|fr=Slava Pestov|lang=en|trad=Slava Pestov|texte=Slava Pestov}} et des contributeurs
|dernière version avancée = construction continue
|typage = [[Typage fort|fort]], [[Typage dynamique|dynamique]]
|influencé par = [[Joy (langage)|Joy]], [[Forth (langage)|Forth]], [[Lisp]], [[Self (langage)|Self]]
|a influencé  = [[Cat (langage)|Cat]]
|système d'exploitation = [[Microsoft Windows|Windows]], [[Mac OS]], [[Linux]], others
|licences      = [[licence BSD]]
|website = [http://factorcode.org/ factorcode.org]
}}

'''Factor''' est un langage de programmation [[Typage dynamique|dynamique]] concaténatif, dont la conception et l'implémentation sont coordonnées par {{Lien|fr=Slava Pestov|lang=en|trad=Slava Pestov|texte=Slava Pestov}}. Les principales influences de Factor sont [[Joy (langage)|Joy]], [[Forth (langage)|Forth]], [[Lisp]] et [[Self (langage)|Self]].

Comme les autres langages concaténatifs, Factor utilise une syntaxe postfixée, ce qui signifie que vous écrivez les arguments d'une fonction avant son nom. À titre d'exemple, afficher « hello world » se fait ainsi :

 &quot;Hello world&quot; print

Définition d'une fonction calculant la factorielle d'un entier  
 : factorielle ( n -- n! ) [ 1 ] [ [1,b] product ] if-zero ;

calcul de la factorielle de 10
 10 factorielle
   

== Liens externes ==
* [http://factorcode.org/ Le site de Factor]
* [http://concatenative.org/wiki/view/Factor/ Le wiki]
* [http://factorcode.org/binaries.fhtml Pour télécharger la dernière version de Factor]
* [http://docs.factorcode.org/ la documentation en ligne]
* [http://planet.factorcode.org/ planet-factor les news] 
* [http://factorcode.org/responder/cgi/gitweb.cgi?p=factor.git;a=summary Le dépôt Git de development]
* [https://lists.sourceforge.net/lists/listinfo/factor-talk Pour accéder à la liste de diffusion]
* [http://www.mail-archive.com/factor-talk@lists.sourceforge.net/ les archives de la mailing-list]
* [http://tunes.org/~nef/logs/concatenative Logs of #concatenative] on [[freenode]], le canal [[Internet Relay Chat|IRC]] principalement dédié à Factor

== Références ==

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>4avs9h2jdq1w7kt2806ofdtv3x07304</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Forth (langage)</title>
    <ns>0</ns>
    <id>10994</id>
    <revision>
      <id>100393486</id>
      <parentid>100150887</parentid>
      <timestamp>2014-01-19T12:41:14Z</timestamp>
      <contributor>
        <username>Ggal</username>
        <id>362597</id>
      </contributor>
      <comment>/* Mise en œuvre */</comment>
      <text xml:space="preserve" bytes="16653">{{Voir homonymes|Forth}}
'''Forth''' est un [[langage de programmation]] {{refnec|interactif atypique}}, inventé par [[Charles H. Moore]] dans les [[années 1960]].

== Historique ==
En [[1958 en informatique|1958]], un jeune informaticien nommé Charles Moore, chargé de calculer des trajectoires de [[satellite artificiel|satellites]], entreprend, pour faciliter son travail quotidien, la construction d'une boîte à outils sous la forme d'un [[interpréteur de commandes]]. D'année en année, cet interpréteur est amélioré et rendu indépendant de la machine hôte. En [[1968 en informatique|1968]], il prend le nom de Forth, et en 1970, il est suffisamment mûr pour faire l'objet d'une première publication comme « Langage pour calcul interactif ».

[[1971 en informatique|1971]] voit la première application d'envergure : Moore utilise Forth pour développer le logiciel de pilotage du [[ARO 12-m telescope|radio-télescope de Kitt Peak]] (Arizona) sur deux [[mini-ordinateur|mini-ordinateurs]] [[16-bits]]. Il y est bientôt rejoint par Elizabeth Rather, qui devient le deuxième programmeur Forth. Par ses performances et sa souplesse d'emploi, l'application intéresse rapidement d'autres observatoires, et en 1976, Forth est adopté comme standard par l'[[union astronomique internationale|Union internationale d'astronomie]].

Après une première modernisation du logiciel de [[Observatoire de Kitt Peak|Kitt Peak]] en 1973, Moore et Rather fondent Forth,Inc., pour promouvoir le langage et ses applications. En 1976, une première version exécutable sur [[microprocesseur]]s [[8-bits]] est disponible sous le nom de MicroFORTH.

En 1978 est créée une association, le ''Forth Interest Group'' (FIG), pour promouvoir une version « domaine public » du langage sur un maximum de processeurs, et publier la revue ''Forth Dimensions''. Le FIG-FORTH, légèrement différent du MicroFORTH, contribuera grandement à la diffusion du langage.

Le besoin de standardisation d'un langage que chacun peut modifier à sa guise devient manifeste. Une première tentative (FORTH77) aboutit au premier standard largement diffusé, FORTH79. Ce standard évolue quatre ans plus tard en FORTH83, mais des incompatibilités entre les deux versions engendrent des problèmes de portabilité, et sont à l'origine d'un clivage dans la communauté des programmeurs FORTH.

== Dénomination ==
Son nom est une contraction de l'[[anglais]] ''fourth'', qui signifie « quatrième » : c'était à l'origine un langage pour les machines de quatrième génération&lt;ref&gt;et non un [[L4G|langage de quatrième génération]], comme il est souvent dit)&lt;/ref&gt; machines dotées de lecteurs de disquettes ; mais, à l'époque, la machine IBM utilisée ne permettait que des noms de cinq lettres (ce qui suggère qu'il s'agissait d'un [[IBM 1130 et 1800|IBM 1130]]). Forth utilisait des concepts novateurs pour l'époque : [[multitâches|multiprogrammation]] et [[Mémoire cache|cache]]-disque notamment.

== Principes ==
Forth repose sur l'utilisation explicite de piles, alors que les autres langages utilisent des piles invisibles au programmeur.
=== Pile de données ===
Une des importantes caractéristiques du langage est l'utilisation d'une [[Pile (informatique)|pile de données]] pour passer des arguments entre les '''mots''', qui sont les constituants d'un programme Forth. 

Un simple exemple : l'expression &lt;code&gt;2+3*4&lt;/code&gt; sera traduite par la suite &lt;code&gt; 2 3 4 * +&lt;/code&gt;, dans la  [[notation polonaise inversée]].

Cette suite de mots agit sur la pile de données, son effet est
*d'empiler successivement les valeurs 2, 3, puis 4
*de remplacer ensuite les  2 nombres du sommet de la pile (3 et 4) par leur produit  12. 
*et enfin de remplacer les 2 nombres en haut de pile (2 et 12) par leur somme  14.

À partir des mots prédéfinis du langage, comme +, *, DUP (qui duplique l'élément en sommet de pile), SWAP (qui échange les
deux éléments du sommets), etc. le programmeur construit le vocabulaire de son application en définissant ses propres mots, qu'il réutilise ensuite :

 : CARRE DUP * ;      ( définition de CARRE )
 11 CARRE             ( on obtient 121 en sommet de la pile )
 : CUBE DUP CARRE * ; ( usage de CARRE dans une définition )
 2 CUBE               ( retourne 8 )

Une conséquence importante de l'utilisation d'une pile est la quasi-suppression des noms de variables locales, qui deviennent inutiles.

=== Pile de retour ===

Comme dans la quasi-totalité des langages, Forth utilise une pile pour stocker les adresses  de retour des sous-programmes en cours d'exécution. L'originalité ici est de mettre cette pile à la disposition du programmeur, principalement pour un stockage temporaire de données, au moyen de deux opérateurs permettant les  transferts pile de données - pile de retour.

=== Sous-programmes ===
Un mot Forth est l'équivalent des sous-programmes, fonctions ou procédures dans les autres langages. Cependant, Moore décrit les mots plus comme des abréviations que comme des fonctions à la [[C (langage)|C]]. Le mot d'ordre en Forth est la factorisation, c'est-à-dire le découpage de l'application en petits mots dont la définition tient sur une ligne ou deux.

Les « mots » de Forth sont « compilés », c'est-à-dire convertis en une forme exécutable et ajoutés au dictionnaire des mots. La forme exécutable diffère suivant le [[compilateur]]/[[interpréteur]] utilisé : génération directe de [[code natif|code machine]] ou ''[[bytecode]]'' par exemple (il existe de nombreuses variantes intermédiaires).

=== Autres caractéristiques ===

Il n'y a pas d'instruction GOTO. La syntaxe particulière de l'instruction IF...ELSE...THEN permet de résoudre de façon élégante le problème des &quot;n+1/2 itérations&quot; qui, en programmation structurée, aboutit à l'introduction d'une variable booléenne supplémentaire si l'on veut absolument éviter le GOTO.

Il n'y a pas d'opérateur d'affectation &quot;=&quot;. Les variables ne sont pas des données, mais des pointeurs vers des zones de mémoire allouées explicitement par le programmeur, qui contiennent les données. Le transfert des données se fait par les deux opérateurs  @ (fetch) et ! (store), qui correspondent aux instructions LDA (Load Accumulator) et STA (Store Accumulator) d'un assembleur, la pile jouant ici le rôle de l'accumulateur.

 VARIABLE toto  3 toto !  ( déclare et initialise toto )
 VARIABLE titi            ( déclare titi )             
 toto @ titi !            ( recopie toto dans titi )

L'invocation de toto pousse l'adresse de la variable toto sur la pile. @ remplace cette adresse par la valeur contenue dans toto, à savoir 3.
A son tour, l'invocation de titi pousse l'adresse de titi sur la pile, qui contient à ce moment les deux valeurs 3 et adr(titi). Enfin, ! écrit 3 en mémoire à l'adresse titi, et laisse la pile vide.

== Mise en œuvre == 

Le mélange interprétation/compilation, associé à des techniques de compilation efficaces et à la possibilité offerte par nombre de systèmes de définir aussi de nouvelles primitives en [[assembleur]], fait de Forth l'un des langages interprétés les plus rapides et les plus compacts.

Très proche du matériel, le Forth est un langage que l'on peut qualifier de « [[Langage de bas niveau|bas niveau]] », mais qui dispose de ressources qui lui permettent de se rapprocher du « [[langage de haut niveau|haut niveau]] ». Le langage est en effet basé sur un petit nombre de primitives suffisamment élémentaires pour être implémentées directement « dans le silicium » (c'est-à-dire être les instructions d'un processeur matériel ; les primitives de Forth sont donc bel et bien un « langage assembleur » pour ces processeurs. Il existe quelques exemples de [[Processeur_bas%C3%A9_sur_la_pile#Instructions|processeurs Forth]]).

Dans le même temps, le langage permet de définir des mots qui ont une action sur la compilation ; on peut ainsi définir de nouvelles structures de contrôle (par exemple la structure switch/case peut s'écrire à partir de la structure if/then/else). Cette caractéristique fait de Forth un [[langage extensible]].

C'est ainsi qu'à partir de quelques primitives écrites en langage machine, on peut construire un interpréteur en ligne de commande, un assembleur, un compilateur, un éditeur de source. La compacité est extrême : sur une machine 8 bits, 7 kilooctets suffisent pour avoir un interpréteur en ligne de commande, dont 700 octets seulement de code machine, le reste étant constitué de tables de pointeurs. En ajoutant environ 5 ko, on dispose de l'éditeur, d'un assembleur, et d'un système rudimentaire de stockage sur disquettes, le tout fonctionnant sans système d'exploitation avec quelques kilooctets de mémoire vive, et tenant sur une simple disquette (source intégrale incluse) ; autrement dit un micro-environnement de développement capable de s'autocompiler à partir de son propre source depuis une plateforme disposant de ressources modestes comme les applications embarquées.

Un des aspects de Forth est de tenter de trouver un juste milieu entre la langue naturelle du programmeur et la « langue » artificielle du processeur, contrairement aux autres langages qui prennent nettement le parti du programmeur au détriment du processeur. Ce compromis donne au langage son aspect exotique et déroutant de prime abord, et requiert sans conteste une certaine capacité d'adaptation de la part du programmeur.

Le langage Forth a fait l'objet d'une normalisation officielle, l'ANS-FORTH, fondée sur les standards officieux précédents Forth-79 et Forth-84. La plupart des Forth commerciaux suivent cette norme. De par l'extrême facilité d'implémentation d'un interpréteur pour ce langage, il existe un nombre incalculable de systèmes Forth de domaine public, qui sont soit alignés sur le standard ANS-Forth (comme gforth de GNU&lt;ref name=GForth&gt;[http://www.gnu.org/software/gforth/ gnu.org - GForth]&lt;/ref&gt;), soit sont des dialectes plus ou moins éloignés de Forth (notamment ColorForth de Charles Moore), et ce pour à peu près toutes les plateformes, du [[Intel 8051]] à Windows, en passant évidemment par [[Linux]].

== Utilisations ==

Forth a été utilisé principalement dans des [[Système embarqué|systèmes embarqués]] et des contrôleurs, en raison de leur caractère compact et de la facilité d'utiliser des mots définis en assembleur dans des programmes de plus haut niveau. Parmi les applications les plus prestigieuses, on relèvera sa présence sur quelques missions de la [[National Aeronautics and Space Administration|NASA]].

Les ROM [[Open Firmware]] des produits d'[[Apple]] et de [[Sun Microsystems|Sun]], ainsi qu'une partie du [[Amorce (informatique)|boot]] de [[FreeBSD]], étaient jusqu'à récemment écrites en Forth, permettant la portabilité du code de bas niveau entre les processeurs.

L'augmentation de performance des [[microcontrôleur|micro-contrôleurs]] permettant désormais la programmation des applications de ce type en [[C (langage)|langage C]], désormais érigé en assembleur universel, l'utilisation de Forth régresse sur son terrain de prédilection. Plus généralement, la tendance étant à ce que le programmeur devienne une ressource interchangeable (ce qui permet déjà l'externalisation de certains développements) au détriment de l'expérience et de la compétence, l'utilisation de Forth ne peut que décliner.

Bien que la mort de Forth ait été annoncée maintes et maintes fois, et que d'aucuns le qualifieraient de moribond, de nouveaux programmeurs de divers horizons curieux et attirés par ses performances et ses conceptions remarquables s'y intéressent régulièrement et s'en inspirent ; la survie de quelques sociétés prestataires de services qui basent leur offre sur Forth et réalisent des développements pour des projets de pointe (gestion de trafic aérien par exemple), laissent à penser que Forth n'est pas une langue morte.

== Notes et références ==
&lt;references /&gt;

== Voir aussi ==
=== Articles connexes ===
* [[Persistance (informatique)|Persistance]] : Forth a été au nombre des premiers langages persistants.
* [[PostScript]] : dans ses principes fondamentaux (pile, notation polonaise inversée, dictionnaire de mots…) le langage PostScript est très voisin de Forth ; il en diffère cependant dans la gestion dynamique de la portée des identificateurs (au moyen d'une pile de contexte contenant un nombre indéfini de dictionnaires, laquelle pile est aussi indépendante de la pile de données constamment utilisée pour l'exécution), et un contrôle complet des modes de fonctionnement entre interprétation, compilation et exécution, le langage permettant même de définir ses propres interprètes, compilateurs et exécuteurs, et la génération dynamique (pendant l'exécution du programme) de code exécutable par le programme lui-même.
* [[Joy (langage)|Joy]] : langage de pile fonctionnel inspiré de Forth
* [[Factor (langage)|Factor]] : langage de pile hérité de Forth
* [[Cat (langage)|Cat]] : un autre descendant de Forth
* [[RPL]] : le langage de programmation RPL inventé par [[Hewlett-Packard]] pour ses calculatrices a popularisé le concept de « pile de données ». Le RPL tient d'ailleurs surtout du Forth, même s'il tient un peu aussi du Lisp ; la concision de ce langage était bien adaptée aux calculatrices.

=== Bibliographie ===
Historiquement, une des premières bibles Forth (techniquement Fig-forth) fut le livre de Kevin McCabe publié en 1983, traduit en français et publié en France en 1985.
* {{ouvrage |langue= en|prénom1= Kevin|nom1= McCabe |titre=FORTH fundamentals |éditeur=Dilithium Press|année=1983  }}
* {{ouvrage |langue= fr|prénom1= Kevin|nom1= McCabe |titre=Le FORTH | éditeur=Belin|année=1985 |pages totales=290 |isbn=2-7011-0587-0 }}
Léo Brodie a écrit deux ouvrages considérés unanimement comme des références par la communauté Forth, qui les a mis en ligne. Le premier est un cours sur le langage, le second un précis de programmation et de style, traitant de sujets tels que l'architecture d'un programme, les différentes étapes du processus de programmation, la programmation ascendante et descendante, la factorisation, le choix des noms, etc.
* {{ouvrage |langue= en|prénom1= Leo|nom1= Brodie |titre=Starting Forth |numéro d'édition=2 |éditeur=Prentice Hall|mois=juin |année=1987 |pages totales=346 |isbn=0-13-843079-9 |lire en ligne=http://www.forth.com/starting-forth/index.html |consulté le=23 août 2009 }}
* {{ouvrage |langue= en|prénom1= Leo|nom1= Brodie |titre=Thinking Forth |numéro d'édition=2 |éditeur=Forth Interest Group|mois=juin |année=1994 |pages totales=316  |isbn=0-935533-00-1  |lire en ligne=http://freefr.dl.sourceforge.net/project/thinking-forth/reprint/rel-1.0/thinking-forth-color.pdf |consulté le=23 août 2009 }}

Un ouvrage décrivant le fonctionnement interne et l'implémentation en liste chaînée sur processeur Z80 d'un langage très voisin de Forth :
* {{ouvrage |langue= en|prénom1= R.G.|nom1= Loeliger |titre=Threaded Interpretive Languages : Their Design and Implementation |pages totales=250 |numéro d'édition=1 |éditeur=Byte Books|mois=janvier|année=1981  |isbn=0-07-038360-X  }}

=== Liens externes ===
* [http://www.forth.com/ Forth,Inc (en)] : le site officiel de la société fondée par Moore, avec un historique détaillé du langage.
* [http://forth.sourceforge.net/website/forthlinks/index.html Forth Links (en)] : un site de liens très complet.
* [http://www.forth.org/ Forth Interest Group (en)] : le site, toujours actif, de feu le FIG, association qui fut très active pour la promotion du langage. Nombreux articles et sources, grosse bibliothèque de liens.
* [http://hub.webring.org/hub/forth/ Forth Programming Webring (en)]
* [http://www.dmoz.org/World/Fran%c3%a7ais/Informatique/Programmation/Langages/Forth/ Entrée française de l'Open Directory Project] : une liste de liens utiles sur le langage Forth.
* [http://www.win32forth.org/ The Home of the Win32Forth Project Group (en)] : projet du domaine public proposant un environnement Forth sous Windows.
* comp.lang.forth est un forum [[usenet]] assez actif, où intervient régulièrement Elizabeth Rather.
* [http://www.complang.tuwien.ac.at/anton/euroforth/ Euroforth (en)] : colloque annuel européen consacré à Forth.


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]

{{lien BA|en}}

[[Catégorie:Langage impératif]]
[[Catégorie:Norme ISO]]</text>
      <sha1>1neme2nzpza0ok610f95co3qtfv4bsi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Quartz Composer</title>
    <ns>0</ns>
    <id>1773425</id>
    <revision>
      <id>90298925</id>
      <parentid>80824538</parentid>
      <timestamp>2013-03-15T13:59:00Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q609180]]</comment>
      <text xml:space="preserve" bytes="814">{{Ébauche|informatique}}

'''Quartz Composer''' est un [[Langage graphique|langage de programmation visuel]], fourni depuis [[Mac OS X]] 10.4 avec le logiciel [[Xcode]], spécialisé dans le traitement et le rendu de données graphiques.

Réaliser un programme consiste à connecter entre eux des blocs de traitement. Quartz Composer utilise [[OpenGL]], [[Core Image]], [[Core Video]], [[JavaScript]] pour créer des traitements qui peuvent être joués en tant que séquences [[Quicktime]], être transformés en [[économiseur d'écran|économiseurs d'écrans]] ou intégrés dans des applications [[Cocoa]] ou [[Carbon]].

== Liens externes ==
* {{en}} [http://quartzcomposer.com quartzcomposer.com]

{{Palette|Logiciel d'Apple}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>1mni5gm9s37znxvcic3nr2qnlr7pwji</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Modula-2</title>
    <ns>0</ns>
    <id>3450535</id>
    <revision>
      <id>101348413</id>
      <parentid>101348403</parentid>
      <timestamp>2014-02-17T20:37:23Z</timestamp>
      <contributor>
        <username>Housterdam</username>
        <id>1438581</id>
      </contributor>
      <comment>[[WP:Patrouille RC|Patrouille RC]] : Révocation des modifications de [[Special:Contributions/83.202.216.194|83.202.216.194]] (retour à la dernière version de [[User:Frakir|Frakir]])</comment>
      <text xml:space="preserve" bytes="13041">{{Infobox Langage de programmation
| nom                    = Modula
| logo                   = 
| paradigme              = [[Généricité|générique]], [[Programmation procédurale|procédural]], [[Programmation impérative|impératif]]
| année                  = [[1977]] 
| auteur                 = [[Niklaus Wirth]]
| typage                 = [[Typage statique|statique]], [[Sûreté du typage|safe]], [[Système nominatif de types|nominatif]]
| implémentations        = [[Windows]], [[OS/2]],[[Solaris (système d'exploitation)|Solaris]], [[Macintosh]], [[Unix]]
| dialectes              = Modula, Modula-1, Modula-2, ISO-Modula, Modula-3
| influencé par          = [[ALGOL]], [[Pascal (langage)|Pascal]]
| a influencé            = [[Python (langage)|Python]], [[Oberon (langage)|Oberon]]
}}

'''Modula''' est un [[langage de programmation]] créé en 1977 par [[Niklaus Wirth]] à l'[[École polytechnique fédérale de Zurich]]. Sa syntaxe est une amélioration de celle du langage [[pascal (langage)|Pascal]] dont il reprend bon nombre de principes.

Modula est un [[langage de programmation]] [[compilation (informatique)|compilé]], [[programmation procédurale|procédural]], [[typage fort|fortement typé]], [[Module (programmation)|modulaire]], facile à lire et à apprendre. Il est conçu pour enseigner la programmation et faciliter le développement des projets de grande ampleur. 

Par rapport à [[Pascal (langage)|Pascal]], il ajoute :
* l'[[encapsulation (programmation)|encapsulation]] en modules - d'où le nom du langage, 
* la notion d'interface, de [[bibliothèque logicielle|bibliothèque]], d'unité de compilation ; avec celle-ci, la programmation de haut et de « bas niveau » (permettant la définition de ''primitives'' ou fonctions de base au niveau le plus physique). 
* la [[programmation concurrente]] et une bien meilleure [[portabilité (informatique)|portabilité]].

En résumé, Modula 2 est plus puissant et plus complet que Pascal. La modularité étant mieux conçue et traitée qu'en [[C (langage)|C]], Modula 2 s'avère plus fiable dans les grosses applications. 

Wirth a déclaré que ce langage était &quot;celui qu'il aurait aimé concevoir quand il avait conçu Pascal&quot;. 

== Dialectes et langages apparentés ==
[[Algol (langage)|Algol W]] et [[Pascal (langage)|Pascal]] (Niklaus Wirth, 1970) sont les ancêtres de Modula.

[[Oberon (langage)|Oberon]] est un descendant direct de Modula. (Niklaus Wirth, 1985)

Modula a influencé les langages Java et C# 

'''dialectes'''
* Modula, aussi appelé Modula-1. Niklaus Wirth, 1977
* Modula-2. Niklaus Wirth, 1978
* ISO-Modula. International Organisation for Standardisation, 1987.
* Modula-3. 1980

== Compilateurs Modula ==
*'''GNU Modula-2''' :  pour platformes [[Unix]] - [[Berkeley Software Distribution|BSD]], [[MacOS X]], [[Linux]], [[Solaris (système d'exploitation)|Solaris]]
*'''MacMETH''' :  pour [[Macintosh]]
*'''MOCKA''' : pour de nombreux [[Unix]] - [[Sun Microsystems|Sun]] [[Solaris (système d'exploitation)|Solaris]], [[Silicon Graphics|SGI]] [[IRIX]], [[Hewlett Packard]] [[HP-UX|HPUX]], [[Linux]], [[Berkeley Software Distribution|BSD]]
*'''Objective Modula-2''' :  avec extensions pour Cocoa et GNUstep sur platformes [[Unix]]
*'''Stony Brook''' : compilateur ISO-Modula et [[Pascal (langage)|Pascal]] pour [[x86]] ([[MS-DOS|DOS]], [[Windows]], [[Linux]]) et [[Sun Microsystems|SUN]] [[Solaris (système d'exploitation)|Solaris]]. Stony Brook a cessé son activité le 31 octobre 2004.
*'''XDS''': compilateur Modula-2 et [[Oberon (langage)|Oberon]] pour [[x86]] ([[Windows]], [[OS/2]], [[Linux]])

== Caractéristiques du langage Modula ==
La syntaxe générale de Modula est celle de [[Pascal (langage)|Pascal]]. La différence majeure étant l'usage moins fréquent du mot clé ''BEGIN'', et le remplacement du mot clé ''PROGRAM'' par ''MODULE'', ''IMPLEMENTATION MODULE'' ou ''DEFINITION MODULE'' selon les cas.

Contrairement au langage Pascal, qui n'est pas [[Sensibilité à la casse|sensible à la casse]], les mots réservés et noms des éléments de base (fonctions, types et constantes) en Modula-2 sont obligatoirement écrits en majuscule.

'''exemple''': [[Hello World]] écrit en Modula :
&lt;pre&gt;
   MODULE Hello;
 
   FROM Terminal IMPORT WriteLn, WriteString;
 
   BEGIN
      WriteString(&quot;Hello world!&quot;);
      WriteLn;
   END Hello.
&lt;/pre&gt;

=== Typage fort et données brutes ===
Modula est un langage [[typage fort|fortement typé]], qui interdit toute conversion entre deux types où il y a possibilité de perte d'information tout en permettant la manipulation de ''données brutes'' et non typées.

Les types de base sont INTEGER (nombre entier), REAL (nombre à virgule flottante), CHAR (caractère), et BOOLEAN. ([[booléen]])

Modula offre de nombreuses possibilités de créer des types complexes tels que [[tableau (structure de données)|tableaux]] ''ARRAY'', enregistrements ''RECORD'', [[pointeur (programmation)|pointeurs typés]] ''POINTER'', [[enumeration|énumérations]], [[Intervalle (mathématiques)|intervalles]], groupe de [[drapeau (informatique)|flags]] ''SET OF''.

Modula offre la possibilité de créer des [[fonction de rappel|''callback'']] par l'utilisation de types ''PROCEDURE''.

En invoquant le module System, Modula offre aussi la possibilité de manipuler des informations ''brutes'' et non typées, grâce aux types génériques ''BYTE''  et ''WORD'' (octet), ''ADDRESS'' ([[pointeur (programmation)|pointeur non typé]] + nombre) et ''BITSET'' (groupe de [[drapeau (informatique)|''flags'']] non typé). Si un paramètre d'une fonction est de type ''ARRAY OF BYTE'' (tableau d'octets de taille quelconque), le paramètre pourra contenir en vrac ''n'importe quel type d'information''. On peut ainsi profiter des avantages de la programmation physique dans les modules où elle est nécessaire, et d'une sécurité maximale partout ailleurs.

=== Modules, interfaces, encapsulation et unité de compilation ===

En Modula le mot clé MODULE sert à [[encapsulation (informatique)|encapsuler]] des éléments tels que des variables, des types ou des fonctions, c'est-à-dire à les rendre invisibles de l'extérieur du module, afin de cacher les détails internes de la construction du module. 

Un module peut contenir d'autres modules. Dans un programme de grande dimension, un seul fichier exécutable peut contenir plusieurs fonctionnalités, le code source de chaque fonctionnalité peut être réparti sur plusieurs fichiers sources. Les fichiers sont alors compilés par petits groupes appelés ''unités de compilation''.

La compilation peut se faire en plusieurs étapes, une ''unité de compilation'' à la fois. 

Pour un programme ordinaire l'unité de compilation est composée d'un seul fichier source qui commence par ''MODULE''. 

Pour une bibliothèque l'unité de compilation est composée de deux fichiers source :
* un ''interface'' qui commence par ''DEFINITION MODULE'', où sont  déclarés les éléments ''rendus publics'', utilisables par les unités qui exploiteront ce module ;
* un ''corps'' qui commence par ''IMPLEMENTATION MODULE'', qui contient les éléments privés, ainsi que les instructions.

Pour utiliser dans un module B un élément (fonction, type, variable) provenant d'un module A, on ajoute au début du module B le mot clé ''FROM'' suivi du nom du module (ici A), puis du mot ''IMPORT'' et de la liste des éléments importés.

=== Primitives et bibliothèques ===
Le langage Modula comporte seulement quelques instructions : INC, DEC, INCL, EXCL, CHR et ORD.

Dans les programmes écrits en Modula, la majorité des opérations se font par l'utilisation des primitives incluses dans un ensemble de [[bibliothèque logicielle|bibliothèques]] fournies avec le [[compilateur]]. les fonctions dans ces bibliothèques peuvent varier selon le système et le compilateur.

Le langage offre la possibilité de créer des bibliothèques, et toutes les bibliothèques de primitives fournies avec le compilateur sont écrites en Modula, exception faite des bibliothèques SYSTEM et COROUTINES.

Chaque bibliothèque consiste en un fichier de définition ''DEFINITION MODULE'' et un fichier d'implémentation ''IMPLEMENTATION MODULE''. 

Dans le fichier de définition sont déclarés les éléments qui seront ''rendu publics'' et dont utilisables par les programmes qui exploiteront ce module. et dans le fichier d'implémentation se trouvent les éléments privés, ainsi que les instructions.

=== Programmation concurrente ===
La programmation concurrente en Modula est basée sur les [[coroutine]]s et les variables de contexte. le contexte étant l'instruction qu'une coroutine était en train d'exécuter à un moment donné (voir [[commutation de contexte]]).

Le type de données contexte s'appelle ''PROCESS'' en Modula-1 et Modula-2 et ''COROUTINE'' en Modula-3.

L'instruction ''TRANSFER'' permet d'arrêter l'exécution de la coroutine en cours  ''A'', et de relancer l'exécution d'une coroutine quelconque ''B''. le contexte d'exécution de la coroutine ''B'' est passé en paramètre. La coroutine ''A'' sera suspendue - l'exécution de l'instruction TRANSFER est ne se terminera pas - jusqu'à ce qu'une autre coroutine utilise l'instruction ''TRANSFER''.

L'instruction ''IOTRANSFER'' permet d'arrêter l'exécution de la coroutine en cours ''A'' et de relancer l'exécution d'une coroutine quelconque ''B'' jusqu'à ce qu'une [[interruption (informatique)|interruption]] matérielle survient. La coroutine ''A'' reste suspendue jusqu'à la venue de l'interruption.

Une instruction permet de créer un nouveau contexte pour une coroutine.

Ces trois instruction suffisent à réaliser un [[noyau de système d'exploitation|noyau multitâche préemptif]], des [[processus léger|thread légers]], ainsi que des mécanismes de [[synchronisation (multitâches)|synchronisation]]. Des mécanismes qui sont souvent inclus dans les bibliothèques fournies avec le compilateur Modula.

=== Programmation de haut niveau et portabilité ===
Modula est un langage de programmation de haut niveau, c'est-à-dire qu'il permet d'écrire un programme sous une forme proche de la pensée humaine, et cache les détails techniques de la machine sur laquelle le programme va être exécuté.

Un langage de programmation de haut niveau permet d'écrire des programmes portables. C'est-à-dire qu'un programme écrit pour un système peut, moyennant quelques changements mineurs, être compilé de nouveau sur un autre système.

Pour faciliter les modifications, les éléments du langage qui peuvent différer d'un système à l'autre sont encapsulés dans les modules SYSTEM et COROUTINE. Il y a notamment les types de données de bas niveau BYTE, ADDRESS, BITSET, PROCESS et COROUTINE. ainsi un module qui risque de demander des changements peut être repéré facilement par le fait qu'il importe des éléments du module SYSTEM ou COROUTINE.

La majorité des instructions dans un programme écrit en Modula consistent à utiliser des fonctions incluses dans les bibliothèques fournies avec le compilateur. Tout comme dans le langage [[C (langage)|C]], il existe une suite de bibliothèques standard et communes à tous les compilateurs, suite à laquelle se rajoutent diverses bibliothèques, différentes d'un compilateur à l'autre.

== Lilith ==
Lilith est le nom d'une [[station de travail]] conçue en 1978 par [[ETH Zurich|L'école Polytechnique Fédérale de Zürich]], et dont l'environnement logiciel est entièrement écrit en Modula.

Cet environnement inclut un compilateur, un système d'exploitation, un environnement graphique et divers outils.
Le développement de la machine était à la fois un exercice grandeur nature pour les élèves des facultés d'électronique et d'informatique de l'université, et une occasion d'évaluer les qualités et les défauts de Modula sur les projets de grande ampleur.
Le processeur utilisait un M-code, et un bus rapide pour l'affichage graphique.

== Voir aussi ==
* {{Lien|trad=Modula-3|Modula 3|texte=Modula-3}} qui a été conçu comme un successeur de la version améliorée de Modula-2, {{lien|Modula-2+}}.
===Références ===
{{Ouvrage
 | titre       = Programming in Modula-2
 | éditeur     = Springer-Verlag
 | auteur      = Niklaus Wirth
 | langue      = anglais
 | année       = 1982
 | lieu        = Berlin
 | isbn        = 3-540-11674-5
}}

{{fr}}
{{Ouvrage
 | titre       = Programmer en Modula-2
 | éditeur     = Presses Polytechniques et Universitaires Romandes
 | auteur      = Niklaus Wirth
 | langue      = français
 | traducteur  = Jacques André
 | année       = 1984
 | lieu        = Lausanne
 | isbn        = 2-88074-063-0
}}
=== Liens externes ===
*{{en}} http://www.ethistory.ethz.ch/rueckblicke/departemente/dinfk/weitere_seiten/lilith/index_EN
*{{en}} http://www.arjay.bc.ca/Modula-2/m2faq.html Modula-2 FAQ

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>2peqjro9zjo1ccz8o2pemrzg5mnou9b</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PL/M</title>
    <ns>0</ns>
    <id>3468721</id>
    <revision>
      <id>92069492</id>
      <parentid>91824881</parentid>
      <timestamp>2013-04-14T10:52:59Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>550160</id>
      </contributor>
      <minor/>
      <comment>replaced: {{article||langue=en → {{article|langue=en| using [[Project:AWB|AWB]]</comment>
      <text xml:space="preserve" bytes="2823">Le '''PL/M''' (sigle&lt;!--Ne pas confondre « acronyme » avec « sigle »--&gt; de '''''P'''rogramming '''L'''anguage for '''M'''icrocomputers'') est un [[langage de programmation]] développé par [[Gary Kildall]]&lt;ref name=&quot;swaine&quot;&gt;{{article|langue=en|
first=Michael|nom=Swaine|
date={{date|22|juin|2001}}|
title=Gary Kildall and Collegial Entrepreneurship|
journal=Dr. Dobb's Journal|
url=http://www.ddj.com/184410428|
accessdate=2006-11-20}}&lt;/ref&gt; en [[1972]] pour [[Intel]] pour ses [[Liste des microprocesseurs Intel|microprocesseurs]].

Le langage incorpore des idées empruntées aux langages [[PL/I]], [[Algol (langage)|ALGOL]] et [[XPL (langage)|XPL]], et possède un [[préprocesseur]] de [[Macro-définition|macros]] intégré. Contrairement aux langages évolués contemporains tels que [[Pascal (langage)|Pascal]], [[C (langage)|C]] ou [[C++]], il ne possède pas de routines d'entrées-sorties standard. Par contre, étant spécialement conçu pour certains processeurs, il est nettement plus efficace que d'autres langages pour certaines opérations de bas niveau.

Le système opérationnel [[CP/M]] ainsi que le ''[[firmware]]'' pour le ''Service Processor Component'' de l'[[AS/400]] ont été écrits en PL/M. On a écrit des [[compilateur]]s PL/M pour les contrôleurs/processeurs suivants : [[Intel 4004]], [[Intel 8008|8008]], [[Intel 8080|8080]], [[Intel 8085|8085]], [[Intel 8051|8051]], 80196, [[Intel 8086|8086/8088]], [[Intel 80186|80186/80188]], [[Intel 80286|286]], et [[Intel 80386|386]].

Quoique PL/M ne soit plus supporté par Intel, il existe toujours, du fait la longévité de certains systèmes informatiques l’utilisant encore, des compilateurs et des outils de traduction PL/M vers C.

== Notes ==
{{références}}

== Références ==
* Intel Corporation (1976). ''PL/M-80 Programming Manual''. Doc # 98-268B.
* McCracken, Daniel D. (1978). ''A Guide to PL/M Programming for Microcomputer Applications''. Pearson Addison-Wesley. 

== Liens externes ==
* [http://www.slac.stanford.edu/grp/cd/soft/rmx/manuals/PLM_386.PDF ''PL/M 386 Programmer’s Guide''] ([[Portable Document Format|PDF]]) – RadiSys Corporation, December 1999. Includes entire syntax of PL/M in [[Backus-Naur Form|BNF]] notation.
* {{lien brisé|consulté le=2013-04-08|url=http://www.ristancase.com/da-plm/index.php|titre=Development Assistant for PL/M (DA-PL/M)}} – Commercial PL/M [[integrated development environment|IDE]] from RistanCASE GmbH
* [http://www.plm2c.com/ PLM2C - PL/M to C Translator] – Commercial product from Alternative Solutions
* {{lien brisé|consulté le=2013-04-08|url=http://www.pennington.com/plmcee.htm|titre=XTRAN Demonstration: Translating PL/M to C}} – Commercial product from Pennington Systems, Inc.

{{FOLDOC}}
{{Portail|informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>052l9hcyykgm8sv3uii5epvln078rgx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>OpenCL</title>
    <ns>0</ns>
    <id>3452000</id>
    <revision>
      <id>101839794</id>
      <parentid>101298540</parentid>
      <timestamp>2014-03-06T14:42:47Z</timestamp>
      <contributor>
        <username>Pautard</username>
        <id>58456</id>
      </contributor>
      <minor/>
      <comment>sont disponibles</comment>
      <text xml:space="preserve" bytes="19433">{{ébauche|informatique}}
{{confusion|OpenGL}}
{{Infobox Logiciel
 | nom = OpenCL
 | logo = OpenCL Logo.png
 | développeur = [[Khronos Group]]
 | dernière version = 1.2
 | date de dernière version = {{Date|15|novembre|2011|en informatique}}
 | os = [[Cross-platform]]
 | type = [[application programming interface|API]]
 | licence = Format Ouvert Libre de Droits
 | site web = [http://www.khronos.org/opencl www.khronos.org]
}}
'''OpenCL''' ('''Open''' '''C'''omputing '''L'''anguage) est la combinaison d'une [[Interface de programmation|API]] et d'un langage de programmation dérivé du [[C (langage)|C]], proposé comme un standard ouvert par le [[Khronos Group]]. OpenCL est conçu pour programmer des systèmes parallèles hétérogènes comprenant par exemple à la fois un [[CPU]] multi-cœur et un [[Processeur graphique|GPU]]. OpenCL propose donc un modèle de programmation se situant à l'intersection naissante entre le monde des [[CPU]] et des [[Processeur graphique|GPU]], les premiers étant de plus en plus parallèles, les seconds étant de plus en plus programmables. 

== Présentation ==
OpenCL distingue le processeur hôte (processeur central faisant office de chef d'orchestre) des périphériques (CPU, GPU, ou autre) dont la mission est d'exécuter des noyaux de calcul intensifs. OpenCL distingue donc d'un coté l'application tournant sur le processeur hôte (et qui va appeler l'API OpenCL), et de l'autre coté les noyaux qui sont programmés en OpenCL-C (et dont la vocation est d'être exécutés sur les périphériques).

OpenCL permet d'exprimer du parallélisme de tâches mais aussi du parallélisme de données sous deux formes ; SPMD (Single Program Multiple Data) et SIMD (Single Instruction Multiple Data), le tout de manière hiérarchique. Un graphe de tâches peut être créé dynamiquement via l'API OpenCL. Chaque tâche peut être représentée soit sous forme d'une instance unique (appelée tâche), soit sous forme d'une collection d'instances (appelée NDRange) d'un même noyau. Les NDRanges peuvent être de 1, 2 ou 3 dimensions. Chaque instance de kernel appartenant à un NDRange est appelée work-item. Le NDrange peut lui-même être structuré en work-groups, ce qui permet aux work-items à l’intérieur des work-groups de partager des données et de se synchroniser via des barrières.

Si parmi certains de ses objectifs techniques, OpenCL semble se rapprocher de C pour [[Compute Unified Device Architecture|CUDA]], modèle de programmation propriétaire de la société Nvidia, OpenCL a des objectifs plus larges car n'étant pas uniquement dédié aux GPU. Dans le monde du calcul haute performance ou du jeu, OpenCL permettra de tirer parti de la puissance des processeurs graphiques, des CPU multi-cœurs ou d'autres systèmes de calcul intensifs tels le [[Cell (processeur)|CELL]] d'[[IBM]], qui équipe notamment la [[PlayStation 3]] de Sony. Dans le monde des systèmes embarqués sur puce ([[SoC]]), tels qu'on les trouve dans les smartphones, OpenCL permettra l'accès, via une infrastructure de programmation unique, au processeur central, ainsi qu'aux différents sous-systèmes multimédia embarqués (GPU, DSP, computing array ou autres).

Il existe actuellement peu de moyens de déboguer des noyaux OpenCL. Tout d'abord, le débogueur NVIDIA Parallel Nsight, capable de déboguer CUDA thread par thread, ne supporte actuellement pas OpenCL, mais permet seulement de traquer les appels à l'API&lt;ref&gt;http://developer.download.nvidia.com/assets/tools/docs/Nsight_Datasheet_Feb_11_Screen.pdf&lt;/ref&gt;. Ensuite, AMD propose une extension permettant de mettre des traces directement dans le code OpenCL (cl_amd_printf). Enfin, un programme appelé gDebugger (par Gremedy puis par AMD&lt;ref&gt;http://developer.amd.com/TOOLS/GDEBUGGER/Pages/default.aspx&lt;/ref&gt;) permet de suivre le déroulement de l'algorithme thread par thread.

== Historique ==
OpenCL a été initialement conçu par Apple&lt;ref name= pressrelease/&gt; (qui en possède les droits d'auteur), et affiné dans le cadre d'une collaboration avec [[Advanced Micro Devices|AMD]], [[Intel Corporation|Intel]] et [[Nvidia]]. Apple soumet d'abord sa proposition initiale au [[Khronos Group]]. Le {{date|16|juin|2008|en informatique}}, le ''Khronos Compute Working Group'' est formé, comprenant des représentants des fabricants de matériel informatique et de logiciels. Celui-ci travaille durant cinq mois à boucler les détails techniques de la spécification OpenCL 1.0. La spécification est révisée par les membres de Khronos et approuvée pour une version d'essai le 8 décembre. Une nouvelle version, OpenCL 1.1, est publiée en juin 2010 par le [[Khronos Group]]. OpenCL 1.1 clarifie certains aspects de la spécification précédente et apporte de nouvelles fonctionnalités telles que les sous-buffers, les vecteurs à 3 éléments, les événements utilisateur, de nouvelles fonctions builtin, le support en standard d'extensions optionnelles 1.0 (telles que les fonctions atomiques 32 bits) .

OpenCL est intégré dans [[Mac OS X v10.6|Mac OS X 10.6]]&lt;ref name=pressrelease&gt;{{lien web |langue=en|url=http://www.apple.com/pr/library/2008/06/09snowleopard.html  |titre=Apple Previews Mac OS X Snow Leopard to Developers |éditeur=Apple  |date=2008-06-09}}&lt;/ref&gt; (Snow Leopard).
AMD décide de supporter OpenCL et DirectX 11 plutôt que [[Technologie_ATI_Stream|Close to Metal]] dans son framework Stream SDK. [[RapidMind]] annonce l'adoption de OpenCL sous sa plate-forme de développement, afin de supporter les [[processeur graphique|processeurs graphiques]] de plusieurs fabricants avec une interface unique. Nvidia confirme également le 9 décembre 2008 le support complet de la spécification 1.0 dans son GPU Computing Toolkit&lt;ref&gt;[http://www.nvidia.fr/object/io_1229091748589.html Communiqué de presse de Nvidia]&lt;/ref&gt;.

Le 15 novembre 2011, Le Khronos Group a publié les spécifications d'OpenCL 1.2. On y trouve notamment des fonctionnalités liées à la mobilité et à la portabilité, avec par exemple la possibilité de dissocier compilation et édition de liens des noyaux &lt;ref&gt;http://www.khronos.org/news/press/khronos-releases-opencl-1.2-specification&lt;/ref&gt;.

== WebCL ==
{{Article détaillé|WebCL}}
Le Khronos Group a également développé une intégration d'OpenCL, bibliothèque de calcul parallèle, dans l'ensemble des [[Interface de programmation|interfaces de programmation]] d'HTML5&lt;ref&gt;{{en}}[http://www.khronos.org/webcl/ OpenCL]&lt;/ref&gt;. Actuellement, les navigateurs utilisent des extensions pour gérer OpenCL.

[[Nokia]] et Mozilla &lt;ref&gt;http://webcl.nokiaresearch.com/&lt;/ref&gt; ont développé des extensions pour Firefox. [[Samsung Electronics|Samsung]] pour [[WebKit]] et [[Motorola]] pour [[Node.js]].

== Historique des implémentations ==
Des implémentations d'OpenCL existent pour la majorité des plateformes aujourd'hui. IBM pour ses supercalculateurs sous [[GNU]]/Linux utilisant des processeurs Power, les processeurs X86 d'Intel et AMD et les GPU les accompagnant traditionnellement (ATI, nVidia, VIA), les processeurs [[ARM (société)|ARM]] Cortex-A9 (parties SSE et fpu 128bits Neon), ainsi que les DSP, GPU et autres computing array les accompagnant dans les nombreuses implémentations des System on chip (SoC) (nVidia [[Tegra#Tegra 250|Tegra2]], [[Qualcomm]] [[Snapdragon]], [[Apple A4]], [[Marvell]] [[Armada (SoC ARM)|Armada]], etc.). [[Mesa (OpenGL)|Mesa]] (Implémentation OpenGL/OpenVG sous [[GNU]]/Linux) contient un state-tracker OpenCL pour Gallium3D en cours de développement, nommé [[Clover]]&lt;ref&gt;{{
lien web
|langue=en|url=http://cgit.freedesktop.org/mesa/clover
|title=Clover git repo
|date=2010-01-04
|accessdate=2010-01-30
}}&lt;/ref&gt;{{,}}&lt;ref&gt;{{
lien web
|langue=en|url=http://www.phoronix.com/scan.php?page=news_item&amp;px=Nzc4NQ
|title=OpenCL Over Mesa, Gallium3D Discussion
|date=2009-12-09
|accessdate=2010-01-30
}}&lt;/ref&gt;
 
Le 10 décembre 2008, AMD et Nvidia font la première démonstration publique d'OpenCL, une présentation de 75 minutes à ''[[SIGGRAPH|SIGGRAPH Asia 2008]]''. AMD effectue une démonstration d'OpenCL accélérée sur CPU et explique la scalabilité d'OpenCL sur un ou plusieurs cœurs tandis qu'Nvidia fait une démonstration accélérée par GPU&lt;ref&gt;{{
lien web
|langue=en|url=http://www.youtube.com/watch?v=sLv_fhQlqis
|title=OpenCL Demo, AMD CPU
|date=2008-12-10
|accessdate=2009-03-28
}}
&lt;/ref&gt;{{,}}&lt;ref&gt;
{{
lien web
|langue=en|url=http://www.youtube.com/watch?v=PJ1jydg8mLg
|title=OpenCL Demo, NVIDIA GPU
|date=2008-12-10
|accessdate=2009-03-28
}}
&lt;/ref&gt;.

Le 26 mars 2009, à la ''[[Game_Developers_Conference|GDC 2009]]'', AMD et [[Havok_(société)|Havok]] font une démonstration de la première implémentation accélérée par OpenCL, ''Havok Cloth'' sur un GPU de la [[Radeon_R700|série Radeon HD 4000]] d'AMD&lt;ref&gt;
{{
lien web
|langue=en|url=http://www.pcper.com/comments.php?nid=6954
|title=AMD and Havok demo OpenCL accelerated physics
|publisher=PC Perspective
|date=2009-03-26
|accessdate=2009-03-28 
}}
&lt;/ref&gt;.

Le 20 avril 2009, Nvidia annonce la sortie de son pilote OpenCL et du [[Software_development_kit|SDK]] aux développeurs participant à son ''OpenCL Early Access Program''&lt;ref&gt;
{{
lien web
|langue=en|url=http://www.nvidia.com/object/io_1240224603372.html
|title=NVIDIA Releases OpenCL Driver To Developers
|publisher=NVIDIA
|date=2009-04-20
|accessdate=2009-04-27 
}}
&lt;/ref&gt;.

Le 5 août 2009, AMD révèle les premiers outils de développement pour sa plateforme OpenCL comme partie de son programme ''ATI Stream SDK v2.0 Beta''&lt;ref&gt;
{{
lien web
|langue=en|url=http://arst.ch/5te
|title=AMD does reverse GPGPU, announces OpenCL SDK for x86
|publisher=Ars Technica
|date=2009-08-05
|accessdate=2009-08-06 
}}
&lt;/ref&gt;.

Le 28 août 2009, Apple sort [[Mac OS X]] Snow Leopard, qui contient une implémentation complète d'OpenCL&lt;ref&gt;
{{
lien web
|langue=en|author=Dan Moren
|coauthors=Jason Snell
|url=http://www.macworld.com/article/140897/2009/06/keynote.html
|title=Live Update: WWDC 2009 Keynote
|work=macworld.com
|publisher=MacWorld
|date=2009-06-08
|accessdate=2009-06-12 
}}
&lt;/ref&gt;.

Dans Snow Leopard, OpenCL est initialement supporté sur les puces ATI Radeon HD 4850, ATI Radeon HD 4870 ainsi que les puces Nvidia Geforce 8600M GT, GeForce 8800 GS, GeForce 8800 GT, GeForce 8800 GTS, Geforce 9400M, GeForce 9600M GT, GeForce GT 120, GeForce GT 130, GeForce GTX 285, Quadro FX 4800, et Quadro FX 5600&lt;ref&gt;{{
lien web
|langue=en|url=http://www.apple.com/macosx/specs.html
|title=Mac OS X Snow Leopard – ''Technical specifications and system requirements''
|publisher=Apple Inc
|date=2009-06-08
|accessdate=2009-08-25 
}}
&lt;/ref&gt;.

Le 28 septembre 2009, Nvidia sort ses propres pilotes OpenCL et son implémentation du SDK.

Le 13 octobre 2009, AMD sort la quatrième bêta du ''ATI Stream SDK 2.0'', qui fournit une implémentation OpenCL complète sur tous les GPU des familles [[Radeon_R700|R700]]/[[Radeon_R800|R800]], utilisant également les unités [[SSE3]] des CPUs. Le SDK est disponible à la fois pour [[GNU]]/Linux et Windows&lt;ref&gt;{{
lien web
|langue=en|url=http://developer.amd.com/GPU/ATISTREAMSDKBETAPROGRAM/Pages/default.aspx#one
|title=ATI Stream Software Development Kit (SDK) v2.0 Beta Program
|accessdate=2009-10-14
}}&lt;/ref&gt;.

Le 30 octobre 2009, [[IBM]] sort la version 0.1 de son SDK OpenCL pour [[GNU]]/Linux sur l'architecture [[IBM POWER|Power]] utilisé dans une majorité des plus puissants supercalculateurs au monde&lt;ref&gt;{{
lien web
|langue=en|url=http://www.alphaworks.ibm.com/tech/opencl
|title=OpenCL Development Kit for Linux on Power
|accessdate=2009-10-30
}}&lt;/ref&gt;.

Le 26 novembre 2009, Nvidia sort des pilotes pour l'implémentation OpenCL 1.0 (rev 48).

Les implémentations OpenCL d'Apple&lt;ref&gt;{{
lien web
|langue=en|url=http://llvm.org/Users.html#Apple
|title=Apple entry on LLVM Users page
|accessdate=2009-08-29
}}
&lt;/ref&gt;, Nvidia&lt;ref&gt;{{
lien web
|langue=en|url=http://llvm.org/Users.html
|title=Nvidia entry on LLVM Users page
|accessdate=2009-08-06
}}
&lt;/ref&gt;, [[RapidMind]]&lt;ref&gt;{{
lien web
|langue=en|url=http://llvm.org/Users.html
|title=Rapidmind entry on LLVM Users page
|accessdate=2009-10-01
}}&lt;/ref&gt; et Mesa Gallium3D&lt;ref&gt;{{
lien web
|langue=en|url=http://zrusin.blogspot.com/2009/02/opencl.html
|title=Zack Rusin's blog post about the Mesa Gallium3D OpenCL implementation
|accessdate=2009-10-01)
}}
&lt;/ref&gt; sont toutes basées sur la technologie de compilation [[LLVM]] et utilisent le compilateur [[Clang]] comme frontend.

Le 10 décembre 2009, [[VIA Technologies|VIA]] sort son premier produit supportant OpenCL 1.0 - Le processeur vidéo ChromotionHD 2.0 inclus dans les puces VN1000&lt;ref&gt;http://www.via.com.tw/en/resources/pressroom/pressrelease.jsp?press_release_no=4327&lt;/ref&gt;. 

Le 21 décembre 2009, AMD sort la version de production de l'''ATI Stream SDK 2.0''&lt;ref&gt;{{
lien web
|langue=en|url=http://developer.amd.com/gpu/ATIStreamSDK/Pages/default.aspx
|title=ATI Stream SDK v2.0 with OpenCL™ 1.0 Support
|accessdate=2009-10-23
}}&lt;/ref&gt;, qui fournit un support d'OpenCL 1.0 pour les [[Radeon_R800|R800]] GPUs et un support bêta pour [[Radeon_R700|R700]].

Le 29 juin 2011, Intel sort la version finale de son kit de développement supportant OpenCL version 1.1&lt;ref&gt;http://software.intel.com/en-us/blogs/2011/06/29/intel-opencl-sdk-11-gold-released/&lt;/ref&gt;.

Le 3 août 2011 AMD annonce son kit de développement ''ATI Stream SDK 2.5'' &lt;ref&gt;{{
lien web
|langue=en|url=http://blogs.amd.com/developer/2011/08/02/amd-app-sdk-2-5-provides-enhanced-performance-and-major-new-capabilities
|title=AMD APP SDK 2.5 provides enhanced performance and major new capabilities
|accessdate=2011-08-03                                                            
}}&lt;/ref&gt;, qui améliore, entre autres, la bande passante CPU/GPU pour tirer un meilleur parti de ses récents [[Accelerated_Processing_Unit|APU]].

Chez Intel, les processeurs graphiques inclus dans sa gamme de processeurs [[Sandy_Bridge#Famille_Ivy_Bridge|Ivy Bridge]], sortis le 29 avril 2012, Intel HD 2500 ainsi que HD 4000 et supérieurs, sont les premières architectures à supporter matériellement OpenCL, en version 1.1&lt;ref&gt;{{lien web|lang=fr|url=http://www.pcinpact.com/news/74788-nouveaux-pilotes-chez-intel-opengl-4-0-et-ultra-hd-pour-ivy-bridge.htm|titre=Nouveaux pilotes chez Intel : OpenGL 4.0 et Ultra HD pour Ivy Bridge|date=2012-10-24|accessdate=2013-12-10}}&lt;/ref&gt;.

La bibliothèque [[Beignet (bibliothèque)|Beignet]]&lt;ref&gt;{{lien web|url=http://www.freedesktop.org/wiki/Software/Beignet/|titre=Beignet|accessdate=2013-12-10}}&lt;/ref&gt; est une bibliothèque OpenCL libre pour les processeurs Intel IvryBridge GT2, dans le cadre du projet [[freedesktop.org]], et développé principalement par Intel. Il utilise principalement [[LLVM]], mais est également compatible avec [[GNU Compiler Collection|GCC]]. 

Fin 2013, [[ARM (société)|ARM]] annonce à son tour son « [[Mali OpenCL SDK]] », pour ses processeurs graphiques [[ARM Mali|Mali T600 et supérieurs]], dont les premiers modèles sont sortis en 2012. Les sources sont disponibles, mais la licence est propriétaire et contraignante quant à la redistribution&lt;ref&gt;{{lien web|url=http://malideveloper.arm.com/develop-for-mali/sdk/mali-opencl-sdk/|titre=Mali OpenCL SDK|accessdate=2013-12-10}}&lt;/ref&gt;.

== Implémentations Open-source ==
: [[Clover]] [http://people.freedesktop.org/~steckdenis/clover/index.html] et [[libCLC]] [http://libclc.llvm.org/] pour les fonctions de la librairie standard OpenCL
: [[POCL]] (Portable OpenCL) [http://pocl.sourceforge.net/]

== Exemple ==
Cet exemple calcule une [[Transformée de Fourier rapide]]

&lt;source lang=&quot;c&quot;&gt;
/* creation d'un contexte de calcul sur GPU */
context = clCreateContextFromType(NULL, CL_DEVICE_TYPE_GPU, NULL, NULL, NULL);

/* récupération de la liste des cartes disponibles */
clGetContextInfo(context, CL_CONTEXT_DEVICES, 0, NULL, &amp;nb_devices);
clGetContextInfo(context, CL_CONTEXT_DEVICES, nb_devices, devices, NULL);

/* creation d'une queue de commande sur le premier GPU */ 
queue = clCreateCommandQueue(context, devices[0], 0, NULL);

/* allocation des tampons mémoire */
memobjs[0] = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*2*num_entries, srcA, NULL);
memobjs[1] = clCreateBuffer(context, CL_MEM_READ_WRITE, sizeof(float)*2*num_entries, NULL, NULL);

/* création du programme de calcul (le programme qui s'execute sur le GPU) */ 
program = clCreateProgramWithSource(context, 1, &amp;fft1D_1024_kernel_src, NULL, NULL);

/* compilation du programme */
clBuildProgram(program, 0, NULL, NULL, NULL, NULL);

/* création du noyau de calcul */
kernel = clCreateKernel(program, &quot;fft1D_1024&quot;, NULL);

/* mise en place des paramètres */
clSetKernelArg(kernel, 0, sizeof(cl_mem), (void *)&amp;memobjs[0]);
clSetKernelArg(kernel, 1, sizeof(cl_mem), (void *)&amp;memobjs[1]);
clSetKernelArg(kernel, 2, sizeof(float)*(local_work_size[0]+1)*16, NULL);
clSetKernelArg(kernel, 3, sizeof(float)*(local_work_size[0]+1)*16, NULL);

/* création des objets de travail
   et lancement du calcul */
global_work_size[0] = num_entries;
local_work_size[0] = 64;
clEnqueueNDRangeKernel(queue, kernel, 1, NULL, global_work_size, local_work_size, 0, NULL, NULL);
&lt;/source&gt;

Le calcul : (basé sur [http://www.cs.berkeley.edu/~kubitron/courses/cs258-S08/projects/reports/project6_report.pdf Fitting FFT onto the G80 Architecture])&lt;ref name=VolkovKazianFFTG80&gt;
{{lien web 
|langue=en|url=http://www.cs.berkeley.edu/~kubitron/courses/cs258-S08/projects/reports/project6_report.pdf  
|titre=Fitting FFT onto G80 Architecture 
|consulté le=2008-11-14 
|éditeur=Vasily Volkov and Brian Kazian, UC Berkeley CS258 project report
|date=May 2008}}
&lt;/ref&gt;
&lt;source lang=&quot;c&quot;&gt;
// This kernel computes FFT of length 1024. The 1024 length FFT is decomposed into 
// calls to a radix 16 function, another radix 16 function and then a radix 4 function 

__kernel void fft1D_1024 (__global float2 *in, __global float2 *out, 
                          __local float *sMemx, __local float *sMemy) { 
  int tid = get_local_id(0); 
  int blockIdx = get_group_id(0) * 1024 + tid; 
  float2 data[16]; 
  // starting index of data to/from global memory 
  in = in + blockIdx;  out = out + blockIdx; 
  globalLoads(data, in, 64); // coalesced global reads 
  fftRadix16Pass(data);      // in-place radix-16 pass 
  twiddleFactorMul(data, tid, 1024, 0); 
  // local shuffle using local memory 
  localShuffle(data, sMemx, sMemy, tid, (((tid &amp; 15) * 65) + (tid &gt;&gt; 4))); 
  fftRadix16Pass(data);               // in-place radix-16 pass 
  twiddleFactorMul(data, tid, 64, 4); // twiddle factor multiplication 
  localShuffle(data, sMemx, sMemy, tid, (((tid &gt;&gt; 4) * 64) + (tid &amp; 15))); 
  // four radix-4 function calls 
  fftRadix4Pass(data); fftRadix4Pass(data + 4); 
  fftRadix4Pass(data + 8); fftRadix4Pass(data + 12); 
  // coalesced global writes 
  globalStores(data, out, 64); 
}
&lt;/source&gt;

== Références ==
{{Références}}

== Voir aussi ==
* [http://www.khronos.org/opencl/ Site web officiel OpenCL de Khronos ]
* [[GPGPU]]
* [http://gpumodeling.blogspot.com/ GPU Modeling and Development in OpenCL]
* [[OpenHMPP]] [http://www.openhmpp.org New Standard for manycore]

{{Palette|Khronos Group}}
{{portail|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Norme ou standard informatique]]
[[Catégorie:Calcul parallèle]]</text>
      <sha1>cjxx7aisfzxgcspfdtitqbgzmjyyxf5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Cat (langage)</title>
    <ns>0</ns>
    <id>3509235</id>
    <revision>
      <id>93834211</id>
      <parentid>90509666</parentid>
      <timestamp>2013-06-06T21:00:51Z</timestamp>
      <contributor>
        <username>Piku</username>
        <id>14751</id>
      </contributor>
      <comment>{{homon|Cat}}</comment>
      <text xml:space="preserve" bytes="1592">{{homon|Cat}}
{{ébauche|informatique}}
{{Infobox Langage de programmation
|nom = Cat
|logo = Cat-logo-160-b.jpg
|paradigme = multi-paradigme: langage de pile, fonctionnel
|année = 2006
|auteur = Christopher Diggins
|développeurs     = Christopher Diggins et al
|typage = [[Typage statique|statique]]
|influencé par = [[Joy (langage)|Joy]], [[Factor (langage)|Factor]]
|licences      = [[Domaine public (propriété intellectuelle)|Domaine Public]]
|website = [http://www.cat-language.com/]
}}

'''Cat''' est un langage de programmation [[Programmation fonctionnelle|fonctionnel]] orienté [[Pile (informatique)|pile]], à [[typage statique]], inspiré par [[Joy (langage)|Joy]]. Joy et Cat diffèrent cependant des autres langages fonctionnels de par leur approche de composition de fonctions plutôt que d'application de fonctions (comme en [[Scheme]] ou [[Haskell]]).

Cat est un langage polyvalent, plus particulièrement destiné à l'enseignement.

== Exemples ==

Définition de la fonction carré :
&lt;source lang=&quot;text&quot;&gt;
define square { dup * }
&lt;/source&gt;

Définition de la fonction factorielle, avec méta-commentaires (description et test unitaire) et signature de type :
&lt;source lang=&quot;text&quot;&gt;
define fact : (int -&gt; int)
{{
  desc:
    A factorial function
  tests:
    in: 5 fact
    out: 120
}}
{
  eqz
  [pop 1]
  [dup dec fact mul_int]
  if
}

&lt;/source&gt;

== Liens externes ==

* [http://www.cat-language.com/ Site Officiel]
* [http://www.cat-language.com/interpreter.html Interpréteur en ligne]


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>ik9xlkwrpj174ddjml4ghqbxqa8751l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ioke (langage de programmation)</title>
    <ns>0</ns>
    <id>3564402</id>
    <revision>
      <id>96756753</id>
      <parentid>96750405</parentid>
      <timestamp>2013-09-18T07:45:12Z</timestamp>
      <contributor>
        <username>Speculos</username>
        <id>178738</id>
      </contributor>
      <comment>Annulation des modifications 96750405 de [[Spécial:Contributions/90.14.129.220|90.14.129.220]] ([[User talk:90.14.129.220|d]]) justification?</comment>
      <text xml:space="preserve" bytes="784">{{Voir homonymes|Ioke}}
{{ébauche|informatique}}

'''Ioke''' est un [[langage de programmation]] conçu pour la [[Machine virtuelle Java|JVM]] par '''Ola Bini''', l'un des [[Développeur|développeurs]] de [[JRuby]]. C'est un langage de [[programmation orientée prototype]] inspiré par [[Io (langage)|Io]], [[Smalltalk]], [[Lisp]] et [[Ruby]].

Ola Bini utilise [[GNU Emacs]] pour ses développements&lt;ref&gt;{{en}} [http://olabini.com/blog/2008/05/how-large-is-your-emacs/ Ola Bini utilise GNU Emacs].&lt;/ref&gt;.
== Notes et références ==
{{Références}}

== Voir aussi ==
=== Article connexe ===
* [[GNU Emacs ]]

=== Liens externes ===
* [http://ioke.org Site officiel]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de script]]</text>
      <sha1>gnzp4zbuvvko121ph09qdiy6s4zc7vu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PL/I</title>
    <ns>0</ns>
    <id>105170</id>
    <revision>
      <id>97639833</id>
      <parentid>95713227</parentid>
      <timestamp>2013-10-21T08:53:26Z</timestamp>
      <contributor>
        <username>Pautard</username>
        <id>58456</id>
      </contributor>
      <minor/>
      <comment>sont assurées</comment>
      <text xml:space="preserve" bytes="9137">{{ébauche|informatique}}
{{À recycler}}

Le '''PL/I''' ou '''PL/1''' ('''Programming Language number 1''') est un langage de programmation développé par [[International Business Machines Corporation|IBM]] dans les débuts des [[années 1970]]. 

Son objectif était d'être universel et de pouvoir remplacer indifféremment les langages à destination scientifique, tels que [[FORTRAN]] et [[ALGOL]], et le langage [[COBOL]], plus adapté aux problèmes de comptabilité et de gestion. Il permettait même l'accès à des fonctions autrefois réservées à la programmation système, comme la gestion de zones dynamiques de mémoire allouées à la demande (et non simplement à l'entrée dans un bloc), de [[pointeur (programmation)|pointeur]]s, et le travail par programme directement dans les [[tampon]]s d'entrée-sortie. Ses capacités de points d'entrée génériques dans les procédures offraient une possibilité qui se retrouvera avec [[C++]].

Ce langage est défini par les normes [[ECMA]]-50 (1976), [[ANSI]] X3.53-1976, [[AFNOR]] NF Z 65-500 et [[ISO]] 6160:1979. Il fut utilisé comme langage de programmation système dans le projet [[Multics]]. 

Son objectif était de devenir le langage privilégié de programmation des ordinateurs universels [[IBM 360 et 370]]. Les noms de PL/1 à PL/100 furent déposés par IBM par précaution, mais cela empêcha ce langage d'être proposé sous ce nom par d'autres constructeurs, nuisant ainsi à son succès.

Sa syntaxe ajoutait aux idées de FORTRAN certaines idées de COBOL (structures, calcul en mode décimal), et d'ALGOL (structure de blocs imbriqués). Toutefois, les programmeurs de ces deux langages ne communiquaient guère entre eux à l'époque, et chacun jugeait inutile et encombrant ce qui avait été inclus pour l'autre — et vice versa. Son compilateur nécessitait également des machines importantes, et ne comportait au départ ni optimiseur, ni compilateur incrémental (le ''PL/I Optimizing compiler'' et le ''PL/I Checkout compiler'' ne viendront que plus tard).

Ce langage avait beaucoup des caractéristiques de ce qui sera plus tard le [[C (langage)|C]], et même déjà certaines du [[C plus plus|C++]]. [[International Business Machines Corporation|IBM]] déposa les noms PL/1 à PL/100 pour éviter de perdre le contrôle des spécifications du langage. Un effet non prévu de cette décision fut de dissuader la concurrence de nommer « PL/I » ses propres implémentations, qui prirent des noms voisins : « SL/1 », « CPL/1 », « [[PL/M]] », « PL/C »... Devant la multitude de ces appellations, la crainte d'une [[balkanisation]] du langage (et des frais de migration associés en cas de changement de constructeur) dissuada les équipes informatiques d'y migrer. Le lancement du langage, malgré ses qualités (gestion simple du ''[[multitâche|multitasking]]'', [[récursivité]], structures de blocs, facilités de ''[[débogage|debugging]]'' et de [[Profilage_de_code|profilage]], allocation dynamique dans des pools de mémoire eux-mêmes dynamiques (AREA), procédures génériques analogues aux ''templates'' de [[C plus plus|C++]]) ne rencontra donc pas le vif succès attendu. Ses puissantes possibilité de débogage, [[Système de gestion d'exceptions#Historique|en particulier ''(CHECK):'' et ''ON CHECK(...) ...]] furent néanmoins remarquées.

== Caractéristiques ==
* Un objectif du langage est que chacun puisse l'utiliser sans avoir à en connaître la totalité. Il n'y a en conséquence pas de mots réservés dans PL/I.
* Un programmeur doit pouvoir utiliser un nom défini de façon externe — par exemple ''TIME'' — sans avoir à se demander si c'est une variable ou une fonction sans argument.
* Les instructions d’[[entrée/sortie]] font partie du langage et ne sont pas des fonctions de [[Bibliothèque (informatique)|bibliothèques]] externes.

== Défauts ==

La recherche d'universalité du langage, en lui donnant une apparence complexe, a joué contre lui. Les programmeurs Fortran n'avaient guère l'usage des &quot;structures&quot; ni du format décimal inspirés du COBOL et ceux de Cobol ne voyaient pas l'intérêt de calculer en nombres complexes.

Les instructions FORMAT et le GOTO calculé du Fortran combinées aux curiosités du Cobol avec ses [[COBOL#Traits_principaux|PICTURE]] et son tri de fichier intégré ont fait du PL/I un langage certes complet mais plus complexe à apprendre&lt;ref&gt;Une description complète du PL/1 fut cependant publiée chez Masson par Marc Thorin, assistant à l'École Centrale de Paris. Le nom initialement proposé par l'auteur, &quot;Traité de PL/I&quot;, fut refusé parce que l'ouvrage était ''court''.&lt;/ref&gt;

== Héritiers ==

* Les langages de programmation systèmes XPL, PL-16 (pour le Télémécanique [[T1600]] et le [[Solar (ordinateur)|Solar-16]])  et [[PL/M]] sont dérivés de PL/I.
* Les langages d'enseignement CUPL et PL/C développés à Cornell sont basés sur PL/I. 
* Le langage procédural [[Rexx|REXX]].



== Et maintenant ? ==

{{refsou|En 2010, très peu de sites font encore des développements en PL/I}}. 
Il est {{refsou|souvent utilisé}} comme langage [[Outils_RAD|RAD]], {{non neutre|grâce à sa facilité d'utilisation}}.  
Cela permet de se faire des outils très rapides, et aussi simplement qu'en [[REXX]]. 
Mais pour utiliser ce type de langage, il est nécessaire que les développeurs aient une bonne discipline en programmation, alors que pour le [[Cobol]], par exemple, le compilateur « tente » d'éviter ces problématiques qui nécessitent autant de discipline (déclaratives, ''closures'', ..).

== Conclusion ==
PL/I permettait de confiner à des zones prédéfinies et allouées à la demande (''AREA'') la manipulation des pointeurs et des adresses, faisant ainsi bénéficier le programmeur de la [[protection mémoire]] matérielle du système. Il disposait de puissantes possibilités intégrées de [[débogage]]. Ces possibilités natives du langage sont assurées dans d'autres aujourd'hui par des bibliothèques ([[Electric Fence]]...), ou des [[framework]]s ([[Valgrind]]...). Ses autres innovations se retrouvent aujourd'hui, parfois dans le corps des langages et compilateurs (appels génériques de procédure, conversions automatiques de type, profilage, structures chaînées), plus souvent dans des bibliothèques optionnelles.

== Références == 
* Gérard Verroust [http://bat8.inria.fr/~weis/info/histoire_de_l_info.html Histoire de l'informatique] (Cours Université [[Paris 8]], 1994-1997) 
* [http://www.users.bigpond.com/robin_v/pli.htm PL/I] 
* [http://www.cs.toronto.edu/XPL/ XPL] un langage dérivé de PL/I  

 
== Bibliographie ==
* Charles Berthet, ''[http://catalogue.bnf.fr/ark:/12148/cb35379278p/PUBLIC Le Langage de programmation PL/1]'' Paris : Dunod, 1972. 
* Dominique Jacquelin, ''[http://catalogue.bnf.fr/ark:/12148/cb35187189f/PUBLIC Le PL-1: langage de programmation]'' Paris : Dunod, 1973.   
* Françoise Veillon, ''[http://catalogue.bnf.fr/ark:/12148/cb343305086/PUBLIC Cours de programmation en langage PL / 1]''  Paris : A. Colin, 1971.
* Philippe Dupont, ''Les langages de programmation en parallèle : FORTRAN, COBOL, PL/1, APL'' Paris : Masson, 1974. 
*  norme  ''[http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=12406 ISO 6160]'' 1979 
*  [http://www.ecma-international.org/publications/files/ECMA-ST-WITHDRAWN/ECMA-50,%201st%20Edition%20December%201976.pdf Standard ECMA-50 pour le langage PL/I] 1976. 
* P. A. Shovlar, [http://cdsweb.cern.ch/record/125817?ln=fr A concise guide to PL/1] Harwell (Royaume-Uni) 1980.
* R. W. Conway, [http://hdl.handle.net/1813/6411 The Case for PL/I as the Language for Instruction in Programming] Ithaca (États-Unis d'Amérique) 1983. 
* R. W. Conway et W. L. Maxwell, [http://hdl.handle.net/1813/5881 CUPL - An Approach to Introductory Computing Instruction] Ithaca (États-Unis d'Amérique)  1968
* R. W. Conway et R. L. Constable, [http://hdl.handle.net/1813/7436 PL/CS - A Disciplined Subset of PL/I] Ithaca (États-Unis d'Amérique)  1976.  
* [http://www.slac.stanford.edu/grp/cd/soft/rmx/manuals/PLM_386.PDF Manuel de PL/M] un langage de programmation système dérivé de PL/I via XPL 
== Liens externes ==
* [http://pl1gcc.sourceforge.net/ PL/1 for GCC] (Projet, abandonné depuis 2007, visant à ajouter un frontal pour PL/1 au compilateur [[GNU Compiler Collection|GCC]] du projet [[GNU]]) 
* M. Mazaud, [http://www.inria.fr/rrrt/rt-0065.html Un traducteur de PL/1 vers C] ([[INRIA]] Rocquencourt, Rapport technique n° 65, février 1986)
* [http://pl1.raincode.com/ Compilateur RainCode PL/1] (Compilateur pour la plateforme [[Microsoft .NET]])
* [http://www-306.ibm.com/software/awdtools/pli/ Compilateurs PL/I IBM] 
* [http://www.bitsavers.org/pdf/digitalResearch/pl1/ Manuels pour le compilateur PL/I sous CP/M] 
* [http://www.bitsavers.org/pdf/ibm/360/pli/ Documentation PL/I pour l'IBM 360] 

== Notes et références ==
{{Références}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation|Pl/i]]
[[Catégorie:Norme ISO|Pl/i]]
[[Catégorie:Grand Système IBM]]</text>
      <sha1>qeesg7vfd1ipu7t4viwrgf2y93ycqy0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>LACATRE</title>
    <ns>0</ns>
    <id>3636010</id>
    <revision>
      <id>62406644</id>
      <parentid>57625371</parentid>
      <timestamp>2011-02-18T10:25:22Z</timestamp>
      <contributor>
        <username>Léna</username>
        <id>29802</id>
      </contributor>
      <minor/>
      <comment>/* Voir aussi */portail informatique -&gt; portail programmation informatique, replaced: {{portail informatique}} → {{portail|programmation informatique}} using [[Project:AWB|AWB]]</comment>
      <text xml:space="preserve" bytes="1149">'''LACATRE''' est l'abréviation de '''L'''angage d''''A'''ide à la '''C'''onception d''''A'''pplications '''T'''emps-'''RE'''el. C'est un langage graphique utilisé pour la conception de programmes informatiques [[multitâches]] et [[Système temps réel|temps-réels]]. Ce langage est très utile pour représenter les interactions d'une tâche avec les différents moyens de communication ([[Communication inter-processus|IPC]]) de façon simple permettant une première ébauche en conception tout en se rapprochant énormément du code final. Il existe d'ailleurs des applications permettant de traduire le formalisme LACATRE en code [[C (langage)|C]] (notamment pour [[VxWorks]])&lt;ref&gt;Voir le [http://la4.berlios.de/ LA4 Project]&lt;/ref&gt;.

== Notes et références ==
{{Références|colonnes=1}}

== Liens externes ==
=== Cours ===
* {{fr}} [http://www.lisyc.univ-brest.fr/pages_perso/babau/cours/multitache.pdf Cours d'introduction à LACATRE - Jean-Philippe Babeau - INSA de Lyon]

== Voir aussi ==
* [[Synchronisation (multitâches)]]
* [[Système temps réel]]

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>4gmtifm9hbtto4yzg5lm0chfuqbj5p9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Charity (langage)</title>
    <ns>0</ns>
    <id>3688585</id>
    <revision>
      <id>95374256</id>
      <parentid>90547704</parentid>
      <timestamp>2013-07-29T09:01:09Z</timestamp>
      <contributor>
        <username>Romainhk</username>
        <id>5242</id>
      </contributor>
      <comment>modèle abandonné</comment>
      <text xml:space="preserve" bytes="1656">{{Ébauche|informatique}}

'''Charity''' est un [[langage de programmation]] expérimental [[purement fonctionnel]], développé à l'[[Université de Calgary]]. Il ressort des idées de Hagino Tatsuya, et il est complètement fondé sur la [[théorie des catégories]]. 

Nonobstant les interactions [[entrées-sorties]], tous les programmes programmés en Charity sont garantis de terminer. Cela signifie que ce langage n'est pas [[Turing-complet]]. Cependant, il est capable d'exprimer la [[fonction d'Ackermann]] et la rend plus expressive qu'une [[fonction récursive primitive|récursion primitive]]. 

Le langage autorise les [[type récursif|types récursifs]] ordinaires, tels qu'ils se trouvent en [[ML (langage)|ML]], et qui doivent être finis, et également les types de données corécursifs, qui sont autorisés d'être potentiellement infinis. La structure de contrôle pour les opérations sur les types récursifs est une récursion primitive ou [[catamorphisme]], et celle pour les types de données corécursifs est une co-récursion primitive ou [[anamorphisme]]. Les structures de contrôle ne peuvent pas sinon opérer sur d'autres types de données. Tous les catamorphismes terminent et tous les anamorphismes sont productifs. 

== Notes et références ==
{{Traduction/Référence|en|Charity (programming language)|271384332}}
{{Références}}

== Annexes ==
=== Articles connexes ===
* [[Langage de programmation]]

=== Liens externes ===
* [http://pll.cpsc.ucalgary.ca/charity1/www/home.html Page officielle, avec documentation et téléchargement]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>0nes95v44yw4hdhiay7gsqvnzb3r9s6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NULL</title>
    <ns>0</ns>
    <id>743736</id>
    <revision>
      <id>101235052</id>
      <parentid>99902480</parentid>
      <timestamp>2014-02-13T23:25:41Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>syntaxe + typographie + wikif. (REM. : d. c. mais p.-ê. pas art.)</comment>
      <text xml:space="preserve" bytes="7832">{{Langue du titre|en}}
{{Autre|le musicien japonais|Kazuyuki K. Null}}
'''''{{Lang|en|NULL}}''''' est une valeur, une constante ou un mot clef présent dans de nombreux [[Langage de programmation|langages informatiques]], et qui désigne l'état d'un [[Pointeur (programmation)|pointeur]] qui n'a pas de cible ou d'une [[variable (informatique)|variable]] qui n'a pas de valeur. La notion de valeur ou de pointeur NULL est en particulier présente dans les langages [[C (langage)|C]] et [[C++]] (ainsi que dans plusieurs langages dont la syntaxe est proche comme le [[Java (langage)|Java]], le [[JavaScript]] ou le [[PHP]]).

En termes de bases de données, ce mot clef exprime le fait que la valeur d'une donnée n'est pas connue. Il ne s'agit donc pas d'une valeur mais de l'état dans lequel la donnée se trouve, et signifie l'absence de valeur.

== Variantes ==
Il existe des équivalents nommés différemment :
* Selon les langages, ''NULL'' s'écrit : &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;Null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; ;
* Dans certains langages ([[Pascal (langage)|Pascal]], [[Lisp]], [[Common Lisp Object System|Clos]], [[Smalltalk]], [[Ruby]]…), il est nommé &lt;code&gt;nil&lt;/code&gt; ;
* En [[Python (langage)|Python]], l'équivalent de &lt;code&gt;NULL&lt;/code&gt; est &lt;code&gt;None&lt;/code&gt; ;
* En C++11, la constante &lt;code&gt;0&lt;/code&gt; ou la macro-constante &lt;code&gt;NULL&lt;/code&gt; sont dépréciées en faveur du mot-clef &lt;code&gt;nullptr&lt;/code&gt;.

== C et C++ ==
En C, &lt;code&gt;NULL&lt;/code&gt; est défini dans le fichier d'en-tête &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; de la [[bibliothèque standard du C]], a pour valeur zéro et pour type void*&lt;ref&gt;{{en}}[http://c-faq.com/null/macro.html What is NULL and how is it defined?]&lt;/ref&gt;.

En C++, &lt;code&gt;NULL&lt;/code&gt; est remplacé par la constante &lt;code&gt;0&lt;/code&gt;, mais il est toujours possible d'utiliser une macro constante &lt;code&gt;NULL&lt;/code&gt; qui — à la différence de celle utilisée en C — ne doit pas être de type void* (les pointeurs vers des types différents étant incompatibles).

En [[C++11]], le mot clef &lt;code&gt;nullptr&lt;/code&gt; est introduit pour remplacer la constante &lt;code&gt;0&lt;/code&gt; et la macro-constante &lt;code&gt;NULL&lt;/code&gt;.

Voici un exemple de code montrant l'initialisation d'un pointeur à &lt;code&gt;NULL&lt;/code&gt;, avant d'être utilisé pour stocker l'adresse d'une variable :
&lt;source lang=&quot;C&quot;&gt;
int a = 2; // Déclaration de la variable a de type int (entier) et initialisée avec 2
int *p = NULL; // Déclaration d'un pointeur sur un int qui vaut NULL
p = &amp;a; // L'adresse de a est affectée au pointeur p
*p = 5; // p est déréférencé pour affecter 5 à la variable a
&lt;/source&gt;

La valeur réellement utilisée comme pointeur nul par le processeur peut, sur certains systèmes, être différente de l’adresse spéciale 0 ; cela relève de la mécanique interne aux compilateurs&lt;ref&gt;{{en}}[http://c-faq.com/null/machexamp.html Have any actual machines really used nonzero null pointers, or different representations for pointers to different types?]&lt;/ref&gt;. Cependant au niveau du C, &lt;code&gt;NULL&lt;/code&gt; représente toujours un zéro, et doit être utilisé uniquement dans le but de désigner un pointeur qui ne pointe sur rien ; en ce sens, parfois (et toujours en C++, où pointeurs et données sont clairement distincts), sa définition est agrémentée d'un type, &lt;code&gt;((void*)0)&lt;/code&gt; ou &lt;code&gt;((char*)0)&lt;/code&gt;.

=== Différence avec NUL ===
Bien que cela ne pose généralement pas de problème de compilation en C (car une conversion implicite a lieu), le pointeur NULL ne doit pas être confondu avec le [[caractère (informatique)|caractère]] [[ASCII]] &lt;code&gt;[[NUL]]&lt;/code&gt; (un seul L) qui est utilisé pour marquer la fin d'une [[chaîne de caractères]] et correspond sur la majorité des systèmes à un [[octet]] (8 bits) plutôt qu'à un mot (ex. 32 bits) &lt;ref&gt;{{en}}[http://c-faq.com/null/nullor0.html If NULL and 0 are equivalent as null pointer constants, which should I use?]&lt;/ref&gt;:

&lt;source lang=&quot;C&quot;&gt;
// Les deux chaînes suivantes sont équivalentes:
const char str1[] = &quot;Hello&quot;;
const char str2[] = {'H','e','l','l','o',NUL};

const char vide[] = {NUL}; // équivaut à &quot;&quot;.
const char *p = NULL; // p ne pointe sur rien.
p = vide; // p pointe vers le premier élément de la chaîne vide.
                            // Chaîne de caractères de longueur nulle : p[0] vaut NUL.
&lt;/source&gt;

== Java ==
Le [[Java (langage)|langage Java]] ne permet pas l'emploi de pointeur mais de références.
Le mot clé null définit une référence nulle, c'est-à-dire ne désignant aucun objet en mémoire.
Il s'agit de la valeur par défaut des variables non initialisées de type référence d'objet.

Voici un exemple de code montrant l'initialisation d'une référence à null, avant d'être utilisée pour référencer un objet alloué :
&lt;source lang=&quot;Java&quot;&gt;
Object source = null; // Déclaration d'une référence d'objet initialisée à null
source = new Object(); // Maintenant référencer un objet alloué dynamiquement en mémoire
&lt;/source&gt;

== PHP ==

En php, une variable de valeur NULL est considérée comme non-définie :
&lt;source lang=&quot;php&quot;&gt;
&lt;?php
$a=NULL;

if(isset($a)) {
    echo '$a est définie';
} else {
    echo '$a est indéfinie';
}

if(is_null($a)) {
    echo '$a est NULL';
} else {
    echo '$a n\'est pas NULL';
}

if(isset($b)) {
    echo '$b est défini';
} else {
    echo '$b est indéfini';
}

if(is_null($b)) {
    echo '$b est NULL';
} else {
    echo '$b n\'est pas NULL';
}
&lt;/source&gt;

Affiche :
$a est indéfinie.
$a est NULL
$b est indéfini
$b est NULL

== NULL, Typage et Méta-modélisation ==
Soient deux types A et B distincts (et sans rapport)
 A a = null;
 B b = null;
La modélisation correcte d'un système de types rendant ces deux affections valables implique que null possède un type sous-type union de A et B : ''None''.
''None'' est un type singleton ayant comme seule valeur possible ''null'' défini comme l'union de tous les types du programme. Comme ce type n'est pas modélisable sans une forme spéciale du langage et que son utilité est limitée (il n'accepte qu'une seule valeur, ''null'' ), peu de langages à typage statique le proposent.

Si on s'intéresse aux langages à objets, et qu'on pose comme première approximation du système de type :
 type = classe
Alors la classe de null (étrangement tous ces langages utilisent plutôt la forme ''nil'') devient la classe singleton ''None'', sous-classe de toutes les classes ayant pour seule instance ''null''. Pour garantir un fonctionnement cohérent avec le comportement des envois de messages sur null, toutes ces méthodes doivent être redéfinies par l'envoi d'une exception ''NullPointerException''.

Bien qu'en théorie la valeur ''null'' puisse être quelconque, en pratique tous les langages utilisent la valeur 0. Cette valeur est non adressable et toute tentative d'accès provoque une [[erreur de segmentation]]. Si l'on veut proprement lever une exception, on doit protéger tous les envois de messages par un test à ''null''. Un bon compilateur ne génèrera pas ces tests dans les cas où le receveur est trivialement non ''null'' (cas des ''self'', ''this'', ''super'' et autres) et dans certains autres cas.

== UNIX ==
{{article détaillé|/dev/null}}

Dans les systèmes [[UNIX]], [[/dev/null]] est un fichier spécial qui détruit immédiatement toutes les données qui lui sont envoyées. Pour cette raison, ce fichier est appelé le « trou noir » ou encore la « poubelle ».

Les systèmes d'exploitation [[Microsoft]] utilisent un fichier spécial appelé [[NUL]].

== Références ==
{{Références}}

{{Autres projets|wiktionary = null}}

{{Portail|programmation informatique|informatique}}

[[Catégorie:Langage C]]
[[Catégorie:Langage de programmation]]
[[Catégorie:C++]]
[[Catégorie:Unix]]
[[Catégorie:PHP]]
[[Catégorie:Java]]

{{Lien BA|en}}</text>
      <sha1>ctd7lq3krj9dtghc0vhxpru48s74209</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Euphoria (langage)</title>
    <ns>0</ns>
    <id>3874756</id>
    <revision>
      <id>90576940</id>
      <parentid>74430043</parentid>
      <timestamp>2013-03-17T05:25:32Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 9 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1374139]]</comment>
      <text xml:space="preserve" bytes="1034">{{voir homonymie|Euphoria}}
{{ébauche|informatique}}
{{Infobox Langage de programmation
|  nom                    = Euphoria
|  logo                   = 
|  paradigmes             = 
|  année                  = [[1993]]
|  auteur                 = [[Robert Craig]]
|  développeurs           =
|  dernière version stable= 3.1.1
|  date de dernière version stable = {{Date|2|août|2007|en informatique}}
|  typage                 = 
|  implémentations        = 
|  dialectes              = 
|  influencé par          = [[BASIC]], [[C (langage)|C]], [[C++]]
|  a influencé            = [[Py (cryptographie)|Py]]
|  système d'exploitation = [[Multi-plate-forme]]
|  licences               = 
|  site web               = [http://www.rapideuphoria.com http://www.rapideuphoria.com]
}}
Euphoria est un [[langage de programmation]] interprété créé par [[Robert Craig]] de [[Rapid Deployment Software]].

==Hello World==
  puts(1,&quot;Hello World!\n&quot;)

{{Portail|Informatique}}
[[Catégorie:Langage de programmation]]

{{Lien AdQ|pt}}</text>
      <sha1>ckrxfbcupho6m9qi29b1imnl10a27qg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Microsoft Small Basic</title>
    <ns>0</ns>
    <id>3883723</id>
    <revision>
      <id>99455013</id>
      <parentid>91321059</parentid>
      <timestamp>2013-12-22T00:16:34Z</timestamp>
      <contributor>
        <username>Vlaam</username>
        <id>268672</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.30 - [[P:HOM|Homonymies]] : Correction de 1 lien - [[Mash-up]], reste 1 à corriger - [[Public cible]]</comment>
      <text xml:space="preserve" bytes="3880">{{ébauche|informatique}}

{{Infobox Langage de programmation
| nom                    = Microsoft Small Basic
| logo                   =
| paradigme              = 
| auteur                 = Microsoft DevLabs
| année                  = 2008
| dialectes              = Microsoft Small Basic 0.4&lt;br /&gt;(Avril 2009)
| influencé par          = [[Visual Basic .NET]], [[BASIC]]
}}

'''Microsoft Small Basic''' est un [[langage de programmation]] utilisant la technologie [[framework .NET|.NET]] dérivé de [[BASIC]] qui a été créé par [[Microsoft]] en novembre 2008. La volonté des développeurs est que Small Basic soit un langage simple mais performant pour ceux qui n'ont pas encore fait de programmation et qui souhaitent se lancer dans la conception de programmes. 

Microsoft Small Basic (à ne pas confondre avec [[SmallBASIC]], un autre langage basé sur BASIC) a été imaginé et publié en première version par l'équipe Microsoft DevLabs en novembre 2008. Son [[public cible]] est l'ensemble des débutants en programmation (que ce soit des enfants ou des adultes) ou des développeurs confirmés qui souhaitent créer de petits programmes « pour le fun » de manière plus rapide qu'avec des langages conventionnels. Lorsqu'il a été publié, Small Basic ne comportait que 15 mots-clés, ce qui est très peu pour un langage basé sur Basic, et ce dans une volonté de rendre le langage simple à apprendre et à utiliser.

== Langage ==

Le langage en tant que tel, même s'il ressemble au très connu [[Visual Basic.NET]], a son propre compilateur (inclus dans la suite Microsoft Small Basic) et fonctionne de manière très différente. 

=== Le traditionnel 'Hello World' ===
&lt;source lang=&quot;vbnet&quot;&gt;
GraphicsWindow.Show() 'Ouvre la fenêtre graphique
GraphicsWindow.BackgroundColor = &quot;Azure&quot; 'colorie en azure l'arrière plan de la fenêtre graphique
Helloworld = Shapes.AddText(&quot;Hello world&quot;) 'écris le texte &quot;Hello World&quot; sur la fenêtre graphique
Shapes.Move(Helloworld, GraphicsWindow.Width / 2 - 30, GraphicsWindow.Height /2 - 10) 'Place le texte au milieu de la fenêtre
Program.Delay(2000) 'attends 2 secondes
'Zoom le texte
For i = 1 To 9 Step 0.1
  Shapes.Zoom(Helloworld, i, i)
  Program.Delay(50)
EndFor
GraphicsWindow.MouseUp = Mouse_click
Sub Mouse_click
  Program.End() 'Ferme le programme
EndSub
&lt;/source&gt;

=== Changer le fond d'écran ===
Small Basic dispose de fonctionnalités permettant de faire interagir par du [[Application composite|mash-up]] différents services (dictionnaires en ligne, Flickr, ...) et certaines fonctions de Windows, tel le fond d'écran du bureau.

&lt;source lang=&quot;vbnet&quot;&gt;For i = 1 To 10 ' Répéter l'action 10 fois
  pic = Flickr.GetRandomPicture(&quot;mountains&quot;) ' Télécharger une image dont le sujet est les montagnes
  Desktop.SetWallPaper(pic)  ' Appliquer cette image comme fond d'écran
  Program.Delay(10000)  ' Attendre 10 secondes (10 * 1000 ms) avant de continuer
EndFor 
 &lt;/source&gt;

== Essais 'in vivo' ==
Small Basic a déjà été testé par l'équipe de DevLabs avec succès avec plusieurs groupes d'étudiants secondaires et les enfants de certains employés de Microsoft, et les échos ont semblé très positifs.

== Liens externes ==
* {{en}} [http://msdn.microsoft.com/en-us/devlabs/cc950524.aspx Site Officiel de Small Basic]
* {{en}} [http://channel9.msdn.com/posts/Charles/Expert-to-Expert-The-Basics-of-SmallBasic/ The Basics of Small Basic] : discussion entre Vijaye Raji et Erik Meijer sur SmallBasic
* {{en}} [http://smallbasic.com/ Nouveau site officiel de Small Basic]
* {{fr}} [http://www.nerdgen.net/2010/03/18/microsoft-small-basic.html Présentation et critiques de Small Basic]

== Références ==
&lt;references /&gt;

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Environnement de développement intégré]]
[[Catégorie:.NET Framework]]</text>
      <sha1>1ruiyf4a4xbkohqlmnvct4ldou5jdn2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Joy (langage)</title>
    <ns>0</ns>
    <id>3916821</id>
    <revision>
      <id>93834277</id>
      <parentid>90582053</parentid>
      <timestamp>2013-06-06T21:03:45Z</timestamp>
      <contributor>
        <username>Piku</username>
        <id>14751</id>
      </contributor>
      <comment>voir homonymes</comment>
      <text xml:space="preserve" bytes="1514">{{homon|Joy}}
{{ébauche|informatique}}

{{Infobox Langage de programmation
|nom = Joy
|logo =
|paradigme = [[Programmation fonctionnelle]], [[Programmation orienté pile]]
|year = 2001
|auteur = [[Manfred von Thun]]
|développeurs = Manfred von Thun, John Cowan
|dernière version = [[March 17]], [[2003]]
|date de dernière version = [[March 17]], [[2003]]
|typage = [[Typage fort|fort]], [[Typage dynamique|dynamique]]
|implémentations = Joy0, Joy1, &quot;Current Joy&quot;, &quot;John Cowan's Joy&quot;, &quot;JoyJ (Joy in jvmm)&quot;
|dialects = 
|influencé par = [[Forth (langage)|Forth]], [[Scheme]], [[C (langage)|C]]
|a influencé = [[Factor (langage)|Factor]], [[Cat (langage)|Cat]], [[V (langage)|V]]
|licence = 
|website = 
}}

Joy est un [[langage de programmation]] purement [[Programmation fonctionnelle|fonctionnel]] et [[Programmation orienté pile|orienté pile]] conçu par [[Manfred von Thun]] de l'[[Université de La Trobe]] à [[Melbourne]]. Il possède de nombreux points communs avec son ancêtre [[Forth (langage)|Forth]]. Dans cette catégorie de langages, il se démarque par sa pureté mathématique.

== Exemple du [[tri rapide]] ==

&lt;pre&gt;
&lt;nowiki&gt;
 DEFINE qsort ==
   [small]
   []
   [uncons [&gt;] split]
   [[swap] dip cons concat]
   binrec.
&lt;/nowiki&gt;
&lt;/pre&gt;


== Voir aussi ==

* [[Forth (langage)|Forth]]
* [[Factor (langage)|Factor]]
* [[Cat (langage)|Cat]]
* [[Programmation fonctionnelle]]
* [[Programmation orienté pile]]


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>53qiry0rl1gzlt1ixxy5iw9toroq0cf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Visual T Sharp</title>
    <ns>0</ns>
    <id>3907007</id>
    <revision>
      <id>99707422</id>
      <parentid>91922662</parentid>
      <timestamp>2013-12-30T09:55:12Z</timestamp>
      <contributor>
        <username>Pautard</username>
        <id>58456</id>
      </contributor>
      <minor/>
      <comment>les conversions</comment>
      <text xml:space="preserve" bytes="31375">{{Titre incorrect|Visual T#}}
{{guide pratique}}
{{à sourcer|date=septembre 2012}}
{{Voir homonymes|TSharp|.ts}}
{{Infobox Langage de programmation
| nom                    = Visual T#
| paradigme              = Compatible [[C sharp|C#]] donc [[Programmation structurée|structuré]], [[Programmation impérative|imperatif]], [[Programmation orientée objet|orienté objet]]
| année                  = [[2009 en informatique|2009]]
| auteur                 = [http://www.prettyobjects.com Pretty Objects Computers inc.]
| typage                 = [[Typage statique|statique]], [[Typage fort|fort]], [[Système nominatif de types|nominatif]]
}}

'''Visual T#''' (prononcé [{{API|tiː.ʃɑːp}}]) est un environnement de développement '''gratuit''' de tests unitaires intégré à Visual Studio™, mais peut s'utiliser indépendamment. Il comprend :

* T# : un langage de programmation dédié aux tests unitaires. T# est basé sur le langage [[C Sharp|C#]] v2, ce qui le rend très naturel à utiliser par les développeurs .NET. De nouveaux mot-clés y ont été introduits pour simplifier l'écriture de tests. Il met beaucoup d'emphase sur la définition de l'intention des tests ;
* Des outils pour compiler les tests, les exécuter, les tester et pour facilement naviguer parmi les tests, même pour un grand nombre de tests.

== Avantages ==

T# est un langage de programmation pour [[Microsoft .NET]], compatible avec C# v2 (sauf en ce qui concerne le code non &quot;managed&quot;), et offre les avantages suivants par rapport aux solutions NUnit ou Visual Studio Team Test :
* Utilisation des bonnes pratiques : identifie bien les 3 parties (préparation, exécution, vérification).
* Identification rapide des problèmes : les tests mal construits sont séparés des tests qui ont échoué.
* Facilité d'écriture des validations : un seul mot clé &lt;code&gt;assert&lt;/code&gt; pour traiter tous les cas.
* Efficacité dans le débogage : les tests concernant la déclaration que vous travaillez sont exécutés sans savoir où vous les avez déclarés
* Utilisation de différents contextes : ré-exécutez mêmes les tests pour différents contextes sans les réécrire.
* Indication des tests logiques manquants : les tests logiques manquants sont indiqués dès la compilation du code de test.
* Simplicité d'écriture : chaque vérification s'effectue en 1 ligne de code (même pour les événements, les exceptions...), utilisez des vérifications relatives.

== Le langage ==
Voici un exemple d'un test minimal, écrit en T# :

&lt;source lang=&quot;csharp&quot;&gt;
testclass
{
  test
  {
    Calculatrice calc = new Calculatrice();

    runtest double somme = calc.Ajouter(1, 2);

    assert somme == 3;
  }
}
&lt;/source&gt;

== Bonnes pratiques pour les tests unitaires ==
T# est complètement orienté bonnes pratiques.

=== Structure d'un test ===
Un test unitaire est toujours composé de trois parties :
* '''Préparation''' : création des instances nécessaires à l'exécution du test
* '''Exécution''' : une seule instruction pour utiliser la déclaration à tester dans un contexte donné
* '''Vérification''' : vérification que les résultats attendus (directement ou indirectement) sont bien là.
La partie la plus importante étant '''Exécution''', c'est pour elle que vous écrivez le test.

T# identifie clairement la partie '''Exécution''' en faisant commencer l'instruction par le mot clé '''&lt;code&gt;runtest&lt;/code&gt;'''.
La préparation est donc naturellement tout ce qui se trouve avant runtest, et la vérification après runtest.

=== Vérifications ===
La partie vérification s'assure que tous les effets (par exemple : retour de fonction, changements des paramètres, modification d'instance, de déclarations statiques, de fichiers, bases de données...) escompté lors de l'utilisation de la déclaration se sont bien effectués comme prévu.

T# n'offre qu'un seul mot-clé pour cela : '''&lt;code&gt;assert&lt;/code&gt;'''.
Le message est automatiquement généré à partir du code source.
Ainsi, si le test précédent échoue (si la fonction &lt;code&gt;Ajouter&lt;/code&gt; est mal codée en retournant toujours &lt;code&gt;0&lt;/code&gt;), le test échouera avec le message d'erreur suivant : &quot;Expected: somme == 3 but was: 0 == 3&quot;.
Il est ainsi très rapide de déterminer que la somme vaut 0, mais que l'on s'attendait à 3. Cette façon de générer le message d'erreur le rend plus proche du code source (donc plus facile de faire le lien avec le code quand l'erreur apparait) et décompose les différentes valeurs impliquées (si plusieurs variables étaient impliquées, on saurait alors la valeur de chacune des variables et non pas de l'expression finale), rendant le déboguage beaucoup plus facile.

De plus, les conversions naturelles du langage de programmation sont utilisées (somme est un &lt;code&gt;double&lt;/code&gt;, 3 est un entier). Ainsi, pas de problème pour comparer les deux contrairement à Visual Studio Team Test pour lequel vous devez écrire : &lt;code&gt;Assert.AreEqual(3.0, somme);&lt;/code&gt; pour faire la même vérification!

== 4 états pour un test ==
Le test étant du code, il peut lui aussi échouer.
Contrairement aux concurrents, T# sait exactement l'instruction qui teste réellement (&lt;code&gt;runtest&lt;/code&gt;). Ainsi, il est en mesure de déterminer si l'échec du test s'effectue avant ou après cette instruction :
* Si le test échoue avant l'instruction &lt;code&gt;runtest&lt;/code&gt;, c'est que l'on n'arrive pas à se placer dans le contexte voulu pour tester notre intention. Le test n'est pas bon.
* Si le test échoue après l'instruction &lt;code&gt;runtest&lt;/code&gt;, c'est que le code testé ne fait probablement pas la bonne chose. Le code testé n'est pas bon.

T# a donc 4 états pour un test :
* '''Passed''' : le test a réussi.
* '''Ignored''' : le test est temporairement ignoré.
* '''Failed''' : le test a échoué, le code testé n'est pas bon.
* '''Invalid''' : le test a échoué, le contexte pour tester n'est pas bon, il est donc impossible de vérifier si le code testé est correct ou non.

Afin de profiter de cette différence et de rendre le test très clair, utilisez des assert avant l'instruction &lt;code&gt;runtest&lt;/code&gt; :

&lt;source lang=&quot;csharp&quot;&gt;
testclass
{
  test
  {
    Produit prod = new Produit(&quot;T#&quot;, 123);

    runtest prod.Prix = 0;

    assert prod.Prix == 0;
  }
}
&lt;/source&gt;

Dans cet exemple, on veut rendre gratuit T#. Le test passe. Le code &lt;code&gt;set&lt;/code&gt; de la propriété &lt;code&gt;Prix&lt;/code&gt; est donc correct.
Vraiment?
Mais si ni le constructeur, ni le &lt;code&gt;set&lt;/code&gt; de la propriété &lt;code&gt;Prix&lt;/code&gt; ne sont codés... le test passe!

Un bon test pour le changement du prix est donc :

&lt;source lang=&quot;csharp&quot;&gt;
testclass
{
  test
  {
    Produit prod = new Produit(&quot;T#&quot;, 123);

    assert prod.Prix != 0;

    runtest prod.Prix = 0;

    assert prod.Prix == 0;
  }
}
&lt;/source&gt;

Maintenant, ce cas est exclu. Si le constructeur n'initialise pas la propriété &lt;code&gt;Prix&lt;/code&gt;, le premier &lt;code&gt;assert&lt;/code&gt; échouerait et, comme il est avant l'instruction &lt;code&gt;runtest&lt;/code&gt;, le test est 'Invalid' et non pas échoué!
De plus, d'un point de vue logique d'affaires, on voit bien que mettre le prix à 0 le fait passer d'une valeur non nulle à nulle et donc qu'un prix nul est acceptable.

== Quoi tester ? ==
T# incite à dire ce qui est testé, non pas par des noms de classes et méthodes les plus appropriés possibles, mais en l'indiquant clairement.
Ainsi, le test précédent devrait s'écrire :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  test Prix set
  {
    Produit prod = new Produit(&quot;T#&quot;, 123);

    assert prod.Prix != 0;

    runtest prod.Prix = 0;

    assert prod.Prix == 0;
  }
}
&lt;/source&gt;

Les avantages sont les suivants :
* Les éléments testés sont validés par le compilateur.
* On retrouve facilement les tests qui testent une déclaration précise
* Il est possible d'exécuter tous les tests d'une déclaration sans savoir où ils sont! Dans Visual Studio, placez votre curseur d'édition dans le code d'une déclaration et utiliser le menu contextuel pour exécuter 'Run T# Tests'! Particulièrement intéressant lorsque l'on retravaille une déclaration sans changer ses objectifs (refactoring)
* Il est possible d'extraire tous les tests d'une déclaration pour les présenter graphiquement dans le 'Tests Runner'.

== Contextes ==

Comme pour tout système de test, il y a beaucoup de redondances dans l'écriture des tests. En effet, il est nécessaire d'avoir plusieurs tests pour chaque déclaration d'une classe et, généralement, une classe possède plusieurs déclarations. Dans tous ces tests, il sera nécessaire de créer une instance de la classe à tester.

Tous les systèmes de test proposent une méthode à appeler avant tout test et une à appeler après tout test.
T#, lui, ne propose qu'une seule méthode.

Cela procure ainsi les avantages suivants :
* utilisation de variables locales et non pas systématiquement d'instances.
* utilisation d'instructions &lt;code&gt;using&lt;/code&gt;, &lt;code&gt;try...catch&lt;/code&gt;, &lt;code&gt;try...finally&lt;/code&gt; etc pour encadrer tout test
* '''répétition du mot clé runtest pour rouler les tests plusieurs fois!''' directement ou dans une boucle. Particulièrement utile pour exécuter tous les tests dans différents contextes

=== Contexte de chaque test ===

La forme la plus simple de contexte est le ''context'' de chaque test. C'est celle utilisée par défaut.

Les tests sont exécutés, mais pas directement. Le contexte, introduit par une méthode déclarée par le mot clé '''&lt;code&gt;testcontext&lt;/code&gt;''', est appelée pour chaque test.
Le mot clé '''&lt;code&gt;runtest&lt;/code&gt;''' indique l'endroit où le &lt;code&gt;test&lt;/code&gt; doit réellement s'exécuter.

Ainsi, dans notre exemple, nous voulons créer l'instance avec une seule ligne de code, mais il faut créer une instance pour chaque test :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set // valeur minimale
  {
    assert prod.Prix != 0;

    runtest prod.Prix = 0;

    assert prod.Prix == 0;
  }

  test Prix set // valeur valide quelconque
  {
    assert prod.Prix != 12;

    runtest prod.Prix = 12;

    assert prod.Prix == 12;
  }
}
&lt;/source&gt;

=== Différents niveaux de contexte ===

En T#, le contexte se situe à trois niveaux :
# &lt;code&gt;test&lt;/code&gt; : le code du contexte est effectué pour chaque test. Le test lui-même étant effectué à l'appel de runtest dans le contexte. Contexte par défaut.
# &lt;code&gt;testclass&lt;/code&gt; : le code du contexte est effectué pour la classe de test. Les tests de la classe de test étant effectués à l'appel de runtest dans le contexte.
# &lt;code&gt;testassembly&lt;/code&gt; : le code du contexte est effectué pour l'ensemble des classes de test de l'assemblage. Les tests étant effectué à l'appel de runtest dans le contexte.

Dans cet exemple, les tests seront exécutés 2 fois, sans avoir à les écrire 2 fois :
# pour une connexion vers une base de données SQL Server.
# pour une connexion vers une base de données Oracle.

&lt;source lang=&quot;csharp&quot;&gt;
testclass
{
  IDbConnection connexion;

  testcontext
  {
    testclass
    {
      connexion = new SQLConnection(...);
      runtest;

      connexion = new OracleConnection(...);
      runtest;
    }
  }

  ...
}
&lt;/source&gt;

== Quel cas tester ? ==

Lors de l'écriture de tests unitaires, le problème le plus classique est : &quot;Quel cas dois-je tester ?&quot;.
En effet, une même déclaration doit-être testée dans différents cas. Un des exemples précédents traitait du prix d'un produit représenté par une propriété. Combien faut-il de tests et quels sont ces tests dans un tel cas?

Dans les systèmes de tests classiques, c'est encore une fois le nom du test qui dit quel cas est testé (ou un commentaire, comme dans notre exemple précédent). Cela donne des noms souvent très longs et pas nécessairement clairs... ni mis à jour.

T# introduit un nouveau mot clé pour exprimer le cas testé : '''&lt;code&gt;when&lt;/code&gt;''' suivi d'un cas à tester.
Ainsi, l'exemple des tests du prix d'un produit devrait être :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.IsMin
  {
    assert prod.Prix != 0;

    runtest prod.Prix = 0;

    assert prod.Prix == 0;
  }

  test Prix set
    when MinIncluded.IsAboveMin
  {
    assert prod.Prix != 12;

    runtest prod.Prix = 12;

    assert prod.Prix == 12;
  }
}
&lt;/source&gt;

=== Cas manquants ===

En fait, ce qui suit le mot clé &lt;code&gt;when&lt;/code&gt; est un cas parmi plusieurs fonctionnant ensemble, décrits par un critère.
Dans notre exemple, le critère est &lt;code&gt;MinIncluded&lt;/code&gt; qui combine 2 cas normaux (&lt;code&gt;IsAboveMin&lt;/code&gt; et &lt;code&gt;IsMin&lt;/code&gt;) et 1 cas d'erreur (&lt;code&gt;BelowMinCase&lt;/code&gt;).

Il suffit donc d'identifier qu'un prix de produit a une valeur minimale (0) pour identifier qu'il faut tester selon le critère &lt;code&gt;MinIncluded&lt;/code&gt;. Ce critère définissant 3 cas, il va falloir écrire 3 tests pour tester cette propriété, un pour chaque cas défini dans le critère.

Pour l'instant, nous n'avons que deux cas définis (les cas normaux). Dès la compilation, T# indique les cas manquants : &lt;code&gt;MinIncludedCriteria.BelowMinCase&lt;/code&gt;.

=== Expressions de cas ===

En réalité, après un &lt;code&gt;when&lt;/code&gt;, une expression de cas est utilisée. Cette expression peut être un cas simple d'un critère ou une combinaison de critères.

Les opérateurs suivants existent :
* '''&lt;code&gt;&amp;&amp;&lt;/code&gt;''' (et logique) : combine toutes les possibilités entre deux critères, sachant que seules les cas normaux sont combinables, les cas d'erreur devant être testés séparément.
* '''&lt;code&gt;||&lt;/code&gt;''' (ou logique) : regroupe deux cas dans un même test. ''{{lang|la|A priori}}'' ce n'est pas une bonne idée, mais cela peut être nécessaire d'exprimer la situation d'un même test exécutant plusieurs tests avec paramètres.
* '''&lt;code&gt;=&gt;&lt;/code&gt;''' (implication) : combine le cas de gauche avec les différents cas du critère de droite. Utile lorsque toutes les combinaisons ne sont pas logiques.

Enfin, lorsqu'un cas n'a pas de sens, il est possible de demander à ne pas le prendre en compte en déclarant le cas '''&lt;code&gt;!when&lt;/code&gt;'''. Dans ce cas, le test ne doit pas avoir de code, donc pas d'accolades, seulement un point-virgule.

=== Critères ===

Il existe déjà beaucoup de critères dans la bibliothèque de T#, mais cela ne peut couvrir tout vos besoins.
Il est alors très facile de créer les vôtres.

Un critère est comme un type énuméré, mais défini par le mot clé '''&lt;code&gt;criteria&lt;/code&gt;''' et non pas enum. Les cas d'erreur sont repérés en ajoutant l'attribut &lt;code&gt;[Error]&lt;/code&gt; au cas en question.

La convention veut que :
# le nom du critère se termine par &quot;Criteria&quot;, même s'il n'est pas nécessaire de l'ajouter lors de l'utilisation (comme &quot;Attribute&quot; pour les attributs)
# un cas normal se présente avec un 'Is' ou 'Has'
# un cas d'erreur se termine par 'Case'

Ainsi, la déclaration de &lt;code&gt;MinIncludedCriteria&lt;/code&gt; est la suivante :

&lt;source lang=&quot;csharp&quot;&gt;
public criteria MinIncludedCriteria
{
  [Error]
  BelowMinCase,
  IsMin,
  IsAboveMin,
}
&lt;/source&gt;

== Tester les exceptions ==

Comme nous l'avons vu avec les critères dans le paragraphe précédent, il est nécessaire de non seulement tester les cas normaux, mais aussi les cas d'erreur.

Généralement, un cas d'erreur est rapporté par une exception.

Il faut donc pouvoir tester les exceptions.

=== Tester qu'une exception est lancée ===

T# vérifie les exceptions comme toute autre vérification :
* en une seule ligne
* avec le mot assert, mais suivi de '''&lt;code&gt;thrown&lt;/code&gt;''' et du nom de l'exception

Les avantages sont les suivants :
# garantie que l'exception est bien dans la partie runtest (donc dans le code d'affaires) et non pas avant (préparation) ou après (vérification)!
# ajout possible d'autres assertions pour garantir que rien d'inattendu n'a été fait avant l'exception (comme changer le prix avant de déclencher l'exception par exemple!)

Ainsi, dans l'exemple précédent, il est nécessaire de tester le cas où le prix affecté au produit est négatif.
Comme cela n'a pas de sens, la propriété devrait générer une exception &lt;code&gt;ArgumentOutOfRangeException&lt;/code&gt;.
Testez-le ainsi :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.BelowMinCase
  {
    runtest prod.Prix = -12;

    assert thrown ArgumentOutOfRangeException;
    assert prod.Prix == 123; // Le prix n'a pas changé
  }

  ...
}
&lt;/source&gt;

=== Tester complètement une exception ===

En fait, cela va simplement vérifier que l'exception est bien générée dans l'instruction runtest. Ce qui est déjà bien.
Cependant, il serait bon de pouvoir valider le message d'erreur par exemple.

L'instruction &lt;code&gt;assert thrown &lt;type-exception&gt;&lt;/code&gt; peut aussi être suivi d'un nom de variable, comme dans une instruction &lt;code&gt;catch&lt;/code&gt;, et d'un bloc de code pour faire autant de vérifications voulues lorsque l'exception est déclenchée. Accédez alors normalement à cette variable pour vérifier tout ce que vous voulez.

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.BelowMinCase
  {
    runtest prod.Prix = -12;

    assert thrown ArgumentOutOfRangeException e
    {
      assert e.Message == &quot;Un prix ne peut être négatif!&quot;;
    }
    assert prod.Prix == 123; // Le prix n'a pas changé
  }

  ...
}
&lt;/source&gt;

== Vérifier les changements ==

Le problème d'utiliser des contextes est que celui-ci peut se trouver physiquement loin du test que l'on travaille, et lorsqu'il est changé, peut avoir des conséquences sur l'ensemble des tests.

Ainsi, dans l'exemple précédent, si le produit créé a maintenant un prix de 100 au lieu de 123, l'instruction &lt;code&gt;assert prod.Prix == 123;&lt;/code&gt; échoue car le prix sera de 100!

L'idéal serait de faire des tests relatifs : conserver la valeur initiale de &lt;code&gt;prod.Prix&lt;/code&gt; dans une variable locale, puis l'utiliser dans la vérification.
Le problème est que cela fait plus de code à écrire.

T# offre la possibilité d'écrire des vérifications relatives en une seule ligne de code.

=== Vérifier la constance d'une expression ===

La forme la plus simple de vérification relative est celle de la constance d'une expression.

T# offre une nouvelle forme de l'instruction &lt;code&gt;assert&lt;/code&gt; : '''&lt;code&gt;assert !changed &lt;expression&gt;&lt;/code&gt;'''

L'expression sera évalué avant l'instruction &lt;code&gt;runtest&lt;/code&gt;, et sa valeur conservée, pour être de comparée par égalité au moment du &lt;code&gt;assert&lt;/code&gt; en question.

Ainsi, dans notre exemple, plutôt que de vérifier que le prix du produit est bien 123, il serait préférable de vérifier que le prix n'a pas changé :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.BelowMinCase
  {
    runtest prod.Prix = -12;

    assert thrown ArgumentOutOfRangeException e
    {
      assert e.Message == &quot;Un prix ne peut être négatif!&quot;;
    }
    assert !changed prod.Prix;
  }

  ...
}
&lt;/source&gt;

=== Vérifier la constance d'un objet ===

La forme la plus sophistiquée de vérification relative est celle de la constance d'un objet. En effet, qui dit que notre code d'affaires n'a pas modifié l'objet avant que de lancer l'exception?

Dans l'instruction &lt;code&gt;assert !changed &lt;expression&gt;&lt;/code&gt;, l'expression peut référencer un objet et se terminer par :
# &lt;code&gt;.*&lt;/code&gt; : indique au compilateur T# de vérifier chacune des propriétés publique de l'objet en question. Donc que l'objet n'a pas changé en apparence.
# &lt;code&gt;.-*&lt;/code&gt; : indique au compilateur T# de vérifier chacune des variables (quel que soit le niveau d'encapsulation) de l'objet en question. Donc que l'objet n'a vraiment pas changé.

Note : l'opérateur &lt;code&gt;.-&lt;/code&gt; est semblable à l'opérateur &lt;code&gt;.&lt;/code&gt; si ce n'est qu'il accède à n'importe quelle déclaration, privée ou non.

Ainsi, dans notre exemple, plutôt que de vérifier que le prix du produit n'a pas changé, il serait préférable de vérifier que l'objet &lt;code&gt;prod&lt;/code&gt; n'a pas changé :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.BelowMinCase
  {
    runtest prod.Prix = -12;

    assert thrown ArgumentOutOfRangeException e
    {
      assert e.Message == &quot;Un prix ne peut être négatif!&quot;;
    }
    assert !changed prod.-*; // le produit n'a pas changé
  }

  ...
}
&lt;/source&gt;

=== Vérifier un changement ===

Sur le même principe, vérifiez qu'un changement a été apporté par une assertion relative.

Une assertion relative de changement s'effectue avec l'instruction '''&lt;code&gt;assert changed &lt;affectation&gt;&lt;/code&gt;'''.

L'affectation se présente sous 3 formes :
# &lt;code&gt;élément = expression&lt;/code&gt;
# &lt;code&gt;élément op= expression&lt;/code&gt; : ainsi, &lt;code&gt;élément += 1&lt;/code&gt; est équivalent à &lt;code&gt;élément = élément + 1&lt;/code&gt;
# &lt;code&gt;élément++&lt;/code&gt; ou &lt;code&gt;element--&lt;/code&gt; : ainsi, &lt;code&gt;élément++&lt;/code&gt; est équivalent à &lt;code&gt;élément += 1&lt;/code&gt; donc à &lt;code&gt;élément = élément + 1&lt;/code&gt;

La partie de droite est évaluée avant l'instruction runtest, et conservée, pour être comparée par égalité à la partie de gauche sur le &lt;code&gt;assert&lt;/code&gt; correspondant.
Ainsi, &lt;code&gt;assert changed élément++&lt;/code&gt; n'incrémente pas élément, mais vérifie que la valeur d'élément ajoutée de 1 avant l'instruction &lt;code&gt;runtest&lt;/code&gt; est égale à la valeur d'élément après l'instruction &lt;code&gt;runtest&lt;/code&gt;. Ou tout simplement, que l'instruction runtest à bien fait augmenter de 1 la valeur d'élément.
Ainsi, c'est l'expression équivalente à une affectation comme précisé, mais seulement des accès en lecture sont effectués. Il est donc possible de l'utiliser avec des propriétés en lecture seule.

Si nous reprenons notre exemple avec notre classe &lt;code&gt;Produit&lt;/code&gt;, on pourrait ajouter une classe &lt;code&gt;Inventaire&lt;/code&gt; (une collection de &lt;code&gt;Produit&lt;/code&gt;)qui aurait donc une méthode &lt;code&gt;Add(Produit)&lt;/code&gt; et une propriété &lt;code&gt;Count&lt;/code&gt;.

Le test de cette méthode serait :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Inventaire
{
  Inventaire inventaire;

  testcontext
  {
    inventaire = new Inventaire();
    runtest;
  }

  test Add( Produit p )
  {
    Product produit = new Product( &quot;T#&quot;, 123 );

    runtest inventaire.Add( produit );

    assert changed inventaire.Count++; // un produit a été ajouté
    assert inventaire[ inventaire.Count - 1 ] == produit; // le produit a été ajouté en dernier
  }

  ...
}
&lt;/source&gt;

== Tester les événements ==

En dehors des exceptions, les événements non plus ne sont pas faciles à tester correctement.
Il n'existe aucune facilité fournie par les système de tests existants.

T# offre une nouvelle fois l'instruction &lt;code&gt;assert&lt;/code&gt; mais avec le mot clé &lt;code&gt;raised&lt;/code&gt;.

Par exemple, une classe implémentant &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; doit déclencher l'événement &lt;code&gt;PropertyChanged&lt;/code&gt; si une propriété est changée. Mais, elle ne devrait '''pas''' déclencher l'événement si la valeur affectée est la même que celle actuelle!

Note : Ce cas étant classique, nous T# fournit déjà le critère &lt;code&gt;NotifyPropertyChangedCriteria&lt;/code&gt; avec 3 cas :
# HasNoSubscriber : test normal, cas représenté dans les exemples précédents.
# HasSubscribersSetSameValue : cas représenté dans le prochain paragraphe.
# HasSubscribersSetOtherValue : cas représenté dans les paragraphes suivants.

=== Vérifier le non-déclenchement d'un événement ===

La forme la plus simple est la vérification du non déclenchement d'un événement.

En T#, la vérification du non-déclenchement d'un événement s'effectue comme toujours en une ligne de code : &lt;code&gt;assert !raised &lt;événement&gt;;&lt;/code&gt;

Le compilateur T# génère une variable d'instance et une méthode compatible avec la signature de l'événement.
Dans le test, la variable est initialisée à faux, le méthode est enregistrée (&lt;code&gt;+=&lt;/code&gt;) auprès de l'événement avant l'instruction &lt;code&gt;runtest&lt;/code&gt; et désenregistrée (&lt;code&gt;-=&lt;/code&gt;) après l'instruction &lt;code&gt;runtest&lt;/code&gt;.
La méthode générée va réinitialiser la variable à vrai.
L'instruction &lt;code&gt;runtest !raised&lt;/code&gt; va vérifier que la variable est toujours à faux.

En supposant que notre classe &lt;code&gt;Produit&lt;/code&gt; supporte l'interface &lt;code&gt;INotifyPropertyChanged&lt;/code&gt;, nous devrions avoir le test suivant :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.IsAboveMin &amp;&amp; NotifyPropertyChanged.HasSubscribersSetSameValue
  {
    runtest prod.Prix = prod.Prix;

    assert !changed prod.-*;
    assert !raised prod.PropertyChanged;
  }

  ...
}
&lt;/source&gt;

=== Vérifier le déclenchement d'un événement ===

La forme la plus simple de vérification du déclenchement d'un événement vérifie seulement que l'événement est déclenché.

Comme toujours, T# le vérifie en une seule ligne de code : &lt;code&gt;assert raised &lt;événement&gt;;&lt;/code&gt;

Le compilateur T# génère exactement les mêmes choses que pour &lt;code&gt;assert !changed&lt;/code&gt;, mais vérifie que la variable est à vrai.

Ainsi, dans notre exemple, nous devrions avoir :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.IsAboveMin &amp;&amp; NotifyPropertyChanged.HasSubscribersSetOtherValue
  {
    assert prod.Prix != 12;

    runtest prod.Prix = 12;

    assert prod.Prix == 12;
    assert raised prod.PropertyChanged;
  }

  ...
}
&lt;/source&gt;

=== Vérifier complètement un événement ===
L'inconvénient de procéder comme dans le chapitre précédent, c'est que cela prouve simplement que l'événement s'est déclenché, pas que :
# les paramètres associés sont correctement passés. Selon notre exemple, le &lt;code&gt;sender&lt;/code&gt; est-il bien le produit modifié? Le second paramètre fait-il bien référence à la bonne propriété?
# l'état de l'objet est correct au moment de l'événement. Selon notre exemple, le produit est-il bien déjà avec sa nouvelle valeur de prix quand l'événement est déclenché?

Une forme beaucoup plus sophistiquée de test des événement existe : '''&lt;code&gt;assert raised &lt;événement&gt;(&lt;paramètres&gt;) { &lt;vérifications&gt; }&lt;/code&gt;'''
Où :
* &lt;paramètre&gt; représente les paramètres correspondant à la signature de l'événement.
* &lt;vérifications&gt; représente les assertions à vérifier dans la méthode réagissant à l'événement.

Ainsi, le même tests que dans le chapitre précédent, mais complet serait :

&lt;source lang=&quot;csharp&quot;&gt;
testclass for Produit
{
  Produit prod;

  testcontext
  {
    prod = new Produit(&quot;T#&quot;, 123);
    runtest;
  }

  test Prix set
    when MinIncluded.IsAboveMin &amp;&amp; NotifyPropertyChanged.HasSubscribersSetOtherValue
  {
    assert prod.Prix != 12;

    runtest prod.Prix = 12;

    assert prod.Prix == 12;
    assert raised prod.PropertyChanged( object sender, PropertyChangedEventArgs e )
    {
      assert sender == prod;
      assert e.PropertyName == &quot;Prix&quot;;
      assert prod.Price == 12;
    }
  }

  ...
}
&lt;/source&gt;

== Tester avec les 'Code Snippets' ==

Visual Studio offre la possibilité d'utiliser des 'Code Snippets' dans les langages de Microsoft. Nous avons aussi ajouté des 'Code Snippets' pour Visual T# (25 dans la version 1.0).

Ainsi, rien de plus facile pour générer vos tests :
# identifier quel critère s'applique.
# utiliser le 'Code Snippet' correspondant.
# remplacer les quelques paramètres du 'Snippets'.

Dans notre exemple, nous voulons tester le prix d'un produit.

Nous avons déjà établi que les critères à utiliser sont :
# &lt;code&gt;MinIncludedCriteria&lt;/code&gt; : car le prix peut être nul (valeur minimale), mais pas négatif.
# &lt;code&gt;NotifyPropertyChangedCriteria&lt;/code&gt; : car la classe Produit implémente l'interface &lt;code&gt;INotifyPropertyChanged&lt;/code&gt;.

Comme par hasard, il existe le 'Code Snippet' &lt;code&gt;NotifyMinIncluded&lt;/code&gt; qui va générer d'un seul coup le code.

Il ne reste plus qu'à indiquer les informations suivantes :
# le nom de la propriété à tester (Prix).
# le nom de l'instance à utiliser, c'est-à-dire celle créé dans le contexte (prod).
# la valeur minimale acceptable (0).
# la valeur au-dessus du minimum à utiliser (12).
# la valeur en dessous du minimum à utiliser (-12).

Et voici le code généré :
&lt;source lang=&quot;csharp&quot;&gt;

    test Prix set
      when MinIncluded.IsMin &amp;&amp; NotifyPropertyChanged.HasNoSubscriber
    {
      assert prod.Prix != 0;

      runtest prod.Prix = 0;

      assert prod.Prix == 0;
    }

    test Prix set
      when MinIncluded.IsMin &amp;&amp; NotifyPropertyChanged.HasSubscribersSetSameValue
    {
      assert prod.Prix == 0;

      runtest prod.Prix = 0;

      assert !changed prod.Prix;
      assert !raised prod.PropertyChanged;
    }

    test Prix set
      when MinIncluded.IsMin &amp;&amp; NotifyPropertyChanged.HasSubscribersSetOtherValue
    {
      assert prod.Prix != 0;

      runtest prod.Prix = 0;

      assert prod.Prix == 0;
      assert raised prod.PropertyChanged( object sender, PropertyChangedEventArgs args )
      {
        assert sender == prod;
        assert args.PropertyName == &quot;Prix&quot;;
        assert prod.Prix == 0;
      }
    }

    test Prix set
      when MinIncluded.IsAboveMin &amp;&amp; NotifyPropertyChanged.HasNoSubscriber
    {
      assert prod.Prix != 12;

      runtest prod.Prix = 12;

      assert prod.Prix == 12;
    }

    test Prix set
      when MinIncluded.IsAboveMin &amp;&amp; NotifyPropertyChanged.HasSubscribersSetSameValue
    {
      assert prod.Prix == 12;

      runtest prod.Prix = 12;

      assert !changed prod.Prix;
      assert !raised prod.PropertyChanged;
    }

    test Prix set
      when MinIncluded.IsAboveMin &amp;&amp; NotifyPropertyChanged.HasSubscribersSetOtherValue
    {
      assert prod.Prix != 12;

      runtest prod.Prix = 12;

      assert prod.Prix == 12;
      assert raised prod.PropertyChanged( object sender, PropertyChangedEventArgs args )
      {
        assert sender == prod;
        assert args.PropertyName == &quot;Prix&quot;;
        assert prod.Prix == 12;
      }
    }

    test Prix set
      when MinIncluded.BelowMinCase
    {
      runtest prod.Prix = -12;

      assert thrown ArgumentOutOfRangeException;
      assert !changed prod.-*;
    }
&lt;/source&gt;

== Liens externes ==
Visual T# est téléchargeable '''gratuitement''' sur : [http://forum.prettyobjects.com/forum2-t-download.aspx Forum Visual T#]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:.NET Framework]]
[[Catégorie:Compilateur]]
[[Catégorie:Test logiciel|Unitaire]]</text>
      <sha1>a09699wbowxzcv9xx3jzg2buf5ss12v</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>APL (langage)</title>
    <ns>0</ns>
    <id>91480</id>
    <revision>
      <id>101893480</id>
      <parentid>101893465</parentid>
      <timestamp>2014-03-08T15:38:43Z</timestamp>
      <contributor>
        <username>François-Dominique</username>
        <id>4980</id>
      </contributor>
      <minor/>
      <comment>/* Réalisations */</comment>
      <text xml:space="preserve" bytes="26194">{{Unicode}}
{{voir homonymes|APL}}
{{à recycler}}
L''''APL''' (initialement ''A Programming Language'', officieusement ''Array-Processing Language'') est un [[langage de programmation]] conçu entre [[1957]] et [[1967]] par [[Kenneth Iverson]] pour décrire commodément des opérations portant globalement sur des tableaux (booléens, numériques ou, dans une moindre mesure, de caractères).

Révolutionnaire à son lancement (usage du terminal à boule ou à écran alors que la carte perforée restait encore la référence, gestion dynamique de mémoire, interactivité totale, concision par suppression de la nécessité des ordres de boucles), il connut un succès croissant jusqu'au milieu des années 1980, époque où le [[tableur]] le concurrença pour les petits travaux, et des outils comme [[SAS (langage)|SAS]], puis [[R (langage de programmation et environnement statistique)]] pour le travail sur les grands volumes de données.
== Historique ==

APL s’est montré particulièrement adapté en son temps aux calculs [[statistique]]s, aux ventilations, aux consolidations, aux descriptions fonctionnelles d’architectures comme celle de l’[[IBM 360 et 370|IBM 360]], aux graphiques interactifs ([[GRAPHPAK]]) et à quelques travaux en [[combinatoire]] et en [[théorie des graphes]]. Il a également été utilisé pour le [[prototypage]] d’applications et l’écriture de '''langages de manipulation simples''' dans le cadre d’un [[infocentre]] en masquant les symboles appropriés sous des dénominations commodes et parlantes, par exemple en permettant d’écrire simplement :

''MOYENNE X'' pour ''(+/X)÷⍴X''.

''NORMALISER X'' pour ''X÷+/X''

etc.

Il permet de manipuler aisément des tableaux de 1 à N indices (N variant de 7 à 255 selon l’implémentation considérée) de façon ''globale''. Les opérations puissantes de ''feuilletage'' (''lamination'') ainsi que les opérateurs de ''réduction'', ''expansion'', ''compression'', ''produit intérieur'' et ''produit extérieur'' évitent souvent toute nécessité d’indices de boucle explicite - ainsi d’ailleurs que l’usage de boucles lui-même.

Il utilise de nombreux symboles représentant des opérations utilisables en programmation comme en calcul immédiat à la console, par exemple le « domino » (⌹) qui inverse directement une [[matrice (mathématiques)|matrice]], ou résout un système d’[[équations linéaires]] surdimensionné au sens des [[Méthode des moindres carrés|moindres carrés]].

On estimait dans les années 1970-80 qu’une équipe de 5 développeurs APL avait la puissance de développement d’une équipe de 25 programmeurs [[FORTRAN]]&lt;ref&gt;TECHNIP : Description de l'équipe informatique&lt;/ref&gt;. L’application APL se montrait plus gourmande en ressources matérielles, mais le prix de celles-ci était en constante diminution. Aujourd'hui, 2013, son adaptation à la [[programmation agile]] lui donne un regain d'intérêt pour toutes les applications à mettre en place ou faire évoluer rapidement, aussi bien que pour les applications à courte durée de vie. Il a été utilisé entre autres&lt;ref&gt;http://www.quantys.fr/services/qtyapl1.htm&lt;/ref&gt; par [[NASA]], [[British Airways]], [[Banque de France]] (études économiques éclair), [[Direction générale des Impôts]] (impact fiscal de lois nouvelles), etc.

Depuis 2013 également, il est proposé pour la réalisation de [[servlet]]s&lt;ref&gt;http://www.apl.it/fra/societe.php?display=interpretes&lt;/ref&gt;.

Son interface initiale (bicolore en mode machine à écrire) a inspiré celle de logiciels comme [[Maple]].

== Présentation ==

APL innovait à son époque par plusieurs aspects conviviaux : 
* pas de déclaration de types ni de tailles, une variable contenant tout simplement ce qu’on a mis dedans (scalaire ou tableau) ;
* possibilité d’interrompre un programme, d’interroger et de modifier des variables, et de reprendre l’exécution ; ou bien de tout stocker en l’état et de reprendre le lendemain en retrouvant les objets de la zone de travail - fonctions, variables et états d’exécution - exactement comme on les avait laissés (bref, de la [[Persistance (informatique)|persistance]] avant la lettre… dès 1969 !) ; 
* gestion dynamique de mémoire automatique ; 
* pas de syntaxe compliquée pour afficher des résultats : quand quelque chose est calculé sans être mémorisé dans une variable, alors on l’affiche simplement au terminal dans le format estimé le plus lisible. 

=== Exemples ===

Ainsi pour écrire « Hello, World! » en APL, les choses se passent ainsi :

  'Hello, World!'         ⍝ tapé par l’utilisateur
  ''Hello, World!''           ⍝ réponse du terminal)

  2+2 3 5 7               ⍝ donne
  ''4 5 7 9''

Il faut y ajouter la possibilité spectaculaire d’indexer un tableau par un autre tableau. Ainsi :

  'LE CHAT'[7 5 2 3 4 6 7]         ⍝ donne
  ''THE CAT''

Voire :

  'LE CHAT'[2 3 ⍴ 7 5 2 4 6 7]     ⍝ donne
  ''THE''
  ''CAT''

Pas de [[traduction automatique]] ici ni dans un cas ni dans l'autre : l'indice a simplement été remplacé par ce qui était indicé (ainsi ''T'' est le septième caractère), ce qui est le propre de l'opération d'indexation. Ce qui est indicé prend également la forme de l'indice (ainsi, une matrice 2x3 dans le second cas).

Grâce à sa priorité de gauche à droite, le langage se lit simplement, comme une langue naturelle : « 1 plus somme des inverses des factorielles des entiers de 1 à 30 »  s'écrira :

  1++/÷!⍳30          ⍝ qui donne
  ''2.718281828''

Une extension d'APL, nommée APL2, gère quant à elle des tableaux de tableaux, et permet à l'utilisateur de définir lui-même ses propres « opérateurs ». Elle travaille également en [[nombres complexes]] automatiquement si les besoins du calcul le demandent.

=== Opérations sur tableaux ===

 ⎕←A←2 2⍴1 2 3 4     ⍝ donne &lt;br /&gt;
 1 2&lt;br /&gt;
 3 4&lt;br /&gt;

APL a créé une matrice A de 2 lignes et 2 colonnes, la remplit avec les nombres 1 2 3 4, puis l'imprime&lt;br /&gt;

 A=2     ⍝ donne &lt;br /&gt;
 0 1&lt;br /&gt;
 0 0&lt;br /&gt;
le résultat est une [[matrice booléenne]] indiquant les éléments de A égaux à 2&lt;br /&gt;
 A,A        ⍝ donne &lt;br /&gt;
 1 2 1 2&lt;br /&gt;
 3 4 3 4&lt;br /&gt;
APL concatène la matrice A avec elle-même, formant une matrice de 2 lignes et 4 colonnes&lt;br /&gt;

 A,5     ⍝ donne &lt;br /&gt;
 1 2 '''5'''&lt;br /&gt;
 3 4 '''5'''&lt;br /&gt;
APL concatène le scalaire 5 à la matrice A&lt;br /&gt;

 A, +/A     ⍝ donne &lt;br /&gt;
 1 2 '''3'''&lt;br /&gt;
 3 4 '''7'''&lt;br /&gt;
APL concatène à A un vecteur 'somme des lignes de A' &lt;br /&gt;

  A⍪+⌿A ⍝ donne   &lt;br /&gt;
 1 2&lt;br /&gt;
 3 4&lt;br /&gt;
 '''4 6'''&lt;br /&gt;
même chose suivant l'autre axe : colonnes&lt;br /&gt;
 A,[.5]0   ⍝ donne &lt;br /&gt;
 1 2&lt;br /&gt;
 3 4&lt;br /&gt;
 &lt;br /&gt;
 '''0 0'''&lt;br /&gt;
 '''0 0'''&lt;br /&gt;
concaténation en créant une nouvelle dimension : la matrice devient cube

 A,[1.5]0&lt;br /&gt;
 1 2&lt;br /&gt;
 '''0 0'''&lt;br /&gt;
 &lt;br /&gt;
 3 4&lt;br /&gt;
 '''0 0'''&lt;br /&gt;
concaténation en créant une nouvelle dimension sur un autre axe

 ⎕←A←1 2∘.×3 4 5 6 7   ⍝ donne &lt;br /&gt;
 3 4  5  6  7&lt;br /&gt;
 6 8 10 12 14&lt;br /&gt;
APL met dans A et imprime un produit externe ou cartésien, genre table de multiplication&lt;br /&gt;

 (,A)[⍋,A]    ⍝ donne
 3 4 5 6 6 7 8 10 12 14&lt;br /&gt;
APL édite la suite résultant du tri ascendant des éléments de A

=== Opérateurs ===

De même qu'une ''fonction'' agit sur une ou plusieurs ''variables'', un ''opérateur'' agit sur une ou plusieurs ''fonctions'' (ou opérations). Pour prendre une comparaison mathématique, « sigma » et « pi » correspondent à l'opérateur APL de ''réduction'' (« / ») appliqué aux opérations « + » et « × ». Sigma (somme de termes) s'écrit ''+/'', « pi » (multiplication entre termes) ''×/'', « Union » (''ou'' logique entre termes) ∨''/'', etc. On parle, dans d'autres langages, de [[Clôture (mathématiques)|clôture]] (''closure'').

Dans la première version d’APL, les ''opérateurs'' sont définis de façon fixe (réduction (/), scan (\), produit externe (°.), composition (.), …). En APL2, l’utilisateur peut fabriquer les siens à volonté et leur donner des noms. Un opérateur peut agir indifféremment sur des opérations de base du langage ou sur des fonctions définies par l’utilisateur dans sa ''workspace''.

APL2 introduit également l'opérateur tréma ('¨', nommé ''each''), généralisant au niveau de chaque sous-tableau une opération dans les ''tableaux de tableaux''.

=== Tableaux de tableaux, et fonction ⍎ ===
Une opération nommée ''enclose'' (⊂) permet d’''encapsuler'' un tableau qui est alors vu comme un scalaire. Il est dès lors facile de représenter des structures complexes sous forme de ''tableaux ayant pour éléments d’autres tableaux''. L’existence d’une fonction ''execute'' (⍎) permet même d’inclure dans ces tableaux de tableaux des désignateurs de fonction que l’on peut exécuter à la demande, comme en [[langage C]]. Elle permet aussi à un programme d’engendrer lui-même un code qu’il exécutera ensuite, comme en [[Lisp]].

Le nombre d'''indices'' d’un tableau est par convention nommé ''rang'' (rank) en APL. Le nombre de ''niveaux'' d’un tableau de tableaux est nommé ''profondeur'' (depth).

=== Espace de travail ===

L’utilisateur travaille dans un ''espace de travail'' où il stocke ses fonctions et ses variables. Il peut à tout moment sauvegarder l’ensemble (y compris en état d’exécution suspendue) et reprendre plus tard son travail exactement dans les conditions où il l’avait laissé&lt;ref&gt;Cette notion a été reprise ensuite dans d'autres langages ([[Forth (langage)|FORTH]], [[Smalltalk]], [[C++]]) sous le nom de [[persistance (informatique)|persistance]]&lt;/ref&gt;. Des commandes comme '')COPY'' et '')PCOPY'', et la notion de ''groupe'' permettent des transferts aisés de fonctions et de variables d’un ''workspace'' à un autre.

=== Horodatage automatique ===
Chaque objet APL2 (variable, fonction ou opérateur) est horodaté dans la ''espace de travail'', ce qui facilite sa gestion sur le long terme. Le type et la date des objets sont retournées par la fonction système ''⎕AT'' (=''AT''tributes). Couplé aux opérateurs de tri ⍋ (''grade-up'') et ⍒ (''grade-down''), cet horodatage des objets facilite beaucoup le processus de développement.

=== Éléments anecdotiques ===
* APL travaillant sur des vecteurs, il doit distinguer l’opération « - » (moins), qui désigne l'opération de soustraction entre deux variables numériques ou le changement de signe d'une variable numérique d'une part, du ''signe négatif'' qui ne porte que sur la valeur numérique qui le suit immédiatement, d'autre part. Celui-ci est noté par une ''barre supérieure'' « ¯ ».

:Ainsi, 7  5  6  -  4  3  2   produit  3 2 4,  mais  7  5  6  ¯4  3  2 produit… 7 5 6 ¯4 3 2

* Lorsqu’APL tourne sur un système, par exemple le [[RS/6000]], on s’écarte de la tradition en le nommant non pas APL/6000, mais bien '''APL\6000'''. Pourquoi ? Parce que « / » est un opérateur de ''réduction'' et que « \ » qui est l’opérateur d'''expansion''. Logique.

* APL était au départ utilisé uniquement en interne par IBM, sans plan de commercialisation. Selon ''Yves Le Borgne'', la [[NASA]] fit toutefois pression pour que ce langage fût mis à sa disposition, menaçant de changer de constructeur si elle n’obtenait pas satisfaction. Le langage fut mis timidement au catalogue en [[1969]] à titre de ''produit complémentaire'', puis en quelques années prit le statut de langage stratégique, qu’il garda jusqu’en [[1990]] (à partir de cette date, ne pouvait plus être considéré comme stratégique un langage ne tournant pas sur toutes les plateformes, et porter APL sur l’AS/400 ne présentait pas d’intérêt vu le créneau spécifique de cette machine)

== Implémentations ==
[https://commons.wikimedia.org/wiki/File:Nars2000-wikipedia.png Exemple de session NARS2000]

Trois implémentations en [[Open Source]] d'APL sont téléchargeables gratuitement à ce jour, 2013 :

* [[NARS2000]]&lt;ref&gt;http://wiki.nars2000.org/&lt;/ref&gt;, muni d'un installeur pour Windows, et disponible en versions 32 et 64 bits&lt;ref&gt;http://www.nars2000.org/download/Download-body.php&lt;/ref&gt;. La version 32 bits fonctionne également depuis [[Wine]] sous [[Linux]] (voir illustration ci-dessus)&lt;ref&gt;Wine ne supporte pas encore officiellement le 64 bits en 2014.&lt;/ref&gt;.
** [http://www.lulu.com/shop/richard-snow/introduction-to-apl-programming-in-nars2000/ebook/product-20319236.html Manuel d'initiation à NARS2000] (PDF, gratuit)
* [[GNU APL]]&lt;ref&gt;https://www.gnu.org/software/apl/&lt;/ref&gt; directement utilisable sous Linux, mais aussi sous Windows au moyen de [[Cygwin]].
* ''A+'', dialecte d'APL livré en standard avec plusieurs distributions Linux, dont Ubuntu, sous le nom de ''aplus-fsf''.
=== Réalisations ===
Des interpréteurs APL ont existé pour l’[[IBM 7090]], les [[IBM 360 et 370|IBM 360 à zSeries]] (sous [[Time Sharing Option|TSO]], [[VM/CMS]] et même [[Customer Information Control System|CICS]]!), l’[[IBM 1130 et 1800|IBM 1130]], le ''Xerox XDS Sigma 7'' alias [[CII 10070]], et le [[Compagnie internationale pour l'informatique|CII]] [[Iris 80]], le [[Bull DPS-7]], le [[Burroughs B1700]], le [[T1600|Bull SEMS T1600]] (ex-''Télémécanique Électrique T1600''), la série des Mitra, etc. 

Ce langage était même directement en [[Mémoire morte|ROM]] dans des ordinateurs personnels du milieu des années 1970 comme le ''MCM-70'' ou l’[[IBM 5100 et 5110|IBM 5110]] modèles A et C.

Des versions [[station de travail]] et [[ordinateur personnel]] en ont aussi été commercialisées ou réalisées gratuitement pour [[AIX]], [[solaris (informatique)|Solaris]], [[Linux]], [[Microsoft Windows|Windows]], [[Mac OS]], [[OS/2]] et même le [[DOS]] (une version gratuite nommée TRYAPL2 existe pour le DOS, en version anglaise comme française).

La société [[Microsoft]] considérait l'APL comme le successeur naturel de son [[BASIC]] et avait entrepris deux implémentations du langage sur [[8080]] et [[6800]], comme le montre un extrait de lettre de [[Bill Gates]] aux utilisateurs de l'[[Altair BASIC]]&lt;ref&gt;On peut voir un extrait de cette lettre dans le film ''Pirates of the Silicon Valley''&lt;/ref&gt; &lt;ref&gt;[[:en:Open Letter to Hobbyists]]&lt;/ref&gt;

Le succès de [[DOS]], de [[Windows]] et surtout des [[tableur]]s [[Multiplan]] et [[Excel]] fit abandonner ce projet, qui s'adressait à un marché potentiel bien plus restreint.

=== Environnements informatiques ===
Le mécanisme d’échange dit des ''processeurs auxiliaires'' permet à des workspaces APL de communiquer avec le monde extérieur : fichiers, [[Structured Query Language|SQL]]/[[DB2]], [[TCP/IP]], [[X Window System|X-window]], [[OpenGL]], ainsi qu'''autres workspaces APL et consoles du réseau actives au même moment'' si celles-ci en donnent l’autorisation. On peut ainsi commencer à mettre au point un calcul sur un PC, puis une fois qu’il est au point l’exécuter à distance sur un [[mainframe]] équipés de dizaines de processeurs parallèles depuis la même session.

Les processeurs auxiliaires se codent le plus souvent en [[langage C]].

== Situation présente du langage ==

L’apparition du [[tableur]], plus intuitif et plus facile à manier, a fait disparaître une partie de l’intérêt du langage. Cela n’enlève rien pour autant à sa puissance d’expression et à sa concision, et plusieurs interpréteurs APL sont téléchargeables gratuitement sur [[Internet]], pour le [[Compatible PC|PC]] comme pour le [[Macintosh]]. La généralisation des écrans et des imprimantes à laser ont éliminé l’ancien problème que représentait l’usage de caractères spécifiques. Les caractères APL/APL2 sont d’ailleurs présents dans l’[[Unicode]].

APL traitant globalement les tableaux, ses implémentations tirent aisément parti des possibilités de [[calcul parallèle]] ou de [[pipeline (informatique)|pipeline]] des processeurs modernes. Elles utilisent extensivement les possibilités vectorielles du [[IBM 360 et 370|S/390 (zSeries)]], de l’architecture [[PowerPC]] et des instructions multimédia ([[Streaming SIMD Extensions|SSE]]) de l’architecture Intel/AMD.

Il a deux successeurs, le langage [[A plus (langage)|A+]], et le langage [[J (langage)|J]], ce dernier ayant été promu par K. E. Iverson lui-même, et ne nécessitant pas l’usage de caractères spéciaux. APL possède toutefois une lisibilité supérieure, à condition de disposer de la police de caractères appropriée. La mise à disposition du langage lui-même n’aurait pas été possible dès [[1969]] sans les ''terminaux IBM à boule'' également nommés [[Selectric]] (par exemple le ''2741'').

Pour information, des calculs actuels typiques sur un [[Celeron]] {{Unité|300|MHz}} s’effectuent à peu près en un dixième du temps de calcul qu’ils prenaient en 1970 sur un ''[[IBM 360 et 370|IBM 360]]/91''. Le cœur de l’interpréteur tient entièrement dans le [[cache d'instructions]] d’un [[microprocesseur]] contemporain (2004), donnant à APL des performances comparables à celle qu’on obtenait il y a quelques années avec un langage [[compilateur|compilé]].

[[GRAPHPAK]] est une des workspaces fournies avec APL et combinable avec toute autre application de l’utilisateur pour lui donner des possibilités d’entrée-sortie graphiques 2D comme 3D. La structure des appels du langage (pas de nécessité de parenthèses pour les appels de fonctions et de sous-programmes) permet de donner des ordres ayant une vague allure de langage naturel. Les éléments ''IBM'' et ''AP'', fournis avec cette workpsace, sont simplement des matrices contenant des coordonnées de points respectivement en 2D et en 3D, la première colonne spécifiant une indication de tracé (couleur et style).

== Caractères APL/APL2 en Unicode ==
Vérifiez que votre navigateur accepte bien l’[[Unicode]]; dans le cas contraire, vous verrez s’afficher des rectangles blancs ou des points d’interrogation à la place des caractères APL.
=== Glyphes ===

{|
|- align=center
|' || ( || ) || + ||, || - || . || / || : || ; || &amp;lt; || = || &amp;gt; || ? || [ || ]
|- align=center
| \ || _ ||¨ || ¯ || × || ÷ || ← || ↑ || → || ↓ ||∆ || ∇ || ∘ || ∣ || ∧ || ∨
|- align=center
| ∩ || ∪ || ∼ || ≠ || ≤ || ≥ || ≬ || ⊂ || ⊃ || ⌈ ||⌊ || ⊤ || ⊥ || ⋆ || ⌶ || ⌷
|- align=center
| ⌸ || ⌹ || ⌺ || ⌻ || ⌼ || ⌽ || ⌾ || ⌿ || ⍀ || ⍁ || ⍂||⍃ || ⍄ || ⍅ || ⍆ || ⍇
|- align=center
| ⍈ || ⍉ || ⍊ || ⍋ || ⍌ || ⍍ || ⍎ || ⍏ || ⍐ || ⍑ || ⍒ ||⍓ || ⍔ || ⍕ || ⍖ || ⍗
|- align=center
| ⍘ || ⍙ || ⍚ || ⍛ || ⍜ || ⍝ || ⍞ || ⍟ || ⍠ || ⍡ || ⍢ ||⍣ || ⍤ || ⍥ || ⍦ || ⍧
|- align=center
| ⍨ || ⍩ || ⍪ || ⍫ || ⍬ || ⍭ || ⍮ || ⍯ || ⍰ || ⍱ || ⍲ ||⍳ || ⍴ || ⍵ || ⍶ || ⍷
|-align=center
| ⍸ || ⍹ || ⍺ || ⎕ || ○
|}

Tous les caractères APL ne sont pas encore associés à une signification aujourd'hui (2004).

=== Polices APL existantes ===
En mai 2010, les principales polices APL téléchargeables depuis l'Internet sont les suivantes&lt;ref&gt;http://aplwiki.com/AplCharacters#The_.22APL385_Unicode.22_Font&lt;/ref&gt; :
* APL385 Unicode (Dyalog APL)
* APX Upright (MicroAPL APLX)
* Courier APL2 Unicode (IBM APL2)
* SImPL

== Quelques opinions ==
* [[Edsger Dijkstra]]
« APL is a mistake, carried through to perfection. It is the language of the future for the programming techniques of the past: it creates a new generation of coding bums ».

''« APL est une erreur, poussée jusqu'à la perfection. C’est le langage de l’avenir pour les techniques de programmation du passé : il crée une nouvelle génération de fainéants du codage»''.

* Roy Keir
« APL is a write-only language. I can write programs in APL, but I can’t read any of them ».&lt;br /&gt;
''« APL est un langage en écriture seule. Je peux écrire des programmes en APL, mais je ne peux en lire aucun. »''

* Joel Moses 
« APL is like a diamond. It has a beautiful crystal structure; all of its parts are related in a uniform and elegant way. But if you try to extend this structure in any way - even by adding another diamond - you get an ugly kludge ».

''« APL est comme un diamant. Il a une superbe structure cristalline ; toutes ses parties sont en correspondance d’une façon uniforme et élégante. Mais si vous essayez d’étendre cette structure de quelque façon que ce soit — même en y ajoutant un autre diamant — vous obtenez un bricolage hideux »''. (Allusion au passage d’APL à APL2).

* [[Jacques Arsac]]
« Je ne recommanderais pas de mettre rapidement APL entre les mains des étudiants&lt;ref&gt;Interview, ''01 Hebdo''&lt;/ref&gt; ».

== Lacune d’APL ==

APL n’a jamais officiellement connu les [[table associative|tables associatives]], indexant un tableau avec autre chose que des valeurs entières. On ne peut donc pas écrire :

''CAPITALE[⊂'FRANCE']←⊂'PARIS'

ou, pour rester dans le vectoriel,

''CAPITALE['FRANCE' 'ESPAGNE' 'ITALIE']←'PARIS' 'MADRID' 'ROME'''

ce qui est regrettable, car :

# une telle extension ne demanderait que très peu de modification de syntaxe, et n'en demanderait ''aucune'' des programmes existants
# les langages modernes permettent l'indexation par des chaînes de caractères (soit l'indexation des tableaux comme en [[PHP]] qui autorise à écrire ''$capitale['France']='Paris';'', soit via des objets voisins comme les ''[[table de hachage|tables de hachage]]'' en [[Perl (langage)|Perl]]&lt;ref&gt;''$capitale{'France'}='Paris';''&lt;/ref&gt;).
# rares sont les applications où il ne faille pas gérer des accès par symboles plutôt que par numéros. Si APL ne le permet pas de façon immédiate, l’utilisateur se tourne naturellement vers d’autres langages répondant mieux à ses besoins.

Il est peu ergonomique de contourner cette lacune au prix de variables supplémentaires, comme par exemple:
''FRANCE←32'' (dès lors, ''CAPITALE[FRANCE]←⊂&quot;PARIS&quot;''. Si le pays provient d'une saisie, l'indice peut être retrouvé par &quot;execute&quot; : ''⍎&quot;FRANCE&quot;'' qui rend 32, mais l'application perd en robustesse et on encombre inutilement la table des symboles (APL/X contourne la difficulté par des ''namespaces'').

Une autre manière est de définir un vecteur des noms de pays :
''PAYS ←'BELGIQUE' 'FRANCE' '', l'instruction devenant alors :
''CAPITALE[PAYS⍳⊂'FRANCE']←⊂'PARIS' ''

Mais en ce cas, indépendamment de la lisibilité plus faible, le temps d'accès n'a plus le moindre rapport avec un accès direct de type &quot;hash&quot; en [[Perl (langage)|Perl]] ou PHP, surtout si s'il y a des centaines de noms.

Non seulement la lisibilité des programmes n'y gagne rien, mais leur facilité de maintenance s'effondre compte tenu des variables ''surajoutées'' au programme.

== APL, langage cryptique ==

Épargnant l’usage des indices et des boucles en multipliant les opérateurs, APL permet l'écriture rapide et concise d'expressions qui seraient bien plus longues avec un langage classique.  Vue la compacité et la puissance du langage, certains puristes considéraient que pour être « élégant », un programme APL ne devait pas dépasser une ligne de code. Ces programmes, nommés ''one-liners'' dans la revue de l'[[Association for Computing Machinery|ACM]] ''APL Quote-Quad'' étaient les ancêtres des ''deulignes'' de ce qui sera plus tard [[Hebdogiciel]].

Cependant, la multiplicité des glyphes, leur usage unaire ou binaire, les superpositions de caractère sensées les exprimer ont fait qualifier ce langage de ''cryptique''. D'autant que l'absence de mécanismes conditionnels amenait chacun à employer diverses astuces, nuisant à la lisibilité et à la maintenance des applications, sauf à introduire des opérateurs nommés à usage auto-documentaire.

== Succession ==

* Le langage [[R (logiciel)|GNU R]], dans la mesure où il traite lui aussi directement des tableaux et possède des modules graphiques adaptés à la statistique et des interfaces avec les bases de données, peut être considéré comme l'un des successeurs d'APL.
* Le langage [[GNU Octave]], par son traitement aisé des matrices et vecteurs en mode calculateur de bureau, est également envisageable. Ses possibilités graphiques intégrées pallient l'absence de [[GRAPHPAK]].

Ces deux langages, du fait de leur appartenance au projet [[GNU]], sont par ailleurs gratuits.

== Notes et références ==
{{Références}}

== Voir aussi ==
=== PDF gratuit en français ===
* [http://www.afapl.asso.fr/AFAPL_2006_v2.pdf APL vu du ciel], Bernard Legrand, AFAPL, 2006.

=== Vidéos ===
* [https://www.youtube.com/watch?v=a9xAKttWgP4 Jeu de la vie de Conway] utilisant la programmation matricielle d'APL
* [https://www.youtube.com/watch?v=_DTpQ4Kk2wA Introduction à APL]... en 1975 (terminaux à boule sur [[mainframe]])

=== Livres ===
* Bernard  Robinet  ''Le langage APL'' (Editions TECHNIP, 1979)
* Robert Caillibot, Marcel Dupras et Claire Girard ''Programmation en langage APL'' (Les Presses de l'Université Laval, 1981) 
* Stéphane Pommier ''Introduction à A.P.L.'' (Dunod, 1978) 
* {{en}} Kenneth Iverson, ''A Programming Language'', John Wiley and Sons, (1962)
* {{en}} Federico Biancuzzi et Shane Warden, ''Masterminds of Programming, Conversations with the Creators of Major Programming Languages'', O'Reilly, 2009. [chapitre Trois : entretien avec Adin Falkoff]

=== Articles connexes ===

* [[Scilab]]

=== Liens externes ===

* {{en}} [http://vids.myspace.com/index.cfm?fuseaction=vids.individual&amp;videoid=60771080 Les origines d'APL] (vidéo)
* {{fr}} [http://www.afapl.asso.fr/AFAPL_2006_v2.pdf APL vu du Ciel]
* {{en}} http://aplwiki.com/ : Wiki sur APL
* {{fr}} [http://ensmp.net/langlet/transform.html La propagation asymétrique de la parité ou &quot;Transformée de Langlet&quot;]

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]</text>
      <sha1>6om3fqb7eadms7j39q89b1vamtxwxmg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Falcon (langage)</title>
    <ns>0</ns>
    <id>3662401</id>
    <revision>
      <id>90542841</id>
      <parentid>74190956</parentid>
      <timestamp>2013-03-16T23:54:35Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q580448]]</comment>
      <text xml:space="preserve" bytes="854">{{Voir homonymes|Falcon}}
'''Falcon''' est un [[langage de programmation]] de [[langage de script|scripts]] créée par Giancarlo Niccolai. Il supporte différents paradigmes.

== [[Hello world|Hello, world!]] ==

&lt;source lang=&quot;html4strict&quot;&gt;
printl (&quot;Hello, world&quot;)
&lt;/source&gt;


== Liens externes ==
*{{en}} [http://www.falconpl.org/ Site Officiel]
*{{en}} [http://www.freesoftwaremagazine.com/articles/falcon_programming_language_brief_tutorial Un bref tutoriel pour Falcon sur Free Software Magazine]
*{{en}} [http://www.linuxjournal.com/article/10161 Revue de Falcon sur Linux Journal]
*{{en}} [http://www.computerworld.com.au/article/298655/-z_programming_languages_falcon?fp=16&amp;fpid=1 Entrevue avec Giancarlo Niccolai sur Computerworld]

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de script]]</text>
      <sha1>5x6czll033ohhjvykiae4zpq66m8xav</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>YAML</title>
    <ns>0</ns>
    <id>148634</id>
    <revision>
      <id>101612050</id>
      <parentid>101610949</parentid>
      <timestamp>2014-02-26T14:56:03Z</timestamp>
      <contributor>
        <username>Lacrymocéphale</username>
        <id>87136</id>
      </contributor>
      <comment>Annulation des modifications 101610949 de [[Spécial:Contributions/217.128.56.15|217.128.56.15]] ([[User talk:217.128.56.15|d]])</comment>
      <text xml:space="preserve" bytes="9898">'''YAML''', [[acronyme récursif]] de '''YAML Ain't [[Langage de balisage|Markup Language]]''', est un format de représentation de données par [[sérialisation]] [[Unicode]]. Il reprend des concepts d'autres langages comme [[Extensible Markup Language|XML]], ou encore du format de message électronique tel que documenté par [[RFC]] [[RFC 2822|2822]]. YAML a été proposé par [[Clark Evans]] en 2001&lt;ref&gt;[http://tech.groups.yahoo.com/group/sml-dev/message/4710 YAML Draft 0.1], Clark Evans, 11 mai 2001, Yahoo! Tech groups: sml-dev&lt;/ref&gt;, et implémenté par ses soins ainsi que par [[Brian Ingerson]] et [[Oren Ben-Kiki]].

== Caractéristiques ==
L'idée de fond de YAML est que toute donnée peut être représentée par une combinaison de listes, tableaux (de hachage) et données scalaires. YAML décrit ces formes de données (les ''représentations YAML''), ainsi qu'une syntaxe pour présenter ces données sous la forme d'un flux de caractères (le ''flux YAML'').

Une application informatique passe du flux YAML à la représentation YAML par l'opération de ''chargement'' (anglais ''load''). Elle passe de la représentation au flux par l'opération de ''déchargement'' (anglais ''dump'').

La syntaxe du flux YAML est relativement simple et efficace, moins verbeuse que du [[XML]], moins compacte que du [[Comma separated values|CSV]], et a été établie de sorte qu'elle soit le plus lisible possible par des humains, tout en pouvant être mise en correspondance facilement avec les types de données précités, communs dans les langages de haut niveau. À ces langages il emprunte certaines notations.
* Les commentaires sont signalés par le signe dièse (&lt;code&gt;#&lt;/code&gt;) et se prolongent sur toute la ligne.
* Une valeur nulle s'écrit avec le caractère tilde (&lt;code&gt;~&lt;/code&gt;)
* Il est possible d'inclure une syntaxe [[JSON]] dans une syntaxe YAML.
* Les items de listes sont dénotés par le tiret (&lt;code&gt;-&lt;/code&gt;), suivi d'un espace, à raison d'un item par ligne.
* Les tableaux sont de la forme ''clé: valeur'', soit à raison d'un couple par ligne.
* Les scalaires peuvent être entourés de guillemets doubles (&lt;code&gt;&quot;&lt;/code&gt;), ou simples (&lt;code&gt;'&lt;/code&gt;), ou encore être représentés par un bloc indenté avec des modificateurs facultatifs pour conserver (&lt;code&gt;|&lt;/code&gt;) ou éliminer (&lt;code&gt;&gt;&lt;/code&gt;) les retours à la ligne.
* Plusieurs documents rassemblés dans un seul fichier sont séparés par trois traits d'union (&lt;code&gt;---&lt;/code&gt;) ; trois points (&lt;code&gt;...&lt;/code&gt;) optionnels marquent la fin d'un document dans un fichier.
* Les nœuds répétés sont initialement signalés par une esperluette (&lt;code&gt;&amp;&lt;/code&gt;) puis sont référencés avec un astérisque (&lt;code&gt;*&lt;/code&gt;) ; [[JSON]], un langage concurrent de YAML, est compatible avec la syntaxe de [[JavaScript]] mais ne supporte pas cette notion de référence.
* L'indentation, par des espaces, manifeste une arborescence.
* Il est possible de préciser le [[Type (informatique)|type]] (anglais ''Tag'') d'une donnée. Cependant, cette précision n'opère aucune contrainte, et fonctionne plutôt comme un marquage, ou une modélisation.
* Un fichier YAML est analysable en une seule passe de lecture.

La syntaxe YAML se distingue de JSON par le fait qu'il se veut plus facilement lisible par une personne. Il se distingue du XML par le fait qu'il s'intéresse d'abord à la sérialisation de données, et moins à la documentation.

''[[phpMyAdmin]]'' permet l'export des bases [[MySQL]] en YAML, entre autres formats.

== Exemples ==
{{Guide pratique}}

=== Listes ===

&lt;syntaxhighlight lang=&quot;yaml&quot;&gt;
 --- # Films préférés, format bloc
 - Casablanca
 - Bourgogne Casablanca
 - La Règle du jeu
 - Titanic
 --- # Listes de courses, format linéaire
 [lait, pain, œufs]
&lt;/syntaxhighlight&gt;

=== Tableaux associatifs ===

&lt;syntaxhighlight lang=&quot;yaml&quot;&gt;
 --- # bloc
 nom: Paul Dupond
 age: 33
 --- # linéaire
 {nom: Paul Dupond, age: 33}
&lt;/syntaxhighlight&gt;

=== Blocs de mise en forme ===

==== Nouvelles lignes conservées ====

&lt;syntaxhighlight lang=&quot;yaml&quot;&gt;
 --- |
   There was a young fellow of Warwick
   Who had reason for feeling euphoric
       For he could, by election
       Have triune erection
   Ionic, Corinthian, and Doric
&lt;/syntaxhighlight&gt;

==== Nouvelles lignes rassemblées ====

&lt;syntaxhighlight lang=&quot;yaml&quot;&gt;
 --- &gt;
   Le texte ainsi
   séparé sera ensuite
   rassemblé sur
   une seule ligne
 
   Une ligne vide
   signale un nouveau
   paragraphe
&lt;/syntaxhighlight&gt;

=== Listes de tableaux associatifs ===

&lt;syntaxhighlight lang=&quot;yaml&quot;&gt;
 - {name: Paul Dupond, age: 33}
 -
   name: Marie Dupont
   age: 27
&lt;/syntaxhighlight&gt;

=== Tableaux de listes ===

&lt;syntaxhighlight lang=&quot;yaml&quot;&gt;
 homme: [Paul Dupond, Pierre Dubois]
 femme:
   - Marie Dupont
   - Susanne Didier
   - Jean Michel
&lt;/syntaxhighlight&gt;

== Implémentations ==

Des bibliothèques pour YAML existent pour les langages suivants :

; [[ActionScript]]
: [http://code.google.com/p/as3yaml as3yaml] Portage de jvyaml pour Actionscript 3.
; [[C++]]
: [http://git.snoyman.com/cppweb.git?a=blob;f=src/cppmodels/yaml.hpp;h=e67377c792309a51eb5a4c9dac05ba89befd38d6;hb=HEAD surcouche C++ de LibYaml].
: voir aussi la bibliothèque C++ native [http://code.google.com/p/yaml-cpp/ yaml-cpp].
; [[D (langage)|D]]
: [http://dyaml.alwaysdata.net/ D:YAML]
; [[Erlang (langage)|Erlang]]
: [https://github.com/goertzenator/yamler yamler] basé sur LibYAML.
; [[Go (langage)|Go]]
: [http://code.google.com/p/goyaml/ goyaml] basé sur LibYAML mais réécrit entièrement en Go.
; [[Haskell]]
: [http://ben-kiki.org/oren/YamlReference/ YamlReference] implémentation de la syntaxe YAML et utilitaires.
: [http://hackage.haskell.org/package/yaml/ yaml] encapsulation de LibYAML.
: [http://hackage.haskell.org/package/HsSyck HsSyck] interface de SYCK.
: [http://hackage.haskell.org/package/json2yaml/ json2yaml] conversion.
; [[Java (langage)|Java]]
: [https://jvyaml.dev.java.net/ jvyaml] basé sur Syck API, et inspiré RbYAML.
: [http://jyaml.sourceforge.net/ JYaml] petite impleméntation en Java natif.
: [http://www.snakeyaml.org/ SnakeYAML] YAML 1.1 pour Java 5.
; [[JavaScript]]
: [https://github.com/nodeca/js-yaml JS-YAML] Réecriture native de PyYAML. Le parseur YAML 1.1+ le plus complet en JS.
: [https://github.com/visionmedia/js-yaml CommonJS js-yaml] Sous-ensemble réduit de YAML.
: [http://code.google.com/p/javascript-yaml-parser/ javascript-yaml-parser].
: [http://stackoverflow.com/questions/428364/pure-javascript-yaml-library-that-supports-both-dump-and-load jsyaml code on stackoverflow].
; [[Lua (langage)|Lua]]
: [http://github.com/indeyets/syck/tree/master/ext/lua Lua-Syck].
: [http://yaml.luaforge.net yaml] Encapsulation de LibYAML.
; [[.NET Framework]]
: [http://yaml-net-parser.sourceforge.net/ Yaml Library for .NET (C#)].
: [http://www.codeproject.com/KB/recipes/yamlparser.aspx YAML Parser in C#] Une implémentation presque complète de YAML. Écrit en C#.
: [http://www.codeplex.com/yaml YAML for .NET, Visual Studio and Powershell].
; [[OCaml]]
: [http://sourceforge.net/projects/ocaml-syck/ OCaml-Syck].
; [[Objective-C]]
: [http://github.com/mirek/YAML.framework YAML.framework] basé sur LibYAML.
: [http://github.com/indeyets/syck/tree/master/ext/cocoa syck/ext/cocoa].
; [[Perl (langage)|Perl]]
: [http://metacpan.org/release/YAML YAML] interface vers plusieurs parseurs YAML.
: [http://metacpan.org/release/YAML-Tiny/ YAML::Tiny] implémente un sous-ensemble utilisable de YAML; petit, en  Perl pur, et plus rapide que l'implémentation complète.
: [http://metacpan.org/release/YAML-Syck/ YAML::Syck] Encapsulation de la bibliothèque C SYCK, complète et rapide.
: [http://metacpan.org/release/YAML-LibYAML/ YAML::XS] Encapsulation de LibYaml. Meilleure compatibilité YAML 1.1.
: [http://metacpan.org/module/YAML::Any YAML::Any] Détecte la meilleure implémentation YAML et l'encapsule avec l'API standard YAML.
; [[PHP]]
: [http://code.google.com/p/spyc/ Spyc] implémentation en pur PHP.
: [http://pecl.php.net/package/syck PHP-Syck] (encapsulation de la bibliothèque SYCK).
: [http://symfony.com/doc/current/components/yaml.html Symfony YAML Component] issu du framework [[Symfony]].
: [http://pecl.php.net/package/yaml PECL Yaml] (encapsulation de la bibliothèque LibYAML).
; [[Python (langage)|Python]]
: [http://pyyaml.org/ PyYaml] Très complète. Python natif ou au choix utilise LibYAML.
: [http://pyyaml.org/wiki/PySyck PySyck] Encapsulation de la bibliothèque SYCK.
; [[Ruby (langage)|Ruby]]
: (YAML est en standard, depuis la version 1.8, basé sur SYCK)
: [http://rubyforge.org/projects/ya2yaml/ Ya2YAML] avec support [[UTF-8]] complet.
: [http://github.com/hallettj/zaml/tree/master ZAML] nettement plus rapide que l'implémentation standard.
: [http://rbyaml.rubyforge.org/ RbYAML] Parseur en Ruby natif.
; [[R (langage)|R]]
: [http://biostat.mc.vanderbilt.edu/twiki/bin/view/Main/YamlR CRAN YAML] (encapsulation de la bibliothèque LibYAML).
; [[Scala (langage)|Scala]]
: [https://github.com/yaml/scala-yaml scala-yaml].
; [[Tcl]]
: [http://tcllib.sourceforge.net/doc/yaml.html Disponible en Tcl 8.4].
; [[Extensible Markup Language|XML]]
: [http://yaml.org/xml.html YAXML] (non finalisé).

== Notes et références ==
&lt;references/&gt;

== Voir aussi ==

=== Liens externes ===
* [http://www.yaml.org Site officiel]
* {{en}} [http://yaml4r.sourceforge.net/cookbook/ YAML Cookbook]
* {{en}} [http://code.google.com/p/snakeyaml/ Implémentation en Java]
* {{fr}} [http://www.symfony-project.org/reference/1_4/fr/02-YAML Le format YAML] dans ''The symfony Reference Book'', ou le format YAML expliqué aux développeurs PHP.
* {{fr}} [http://sweetohm.net/html/introduction-yaml.html Une bonne introduction à YAML]

{{Portail|programmation informatique}}

{{DEFAULTSORT:Yaml}}
[[Catégorie:Langage de programmation]]
[[Catégorie:Format de sérialisation de données]]</text>
      <sha1>g74v196u6ixkkjmoo066uhuxzppv2o1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>IronRuby</title>
    <ns>0</ns>
    <id>4004355</id>
    <revision>
      <id>97087247</id>
      <parentid>97087177</parentid>
      <timestamp>2013-09-29T09:51:11Z</timestamp>
      <contributor>
        <username>B-root</username>
        <id>20627</id>
      </contributor>
      <comment>/* Liens */</comment>
      <text xml:space="preserve" bytes="9882">{{Ébauche|informatique}}

{{Infobox Langage de programmation
| nom                             = IronRuby
| développeur                     = [[Microsoft]] [[Dynamic Language Runtime]] Team
| dernière version stable         = IronRuby 1.1.3
| date de dernière version stable = {{Date|13|mars|2011|en informatique}}
| système d'exploitation          = [[Multiplate-forme]]
| implémentation                  = [[Microsoft .NET|.NET]]
| licence                         = [[Shared source|Microsoft Public License]] 
| site web                        = [http://ironruby.net/ IronRuby.net]
}}

'''IronRuby''' est une implémentation de l'interpréteur du [[Ruby|langage de programmation Ruby]] visant le [[.NET Framework]] de [[Microsoft]]. C'est une surcouche au [[Dynamic Language Runtime|DLR]], une bibliothèque se superposant au [[Common Language Runtime|CLR]] 2.0 qui fournit, entre autres, un [[typage dynamique]] et la délégation dynamique des méthodes pour les [[Langage de programmation dynamique|langages dynamiques]].

== Histoire ==

Le 30 avril 2007, à la [[:en:MIX (Microsoft)|conférence MIX]] 2007, Microsoft dévoila IronRuby, qui utilise le même nom que le projet de Wilco Bauwer, avec l'accord de ce dernier&lt;ref&gt;{{lien web | url = http://www.wilcob.com/Wilco/IronRuby/microsoft_ironruby.aspx | titre = Microsoft's Iron Ruby | auteur = Wilco Bauwer | en ligne le = 2007-07-24}}&lt;/ref&gt;. Sa sortie publique était annoncée pour l'[[O'Reilly Open Source Convention|OSCON]] 2007&lt;ref&gt;{{lien web | url = http://www.iunknown.com/2007/05/microsoft_and_i.html | titre = Microsoft and IronRuby | auteur = John Lam | en ligne le = 2007-06-18}}&lt;/ref&gt;.

Le 23 juillet 2007, comme prévu, John Lam et la DLR Design Team présentèrent la version pré-Alpha du compilateur IronRuby à l'[[OSCON]]. Il annonça également une intégration rapide de IronRuby au sein de la communauté open source&lt;ref&gt;{{lien web | url = http://www.iunknown.com/2007/07/a-first-look-at.html | titre = A First Look at IronRuby | auteur = John Lam | en ligne le = 2007-07-23}}&lt;/ref&gt;.

Le 31 août 2007, John Lam et la DLR Design Team publièrent le code (au stade de [[Version alpha|version pre-alpha]]) sur RubyForge&lt;ref&gt;{{lien web 
|url = http://www.iunknown.com/2007/08/ironruby-on-rub.html 
|titre = IronRuby on Rubyforge! 
|citation = ''Today, you must check the source code out of the IronRuby Subversion repository on Rubyforge. You will need a Subversion client; we recommend TortoiseSVN. To build the sources from the command line, you must also have Ruby installed on your computer already''
| en ligne le = 2007-08-31}}&lt;/ref&gt;. Le code source a été mis à jour régulièrement par l'équipe de Microsoft. L'équipe n'accepte pas les contributions de la part de la communauté concernant le noyau de la bibliothèque [[Dynamic Language Runtime|DLR]], du moins pour le moment&lt;ref&gt;{{lien web 
|url = http://rubyforge.org/pipermail/ironruby-core/2008-April/001507.html
|titre = Regarding IronRuby... How true it sounds from this blog
|citation = ''The DLR is does not accept contributions from the community (...) Today we do not push to SVN on every successful SNAP check-in''
|date = 2008-04-29
|en ligne le = 2008-05-25}}&lt;/ref&gt;.

Le 24 juillet 2008, la IronRuby team publia la première version alpha exécutable, dévoilée pour l'[[O'Reilly Open Source Convention|OSCON]] 2008&lt;ref&gt;{{lien web 
|url = http://www.iunknown.com/2008/07/ironruby-at-oscon.html
|titre = IronRuby at OSCON
|citation = ''We’re shipping our first binary release. In this package, we’re taking a “batteries included” approach and shipping the Ruby standard libraries in it''
|date=2008-07-24
|en ligne le = 2008-08-04}}&lt;/ref&gt;. Le 19 novembre 2008, une seconde version alpha vit le jour. 

L'équipe de développement travailla activement sur le support de [[Ruby on Rails|Rails]] par IronRuby&lt;ref&gt;{{lien web 
|url = http://en.oreilly.com/rails2008/public/schedule/detail/2056
|titre = IronRuby on Rails
|en ligne le = 2008-05-25}}&lt;/ref&gt;{{,}}&lt;ref&gt;{{lien web 
|url = http://rubyforge.org/pipermail/ironruby-core/2008-May/001911.html
|titre = IronRuby r112 is out
|date=2008-05-24
|en ligne le = 2008-05-25}}&lt;/ref&gt;. Quelques tests fonctionnels de Rails donnent des résultats, mais il y a encore beaucoup de travail à faire avant de pouvoir utiliser Rails dans un environnement de production&lt;ref&gt;{{lien web 
|url = http://rubyforge.org/pipermail/ironruby-core/2008-May/001909.html
|titre = IronRuby / Rails Question
|citation = ''I don't think we're near the end game yet :) We're barely able to run Rails functional tests now, and there's a lot more library work to be done before we can start thinking about deployment''
|date=2008-05-25
|en ligne le = 2008-05-25}}&lt;/ref&gt;.

Le 21 mai 2009, ils publièrent la version 0.5 lors de la RailsConf 2009. Cette version de IronRuby peut exécuter des applications [[Ruby on Rails|Rails]], mais pas encore dans un environnement de production&lt;ref&gt;{{lien web 
|url = http://blog.jimmy.schementi.com/2009/05/ironruby-at-railsconf-2009.html
|titre = IronRuby at RailsConf 2009
|citation = ''IronRuby running Rails is not new, but doing it well or completely – is. IronRuby can now run real Rails applications, rather than just toy-hello-world examples. This does not mean IronRuby on Rails is ready for production, but it’s a great measure of forward progress''
|date=2008-05-25
|en ligne le = 2008-05-25}}&lt;/ref&gt;.

L'annonce de la version 1.0 est attendue pour l'OSCON 2009&lt;ref&gt;{{lien web 
|url = http://en.oreilly.com/oscon2009/public/schedule/detail/7965
|titre = IronRuby 1.0 at OSCON 2009
|date = 2009-06-15
|en ligne le = 2009-06-15}}&lt;/ref&gt;. La version 0.9 a été publiée le {{1er}} août 2009&lt;ref&gt;{{lien web
| url=http://ironruby.codeplex.com/Release/ProjectReleases.aspx?ReleaseId=30914#ReleaseFiles
| titre=IronRuby - Release: 0.9.0}}&lt;/ref&gt;.

== Prise en charge par Mono ==

Normalement, IronRuby s'exécute aussi bien sur [[Mono (logiciel)|Mono]] que sur le [[Common Language Runtime|CLR]] de Microsoft, mais comme l'équipe de développement ne l'a testé qu'avec le CLR s'exécutant sur [[Microsoft Windows|Windows]]&lt;ref&gt;{{lien web
| url=http://rubyforge.org/pipermail/ironruby-core/2008-August/002553.html
| titre=IronRuby and Mono
| date=2008-08-06
| en ligne le=2008-09-13}}&lt;/ref&gt;, il pourrait ne pas être supporté par Mono suivant l'architecture&lt;ref name=&quot;Mono_Sep2008&quot;&gt;{{lien web
| url=http://rubyforge.org/pipermail/ironruby-core/2008-September/002787.html
| titre=IronRuby and Mono
| date=2008-09-04
| en ligne le=2008-09-13}}&lt;/ref&gt;{{,}}&lt;ref&gt;{{lien web
| url=http://rubyforge.org/pipermail/ironruby-core/2009-January/003654.html
| titre=DLR Daily Builds (including IronRuby)
| date=2009-01-23
| en ligne le=2009-01-23}}&lt;/ref&gt;{{,}}&lt;ref name=&quot;Mono_Sep2008&quot;/&gt;{{,}}&lt;ref&gt;{{lien web
| url=http://rubyforge.org/pipermail/ironruby-core/2009-May/004638.html
| titre=mono builds
| date=2009-05-26
| en ligne le=2009-06-05}}&lt;/ref&gt;.

== Interopérabilité vis-à-vis de .NET ==

L'interopérabilité entre les classes d'IronRuby et les classes habituelles du [[.NET Framework]] est plutôt limitée pour le moment car de nombreuses classes de Ruby ne sont pas des classes de .NET&lt;ref&gt;{{lien web
| url=http://rubyforge.org/pipermail/ironruby-core/2008-December/003390.html
| titre=Xna+IronRuby+RubyNewb=headache
| date=2008-12-16
| en ligne le=2008-12-20}}&lt;/ref&gt;. Cependant, un meilleur support des langages dynamiques dans [[.NET Framework#.NET Framework 4.0|.NET 4.0]] pourrait accroître l'interopérabilité à l’avenir&lt;ref&gt;{{lien web
| url=http://rubyforge.org/pipermail/ironruby-core/2008-December/003378.html
| titre=WPF databinding with ruby objects
| date=2008-12-12
| en ligne le=2008-12-13}}&lt;/ref&gt;.

== Exemple ==

&lt;source lang=&quot;ruby&quot; line&gt;
require 'mscorlib'
require 'System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'
require 'System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'

Application = System::Windows::Forms::Application
Form = System::Windows::Forms::Form
MessageBox = System::Windows::Forms::MessageBox
Button = System::Windows::Forms::Button
Point = System::Drawing::Point

class MyForm &lt; Form

  def initialize
    self.text = &quot;My .NET Form from Ruby&quot;

    @button = Button.new
    @button.location = Point.new 150, 150
    @button.text = &quot;Click Me!&quot;

    my_click_handler = Proc.new {|sender, e| MessageBox.show 'Hello from Ruby!'}
    @button.click(&amp;my_click_handler)

    self.controls.add @button
  end
end

my_form = MyForm.new
Application.run my_form
&lt;/source&gt;

== Licence ==

IronRuby est disponible sous la [[Shared source|Microsoft Public License]], certifiée par l'[[Open Source Initiative]]&lt;ref&gt;{{lien web
| url=http://www.opensource.org/licenses/ms-pl.html
| titre=Microsoft Public License (Ms-PL)}}&lt;/ref&gt;.

== Voir aussi ==

* [[JRuby]]
* [[IronPython]]

== Références ==

{{références|colonnes=2}}

== Liens ==

* {{en}} {{ lien mort archive | url=http://www.ironruby.net | titre=Site officiel du projet IronRuby | date = 20130807040637}}
* {{en}} [http://ironruby.codeplex.com/ IronRuby] sur [[CodePlex]]
* {{en}} [https://github.com/IronLanguages/main/ Code Source d'IronRuby]
* {{en}} [http://blogs.msdn.com/somasegar/archive/2007/04/30/mix-07-silverlight-shines-brighter.aspx Article du blog de S. Somasegar annonçant Iron Ruby]
* {{en}} {{ lien brisé | url=http://rubyconf2007.confreaks.com/d2t1p1_state_of_ironruby.html | titre=Etat de l'art d'Iron Ruby }} par John Lam à la RubyConf 2007
* {{en}} [http://channel9.msdn.com/pdc2008/TL44/ IronRuby: Le bon langage pour la bonne tâche] by John Lam à la conférence PDC2008

{{Portail|programmation informatique}}

[[Catégorie:.NET Framework]]
[[Catégorie:Ruby|*]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]</text>
      <sha1>j1qfkclil0aukxfrebdkn8iudmutuar</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Command LIST</title>
    <ns>0</ns>
    <id>545298</id>
    <revision>
      <id>89991171</id>
      <parentid>82342652</parentid>
      <timestamp>2013-03-13T15:19:15Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q579880]]</comment>
      <text xml:space="preserve" bytes="2011">'''Command LIST''', le plus souvent appelé simplement '''CLIST''', est un langage de [[programmation procédurale]] que l'on retrouve essentiellement sur le système d'exploitation [[Multiple Virtual Storage|MVS]] des [[grand Système IBM|grands systèmes IBM]], en particulier sous [[Time Sharing Option|TSO]] et TSO/[[ISPF]].

Bien qu'exécutable en [[ligne de commande]] ou en mode [[traitement par lots]] (''batch''), sa principale utilité est de permettre le développement d'applications interactives. 

Sous sa forme basique, une CLIST est juste une simple liste de commandes devant être exécutées dans l'ordre précis (comme un [[traitement par lots]]).

Une CLIST peut aussi lire/écrire des fichiers MVS, réaliser une lecture/écriture sur un terminal TSO et possède les instructions normales de bloc (IF/ELSE  DO/END). Elle peut lire des variables passées en paramètre et a également une fonction pour garder des variables globales et les passer d'une CLIST à l'autre.

CLIST est un [[langage interprété]]. C'est-à-dire que l'ordinateur doit traduire un programme en CLIST chaque fois que celui-ci est exécuté. Les CLIST tendent donc à être beaucoup plus lents que des programmes écrits en langages compilés tels que [[COBOL]], [[Fortran]] ou [[PL/I]] (un programme écrit en langage compilé est traduit une seule fois pour créer un exécutable qui sera lancé par la suite).

Langage très lourd à première vue, il comporte de grandes similitudes avec [[REXX]]. Il est donc recommandé de commenter abondamment les CLIST, notamment en cas d'utilisation de code REXX dans le script.

Quelques mots sur la syntaxe :

Cet exemple :
&lt;pre&gt;
DO I=1 TO 5
SAY 'Bonjour'
END  
&lt;/pre&gt;
peut être valable aussi bien en CLIST qu'en [[REXX]]

== Fonctionnalités ==
# exécution en mode interactif ou par lots
# mode débogage très verbeux

{{Portail|informatique|programmation informatique}}
{{DEFAULTSORT:CLIST}}
[[Catégorie:Grand Système IBM]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>0i075993ed4282lzp928n30nwrl3ceo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Reia</title>
    <ns>0</ns>
    <id>4011245</id>
    <revision>
      <id>90596390</id>
      <parentid>62406876</parentid>
      <timestamp>2013-03-17T08:47:38Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3423741]]</comment>
      <text xml:space="preserve" bytes="1903">'''Reia''' est un [[langage de programmation]] [[Programmation concurrente|concurrent]] [[Programmation orientée objet|orienté objet]] pour la [[machine virtuelle]] [[Erlang (langage)|Erlang]].

Reia supporte différents [[paradigme (programmation)|paradigmes]] dont : la [[programmation impérative]] la [[programmation orientée objet]], la [[programmation fonctionnelle]], la [[programmation déclarative]] et la [[programmation concurrente]].
Ce langage utilise le [[modèle d'acteur]] pour la concurrence, de manière à fonctionner avec son système d'objets.
Son typage est [[typage dynamique|dynamique]], et gère la mémoire de manière automatique (via un [[Ramasse-miettes (informatique)|ramasse-miettes]]).

Ce langage est proche, par différents aspects, de l'[[Erlang (langage)|Erlang]], du [[Ruby]] et du [[Python (langage)|Python]].

==Voir aussi==
* [[Programmation concurrente]]
* [[Calcul distribué|Programmation distribuée]]
* [[Erlang (langage)|Erlang]]

==Liens externes==
*{{en}} [http://reia-lang.org/ Site officiel]
*{{en}}  Interview du créateur de Reia, Tony Arcieri : [http://erlanginside.com/interview-with-reia-creator-tony-arcieri-on-erlang-reia-python-and-rails-48 Partie I], [http://erlanginside.com/interview-with-tony-arcieri-on-reia-and-erlang-part-ii-59 Partie II]
*{{en}} [http://debasishg.blogspot.com/2008/06/targeting-beam-for-extreme-reliability.html Article : Targeting BEAM for extreme reliability]
*{{en}} [http://erlanginside.com/reia-brings-scripting-to-erlang-34 Reia comme langage de script pour Erlang]
*{{en}} [http://lambda-the-ultimate.org/node/3018 Reia: Python/Ruby style language on top of Erlang]

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]
[[Catégorie:Langage fonctionnel]]
[[Catégorie:Programmation concurrente]]</text>
      <sha1>e3v4fcyg4jv4sm7tbad3fpzckcsd5i9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MUMPS</title>
    <ns>0</ns>
    <id>4028420</id>
    <revision>
      <id>91247655</id>
      <parentid>91157850</parentid>
      <timestamp>2013-03-24T21:40:04Z</timestamp>
      <contributor>
        <username>Rome2</username>
        <id>1347469</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.24 - [[P:CS|Correction syntaxique]] - Orthographe et typographie</comment>
      <text xml:space="preserve" bytes="2342">{{ébauche|informatique}}
{{à wikifier|date= mars 2013}}

{{Infobox Langage de programmation
| nom                           = MUMPS
| paradigme                  = [[Programmation procédurale|procédural]]
| année                         = [[1966]]
| auteur                         = [[Neil Pappalardo]]
| typage                        = [[Typage fort|faible]]
| influencé par               = [[JOSS]]
| système d'exploitation = [[Multiplate-forme]]
}}

'''MUMPS''' ('''M'''assachusetts General Hospital '''U'''tility '''M'''ulti-'''P'''rogramming '''S'''ystem), est un langage de programmation développé par Neil Pappalardo dans le laboratoire vétérinaire du {{Dr}} Octo Barnett à l'hôpital général du Massachusetts de Boston entre 1966 et 1967 afin de produire des applications de gestion de bases des données multi-utilisateur. Il fut beaucoup utilisé dans le domaine de la santé mais également dans les systèmes d'informations du monde de la finance entre 1970 et 1980.

==Caractéristiques du langage==
MUMPS est un langage conçu pour le développement l'application utilisatrice de base de données, {{pourquoi|leur utilisation est ainsi transparente.}} {{évasif|À l'origine}}, MUMPS est un langage interprété, {{lesquels|il existe toutefois des moyens de compiler totalement ou partiellement le code}}.

Dans MUMPS, il n'y a {{lequel|qu'un seul type de donnée}} qui est ensuite interprété en chaine de caractères, en entier ou en flottant selon le contexte. Il ne s'agit pas d'un langage faiblement typé mais bien d'un langage non-typé ou plutôt mono-typé. Ainsi, MUMPS n'associe pas les types de données. De cette façon, un nombre peut-être traité comme une chaîne de caractères et une chaîne de caractères peut être traitée comme un nombre avec les opérateurs numériques.

Le typage est dynamique. Les variables ne sont pas déclarées, elles sont créées lors de leur première référence dans le code.

Les commandes et fonctions principales ne sont pas sensibles à la casse. Par contre, les nom des variables et les labels le sont.

Détails important, dans MUMPS, il n'y a pas de mot réservé: Le code est interprété selon le contexte.


{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Norme ISO]]</text>
      <sha1>nb4nu9x3o32snx25mot1bp6gt78g7q3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NCL (langage)</title>
    <ns>0</ns>
    <id>3982522</id>
    <revision>
      <id>100579853</id>
      <parentid>100537977</parentid>
      <timestamp>2014-01-25T10:03:15Z</timestamp>
      <contributor>
        <username>Roll-Morton</username>
        <id>1333940</id>
      </contributor>
      <minor/>
      <comment>Changement rapide de {{portail}} : - informatique théorique , + informatique ; avec [[Projet:JavaScript/Notices/BandeauxPortails|BandeauxPortails]]</comment>
      <text xml:space="preserve" bytes="4875">{{Infobox Langage de programmation
 | nom                    = &lt;!-- NCL --&gt;
 | année                  = 1987
 | développeur            = Nat System
 | paradigme              = [[Programmation événementielle|Programmation évènementielle]]
 | typage                 = [[Typage statique|Statique]], [[Typage fort|fort]]
 | influencé par          = [[C (langage)|C]]/[[C++]] 
 | système d'exploitation = [[Microsoft Windows]]
 | site web               = [http://www.natsystem.fr/ www.natsystem.fr]
}}

'''NCL''' ([[sigle]] de '''''Nat System’s Command Language'''''&lt;ref&gt;http://www.natsystem.fr/actualites/produits/cible-java.html#contenu&lt;/ref&gt;) est un [[L4G|langage de programmation de 4{{e}} génération]], créé par [[Nat System]] pour l'[[Environnement de développement intégré]] [[NSDK]] et plus tard utilisé dans [[Natstar]].

== Présentation ==
{{...}}

== Syntaxe ==
=== Mots réservés, primitifs et littéraux ===
{{...}}
=== Structures de contrôle ===
==== Les collections d'objets ====
{{...}}
==== Boucles ====
Bien qu’elles aient toutes un rôle similaire, chaque boucle est pourtant adaptée à une situation :

* Structure '''tant que''' (adaptée pour effectuer des opérations tant qu’une condition n’est pas rencontrée) :
&lt;source lang=&quot;autoit&quot;&gt;
While &lt;expression booléenne&gt;
  instruction(s)
EndWhile
&lt;/source&gt;
* Structure '''faire … tant que''' (adaptée pour effectuer des opérations qui demandent le même état d’origine à chaque itération) :
&lt;source lang=&quot;autoit&quot;&gt;
Repeat
  instruction(s)
Until &lt;expression booléenne&gt;
&lt;/source&gt;
Boucle sans condition au début ou à la fin (quand la condition est au milieu des traitements):
&lt;source lang=&quot;autoit&quot;&gt;
Loop
  instruction(s)
  If &lt;expression booléenne&gt;
    instruction(s)
    Break
  EndIf
  instruction(s)
EndLoop
&lt;/source&gt;

* Structure '''pour''' (adaptée lorsqu'une collection doit être parcourue en totalité pour traitement) :
&lt;source lang=&quot;autoit&quot;&gt;
For &lt;expression de type numérique&gt; = &lt;valeur de début&gt; To &lt;valeur de fin&gt; Step &lt;expression d’incrémentation&gt;
  Instruction(s)
EndFor
&lt;/source&gt;

==== Structures conditionnelles ====
Structure si : condition simple
&lt;source lang=&quot;autoit&quot;&gt;
If &lt;expression booléenne&gt;
  instruction(s)
EndIf
&lt;/source&gt;

Structure si … sinon : condition avec alternative unique
&lt;source lang=&quot;autoit&quot;&gt;
If &lt;expression booléenne&gt;
  instruction(s)
Else
  instruction(s)
EndIf
&lt;/source&gt;

Structure si … ou si … ou si … : condition avec alternatives multiples
&lt;source lang=&quot;autoit&quot;&gt;
If &lt;expression booléenne&gt;
  instruction(s)
ElseIf &lt;expression booléenne&gt;
  instruction(s)
ElseIf &lt;expression booléenne&gt;
  instruction(s)
Else
  instruction(s)
EndIf
&lt;/source&gt;

Structure atteindre … cas x … cas y …&quot; : embranchement vers un bloc d’instructions énuméré
&lt;source lang=&quot;autoit&quot;&gt;
Evaluate &lt;expression&gt;
  Where &lt;expression&gt;
    instruction(s)
  EndWhere 
  Where &lt;expression1&gt;, &lt;expression2&gt; To &lt;expression3&gt;, &lt;expression4&gt;
    instruction(s)
  EndWhere 
  [...]
Else
  instruction(s)
EndEvaluate
&lt;/source&gt;

&lt;tt&gt;Evaluate&lt;/tt&gt; fonctionne avec les types entiers, flottants et chaîne (attention, &quot;A&quot; ≠ &quot;a&quot;). Les expressions dans les &lt;tt&gt;Where&lt;/tt&gt; peuvent être arbitrairement complexes, mais le code est plus efficace quand on utilise uniquement une expression entière dans l'&lt;tt&gt;Evaluate&lt;/tt&gt; et de simples constantes littérales entières (12, $7F) en évitant les grands intervalles (n1 To n2 quand n2 - n1 &gt;= 16) dans les &lt;tt&gt;Where&lt;/tt&gt;.

La commande &lt;tt&gt;Break&lt;/tt&gt; sort immédiatement de la boucle en cours (&lt;tt&gt;For&lt;/tt&gt;, &lt;tt&gt;While&lt;/tt&gt;, &lt;tt&gt;Repeat&lt;/tt&gt; ou &lt;tt&gt;Loop&lt;/tt&gt;), même si elle apparaît dans un &lt;tt&gt;Evaluate&lt;/tt&gt;.

De même, &lt;tt&gt;Continue&lt;/tt&gt; ramène au début de la boucle (en passant à l'itération suivante dans le cas d'une boucle For).

Les instructions &lt;tt&gt;Exit&lt;/tt&gt; ou &lt;tt&gt;Return&lt;/tt&gt; font quitter fonction, instruction ou évènement, en retournant la valeur par défaut (0, 0.0 ou &quot;&quot;) selon le type retourné dans le cas des fonctions et évènements.

Avec &lt;tt&gt;Return uneValeur&lt;/tt&gt;, uneValeur sera renvoyée à la méthode appelante (si l'on est dans une fonction ou un évènement appelé par Send avec variable de retour).

=== Exemples ===

'''Fonction qui retourne l’aire d’un cercle :'''
&lt;source lang=&quot;autoit&quot;&gt;
Function AireDuCercle#(Num Rayon) Return Num
	Return 3.14159265 * Rayon * Rayon ; Il est possible d'utiliser la valeur PI# qui est définie dans NSMATH.NCL
EndFunction

Message &quot;AireDuCercle&quot;, &quot;L'aire d'un cercle de rayon 2.4cm est :&quot; &amp;&amp; String$(AireDuCercle#(2.4)) &amp;&amp; &quot;cm².&quot;
&lt;/source&gt;

La dernière ligne de l'exemple ci-dessus va afficher une fenêtre ayant pour titre &quot;AireDuCercle&quot; et pour contenu la phrase : &quot;L'aire d'un cercle de rayon 2.4cm est 18.0864 cm².&quot;

== Notes et références ==
{{Références}}

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>3ffibpu27e9a0hhrgqa56otzo0ykanq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Simple (programmation)</title>
    <ns>0</ns>
    <id>4008341</id>
    <revision>
      <id>95931748</id>
      <parentid>46394996</parentid>
      <timestamp>2013-08-19T15:09:17Z</timestamp>
      <contributor>
        <username>PAC2</username>
        <id>675122</id>
      </contributor>
      <comment>tentative</comment>
      <text xml:space="preserve" bytes="370">{{orphelin|date=août 2009|tentative=août 2013}}
{{Ébauche|informatique}}
'''Simple''' est un langage de programmation de [[Google]] pour [[Android]].
Il est inspiré du [[BASIC]]. 
== Lien externe ==
* {{en}} [http://code.google.com/p/simple/ Site officiel]

{{Portail|programmation informatique|Google}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Google]]</text>
      <sha1>14wa4jeogf9vmfujkw2tfj0zm9v9i0y</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Python (langage)</title>
    <ns>0</ns>
    <id>2340</id>
    <revision>
      <id>101378536</id>
      <parentid>101361332</parentid>
      <timestamp>2014-02-18T20:44:25Z</timestamp>
      <contributor>
        <ip>212.243.229.186</ip>
      </contributor>
      <comment>/*  Grammaire */</comment>
      <text xml:space="preserve" bytes="56415">{{Voir homonymes|Python}}
{{Infobox Langage de programmation
 | couleur boîte = 3778ae
 | nom et logo = oui
 | nom = {{blanc|Python}}
 | logo = Python logo.svg
 | paradigmes = [[Programmation orientée objet|Objet]], [[Programmation impérative|impératif]]
 | année = [[1990]]
 | auteur = [[Guido van Rossum]]
 | développeurs = [[Python Software Foundation]]
 | typage = [[Typage fort|Fort]], [[Typage dynamique|dynamique]]
 | implémentations = [[CPython]], [[Jython]], [[IronPython]], [[PyPy]]
 | dialectes = 
 | influencé par = [[ABC (langage)|ABC]], [[C (langage)|C]], [[Eiffel (langage)|Eiffel]], [[ICON]], [[Modula-3]], [[Java (langage)|Java]]&lt;ref&gt;http://www.python.org/dev/peps/pep-0318/&lt;/ref&gt;, [[Perl (langage)|Perl]], [[Smalltalk]], [[Tool Command Language|Tcl]]
 | a influencé = [[Ruby]], [[Groovy (langage)|Groovy]], [[Boo (langage)|Boo]]
 | système d'exploitation = [[Multiplate-forme]]
 | licence = [[Python Software Foundation License]]
 | site web = [http://www.python.org/ www.python.org]
}}

'''Python''' est un [[langage de programmation]] [[Programmation orientée objet|objet]], multi-[[paradigme (programmation)|paradigme]] et [[Plate-forme (informatique)|multi-plateformes]]. Il favorise la [[programmation impérative]] structurée et [[Programmation orientée objet|orientée objet]]. Il est doté d'un [[typage dynamique]] [[typage fort|fort]], d'une gestion automatique de la mémoire par [[ramasse-miettes (informatique)|ramasse-miettes]] et d'un [[système de gestion d'exceptions]] ; il est ainsi similaire à [[Perl (langage)|Perl]], [[Ruby]], [[Scheme]], [[Smalltalk]] et [[Tool Command Language|Tcl]].

Le langage Python est placé sous une [[licence libre]] proche de la [[licence BSD]]&lt;ref&gt;[http://www.python.org/psf/license/ Python License]&lt;/ref&gt; et fonctionne sur la plupart des plates-formes informatiques, des [[supercalculateur]]s aux [[Ordinateur central|ordinateurs centraux]], de [[Windows]] à [[Unix]] en passant par [[GNU]]/[[Linux]], [[Mac OS]], ou encore [[Android]], [[iOS (Apple)|iOS]], et aussi avec [[Java (langage)|Java]] ou encore [[Microsoft .NET|.NET]]. Il est conçu pour optimiser la productivité des programmeurs en offrant des outils de [[Langage de haut niveau|haut niveau]] et une syntaxe simple à utiliser.

Il est également apprécié par les pédagogues qui y trouvent un langage où la syntaxe, clairement séparée des mécanismes de [[Langage de bas niveau|bas niveau]], permet une initiation plus aisée aux concepts de base de la programmation&lt;ref&gt;{{en}} [http://www.greenteapress.com/thinkpython/thinkCSpy/html/preface.html « il faut treize paragraphes pour expliquer un ''Hello, World!'' en C++, seulement deux en Python »]&lt;/ref&gt;.

== Utilisations ==
Python est un [[Langage de programmation|langage]] qui peut s'utiliser dans de nombreux contextes et s'adapter à tout type d'utilisation grâce à des bibliothèques spécialisées. Il est cependant particulièrement utilisé comme [[langage de script]] pour automatiser des tâches simples mais fastidieuses comme par exemple un script qui récupérerait la météo sur Internet ou qui s'intégrerait dans un logiciel de [[conception assistée par ordinateur]] afin d'automatiser certains enchaînements d'actions répétitives. On l'utilise également comme langage de développement de prototype lorsqu'on a besoin d'une application fonctionnelle avant de l'optimiser avec un langage de plus bas niveau.
Il est particulièrement répandu dans le monde scientifique, et possède de nombreuses extensions destinées aux applications numériques.

== Historique ==
=== Au CWI ===
[[Fichier:Guido van Rossum OSCON 2006.jpg|thumb|upright=0.7|left|Guido van Rossum, créateur de Python, à la [[OSCON]] 2006.]]

À la fin des [[années 1980]], le [[développeur|programmeur]] [[Guido van Rossum]] participe au développement du langage de programmation [[ABC (langage)|ABC]] au [[Centrum voor Wiskunde en Informatica]] (CWI) d'[[Amsterdam]], aux [[Pays-Bas]]. Il travaillait alors dans l’équipe du système d’exploitation [[Amoeba (système d'exploitation)|Amoeba]] dont les appels systèmes étaient difficilement interfaçables avec le [[bourne shell]] utilisé comme interface utilisateur. Il estime alors qu’un langage de script inspiré d’ABC pourrait être intéressant comme interpréteur de commandes pour Amoeba&lt;ref name=&quot;FAQ1.2&quot;&gt;[http://www.python.org/doc/faq/general/#why-was-python-created-in-the-first-place ''{{lang|en|FAQ Python 1.2 Why was Python created in the first place?}}'']&lt;/ref&gt;.

En [[1989]], profitant d’une semaine de vacances durant les fêtes de Noël, il utilise son ordinateur personnel&lt;ref&gt;[http://homepages.cwi.nl/~jack/macpython/intro.html ''{{lang|en|Introduction to MacPython}}'']&lt;/ref&gt; pour écrire la première version du langage. Fan de la série télévisée des [[Monty Python]], il décide de baptiser ce projet Python.  Il s’est principalement inspiré d’ABC, par exemple pour l’[[indentation comme syntaxe]] ou les types de haut niveau mais aussi de [[Modula-3]] pour la gestion des [[Système de gestion d'exceptions|exceptions]], du [[langage C]] et des outils UNIX&lt;ref&gt;[http://www.python.org/doc/essays/foreword/ Introduction de la première édition du livre ''Programming Python'' de Mark Lutz], Guido van Rossum 1996&lt;/ref&gt;.

Durant l’année suivante, le langage commence à être adopté par l’équipe du projet Amoeba, Guido poursuivant son développement principalement pendant son temps libre. En février 1991, la première version publique, numérotée 0.9.0&lt;ref&gt;Selon le fichier [http://svn.python.org/projects/python/trunk/Misc/HISTORY HISTORY] mais la plus ancienne version accessible dans les archives du forum est la  
[http://groups.google.com/group/alt.sources/browse_thread/thread/3b6652abb0e23b03/53ee3620bc53c281 0.9.1]&lt;/ref&gt;, est postée sur le forum [[Usenet]] alt.sources. La dernière version sortie au CWI fut Python 1.2

=== Au CNRI ===
En [[1995]], Van Rossum continua son travail sur Python au {{Lien|fr=Corporation for National Research Initiatives|lang=en|texte=CNRI}} à [[Reston (Virginie)|Reston]], aux [[États-Unis]], où il sortit plusieurs versions du logiciel. 

À partir d'{{date||août|1995|en informatique}}, l'équipe Python travaille au CNRI sur ''Grail''&lt;ref&gt;[http://grail.sourceforge.net/info/team.html The Grail Development Team&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt; un [[navigateur web]] utilisant [[Tk (informatique)|Tk]]. Il est l'équivalent pour Python du navigateur [[HotJava]], permettant d'exécuter des applets  dans un environnement sécurisé. La première version publique, disponible en novembre, est la 0.2&lt;ref&gt;[http://grail.sourceforge.net/info/papers/restofus.html ''Grail -- The Browser For The Rest Of Us'']&lt;/ref&gt;. Il a entraîné le développement de modules pour la bibliothèque standard comme ''rexec''&lt;ref&gt;[http://docs.python.org/lib/module-rexec.html 28.1 rexec - Restricted execution framework&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;, ''htmllib'' ou ''urllib''&lt;ref&gt;http://grail.sourceforge.net/info/diagram.gif&lt;/ref&gt;. La version 0.6 sera la dernière de ''Grail''; elle est publiée en avril 1999&lt;ref&gt;[http://grail.sourceforge.net/ Grail Home Page&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;. 

En [[1999]], le projet ''Computer Programming for Everybody'' (CP4E) est lancé avec collaboration entre le CNRI et la [[DARPA]]. Il s'agit d'utiliser Python comme langage d'enseignement de la programmation. Cette initiative conduira à la création de l'environnement de développement IDLE. Cependant, du fait du manque de financement du projet par la DARPA, et du départ de nombreux développeurs Python du CNRI (dont Guido van Rossum), le projet s’éteint en 2000.&lt;ref&gt;[http://www.python.org/doc/essays/cp4e Computer Programming for Everybody&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;. Python 1.6 fut la dernière version sortie au CNRI.

=== À BeOpen ===

En [[2000]], l'équipe principale de développement de Python déménagea à [[BeOpen.com]] pour former l'équipe [[PythonLabs]] de BeOpen. Python 2.0 fut la seule version sortie à BeOpen.com. Après cette version, Guido Van Rossum et les autres développeurs de PythonLabs rejoignirent Digital Creations (à présent connue sous le nom de [http://www.zope.com/ Zope Corporation])&lt;ref&gt;[http://docs.python.org/2/license.html History of the software]&lt;/ref&gt;.

Andrew M. Kuchling a publié en décembre 1999&lt;ref&gt;{{lien brisé|consulté le=2013-11-07|url=http://mail.python.org/pipermail/python-list/1999-December/018678.html|titre=Python warts}}&lt;/ref&gt; un texte nommé ''python warts''&lt;ref&gt;[http://web.archive.org/web/20031002184114/www.amk.ca/python/writing/warts.html Python Warts]&lt;/ref&gt; qui synthétise les griefs les plus fréquents exprimés à l'encontre du langage. Ce document aura une influence certaine sur les développements futurs du langage&lt;ref&gt;[http://www.python.org/download/releases/2.2.3/descrintro/ Unifying types and classes in Python 2.2]&lt;/ref&gt;.

=== La Python Software Foundation ===
Python 2.1 fut une version dérivée de Python 1.6.1, ainsi que de Python 2.0. Sa licence fut renommée [[Python Software Foundation License]]. Tout code, documentation et spécification ajouté, depuis la sortie de Python 2.1 alpha, est détenu par la [[Python Software Foundation]] (PSF), une association sans but lucratif fondée en 2001, modelée d'après l'[[Apache Software Foundation]].

Afin de réparer certains défauts du langage (ex: orientation objet avec deux types de classes), et pour nettoyer la bibliothèque standard de ses éléments obsolètes et redondants, Python a choisi de casser la compatibilité ascendante dans la nouvelle version majeure : Python 3.0, publié en décembre 2008. Cette version a été suivie rapidement par une version 3.1 qui corrige les erreurs de jeunesse de la version 3.0 en la rendant directement obsolète.

== Caractéristiques ==
=== Syntaxe ===
Python a été conçu pour être un langage lisible. Il vise à être visuellement épuré. Par exemple, il possède moins de constructions syntaxiques que de nombreux langages structurés tels que C, Perl, ou Pascal. Les commentaires sont indiqués par le caractère [[Croisillon (signe)|croisillon]].

Les blocs sont identifiés par l'[[Style d'indentation|indentation]], au lieu d'accolades comme en [[C (langage)|C]] ou [[C++]] ; ou de &lt;code&gt;begin ... end&lt;/code&gt; comme en [[Pascal (langage)|Pascal]]. Une augmentation de l'indentation marque le début d'un bloc, et une réduction de l'indentation marque la fin du bloc courant. Les parenthèses sont facultatives dans les structures de contrôle :
{| class=&quot;wikitable&quot;
!width=&quot;50%&quot;|Fonction factorielle en C
!width=&quot;50%&quot;|Fonction factorielle en Python
|-valign=&quot;top&quot;
|
&lt;source lang=&quot;C&quot;&gt;
 /* Fonction factorielle en C */
 int factorielle(int x) {
     if (x &lt; 2) {
         return 1;
     } else {
         return x * factorielle(x-1);
     }
 }
&lt;/source&gt;
|
&lt;source lang=&quot;python&quot;&gt;
 # Fonction factorielle en Python
 def factorielle(x):
     if x &lt; 2:
         return 1
     else:
         return x * factorielle(x-1)
&lt;/source&gt;
|}

NB : des accolades pourraient être retirées de la version en C mais, des erreurs pouvant être aisément commises en cas d'imbrication de plusieurs blocs, cela ne correspondrait pas aux normes de codages habituellement recommandées. À noter que l’indentation automatique mise en oeuvre par les éditeurs de code modernes ôte toute raison d'être à cette habitude. En conséquence, il est de plus en plus souvent conseillé de ne pas utiliser d’accolades, afin de favoriser la lisibilité du code, et, ce, dans un esprit analogue à celui de Python.

==== Mots-clés du langage ====
Les mots-clés sont fournis dans la liste &lt;code&gt;keyword.kwlist&lt;/code&gt; du module &lt;code&gt;keyword&lt;/code&gt;&lt;ref&gt;[http://docs.python.org/3/library/keyword.html The Python Standard Library - 31.6. keyword — Testing for Python keywords]&lt;/ref&gt;. Les mots-clés de Python 2.7.5 sont les suivants : &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;as&lt;/code&gt;, &lt;code&gt;assert&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, &lt;code&gt;del&lt;/code&gt;, &lt;code&gt;elif&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;except&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;global&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, &lt;code&gt;is&lt;/code&gt;, &lt;code&gt;lambda&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;pass&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;raise&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;, &lt;code&gt;yield&lt;/code&gt;.

À partir de Python 3.0, &lt;code&gt;print&lt;/code&gt; et &lt;code&gt;exec&lt;/code&gt; ne sont plus des mots-clés du langage, mais des fonctions du module &lt;code&gt;builtins&lt;/code&gt;&lt;ref&gt;[http://docs.python.org/3/library/functions.html#built-in-funcs The Python Standard Library - 2. Built-in Functions]&lt;/ref&gt;. Sont ajoutés aux mots-clés : &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;None&lt;/code&gt; et &lt;code&gt;nonlocal&lt;/code&gt;. Les trois premiers étaient déjà présents dans les versions précédentes, mais ils ne sont plus modifiables (auparavant, l'affectation &lt;code&gt;True = 1&lt;/code&gt; était possible)&lt;ref&gt;[http://wiki.python.org/moin/Python3.0 Python 3.0 - Core Language Changes]&lt;/ref&gt;. &lt;code&gt;nonlocal&lt;/code&gt; a été introduit par le PEP 3104&lt;ref&gt;[http://www.python.org/dev/peps/pep-3104/ PEP 3104 - Access to Names in Outer Scopes]&lt;/ref&gt;, et permet, dans une fonction définie à l'intérieur d'une autre fonction, de modifier une variable d'un niveau supérieur de [[Portée (informatique)|portée]]. Avant cela, seules les variables locales à la fonction, et globales (niveau module) étaient modifiables.

==== Types de base ====
Les types de base en Python sont relativement complets et puissants, il y a entre autres :
* Les objets numériques 
** &lt;code&gt;int&lt;/code&gt; est un entier illimité. Avant la version 3.0, ce type était dénommé &lt;code&gt;long&lt;/code&gt;, et le type &lt;code&gt;int&lt;/code&gt; correspondait à un entier 32 ou 64 bits. Néanmoins, une conversion automatique évitait tout débordement. 
** &lt;code&gt;float&lt;/code&gt; est un flottant équivalent au type &lt;code&gt;double&lt;/code&gt; du C, soit un nombre entre {{nombre|-1.7}}{{x10|308}} et {{nombre|1.7}}{{x10|308}} sur les plateformes en conformité avec l'[[IEEE 754]]].
** &lt;code&gt;complex&lt;/code&gt; est une approximation d'un [[nombre complexe]] (typiquement deux &lt;code&gt;floats&lt;/code&gt;)
* Les objets « itérables »
** Les objets &lt;code&gt;tuple&lt;/code&gt; (ou &lt;code&gt;[[n-uplet]]&lt;/code&gt;) sont des listes [[Objet immuable|immuables]] d'objets hétérogènes.
** Les objets &lt;code&gt;list&lt;/code&gt; sont des tableaux dynamiques (ils étendent automatiquement leur taille lorsque nécessaire) et acceptent des types de données hétérogènes.
** Les objets &lt;code&gt;set&lt;/code&gt; sont des ensembles non ordonnés d'objets.
** Les objets &lt;code&gt;frozenset&lt;/code&gt; forment une variante immuable des &lt;code&gt;set&lt;/code&gt;.
** Les objets &lt;code&gt;dict&lt;/code&gt; sont des [[Tableau associatif|tableaux associatifs]] (ou dictionnaires) permettant d'associer un objet (une clef) à un autre.
** Les objets &lt;code&gt;str&lt;/code&gt; sont des chaînes de caractères. À partir de la version 3.0, les caractères sont en [[Unicode]] sur 16 ou 32 bits ; les chaines d'octets ASCII sont des objets &lt;code&gt;bytes&lt;/code&gt;. Dans les versions précédentes, ces objets étaient respectivement de type &lt;code&gt;unicode&lt;/code&gt; et &lt;code&gt;str&lt;/code&gt;.

Les objets itérables sont parcourus à l'aide d'une boucle &lt;code&gt;for&lt;/code&gt; de la manière suivante :
&lt;source lang=&quot;python&quot;&gt;
for element in objet_iterable:
  traiter(element)
&lt;/source&gt;
Pour une chaîne de caractères, l'itération procède caractère par caractère.

Il est possible de dériver les classes des types de base pour créer ses propres types.
On peut également fabriquer ses propres types d'objets itérables sans hériter des itérables de base en utilisant le protocole d'itération du langage.

==== Programmation fonctionnelle ====
Python permet de programmer dans un style [[Programmation fonctionnelle|fonctionnel]]. Les [[Liste en compréhension|compréhensions de listes]] sont disponibles. Par exemple, pour construire la liste des carrés des entiers naturels plus petits que 10, on peut utiliser l'expression :
&lt;source lang=&quot;python&quot;&gt;
liste = [x**2 for x in range(10)]
# liste = [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/source&gt;

la liste des nombres '''pairs''' :
&lt;source lang=&quot;python&quot;&gt;
liste = [entier for entier in range(10) if entier % 2 == 0]
# liste = [0, 2, 4, 6, 8]
&lt;/source&gt;

Une forme limitée de [[Lambda-calcul|fonctions lambda]], ou fonctions anonymes, est disponible :
&lt;source lang=&quot;python&quot;&gt;
lambda x: x + 2
&lt;/source&gt;
Les fonctions lambda peuvent être définies en ligne et utilisées comme arguments dans des expressions fonctionnelles : &lt;source lang=&quot;python&quot;&gt; filter(lambda x: x &lt; 5, une_liste) &lt;/source&gt; retournera une liste constituée des éléments de une_liste inférieurs à 5. Le même résultat peut être obtenu avec &lt;source lang=&quot;python&quot;&gt; [x for x in une_liste if x &lt; 5] &lt;/source&gt;

Les lambdas de Python n'admettent que des expressions et ne peuvent être utilisées comme fonctions anonymes généralisées ; mais en Python, toutes les fonctions sont des objets, elles peuvent donc être passés en arguments d'autres fonctions, et appelés lorsque nécessaire. En effet, les fonctions définies avec '''def''' sont équivalentes à celles définies avec '''lambda''', il est d'ailleurs possible de '''définir''' une fonction à l'intérieur d'une autre fonction et ainsi obtenir une définition de fonction dans une variable locale, exemple :
&lt;source lang=&quot;python&quot;&gt;
def filtre_inferieur_a_5(une_liste):
    def mon_filtre(x): # variable locale mon_filtre
        return x &lt; 5
    return filter(mon_filtre, une_liste)
&lt;/source&gt;

==== Programmation objet ====
La programmation objet est très bien supportée par Python : tous les types de base, les fonctions, les instances de classes (les objets « classiques » des langages C++ et Java) et les classes elles-mêmes (qui sont des instances de méta-classes) sont des objets.
 
Une classe se définit avec le mot &lt;code&gt;class&lt;/code&gt;. Les classes Python supportent l'héritage multiple ; il n'y a pas de surcharge statique comme en C++,ou des restrictions sur l'heritage comme le cas en java (une classe implémente plusieurs interface et hérite d'une seule classe) mais le mécanisme des arguments optionnels et par mot-clef est plus général et plus flexible. En Python, l'attribut d'un objet peut référencer une variable d'instance ou de classe (le plus souvent une méthode). Il est possible de lire ou de modifier un attribut dynamiquement avec les fonctions :

* &lt;code&gt;getattr(objet, 'nom_attribut') &lt;/code&gt;
* &lt;code&gt;setattr(objet, 'nom_attribut', nouvel_attribut)&lt;/code&gt;

Exemple de deux classes simples :
&lt;source lang=&quot;python&quot;&gt;
class Personne:
   def __init__(self, nom, prenom):
       self.nom = nom
       self.prenom = prenom
   def presenter(self) :
       return self.nom + &quot; &quot; + self.prenom

class Etudiant(Personne):
   def __init__(self, niveau, nom, prenom):
       Personne.__init__(self, nom, prenom)
       self.niveau = niveau
   def presenter(self):
       return self.niveau + &quot; &quot; + Personne.presenter(self)

e = Etudiant(&quot;Licence INFO&quot;, &quot;Dupontel&quot;, &quot;Albert&quot;)
assert e.nom == &quot;Dupontel&quot;
&lt;/source&gt;

==== Méthodes spéciales et définition des opérateurs ====

Python fournit un mécanisme élégant et orienté objet pour définir un ensemble pré-défini d'opérateurs : tout objet Python peut se voir doté de méthodes dites spéciales.

Ces méthodes, commençant et finissant par deux tirets de soulignement ''(underscores)'', sont appelées lors de l'utilisation d'un opérateur sur l'objet : &lt;code&gt;+&lt;/code&gt; (méthode &lt;code&gt;__add__&lt;/code&gt;), &lt;code&gt;+=&lt;/code&gt; (méthode &lt;code&gt;__iadd__&lt;/code&gt;), &lt;code&gt;[]&lt;/code&gt; (méthode &lt;code&gt;__getitem__&lt;/code&gt;), &lt;code&gt;()&lt;/code&gt; (méthode &lt;code&gt;__call__&lt;/code&gt;), … Des méthodes comme &lt;code&gt;__repr__&lt;/code&gt; et &lt;code&gt;__str__&lt;/code&gt;, permettent de définir la représentation d'un objet dans l'interpréteur interactif et son rendu avec le mot clé ''print''. 

Les possibilités sont nombreuses et sont décrites dans la documentation du langage&lt;ref&gt;[http://docs.python.org/ref/specialnames.html documentation du langage]&lt;/ref&gt;.

Par exemple on peut définir l'addition de deux vecteurs à 2 dimensions avec la classe suivante :
&lt;source lang=&quot;python&quot;&gt;
class Vector2D:
    def __init__(self, x, y):
        # On utilise un tuple pour stocker les coordonnées
        self.coords = (x, y)

    def __add__(self, other):
        # L'instruction a+b sera résolue comme a.__add__(b)
        # On construit un objet Vector2D à partir des coordonnées propres à l'objet, et à l'autre opérande
        return Vector2D(self.coords[0]+other.coords[0], self.coords[1]+other.coords[1])

    def __repr__(self):
        # L'affichage de l'objet dans l'interpréteur
        return &quot;Vector2D(%s, %s)&quot; %self.coords

a = Vector2D(1, 2)
b = Vector2D(3, 4)
print(a + b) # Vector2D(4, 6)
&lt;/source&gt;

==== Générateurs ====
Le mot-clef ''yield'' utilisé dans une fonction permet de faire de cette fonction un générateur. L'appel de cette fonction renvoie un objet de type ''generator'', qui peut être utilisé dans une boucle ''for'', par exemple.

À chaque appel, le générateur effectue son traitement jusqu'à rencontrer le mot-clé ''yield'', renvoie la valeur de l'expression ''yield'', et à l'appel suivant, reprend son déroulement juste après le ''yield''. Par exemple pour calculer la [[suite de Fibonacci]], on peut faire :
&lt;source lang=&quot;python&quot;&gt;
def gen_fibonacci():
    &quot;&quot;&quot;Générateur de la suite de Fibonacci&quot;&quot;&quot;
    a, b = 0, 1

    while True:
        yield a  # Renvoi de la valeur de &quot;a&quot;, résultat de l'itération en cours
        a, b = b, a + b

fi = gen_fibonacci()
for i in range(20):
    print(fi.next())
&lt;/source&gt;

{| class=&quot;wikitable&quot;
!width=&quot;50%&quot;|L'exécution de
!width=&quot;50%&quot;|renverra
|-valign=&quot;top&quot;
|
&lt;source lang=&quot;python&quot;&gt;
def gen_nombres_pairs():
    &quot;&quot;&quot;Générateur de nombres pairs&quot;&quot;&quot;
    a = 0
    while True:
        print(&quot;Génère le nombre&quot;, a)
        yield a
        a += 2

pi = gen_nombres_pairs()
for i in range(4):
    print(pi.next())
&lt;/source&gt;
|
Génère le nombre 0&lt;br /&gt;
0&lt;br /&gt;
Génère le nombre 2&lt;br /&gt;
2&lt;br /&gt;
Génère le nombre 4&lt;br /&gt;
4&lt;br /&gt;
Génère le nombre 6&lt;br /&gt;
6
|}

Un générateur peut sembler identique à une fonction qui retourne une liste, mais contrairement à une liste qui contient ''tous'' ses éléments un générateur calcule ses éléments ''un'' par un.

=== Réflexivité ===

Grâce à un usage intensif des dictionnaires (conteneur associatif développé avec des [[table de hachage|tables de hachage]]), Python permet d'explorer les divers objets du langage ([[introspection (informatique)|introspection]]) et dans certains cas de les modifier ([[intercession (informatique)|intercession]]).

=== Typage ===
Le [[typage]] n'est pas vérifié à la compilation. De ce fait, des opérations sur un objet peuvent échouer, signifiant que l'objet en question n'est pas du bon type. Malgré l'absence de typage statique, Python est fortement typé, interdisant des opérations ayant peu de sens (comme, par exemple, additionner un nombre à une chaîne de caractères) au lieu de tenter silencieusement de la convertir en une forme qui a du sens. Python propose des fonctions permettant de transformer les variables dans un autre type :
&lt;source lang=&quot;python&quot;&gt;
points = 3.2 # points est du type float
print(&quot;Tu as &quot; + points + &quot; points !&quot;) # Génère une erreur de typage

points = int(points) # points est maintenant du type int (entier), sa valeur est arrondie à l'unité inférieure (ici 3)
print(&quot;Tu as &quot; + points + &quot; points !&quot;) # Génère une erreur de typage

points = str(points) # points est maintenant du type str (chaîne de caractères)
print(&quot;Tu as &quot; + points + &quot; points !&quot;) # Plus d'erreur de typage, affiche 'Tu as 3 points !'
&lt;/source&gt;

De même, chaque variable devra être déclarée avant d'être utilisée.

Python propose aussi un mécanisme de [[typage fort]] grâce à l'API ''trait'' ou au [[Patron de conception|design pattern]] ''decorators''.

==== Compilation ====

Il est possible d'effectuer une analyse statique des modules Python avec des outils comme  Pylint &lt;ref&gt;http://www.pylint.org&lt;/ref&gt; ou PyChecker. Sans nécessiter une exécution, ces outils repèrent des fautes ou des constructions déconseillées. Par exemple, une classe qui hérite d'une classe abstraite et qui ne redéfinit pas les méthodes abstraites, ou bien des variables utilisées avant d'être déclarées, ou encore des attributs d'instance déclarés en dehors de la méthode &lt;code&gt;__init__&lt;/code&gt;.

Il est aussi possible de générer un code intermédiaire ([[bytecode]]) Python.

Des outils comme PyInstaller&lt;ref&gt;{{en}} [http://www.pyinstaller.org// Site officiel de PyInstaller]&lt;/ref&gt; ou d'autres plus spécifiques comme cx_Freeze sous [[Unix]], [[Microsoft Windows|Windows]] et [[Mac OS X]], py2app&lt;ref&gt;http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html#abstract&lt;/ref&gt; sous [[Mac OS X]] et [[py2exe]] sous [[Microsoft Windows|Windows]] permettent de « compiler » un programme Python sous forme d'un exécutable comprenant le programme et un interpréteur Python.

Le programme ne tourne pas plus rapidement (il n'est pas compilé sous forme de code machine) mais cela simplifie largement sa distribution, notamment sur des machines où l'interpréteur Python n'est pas installé.

=== Modèle objet ===
En Python, ''tout est objet'', dans le sens qu'une variable peut contenir une [[référence (informatique)|référence]] vers tous les éléments manipulés par le langage : nombres, méthodes, modules{{etc.}}&lt;ref&gt;{{lien brisé|consulté le=2013-11-07|url=http://diveintopython.adrahon.org/getting_to_know_python/everything_is_an_object.html|titre=2.4. Tout est objet&lt;!-- Titre généré automatiquement --&gt;}}&lt;/ref&gt;. Néanmoins, avant la version 2.2, les classes et les instances de classes étaient un type d'objet particulier, ce qui signifiait qu'il était par exemple impossible de dériver sa propre sous-classe de l'objet ''list''.

==== Méthodes ====
Le modèle objet de Python est inspiré de celui de Modula-3&lt;ref&gt;[http://docs.python.org/tut/node11.html ''Python Tutorial''] chapitre 9&lt;/ref&gt;. Parmi ces emprunts se trouve l'obligation de déclarer l'instance de l'objet courant, conventionnellement nommée ''self'', comme premier argument des méthodes, et à chaque fois que l'on souhaite accéder à une donnée de cette instance dans le corps de cette méthode. Cette pratique n'est pas naturelle pour des programmeurs venant par exemple de C++ ou Java, la profusion des ''self'' étant souvent critiquée comme étant une pollution visuelle qui gène la lecture du code. Les promoteurs du ''self'' explicite estiment au contraire qu'il évite le recours à des conventions de nommage pour les données membres et qu'il simplifie des tâches comme l'appel à une méthode de la superclasse ou la résolution d'homonymie entre données membres&lt;ref&gt;[http://effbot.org/pyfaq/why-must-self-be-used-explicitly-in-method-definitions-and-calls.htm Why must 'self' be used explicitly in method definitions and calls?&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;. {{pas clair|Il permet par ailleurs un traitement orthogonal des méthodes et fonctions.}}

Python reconnaît trois types de méthodes :
* les méthodes d'instances, qui sont celles définies par défaut. Elles reçoivent comme premier argument une instance de la classe où elles ont été définies. 
* les méthodes de classes, qui reçoivent comme premier argument la classe où elles ont été définies. Elles peuvent être appelées depuis une instance ou directement depuis la classe. Elles permettent de définir des constructeurs alternatifs comme la méthode &lt;code&gt;fromkeys()&lt;/code&gt; de l'objet &lt;code&gt;dict&lt;/code&gt;.
* les méthodes statiques, qui ne reçoivent pas de premier argument implicite. Elles sont similaires aux méthodes statiques que l'on trouve en Java ou C++.

==== Visibilité ====
Le langage a un support très limité de l'[[encapsulation (programmation)|encapsulation]].  Il n'y a pas, comme en java par exemple, de contrôle de l'accessibilité par des mots clefs comme &lt;code&gt;protected&lt;/code&gt; ou &lt;code&gt;private&lt;/code&gt;.

La philosophie de Python est de différencier conceptuellement l'encapsulation du masquage d'information. Le masquage d'information vise à prévenir les utilisations frauduleuses, c'est une préoccupation de [[sécurité du système d'information|sécurité informatique]]. Le module ''bastion'' de la bibliothèque standard, qui n'est plus maintenu dans les dernières versions du langage, permettait ainsi de contrôler l'accès aux attributs d'un objet dans le cadre d'un environnement d'exécution restreint.

L'encapsulation est une problématique de développement logiciel. Le slogan des développeurs Python est ''we're all consenting adults here''&lt;ref&gt;[http://www.mactech.com/articles/mactech/Vol.20/20.11/PythonForAppleScripters/index.html Python For AppleScripters&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt; (nous sommes entre adultes consentants). Ils estiment en effet qu'il suffit d'indiquer, par des conventions d'écriture, les parties publiques des interfaces et que c'est aux utilisateurs des objets de se conformer à ces conventions ou de prendre leurs responsabilités. L'usage est de préfixer par un underscore les membres privés. Le langage permet par ailleurs d'utiliser un double underscore pour éviter les collisions de noms, en préfixant automatiquement le nom de la donnée par celui de la classe où elle est définie. 

L'utilisation de la fonction &lt;code&gt;property()&lt;/code&gt; permet de définir des propriétés qui ont pour but d'intercepter, à l'aide de méthodes, les accès à une donnée membre. Cela rend inutile la définition systématique d'[[accesseur|accesseurs]] et le masquage des données comme il est courant de le faire en C++ par exemple.

==== Héritage ====
Python supporte l'[[héritage multiple]]. Depuis la version 2.3, il utilise l'{{lien|lang=en|trad=C3 linearization||fr=algorithme C3}}, issu du langage [[Dylan (langage)|Dylan]]&lt;ref&gt;[http://192.220.96.201/dylan/linearization-oopsla96.html A Monotonic Superclass Linearization for Dylan&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;, pour résoudre l'[[ordre de résolution de méthode]] (''MRO''). Les versions précédentes utilisaient un [[algorithme de parcours en profondeur]]  qui posait des problèmes dans le cas d'un [[héritage en diamant]]&lt;ref&gt;[http://www.python.org/download/releases/2.3/mro/ The Python 2.3 Method Resolution Order&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;.

== Bibliothèque standard ==
[[Image:Python batteries included.jpg|thumb|250px|Python est fourni « piles incluses ».]]
Python possède une grande [[bibliothèque standard]], fournissant des outils convenant à de nombreuses tâches diverses. Le nombre de modules de la bibliothèque standard peut être augmenté avec des modules spécifiques écrits en C ou en Python. 

La bibliothèque standard est particulièrement bien conçue pour écrire des applications utilisant Internet, avec un grand nombre de formats et de protocoles standards gérés (tels que [[MIME]] et [[HTTP]]). Des modules pour créer des [[interface graphique|interfaces graphiques]] et manipuler des [[expression rationnelle|expressions rationnelles]] sont également fournis. Python inclut également un [[framework]] de [[test unitaire|tests unitaires]] (&lt;code&gt;unittest&lt;/code&gt;, anciennement [[PyUnit]] avant version 2.1) pour créer des suites de tests exhaustives.

== Conventions de style ==
Bien que chaque programmeur puisse adopter ses propres conventions pour l'écriture de code Python, [[Guido van Rossum]] a mis un guide à disposition, référencé comme « PEP 8 »&lt;ref&gt;[http://www.python.org/dev/peps/pep-0008/ PEP 8 - Style Guide for Python Code]&lt;/ref&gt;. Publié en 2001, il est toujours maintenu en 2013, pour l'adapter aux évolutions du langage. [[Google]] propose également un guide&lt;ref&gt;[http://google-styleguide.googlecode.com/svn/trunk/pyguide.html Google Python Style Guide]&lt;/ref&gt;.

== Interfaces graphiques ==

Python possède plusieurs modules disponibles pour la création de logiciels avec une interface graphique. Le plus répandu est [[Tkinter]]. Ce module convient à beaucoup d'applications et peut être considéré comme suffisant dans la plupart des cas. Néanmoins, d'autres modules ont été créés pour pouvoir lier Python à d'autres [[bibliothèques logicielles]] (« ''[[toolkit]]'' »), pour davantage de fonctionnalités, pour une meilleure intégration avec le système d'exploitation utilisé, ou simplement pour pouvoir utiliser Python avec sa bibliothèque préférée. En effet, certains programmeurs trouvent l'utilisation de Tkinter plus pénible que d'autres bibliothèques. Ces autres modules ne font pas partie de la bibliothèque standard et doivent donc être obtenus séparément.

Les principaux modules donnant accès aux bibliothèques d'interface graphique sont [[Tkinter]] et Pmw (Python megawidgets)&lt;ref&gt;[http://pmw.sourceforge.net/ Pmw - Python megawidgets]&lt;/ref&gt; pour [[Tk (informatique)|Tk]], [[wxPython]] pour [[wxWidgets]], [[PyGTK]] pour [[GTK+]], [[PyQt]] et [[PySide]] pour [[Qt]], et enfin FxPy pour le [[FOX Toolkit]]. Il existe aussi une adaptation de la bibliothèque [[Simple DirectMedia Layer|SDL]] : [[Pygame]], un [[binding]] de la [[SFML]] : PySFML, ainsi qu'une bibliothèque écrite spécialement pour Python : {{Lien|fr=Pyglet|lang=en}}.

Il est aussi possible de créer des applications [[Silverlight]] en Python sur la plateforme [[IronPython]].

== La communauté Python ==
Van Rossum est le principal auteur de Python, et son rôle de décideur central permanent de Python est reconnu avec humour par le titre de « Dictateur bienveillant à vie » (''Benevolent Dictator for Life'', BDFL).

Il est assisté d'une équipe de ''core developers'' qui ont un accès en écriture au dépôt de CPython et qui se coordonnent sur la liste de diffusion python-dev. Ils travaillent principalement sur le langage et la bibliothèque de base. Ils reçoivent ponctuellement les contributions d'autres développeurs Python via la plateforme de gestion de bug Roundup, qui a remplacé [[SourceForge (logiciel)|SourceForge]].

Les utilisateurs ou  développeurs de bibliothèques tierces utilisent diverses autres ressources. Le principal média généraliste autour de Python est le forum Usenet anglais comp.lang.python.

Les allusions aux Monty Python sont assez fréquentes. Les didacticiels consacrés à Python utilisent souvent les mots ''spam'' et ''eggs'' comme [[variable métasyntaxique]]. Il s'agit d'une référence au sketch ''[[Spam (sketch)|Spam]]'' des [[Monty Python]], où deux clients tentent de commander un repas à l'aide d'une carte qui contient du jambon en conserve de marque [[SPAM]] dans pratiquement tous les plats. Ce sketch a été aussi pris pour référence pour désigner un email non sollicité.

=== Adoption de Python ===
Plusieurs entreprises mentionnent sur leur site officiel&lt;ref&gt;[http://www.python.org/about/quotes/ Quotes about Python]&lt;/ref&gt; qu'elles utilisent Python :
* [[Google]] ([[Guido van Rossum]] a travaillé au sein de cette entreprise entre 2005 et 2012&lt;ref&gt;[http://www.oreillynet.com/onlamp/blog/2005/12/python_creator_guido_van_rossu.html ''Python Creator Guido van Rossum now working at Google''], article sur ''ONLamp.com''&lt;/ref&gt;) ;
* [[Industrial Light &amp; Magic]] ;
* la [[National Aeronautics and Space Administration|NASA]] ;
* et CCP Games, les créateurs du [[jeu vidéo]] [[EVE Online]].

Python est aussi le langage de commande d'un grand nombre de logiciels libres :
* [[FreeCAD]], logiciel de CAO 3D
* [[Blender]], logiciel de modélisation 3D
* [[Inkscape]], logiciel de dessin vectoriel
* [[LibreOffice]], une [[suite bureautique]]
* [[Portage (Gentoo)|Portage]], le gestionnaire de paquets du [[système d'exploitation]] [[Gentoo]]
* [[ParaView]], logiciel de visualisation de données numériques
* [[XBMC Media Center|XBMC]], un [[lecteur multimédia]]
Python est utilisé comme langage de programmation dans l'enseignement élémentaire et supérieur &lt;ref&gt;[http://www.phys.ens.fr/spip.php?article1022 ''Python en Prepa''], article sur ESN&lt;/ref&gt;&lt;ref&gt;[http://cache.media.education.gouv.fr/file/special_3_ESR/50/5/programme-informatique_252505.pdf ''Bulletin officiel spécial n° 3 du 30 mai 2013''], article sur http://www.education.gouv.fr/&lt;/ref&gt;

== Implémentations du langage ==
Outre la version de référence, nommée [[CPython]] (car écrite en langage [[C (langage)|C]]), il existe d'autres systèmes mettant en œuvre le langage Python :
* [[Stackless Python]], une version de CPython n'utilisant pas la pile d'appel du langage C ;
* [[Jython]], un [[interprète (informatique)|interprète]] Python pour [[machine virtuelle Java]]. Il a accès aux bibliothèques fournies avec l'[[environnement de développement]] [[Java (langage)|Java]] ;
* [[IronPython]], un interprète / compilateur (expérimental) pour plateforme [[Microsoft .NET|.Net]] / [[Mono (informatique)|Mono]] ;
* [[PyPy]] un interprète Python écrit dans un sous-ensemble de Python compilable vers le [[C (langage)|C]] ou [[LLVM]] ;
* un [[compilateur]] (expérimental) pour [[Parrot (machine virtuelle)|Parrot]], la machine virtuelle de [[Perl (langage)|Perl]] 6 ;
* {{lien|lang=en|trad=Shed Skin|fr=Shed Skin}}&lt;ref&gt;[http://code.google.com/p/shedskin/ Shed Skin]&lt;/ref&gt;, un [[compilateur]] d'un sous-ensemble de Python produisant du code en [[C++]] ;
* {{lien|lang=en|trad=Unladen Swallow|fr=Unladen Swallow}}&lt;ref&gt;[https://code.google.com/p/unladen-swallow/ Unladen Swallow]&lt;/ref&gt;, une version de CPython optimisée et basée sur LLVM, maintenant abandonnée (la dernière version remonte à octobre 2009) ;
Ces autres versions ne bénéficient pas forcément de la totalité de la bibliothèque de fonctions écrites en C pour la version de référence.

== Les distributions ==
Différentes distributions sont disponibles, qui incluent parfois beaucoup de packages dédiés à un domaine donné :
* ActivePython&lt;ref&gt;[http://www.activestate.com/activepython ActivePython]&lt;/ref&gt;
* Python(x,y)&lt;ref&gt;[http://code.google.com/p/pythonxy/ Python(x,y)]&lt;/ref&gt; : une distribution Python à l'usage des scientifiques basée sur [[Qt]] et [[Eclipse (projet)|Eclipse]]
* Enthought Canopy&lt;ref&gt;[https://www.enthought.com/ Enthought]&lt;/ref&gt; : un autre distribution à usage scientifique
* Anaconda&lt;ref&gt;[http://continuum.io/ Anaconda]&lt;/ref&gt; : une troisième distribution à usage scientifique
* Pyzo&lt;ref&gt;[http://www.pyzo.org/ Pyzo]&lt;/ref&gt; : « ''Python to the people'' », destinée à être facile d'utilisation

=== Historique des versions ===

{| class=&quot;wikitable sortable&quot;
! Version !! Date de sortie !! class=&quot;unsortable&quot; | Nouveautés&lt;ref&gt;{{en}} [http://docs.python.org/whatsnew/ What’s New in Python] sur python.org&lt;/ref&gt;
|-
|| 1.5(.2) || {{Date|13|avril|1999|en informatique}} ||
* Ajout du mot clé '''assert'''
* Possibilité d'importer une hiérarchie de modules (import spam.ham.eggs)
* Nouveau module [[Expression rationnelle|re]] qui remplace regex
* Les exceptions sont maintenant des classes
* Ajout de l'option -O qui supprime les assertions et informations de ligne de fichier
|-
|| 1.6 || {{Date|5|septembre|2000|en informatique}} ||
* La méthode append() des listes n'accepte plus qu'un seul argument
* Le résultat des fonctions str() et repr() est maintenant beaucoup plus souvent différent, exemple : str(1L)=='1' et repr(1L)=='1L'
* Les chaînes de caractères ont maintenant des méthodes (&quot; abc &quot;.strip())
* Le module re est compatible avec l'ancien moteur, est plus rapide, et accepte les chaînes Unicode
* Ajout du module distutils
* Nouveau prototype « def f(*args, **kw) » pour les fonctions, avant il fallait utiliser apply()
* int() et long() acceptent maintenant une base en second argument
* L'opérateur in peut être surchagé avec une méthode __contains__()
|-
|| 2.0 || {{Date|16|octobre|2000|en informatique}} ||
* Changement majeur : support d'Unicode
* Ajout des compréhensions de liste (''List Comprehensions'')
* Ajout des opérateurs avec assignement (a+=b, a*=b, etc.)
* Les chaînes str ont maintenant des méthodes
* Nouveau [[ramasse-miettes (informatique)|ramasse-miettes]] à cycles
* Nouveau prototype « def f(*args, **kw) » pour les fonctions, avant il fallait utiliser apply()
* Ajout des modules distutils, xml.dom.minidom module et xml.sax
|-
|| 2.1 || {{Date|17|avril|2001|en informatique}} ||
* Création du module __future__ pour rendre les transitions plus douces
* Comparaisons riches (méthodes  __lt__,   __le__, ..., __ne__)
* Framework d'avertissement
* Ajout des modules [[Introspection (informatique)|inspect]], [[Commentaire (informatique)|pydoc]], [[Méthode agile|doctest]], [[pyunit]]
* Ajout des références faibles (''weak references'')
* Les fonctions peuvent avoir des attributs
* ''Nested Scopes''
* La version 2.0.1 ({{Date||juin|2001|en informatique}}) sera la première version compatible [[Licence publique générale GNU|GPL]]
|-
|| 2.2 || {{Date|21|décembre|2001|en informatique}} ||
* Unification de Type et de Class: on peut maintenant hériter des types de base
* Ajout des [[itérateur (motif de conception)|itérateur]]s et [[générateur (informatique)|générateur]]s
* Nouvel opérateur a // b pour la division entière
|-
|| 2.3 || {{Date|29|juillet|2003|en informatique}} ||
* Ajout des fonctions enumerate() et sum()
* Le type [[Algèbre de Boole (logique)|bool]] est maintenant vraiment distinct d'un entier
* Beaucoup d'améliorations du support [[Unicode]]
|-
|| 2.4 || {{Date|30|novembre|2004|en informatique}} ||
* Ajout des décorateurs de fonction/méthode (@decorateur)
* Conversion automatique d'un entier court en entier long si le résultat d'une opération est trop grand
* Expressions de générateur retournant les résultats l'un après l'autre et non pas sous forme d'une liste, exemple : sum( x for x in xrange(10000) )
* Ajout des fonctions reversed() et sorted()
* La fonction sort() accepte les mots clés cmp, key et reverse
* Création du module decimal et du routeur
|-
|| 2.5 || {{Date|19|septembre|2006|en informatique}} ||
* Ajout de l'opérateur '''with'''
* Ajout des méthodes send(), throw() et close() aux générateurs
* Expression conditionnelle (a if test else b)
* Les imports de module peuvent être relatifs
* Ajout des méthodes partition() et rpartition() aux chaînes str et unicode
* Ajout des fonctions any() et all()
* Intégration des bibliothèques ctypes, ElementTree, hashlib, sqlite3 et wsgiref
|-
|| 2.6 || {{Date|1|octobre|2008|en informatique}} ||
* Nouvelle syntaxe de formatage de chaînes de caractères 
* Classes de bases abstraites
* Décorateurs de classes
* Modules [[JSON]], multiprocessing, contextmanager et fractions
* Amélioration de la compatibilité avec Python 3
|-
|| 2.7 || {{Date|3|juillet|2010|en informatique}} ||
* Syntaxe pour les ensembles littéraux : {1, 2, 3} au lieu de set((1, 2, 3))
* Compréhension de dictionnaire et d'ensemble, exemples : {i: i*2 for i in range(3)} (dictionnaire) et {i*2 for i in range(3)} (ensemble)
* Possibilité de spécifier plusieurs gestionnaires de contexte avec une seule déclaration with
* Réimplementation de la bibliothèque io (entrées/sorties) en C pour offrir de meilleures performances. Cette bibliothèque est notamment utile pour accéder à un fichier texte en Unicode.
* Dictionnaires ordonnés (enfin !) comme décrits dans la PEP 372 : from collections import OrderedDict
* La méthode format gère la numérotation automatique : '{} {}!'.format('Hello', 'World') donne 'Hello World'!
* Le formatage des nombres gère les séparateurs de milliers, exemple : '{:,}'.format(10800) donne '10,800'
* Amélioration de précision lors des conversions chaîne vers flottant et flottant vers chaîne. Pour un flottant, float(repr(x)) donnera toujours x.
* Nouveau module argparse pour parser la ligne de commande : version améliorée du module optparse
* Configuration basée sur des dictionnaires pour le module logging
* Objets memoryview : vue en lecture seule ou lecture-écriture d'un objet binaire (API similaire à celle du type bytes)
* Type PyCapsule pour l'API C (pour les modules d'extension)
* Les types int et long gagnent une méthode bit_length() : nombre de bits nécessaires pour représenter la valeur absolue du nombre
|-
|| 3.0 || {{Date|3|décembre|2008|en informatique}}&lt;ref&gt;Python 3.0 http://www.python.org/download/releases/3.0/&lt;/ref&gt; ||
* Fusion des types 'int' et 'long'
* Les chaînes sont en Unicode par défaut, 'bytes' remplace l'ancien type 'str'
* Utilise des itérateurs plutôt que des listes là où c'est approprié (ex : dict.keys())
* a/b est la vraie division par défaut
* exec et print deviennent des fonctions
* None et as deviennent des mots clé
* Le fichier __init__.py n'est plus nécessaire pour les modules Python
* `x` et l'opérateur &lt;&gt; disparaissent
* De nombreuses fonctions disparaissent : apply(), buffer(), callable(), ...
* reduce() disparaît au profit des boucles explicites

''Voir la [http://www.python.org/dev/peps/pep-3100/ PEP 3100] pour les détails''
|-
|| 3.1 || {{Date|27|juin|2009|en|informatique}}&lt;ref&gt;Python 3.1 http://www.python.org/download/releases/3.1/&lt;/ref&gt; ||
* Ajout d'un type de dictionnaire ordonné,
* Optimisations diverses apportées au type 'int',
* Nouvelles fonctionnalités du module 'unittest',
* Module d'entrées/sorties 'io' rendu plus rapide,
* Intégration de l'instruction « import » en pur Python
* Nouvelle syntaxe pour les instructions 'with' imbriquées.
|-
|| 3.2 || {{Date|20|février|2011|en|informatique}}&lt;ref&gt;Python 3.2 http://www.python.org/download/releases/3.2/&lt;/ref&gt; ||
* Ajout du module '''argparse''' pour le parsing des arguments passés à un programme
* Modification de la gestion des fichiers compilés ''.pyc''
* Ajout des certificats ( protocole HTTPS )
* Amélioration du module '''pickle'''
|-
|| 3.3 || {{Date|29|septembre|2012|en|informatique}}&lt;ref name=&quot;py3&quot;&gt;Python 3.3 http://www.python.org/download/releases/3.3.0/&lt;/ref&gt; ||
* Ajout de la syntaxe &quot;yield from&quot; pour utiliser des sous-générateurs&lt;ref name=&quot;py3&quot; /&gt;
* La syntaxe u'unicode' est de nouveau acceptée&lt;ref&gt;http://www.python.org/dev/peps/pep-0380/&lt;/ref&gt;
* Ajout du module faulthandler pour aider à débugger les problèmes de bas niveau
* Support pour la compression [[LZMA]]
* Ajout d'un module pour les [[Mock_(programmation_orientée_objet)|Mock]] dans unittest
* Incorporation des fonctionnalités du module virtualenv avec le module venv
* Refonte de la hiérarchie des erreurs système (I/O).
|-
|| 3.4 || {{Date|16|mars|2014|en|informatique}}&lt;ref name=&quot;py34&quot;&gt;Python 3.4 http://www.python.org/dev/peps/pep-0429/&lt;/ref&gt; (date de sortie prévue)||
|}

== Développement ==
=== Les PEP ===

Les propositions d'amélioration de Python (ou « PEP » : ''Python Enhancement Proposal'') sont des documents textuels qui ont pour objet d'être la voie d'amélioration de Python et de précéder à toutes ses modifications ultérieures. Un pep est une proposition d'orientation pour le développement ''(process PEP)'', une proposition technique ''(Standard Track PEP)'' ou une simple recommandation (''Informational PEP'', la plus célèbre étant certainement celle de Tim Peters : http://www.python.org/dev/peps/pep-0020/). 

À leur sortie, les PEP sont relus et commentés par le BDFL&lt;ref&gt;[http://www.python.org/doc/essays/pepparade.html Parade of the PEPs&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;.

=== Python 3000 ===
Une nouvelle version de Python, appelée Python 3.0 (le projet était appelé « Python 3000 » ou  « Py3K ») abolit la compatibilité descendante avec la série des versions 2.x, dans le but d'éliminer les faiblesses du langage. La ligne de conduite du projet était de « réduire la redondance dans le fonctionnement de Python par la suppression des méthodes obsolètes ». Python 3.0a1, la première version alpha, a été publiée le 31 août 2007&lt;ref name=&quot;autogenerated1&quot;&gt;[http://python.org/download/releases/3.0/ Python 3.0a3 Release&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;, et il existe un PEP&lt;ref&gt;[http://www.python.org/peps/pep-3000.html Python 3000]&lt;/ref&gt; qui détaille les changements prévus, ainsi qu'une page pour orienter les programmeurs dans leur choix de Python 2 ou 3&lt;ref&gt;[http://wiki.python.org/moin/Python2orPython3 Should I use Python 2 or Python 3 for my development activity?]&lt;/ref&gt;.

=== Philosophie ===
Python 3.0 a été développé avec la même philosophie que dans ses versions antérieures, donc toute référence à la philosophie de Python s'appliquera aussi bien à la version 3.0. Comme toujours, Python a accumulé beaucoup de nouvelles méthodes qui font en fait acte de redondance avec d'autres préexistantes. Python 3.0, en recherchant la suppression du code redondant et des modules semblables, suit la grande directive philosophique de Python « Il ne devrait subsister qu'une seule méthode, qui soit à la fois optimale '''et''' naturelle pour chaque chose ».

En dépit de cela, Python 3.0 restera un langage multi-paradigme. Les programmeurs auront encore le choix entre l'orientation objet, la programmation structurée, la programmation fonctionnelle et d'autres paradigmes ; en dépit du choix existant, Python 3.0 a cependant pour but d'être utilisé de manière plus naturelle que dans les versions 2.x.

=== Planning et compatibilité ===
Python 3.0a1, la première version alpha de Python 3.0, a été publiée le 31 août 2007. Les versions 2.x et 3.x de Python seront publiées en parallèle pendant plusieurs cycles de développement, pendant lesquels la série des 2.x subsistera principalement pour la compatibilité, en incluant quelques caractéristiques importées depuis Python 3.x. Le PEP 3000&lt;ref&gt;[http://www.python.org/dev/peps/pep-3000/ Plan de développement PEP 3000]&lt;/ref&gt; contient plus d'informations à propos du processus de publication d'une version.

Comme [[Perl 6]], Python 3.0 rompt la compatibilité descendante (rétro-compatibilité). L'utilisation de code écrit pour les séries 2.x n'est pas garantie avec Python 3.0. Ce dernier apporte des changements fondamentaux, comme le passage généralisé à l'Unicode pour les chaînes de caractères et une distinction forte entre les chaînes de caractère et les objets « bytes ». Le typage dynamique associé à certaines méthodes sur les objets de type dictionnaire  font qu'une transition parfaite de Python 2.x vers Python 3.0 est très difficile. Comme toujours, un outil nommé « 2to3 » réalise la plus grande part du travail de traduction des versions 2.x vers les versions 3.x, en indiquant les zones de codes sujettes à caution par des commentaires spéciaux et des mises en garde.
De plus, dans sa pré-version, 2to3 semble réussir franchement à réaliser une traduction correcte&lt;ref&gt;Sam Ruby, [http://intertwingly.net/blog/2007/09/01/2to3 2to3], {{1er}} septembre 2007&lt;/ref&gt;. Dans le cadre d'une migration de Python 2.x vers Python 3.x, le PEP 3000 recommande de conserver le code original comme base des modifications et de le ''traduire'' pour la plateforme 3.x en utilisant 2to3. 

Python 2.6 devra fournir des caractéristiques de compatibilité ascendante, aussi bien qu'un mode « mise en garde » qui devrait faire prendre conscience des problèmes potentiels de transition pour le passage à Python 3.0&lt;ref&gt;[http://www.python.org/dev/peps/pep-0361/ PEP 361]&lt;/ref&gt;.

=== Python pour smartphones ===
Il existe des versions de python adaptées pour [[Android]] et [[iPhone]] en version 2.6 ou 2.5. Disponible en [[Jailbreak d'iOS]] sur [[IOS (Apple)|iOS]] grâce à &quot;setup tools&quot;, et sur Android grâce à [[SL4A]] qui donne même une possibilité de faire des petites [[interface graphique]]s grâce au module &quot;android&quot; et qui permet d'envoyer des [[SMS]], d'allumer la caméra&lt;ref&gt;http://code.google.com/p/android-scripting/&lt;/ref&gt;, ou encore de faire vibrer le téléphone. Les quelques lignes suivantes montrent comment faire ça : 
&lt;source lang=&quot;python&quot;&gt;
droid = android.Android() # client lié au serveur local lancé par l'application SL4A
       # pour contrôller un téléphone distant à l'adresse 192.168.0.5, avec SL4A lancé sur le port 9887
       # il suffit de faire : android.Android('192.168.0.5', 9887)

droid.vibrate(2.5) # fait vibrer le téléphone (local ou distant) pendant 2.5 secondes
&lt;/source&gt;

Un portage de Python sur les les terminaux [[Blackberry]] est sortie en juin 2012, pour le système [[BlackBerry OS]] 10&lt;ref&gt;[http://blackberry-py.microcode.ca/ BlackBerry-Py Project]&lt;/ref&gt;. Une version allégée est sortie en septembre 2012, appelée « BlackBerry-Tart »&lt;ref&gt;[http://hg.microcode.ca/blackberry-py/wiki/Home blackberry-py] sur [[Bitbucket]]&lt;/ref&gt;{{,}}&lt;ref&gt;[http://peterhansen.ca/blog/blackberry-tart-preview.html BlackBerry-Tart Preview]&lt;/ref&gt;, en raison d'un jeu de mots en anglais : « ''a &quot;tart&quot; is lighter-weight than a &quot;pie&quot;'' ». Elle est basée sur Python 3.2.2.

== Notes et références ==
{{Références|colonnes=2}}

== Voir aussi ==
{{Autres projets
| commons     = Category:Python (programming language)
| wikibooks   = Catégorie:Python
| wikiversity = Python
| wiktionary  = Python
}}

=== Liste de frameworks principaux ===
* Bibliothèques scientifiques : 
** Calcul : [[NumPy]], [[SciPy]], [[International Mathematics and Statistics Library|PyIMSL Studio]], [[Sympy]], [[SAGE (logiciel de calcul formel)|SAGE]]
** [[Système expert]] : [[pyCLIPS]], [[pyswip]]
** Visualisation : [[pydot]], [[maplotlib]], [[pyngl]], [[MayaVi]]
** [[Exploration de données|Data mining]] : [[Orange (logiciel)|Orange]]
** Simulation : [[simPy]]
** Chimie : [[PyMOL]], [[MMTK]], [[Chimera (logiciel)|Chimera]], [[PyQuante]]
** Biologie : [[Biopython]]
* Utilitaire : [[eGenix]], [[ctype]]
* [[Analyse syntaxique|Analyseur syntaxique]] : [[PyParsing]]
* Graphisme : [[Pygame]], [[Python Imaging Library|PIL]], [[Soya 3D]], [[Vpython]], [[pymedia]], [[NodeBox]]
* [[Framework]] web : [[Django (framework)|Django]], [[Karrigell]], webware, {{lien|lang=en|Grok (web framework)|fr=Grok (framework)|texte=Grok}}, [[TurboGears]], {{lien|lang=en|trad=Pylons project|fr=Pylons}}, {{lien|lang=en|trad=Flask (web framework)|fr=Flask (framework)|texte=Flask}}
* [[Serveur HTTP|Serveur web]], [[Système de gestion de contenu|CMS]] : [[Plone]], [[Zope]], [[Google App Engine]], [[CherryPy]], [[MoinMoin]], [[django CMS]]
* [[Système d'information géographique|Cartographie]] : TileCache, FeatureServer, Cartoweb 4, Shapely, GeoDjango, PCL
* Protocoles : 
** pyTango 
** Sérialisation : [[SimpleJSON]]
** [[Transmission Control Protocol|TCP]], [[User Datagram Protocol|UDP]], [[Secure Sockets Layer|SSL]]/[[Transport Layer Security|TLS]], multicast, Unix sockets, [[Hypertext Transfer Protocol|HTTP]], [[Network News Transfer Protocol|NNTP]], [[Internet Message Access Protocol|IMAP]], [[Secure Shell|SSH]], [[Internet Relay Chat|IRC]], [[File Transfer Protocol|FTP]] : [[Twisted]]
* Vecteur : [[GeoJSON]], OWSLib, Quadtree, Rtree, Shapely, WorldMill, ZCO
* [[Mapping objet-relationnel|ORM]] : SQLObject, [[SQLAlchemy]], Storm, Django ORM
* Driver [[Système de gestion de base de données|SGBD]] : [[PyGresQL]], Psycopg, [[MySQL-python]]

=== Articles connexes ===
* [[Afpy|Association Francophone Python]]
* [[Python Software Foundation License]]
* [[bPython]] : terminal interactif.
* [[IPython]] : un autre terminal interactif.
* [[RUR-PLE]] : outil éducatif pour apprendre le Python de façon ludique en pilotant un robot.
* [[PyPI]] : dépôt tiers officiel.

=== Liens externes ===
* {{Site officiel|en|http://www.python.org/}}
* {{fr}} {{dmoz|Python|http://www.dmoz.org/World/Français/Informatique/Programmation/Langages/Python/}}

{{Palette|Python|Langages de programmation}}

{{Portail|informatique|logiciels libres|programmation informatique}}

[[Catégorie:Python|*]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Langage fonctionnel]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]

{{Lien AdQ|ru}}
{{Lien BA|de}}
{{lien BA|en}}</text>
      <sha1>78fpskcckfi326lyijnpulgmxhihew4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Go (langage)</title>
    <ns>0</ns>
    <id>4230561</id>
    <revision>
      <id>101628096</id>
      <parentid>100498861</parentid>
      <timestamp>2014-02-27T02:59:14Z</timestamp>
      <contributor>
        <username>Bloody-libu</username>
        <id>278764</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="9812">{{Voir homonymes|GO}}
{{2autres| le langage de programmation open source créé par Google en 2009 | le langage de programmation créé en 2003 |Go! (langage de programmation)|go dans d'autres contexte|GO}}
{{ébauche|informatique}}
{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom et logo                      = 
 | nom                              = Go
 | logo                             = Go-logo-black.png
 | paradigme                        = [[Compilateur|Langage compilé]], [[programmation concurrente]], [[Programmation impérative|impérative]] et [[Programmation structurée|structurée]]
 | auteur                           = Robert Griesemer&lt;br /&gt;[[Rob Pike]]&lt;br /&gt;[[Ken Thompson]]
 | développeur                      = [[Google|Google Inc.]]
 | date de première version         = {{Date|11|novembre|2009|en informatique}}
 | dernière version stable          = 
 | date de dernière version stable  = {{Date|28|mars|2012|en informatique}}
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = [[typage fort|Fort]], [[typage statique|statique]]
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[C (langage)|C]], [[Pascal (langage)|Pascal]], [[Modula]], [[Oberon (langage)|Oberon]], [[Newsqueak]], [[Limbo (langage)|Limbo]] &lt;ref&gt;{{en}} [http://golang.org/doc/go_faq.html#ancestors What are Go's ancestors?]&lt;/ref&gt;
 | a influencé                      = 
 | système d'exploitation           = [[Windows]], [[Linux]], [[Mac OS|Mac OS X]], [[FreeBSD]], [[Plan_9_from_Bell_Labs|Plan 9]]&lt;ref&gt; {{lien web |langue=en| url = https://groups.google.com/forum/#!topic/golang-nuts/nWm-Fyi_qww | titre = Go on Plan9}}&lt;/ref&gt;
 | licence                          = [[Licence BSD]]&lt;ref&gt; {{lien web |langue=en| url = http://golang.org/LICENSE | consulté le =27 January 2011 | titre = Text file LICENSE}}&lt;/ref&gt;, breveté&lt;ref&gt; {{lien web |langue=en| url=http://code.google.com/p/go/source/browse/PATENTS | consulté le=17 January 2012 | titre = Additional IP Rights Grant}}&lt;/ref&gt;
 | site web                         = [http://golang.org/ golang.org]
 | date de mise à jour              = 
}}

'''Go''' est un [[langage de programmation]] [[Compilateur|compilé]] et  [[Programmation concurrente|concurrent]] inspiré de [[C (langage)|C]] et [[Pascal (langage)|Pascal]]. Ce langage a été développé par [[Google]]&lt;ref&gt;{{en}} http://www.techcrunch.com/2009/11/10/google-go-language/&lt;/ref&gt; à partir d'un concept initial de [[Robert Griesemer]], [[Rob Pike]] et [[Ken Thompson]]. Go possède deux implémentations, la première utilise '''gc''', le [[compilateur]] Go et la seconde utilise '''gccgo''' un « [[w:en:Front and back ends|frontend]] » [[GNU Compiler Collection|GCC]] écrit en [[C++]]. Gc est écrit en C en utilisant [[Lex et yacc|yacc]] et [[GNU Bison]] pour l'analyse syntaxique&lt;ref name=&quot;implémentation&quot;&gt; {{en}} [http://golang.org/doc/go_faq.html#Implementation « FAQ - The Go Programming Language »], ''golang.org'', 6 octobre 2011.&lt;/ref&gt;

[[Fichier:Golang.png|thumb|alt=Logo de Google Go|right|Mascotte de Google Go]]

Go a pour but de faciliter et d'accélérer la programmation à grande échelle : La compilation est de 80 % à 90 % plus rapide que la compilation classique du C&lt;ref&gt;{{en}} {{pdf}} {{lien brisé|consulté le=2013-04-13|url=http://golang.org/doc/go_talk-20091030.pdf|titre=Go Tech Talk}}, page 37&lt;/ref&gt;. Il vise également la rapidité d'exécution, indispensable à la programmation système.

== {{Citation étrangère|lang=en|Hello, world}} ==
Voici un exemple d'un programme [[Hello world]] typique écrit en Go.
&lt;source lang=&quot;go&quot;&gt;
package main

import &quot;fmt&quot;

func main() {
	fmt.Printf(&quot;Hello, World\n&quot;)
}
&lt;/source&gt;

==Caractéristiques==

Le langage Go a été créé pour la programmation système et a depuis été étendu aux applications, ce qui constitue la même cible que le C et surtout le C++. Il s'agit d'un langage [[Programmation impérative|impératif]] et [[programmation concurrente|concurrent]].

===Concurrence===
Go intègre la concurrence en son cœur, permettant très facilement d’exécuter du code en concurrence. Il suffit d'utiliser le mot clé &lt;code&gt;go&lt;/code&gt; pour qu'un appel de fonction puisse être exécuté en concurrence du [[thread (informatique)|thread]] courant. Ce code exécuté en concurrence s'appelle une '''goroutine''' par analogie avec les [[coroutine]]s. Le programme prendra alors avantage de la [[topologie]] de l'ordinateur pour exécuter au mieux les goroutines, pas forcément dans un nouveau thread, mais il est aussi possible qu'un groupe de goroutines soit [[Multiplexage|multiplexé]] sur un groupe de threads.

Les goroutines peuvent communiquer entre elles par [[passage de messages]], en envoyant ou en recevant des messages sur des canaux.
Cet échange de message est le mécanisme principal de synchronisation des goroutines entre elles, conformément au modèle [[Communicating sequential processes|CSP]], considéré par les auteurs comme plus facile à maîtriser par le développeur que le modèle multi-threadé (avec synchronisation via sémaphores, verrous ...).

===[[Système de types]]===
Go a un système de [[Typage statique|type statique]], [[Typage fort|fortement typé]] et [[Sûreté du typage|sûr]], basé sur l'[[inférence de types]] avec la possibilité d'utiliser un typage explicite.

La compatibilité des [[Type abstrait|types composés]] est basée sur les [[Attribut (informatique)|propriété]]s plutôt que sur le nom. C'est-à-dire que deux types composés seront équivalents si leurs propriétés sont équivalentes : même nom pour la propriété et équivalence de type.

Cela a pour conséquence que le langage n'est pas [[Programmation orientée objet|objet]] au sens classique (soit avec [[classe (informatique)|classes]], soit avec [[Programmation orientée prototype|prototype]]), cependant les concepteurs du langage ont fait un choix plus original pour un langage statique. Il est possible de définir des [[interface (informatique)|interface]]s portant des méthodes décrivant le comportement d'un objet (Il est aussi facilement possible de mélanger plusieurs interfaces en une seule)&lt;ref name=&quot;goatgoogle&quot;&gt; {{lien web |langue=en| url = http://talks.golang.org/2012/splash.slide | consulté le = 06 November 2012 | titre = Go at Google | auteur = Rob Pike}}&lt;/ref&gt;. Les fonctions Go peuvent déclarer accepter un [[Paramètre|argument]] de cette interface. Un objet déclarant toutes les méthodes de cette interface, avec la même signature, peut être passé en argument de cette méthode. La vérification du type est effectuée statiquement par le compilateur.

Le fait que Go ne soit pas objet au sens classique fait que Go n'a pas d'[[Héritage (informatique)|héritage]] de type et pas de sous-classage. Ceci permet de contourner les problèmes posés par ces systèmes tels l'[[héritage multiple]] dans les langages qui le permettent (en [[C++]] par exemple), ou l'héritage simple (en [[Java_(langage)|Java]] par exemple). Grâce à l'équivalence de types basée sur les propriétés, Go n'a pas besoin d'héritage de type. Le sous-classage est émulé par l'« embarquement de type ».

La visibilité des structures, attributs, variables, constantes, méthodes, types de haut niveau et des fonctions hors de leur paquetage de déclaration est définie par la [[Sensibilité à la casse|casse]] du premier caractère de leurs [[identificateur]]s.

===Divers===
Dans Go, la gestion de la mémoire est laissée à un [[Ramasse-miettes (informatique)|ramasse-miettes]]&lt;ref name=&quot;goatgoogle&quot;/&gt;.

Il n'y a pas encore de [[Généricité|programmation générique]] même si les concepteurs du langage y réfléchissent. Il n'y a pas de [[surcharge de méthodes]] ou d'[[Pointeur (programmation)#Arithmétique des pointeurs|arithmétique des pointeurs]]. Enfin, il n'y a pas d'[[assertion]]s ou d'[[Système de gestion d'exceptions|exceptions]]. Pour remplacer ces deux derniers, Go fournit les mots clés &lt;code&gt;defer&lt;/code&gt;, &lt;code&gt;panic&lt;/code&gt; et &lt;code&gt;recover&lt;/code&gt; qui donnent des mécanismes similaires aux systèmes de gestion des exceptions de langages tels que C++ et Java (mots clés &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;finally&lt;/code&gt; et &lt;code&gt;throw&lt;/code&gt;).

Go peut s'interfacer avec des bibliothèques en C/C++, des développeurs tiers ayant déjà développé des bindings pour SDL, [[MySQL]], ...

Go définit un format de code standard (au niveau des indentations, de la présentations des structures de contrôle) et fournit un outil pour l'appliquer (go fmt).

Go propose également un système de documentation à partir du code et un framework de test.

L'unité de compilation de go est le package qui est représenté dans l'implémentation standard par un répertoire et les fichiers directement contenu dans ce répertoire.
L'import d'un package se fait par son chemin d'importation et peut préciser soit une bibliothèque standard, soit également des packages tiers installé dans des dépôts de sources distants (actuellement supporté : dépôt sous [[Apache Subversion|svn]], [[Git|git]], [[Mercurial|mercurial]] et [[Bazaar (logiciel)|bazaar]])

== Notes et références ==
{{Références}}

=== Liens externes ===
{{Autres projets|wikibooks=Programmation en Go|wikibooks titre=Programmation en Go}}
* {{en}} [http://golang.org/ Go Site officiel du langage Go]
* {{en}} [http://golang.org/doc/go_faq.html Go FAQ]


{{Palette|Google}}
{{Portail|programmation informatique|Logiciels libres|Google}}

[[Catégorie:Google]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>1pt39vzgon7umy9qw3rzn5cq4lz0y4c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Go! (langage)</title>
    <ns>0</ns>
    <id>4233496</id>
    <revision>
      <id>97334862</id>
      <parentid>91842732</parentid>
      <timestamp>2013-10-09T12:28:58Z</timestamp>
      <contributor>
        <username>Kyro</username>
        <id>257946</id>
      </contributor>
      <minor/>
      <comment>Kyro a déplacé la page [[Go! (langage de programmation)]] vers [[Go! (langage)]]</comment>
      <text xml:space="preserve" bytes="6037">{{à recycler}}
{{ébauche|informatique}}
{{Voir homonymes|GO}}
{{2autres|un langage de programmation multi-agent créé en 2003|le langage de programmation de Google|Go (langage)|go dans d'autres contexte|Go}}

{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom et logo                      = 
 | nom                              = Go!
 | logo                             = 
 | paradigme                        = 
 | auteur                           = [[Francis McCabe]]{{-}}[[Keith Clark]]
 | développeur                      = 
 | date de première version         = 2003
 | dernière version stable          = 
 | date de dernière version stable  = 
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = 
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[Prolog]]
 | a influencé                      = 
 | système d'exploitation           = 
 | licence                          = [[Licence publique générale GNU|GPLv2]]
 | site web                         = 
 | date de mise à jour              = 
}}

'''Go!''' est un  [[Programmation concurrente|langage de programmation concurrent]], originellement conçu par Keith Clark et Francis McCabe en 2003&lt;ref&gt;Clark and McCabe, AAMAS'03, 2003&lt;/ref&gt;. Il est orienté vers le besoin de programmer des agents d'applications surs, de qualité de production. Il est multi-thread, fortement typé et d'un niveau élevé (au sens de la programmation fonctionnelle). Il a des définitions de relation, de fonctions et de procédures d'action. Les threads exécutent les procédures d'action, les appels de fonctions et les ''querying relations'' au besoin. Les threads des différents agents communiquent et se coordonnent en utilisant des messages asynchrones. Les threads à l'intérieur d'un même agent peuvent également utiliser des relations dynamiques partagées agissant comme des registres mémoires.

Sa nature comme langage de programmation multi-paradigme, intégrant des styles de la programmation logique, fonctionnelle et orientée objet&lt;ref name=informatica-survey&gt;Bordini et al., Informatica, 2006&lt;/ref&gt;, est particulièrement mise en œuvre dans les modèles basés sur une [[ontologie (informatique)|ontologie]], tel qu'employés par le [[web sémantique]] en permettant un système type où les classes [[Web Ontology Language|OWL]] peuvent être représentées dans le système type&lt;ref&gt;Clark and McCabe, Applied Intelligence, 2006&lt;/ref&gt;. La conception de Go!, d'après Bordini et al.'s survey&lt;ref name=informatica-survey /&gt;.

Depuis le lancement du langage de programmation de Google, Go! et [[Go (langage)|Go]] sont devenus le sujet d'une polémique sur le nom du langage qui n'est pas résolue au 12 novembre 2009&lt;ref&gt;{{fr+en}} http://www.lemonde.fr/technologies/article/2009/11/12/google-lance-son-propre-langage-de-programmation_1266019_651865.html&lt;/ref&gt;.

== Modèle de Communication ==
Les threads à l'intérieur d'un même processus Go!, et donc dans le même agent, peuvent aussi communiquer en manipulant des objets à relation dynamiques, comparable aux registres de tuple de Linda&lt;ref name=informatica-survey /&gt;, utilisés pour coordonner leurs activités.

== Exemple ==
L'exemple suivant montre le style de type et de déclarations 'ontology-oriented'  de Go!.

&lt;source lang=&quot;javascript&quot;&gt;
Gender::= male | female.

person &lt;˜ {dayOfBirth:[]=&gt;day. age:[]=&gt;integer.
           gender:[]=&gt;Gender. name:[]=&gt;string.
           home:[]=&gt;string. lives:[string]{}}.

person:[string,day,Gender,string]$=person.

person(Nm,Born,Sx,Hm)..{
  dayOfBirth()=&gt;Born.
  age() =&gt; yearsBetween(now(),Born).
  gender()=&gt;Sx.
  name()=&gt;Nm.
  home()=&gt;Hm.
  lives(Pl) :- Pl=home().
  yearsBetween:[integer,day]=&gt;integer.
  yearsBetween(...) =&gt; ..
}.

newPerson:[string,day,Gender,string]=&gt;person.

newPerson(Nm,Born,Sx,Hm)=&gt;$person(Nm,Born,Sx,Hm).
&lt;/source&gt;

== Notes et références ==
{{Références}}

== Voir aussi ==

=== Bibliographie ===
* {{article |langue=en|nom1=Clark |prénom1=K.L. |nom2=McCabe |prénom2=F.G. |année=2003 |titre= Go! for multi-threaded deliberative agents |journal=International Conference on Autonomous Agents (AAMAS'03) |pages=964 - 965 |url=http://portal.acm.org/citation.cfm?doid=860575.860747 | doi=10.1145/860575.860747 }}
* {{ouvrage|nom1=Clark |prénom=K.L. |nom2=McCabe |prénom2=F.G. |année=2003 |titre=Ontology Oriented Programming in Go! |lire en ligne=http://www.doc.ic.ac.uk/~klc/DistKR.pdf }}
* {{article |langue=en|nom1=Clark |prénom1=K.L. |nom2=McCabe |prénom2=F.G. |année=2004 |titre=Go!—A Multi-Paradigm Programming Language for Implementing Multi-Threaded Agents |journal=Annals of Mathematics and Artificial Intelligence |volume=41 |numéro=2-4 |pages=171 - 206 |url=http://portal.acm.org/citation.cfm?id=998367 |doi=10.1023/B:AMAI.0000031195.87297.d9 }}
* {{article |langue=en|nom1=Clark |prénom1=K.L. |nom2=McCabe |prénom2=F.G. |année=2006 |titre=Ontology oriented programming in go! |journal=Applied Intelligence |volume=24 |numéro=3 |pages=189 - 204  |url=http://portal.acm.org/citation.cfm?id=1127540 |doi=10.1145/860575.860747 }}
* {{article |langue=en|auteur=R. Bordini et al. |année=2006 |titre=A Survey of Programming Languages and Platforms for Multi-Agent Systems |journal=Informatica |volume=30 |pages=33 - 44  |url=http://www.informatica.si/vol30.htm }}
* {{article |langue=en|auteur=M. Fisher et al. |année=2007 |titre=Computational Logics and Agents - A Roadmap of Current Technologies and Future Trends |journal=Computational Intelligence|volume=23 |numéro=1 |pages=61 - 91  |url=http://www3.interscience.wiley.com/journal/118495224/issue }}

=== Liens externes ===
* {{fr}} [http://books.google.fr/books?isbn=0975444913 Lets Go! textbook by Francis McCabe]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>7dixvnhrjfslyd0ut7rcnunvq76m59w</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>X10 (langage de programmation)</title>
    <ns>0</ns>
    <id>4244847</id>
    <revision>
      <id>99981682</id>
      <parentid>99981646</parentid>
      <timestamp>2014-01-06T18:02:03Z</timestamp>
      <contributor>
        <username>Rehtse</username>
        <id>759276</id>
      </contributor>
      <minor/>
      <comment>Introduction : orthographe</comment>
      <text xml:space="preserve" bytes="1990">{{Voir homonymes|X10}}

{{Infobox Langage de programmation
| nom                    = X10
| paradigme              = [[Programmation orientée objet]]
| année                  = 2004
| auteur                 = Kemal Ebcioğlu, Vijay Saraswat et Vivek Sarkar
| développeur            = [[IBM]]
| typage                 = [[Typage statique|Statique]], [[Typage fort|fort]], [[Sûreté du typage|sûr]]
| influencé par          = [[Java (langage)|Java]]
| système d'exploitation = [[AIX]], [[Linux]], [[Mac OS X]], [[Cygwin]]
| licence                = [[Eclipse Public License]]
| site web               = [http://x10-lang.org/ x10-lang.org]
}}

'''X10''' est un langage de programmation en cours de développement chez [[IBM]] ''[[Thomas J. Watson Research Center]]'' financé par le projet ''High Productivity Computing Systems'' de [[Defense Advanced Research Projects Agency|DARPA]]. Les auteurs principaux sont Kemal Ebcioğlu, Vijay Saraswat, and Vivek Sarkar&lt;ref&gt;http://www.aurorasoft.net/workshops/lar04/Author_Files/Papers/Vivek_Sarkar_LaR_04_Paper_V1.pdf&lt;/ref&gt;.

X10 est conçu pour la [[programmation parallèle]] avec le modèle ''[[espace d'adressage global partagé]]'' (PGAS).  Un programme s'exécuter sur un ensemble de ''places'' : chaque place possède des données et quelques ''activities'' qui font des calculs sur ces données. Il supporte un système de typage avec des contraintes pour la programmation orientée objet, les types primitifs ''structs'' définis par l'utilisateur, les ''globally distributed arrays'' et le parallélisme structuré et non structuré&lt;ref&gt;http://x10.sourceforge.net/documentation/languagespec/x10-latest.pdf&lt;/ref&gt;.

== Articles connexes ==
* {{lien|fr=Chapel (langage)|lang=en|trad=Chapel (programming language)}}
* [[Fortress (langage)|Fortress]]

==Références==
&lt;references/&gt;

== Liens externes ==
* [http://x10-lang.org Page d'accueil de X10 ]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation|X10]]</text>
      <sha1>hc22k5iklc7svmekzgsjtsbpeenctsf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Common Intermediate Language</title>
    <ns>0</ns>
    <id>3480643</id>
    <revision>
      <id>101016783</id>
      <parentid>99894538</parentid>
      <timestamp>2014-02-08T02:28:31Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>wikif.</comment>
      <text xml:space="preserve" bytes="5909">Dans l'environnement de programmation Microsoft, le '''Common Intermediate Language''' (CIL) est le [[langage de programmation]] de plus [[Langage de bas niveau|bas niveau]] qui peut être lu par un humain. Le code de plus haut niveau dans l'environnement [[.NET Framework]] est compilé en code CIL qui est assemblé dans un code dit [[bytecode]]. CIL est un code assembleur orienté objet et pile. Il est exécuté par une machine virtuelle.

Le CIL était initialement connu sous le nom de Microsoft Intermediate Language ou MSIL durant les béta du langage .NET. Après la standarisation du [[C sharp]] et de la [[Common Language Infrastructure|CLI]], le bytecode fut officiellement référencé sous le nom de CIL. Les utilisateurs précoces de la technologie continuent néanmoins à se référer au terme MSIL.

== Compilateur JIT/NGEN ==
Durant la compilation .NET, le code source est transformé en un code CIL portable, indépendant de la plateforme et du processeur, et appelé bytecode.

Ce bytecode est compilé par la CLR/DLR en temps réel pour obtenir un code immédiatement exécutable par le processeur. Durant cette compilation, le compilateur (JIT) effectue un grand nombre de tâches pour éviter des accès illégaux à la mémoire :
* optimisation spécifique à la plateforme
* sécurisation des types
* vérification des assembly 

Cette compilation peut aussi être réalisée avec un générateur natif d'image (NGEN). Cet outil a pour but de supprimer le temps d'attente dû à la compilation qui a lieu au niveau des [[Common Language Runtime|CLR]] et [[Dynamic Language Runtime|DLR]] . Attention, l'image binaire native est placée dans le cache des 'assemblies' mais nécessite pour s'exécuter le fichier d'origine (certaines informations ne sont pas recopiées dans l'image)&lt;ref&gt;http://msdn.microsoft.com/fr-fr/library/6t9t5wcf(VS.80).aspx&lt;/ref&gt;.

== .NET metadata ==
.NET enregistre les informations concernant les classes compilées dans un fichier de nom [[metadata]]. Ces données agissent comme la bibliothèque [[Component Object Model]], et permettent aux applications compatibles de découvrir les interfaces, les classes, les types, et les méthodes présentes dans le code assembleur. Le processus de lecture de ces données est appelé réflexion. Ces données peuvent être lues en utilisant l'outil ILDASM fourni avec le SDK .NET Framework.

Toute la CIL est autodescriptive, grâce aux [[Métadonnées]] [[Microsoft .NET|.NET]]. La CLR vérifie les métadonnées pour s'assurer que la bonne méthode est appelée. Les métadonnées sont généralement générées par les compilateurs des langages, mais les développeurs peuvent aussi créer leurs propres métadonnées via l'utilisation d'attributs personnalisés. Les métadonnées contiennent aussi des informations à propos des assemblages et sont aussi utilisées pour implémenter la capacité de [[Réflexion (informatique)|réflexion]] du .NET Framework.

== .NET assemblies ==
Le code CIL est stocké dans les [[assemblage .NET|assemblages .NET]] (ou assemblies).

L'assemblage est le bloc de structuration fondamental des applications .NET. Un assemblage regroupe l'ensemble des éléments nécessaires au bon fonctionnement d'une application (ou partie d'une application) : exécutables, métadonnées, autorisations, ressources (images...), etc...
Le concept d'assemblage a été introduit pour résoudre les problèmes d'installation, d'évolution de version, d'internationalisation, de contexte d'exécution, de conflits de DLL... À ce titre, c'est une unité de déploiement indivisible.

Les assemblages sont constitués d´un ou plusieurs fichiers, dont l'un doit contenir un document XML appelé manifeste. Le manifeste&lt;ref&gt;[http://msdn2.microsoft.com/fr-fr/library/1w45z383(en-us,VS.71).aspx Assembly Manifest&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt; contient :
* la liste de l'ensemble des fichiers utilisés (exécutables, DLL, données, images, ressources)
* les métadonnées, 
* la liste des autres assemblages utilisés par l'application
* l'ensemble des informations liées aux autorisations et à la sécurité de l'assemblage.

  
Les assemblages .NET sont enregistrés au format [[Portable Executable File Format|exécutable portable]] (PE) courant sur la plate-forme [[Windows]] pour tous les fichiers [[Bibliothèque logicielle#Cas spécifiques dans différents systèmes d'exploitation|DLL]] ou [[EXE]]. Le nom complet d'un assemblage (à ne pas confondre avec le nom du fichier sur le disque) contient son nom simple, son numéro de version, sa culture et sa [[clé publique]]. La clé publique est unique et est générée à partir du [[Fonction de hachage|hachage]] de l'assemblage après sa compilation. En conséquence, deux assemblages avec la même clé publique sont garantis être identiques. Une [[Clef publique|clé privée]] peut aussi être spécifiée ; elle est uniquement connue du créateur de l'assemblage et peut être utilisée pour le nommage fort de celui-ci. Cela garantit que l'assemblage est du même auteur lors de la compilation d'une nouvelle version.

Le code CIL d'un assemblage .NET existe sous deux formes : exécutables (process assemblies) et DLL (library assemblies). Lors de la compilation, le choix du format final du fichier contenant le code source ne dépend pas de l'extension du fichier mais d'une information stockée dans un fichier PE. Ce fait explique que, dans un même répertoire, deux fichiers de même nom mais avec des extensions différentes ne peuvent par défaut exister. Ce problème a été résolu par l'utilisation d'une clé publique/privée pour signer une DLL ou un exécutable et par l'introduction par .NET du [[Global Assembly Cache|GAC]].

== Notes et références ==
&lt;references /&gt;

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:.NET Framework]]
[[Catégorie:Microsoft]]</text>
      <sha1>gdp1loaq3jkueqkjwjcjc4ylfzrephz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>VisSim</title>
    <ns>0</ns>
    <id>4416059</id>
    <revision>
      <id>99816413</id>
      <parentid>90666326</parentid>
      <timestamp>2014-01-02T16:11:41Z</timestamp>
      <contributor>
        <username>OrlodrimBot</username>
        <id>1055871</id>
      </contributor>
      <minor/>
      <comment>Ajout du paramètre oldid dans {{Traduction/Référence}} — d'après l'historique, la traduction date du 24 janvier 2010, à partir de la version du 11 janvier 2010 de l'article original</comment>
      <text xml:space="preserve" bytes="8450">{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom et logo                      = oui
 | nom                              = VisSim
 | logo                             = VisSimIcon.png
 | paradigme                        = [[Langage graphique]], [[Programmation logique]]
 | auteur                           = 
 | développeur                      = [[Visual Solutions]]
 | date de première version         = 1989
 | dernière version stable          = Version 7
 | date de dernière version stable  = 2008
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = 
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[C (langage)|C]]
 | a influencé                      = 
 | système d'exploitation           = [[Windows]], [[Linux]]
 | licence                          = 
 | site web                         = http://www.vissim.com
 | date de mise à jour              = 
}}

'''VisSim''' est un [[Langage graphique|langage de programmation visuelle]] distingué par sa capacité à modéliser et à simuler des [[systèmes dynamiques]] complexes. VisSim associe une interface intuitive d’assemblage de blocs de diagrammes (par glisser/déposer) à un puissant moteur de simulation. Il est développé par la société américaine Visual Solutions, de [[:en:Westford, Massachusetts|Westford]].

==Applications==
[[File:VisSim screenshot.PNG|left|thumb|Visualiseur VisSim avec modèle miniaturisé.]]
VisSim est largement utilisé pour la conception et la simulation de projets dans le domaine des systèmes de contrôle et de [[traitement numérique du signal|traitement numérique de signal]]. Il intègre des blocs pour l’arithmétique, le booléen et les fonctions transcendantes, ainsi que des [[filtre numérique|filtres numériques]], des [[fonction de transfert|fonctions de transfert]], l’intégration numérique et un interactif de traçage. Les applicatifs les plus couramment modélisés sont du domaine de l’aéronautique, de la biologie ou de la recherche médicale, de la capacité de puissance numérique, des moteurs électriques, ainsi que du procédé électrique, hydraulique, mécanique ou économétrique.

===Programme Académique===
Le Programme Académique VisSim permet aux établissements d’enseignement accrédités l’usage d’une licence libre de VisSim v3.0. Les dernières versions de VisSim, ainsi que leurs fonctionnalités additionnelles, sont également proposées aux étudiants et aux établissements universitaires à des prix considérablement réduits&lt;ref&gt;''Visual simulation with student VisSim'', par Karen Darnell, 1996, PWS Pub. Co., Boston, ISBN 0534954855&lt;/ref&gt;.

===Partage des diagrammes===
[[File:Barnsley fern plotted with VisSim.PNG|thumb|Visualiseur VisSim avec modèle de [[fractale]].]]
Le [http://www.vissim.com/downloads/demos.html Visualiseur VisSim ] offre un moyen gratuit de partager des modèles  avec ses collègues ou des clients, sans licence VisSim complémentaire. Le visualiseur peut exécuter toutes sortes de modèles à partir de VisSim, tout en permettant d’effectuer certains changements dans les blocs ou dans les paramètres de simulation, afin d’illustrer des scénarios de différentes conceptions. Il est possible d’activer ou de changer les boutons inclus dans le modèle.

==Code source==
La fonctionnalité additionnelle VisSim/C-Code convertit automatiquement les modèles VisSim en un code [[C (langage)|C ANSI]] hautement optimisé, qui peut être compilé et exécuté sur toute plate-forme acceptant ce langage. Il en résulte un code plus efficace et plus lisible que par la plupart des autres générateurs de codes. Le développeur de VisSim a siégé au comité « X3J11 ANSI C » et a écrit divers compilateurs C, de même qu’un livre sur le langage C&lt;ref&gt;[http://books.google.fr/books?id=1nsS5q9aZOUC Livre par Peter A. Darnell]&lt;/ref&gt;.
==[[Ingénierie dirigée par les modèles|Ingénierie dirigée par modèle]]==
La construction de modèles est un moyen visuel de se représenter une situation, en utilisant des blocs de résolution de problèmes au lieu de former des équations simultanées avec notations mathématiques. Si un modèle est construit à partir d’une situation concrète, la solution devient plus claire, voire évidente, alors que l’on rencontre fréquemment des problèmes au niveau des équations mathématiques à l’usage de solutions moins performantes.

Les diagrammes imbriqués sont faciles à créer : vous construisez normalement les modèles avec différentes couches VisSim, si nécessaire combinés avec des blocs personnalisés écrits en C ou Fortran, puis un contrôleur virtuel est ajouté avec l’assistance nécessaire pour obtenir toute la réponse souhaitée du système global. Il est encore possible d’ajouter des curseurs et des boutons, rendant plus facile la réalisation de divers scénarios destinés à la formation des opérateurs ou le contrôle de mise au point. La technique de simulation des performances du système hors connexion, suivi de la production automatique du code à partir du diagramme simulé est  connue sous le nom de « Développement architecturé autour d’un modèle ». Il s’agit d’un développement basé sur un modèle pour [[systèmes embarqués]] : largement adopté pour les systèmes de production, il raccourcit les cycles de développement matériel de la même manière que [[Model Driven Architecture|l’architecture dirigée par modèle]] raccourcit les cycles de développement logiciel.

== Fonctionnalités additionnelles VisSim ==
* VisSim/ECD vous donne la possibilité de créer rapidement des prototypes pour des applications de contrôle gérées par les DSP de [[Texas Instruments]]. Pour le [[MSP430]], VisSim besoins seulement 740 octets flash et 64 octets de RAM pour une petite boucle fermée [[Modulation de largeur d'impulsion]] (PWM) système. On-chip peripheral support: serial ports, Controller_area_network (CAN), PWM, [[Modulation d'amplitude en quadrature]] (QAM), Event Capture, [[Serial Peripheral Interface Bus]] (SPI), [[I²C]], [[Convertisseur analogique-numérique]] (ADC), [[Convertisseur numérique-analogique]] (DAC), et [[GPIO]].
* [[Couche physique]] communication système simulation (modulators, encoders, [[Boucle à phase asservie]] (PLLs), Costas Loop, [[BPSK]], [[QPSK]], DQPSK, [[QAM]], Bit Error Rate (BER), Eye Diagram, [[Algorithme de Viterbi]], [[Code de Reed-Solomon]], etc)
* Frequency domain analysis ([[Diagramme de Bode]], Root locus, [[Diagramme de Nyquist]])
* [[Atelier de génie logiciel]] [[C (langage)]] (C-code generation)
* [[Machine électrique]] simulation bibliothèque d'exécution pour AC induction, [[moteur sans balais]], ou [[moteur pas à pas]]
* [[Réseau de neurones artificiel]]
* OPC ([[OLE for process control]]) -- read &amp; write OPC tags pour real-time simulation de [[SCADA]]/HMI virtual plants
* Globale d'optimisation des paramètres système
* Real-time [[Analogique]] et [[Signal électrique]] pour Windows
* Ensemble de blocs pour la modélisation avec [[virgule fixe]] et générateur de C-code pour eux
* Lecture et d'écriture des paquets pour bus [[Controller area network|CAN]]

==Source==
{{Traduction/Référence|en|VisSim|337208285}}
{{reflist}}

== Liens externes ==
* {{fr}} [http://www.sigmaplus.fr/logiciels_modelisations-et-simulations_vissim_240500.html Sigmaplus.]
* {{en}} [http://www.springer.com/engineering/signals/book/978-3-642-01358-4 A Simulation-Aided Introduction with VisSim/Comm] Digital Transmission Series: Signals and Communication Technology, Guimaraes, Dayan Adionel, 2010, ISBN 978-3-642-01358-4
* {{en}} [http://www.ieeecss.org/columns/October2007/Oct2007VisSimProductSpotlight.pdf Texas Instruments MSP430 spotlight article] published in [[IEEE]] magazine.
* {{en}} [http://www.vissim.com VisSim web site]
* {{en}} [http://books.google.com/books?isbn=9780387946757 C: A Software Engineering Approach], by Peter A Darnell, Philip E Margolis, 3rd edition, 1996, ISBN 9780387946757

{{Palette
| Logiciels de calcul numérique
}}
{{Portail|programmation informatique}}

[[Catégorie:Optimisation]]
[[Catégorie:Logiciel de simulation]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>1e9y3x1xr3uh6t5toyilanghi4tnkj5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NesC</title>
    <ns>0</ns>
    <id>4471819</id>
    <revision>
      <id>90675479</id>
      <parentid>61851352</parentid>
      <timestamp>2013-03-17T19:59:55Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 5 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q286443]]</comment>
      <text xml:space="preserve" bytes="392">'''NesC''' est un [[langage de programmation]] dérivé du langage [[C (langage)|C]], fait pour minimiser l’utilisation de mémoire et de puissance de calcul par les [[capteur]]s, qui très souvent disposent de ressources très limitées (batterie de faible puissance et non changeable, mémoire réduite...).

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>n9z7dnkavcf12n919tlon0q45hzds61</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Dylan (langage)</title>
    <ns>0</ns>
    <id>4492793</id>
    <revision>
      <id>90679223</id>
      <parentid>70400723</parentid>
      <timestamp>2013-03-17T20:29:50Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 10 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q1268744]]</comment>
      <text xml:space="preserve" bytes="3198">{{Voir homonymes|Dylan}}
{{Infobox Langage de programmation
|  nom                    = Dylan
|  logo                   =
|  paradigmes             = [[Programmation orientée objet|Objet]], [[Programmation fonctionnelle|fonctionnel]]
|  année                  = [[1992 en informatique|1992]] pour la publication de sa première spécification
|  auteur                 = [[Apple|Apple Computer]]
|  développeurs           =
|  dernière version stable=
|  date de dernière version stable =
|  typage                 = [[Typage dynamique|dynamique]] [[Typage fort|fort]]
|  implémentations        = Open Dylan, Gwydion Dylan
|  dialectes              = 
|  influencé par          = [[CLOS]], [[C++]], [[Algol (langage)|Algol]], [[Scheme]]
|  a influencé            = [[Ruby]], [[Goo]]
|  système d'exploitation = [[Multiplate-forme]]
|  licences               =
|  site web               = [http://www.opendylan.org/ Open Dylan]
}}

'''Dylan''' est un [[langage de programmation]] [[typage dynamique|dynamique]], [[Réflexion (informatique)|réflexif]], [[Programmation orientée objet|orienté objet]] et [[Programmation fonctionnelle|fonctionnel]]. Il propose un modèle de programmation axé vers une génération efficace de code machine. Il a été créé au début des années 1990 par un groupe conduit par [[Apple]] pour son [[PDA]], l'[[Apple Newton]].

== Syntaxe et exemples ==

À l'origine, Dylan utilisait une syntaxe préfixée, similaire à [[Scheme]] ou [[LISP]], basée sur les [[S-expressions]] :

&lt;code&gt;
 (bind ((radius 5)
        (circumference (* 2 $pi radius)))
   (if (&gt; circumference 42)
       (format-out &quot;Hello big circle! c is %=&quot; circumference)
       (format-out &quot;Hello circle! c is %=&quot; circumference)))
&lt;/code&gt;

Avant que la conception du langage ne soit terminée, elle fut remplacée par une syntaxe proche de l'[[Algol (langage)|Algol]], conçue par [[Michael Kahl]], dans l'espoir qu'elle serait familière au plus grand nombre de développeurs :

&lt;code&gt;
  let radius = 5;
  let circumference = 2 * $pi * radius;
  if (circumference &gt; 42)
     format-out(&quot;Hello, big circle! c is %=&quot;, circumference);
  else
     format-out(&quot;Hello, circle! c is %=&quot;, circumference);
  end if
&lt;/code&gt;


Comme dans d'autres langages [[Programmation fonctionnelle|fonctionnels]], le résultat d'une fonction est sa dernière expression évaluée (l'instruction &quot;return&quot; est donc inutile). L'exemple suivant montre l'implémentation récursive de la fonction [[factorielle]]

&lt;code&gt;
 define method factorial(n :: &lt;integer&gt;)
   if (n = 0)
     1
   else
     n * factorial(n - 1)
   end
 end method;
&lt;/code&gt;

== Applications ==

Outre son utilisation pour le [[PDA]] [[Apple Newton|Newton]] d'Apple, Dylan est employé pour :

* Dylan Server Pages : un moteur de templates (similaire à [[JavaServer Pages]])
* Koala : un [[serveur web]]

== Voir aussi ==

=== Liens externes ===

* [http://www.opendylan.org/ Site officiel des implémentations OpenDylan et Gwydion Dylan]

{{Palette Langages de programmation}}
{{Portail|informatique|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage fonctionnel]]</text>
      <sha1>8d6ojx663u0wdvo3h4cl00zi7qh9yag</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Frink (langage)</title>
    <ns>0</ns>
    <id>4614158</id>
    <revision>
      <id>90695043</id>
      <parentid>82025286</parentid>
      <timestamp>2013-03-17T22:41:45Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3087863]]</comment>
      <text xml:space="preserve" bytes="2924">{{Orphelin|date=mai 2011}}
{{Voir homonymes|Frink (homonymie)}}
{{Infobox Langage de programmation
| nom                    = Frink
| paradigme              = 
| année                  = 2001
| auteur                 = [[Alan Eliasen]]
| dialectes              = 
| influencé par          = [[Java (langage)|Java]], [[Perl (langage)|Perl]], [[Ruby]], [[Smalltalk]], [[BASIC]]
| a influencé            = 
| système d'exploitation = [[Multiplateforme]]s
}}
'''Frink''' est un outil de calcul et un [[langage de programmation]] conçu par Alan Eliasen. Il est construit sur la [[machine virtuelle Java]] et inclut des fonctionnalités similaires à Java, Perl, Ruby, Smalltalk, et des nombreuses implémentations du BASIC. Il se concentre principalement sur les domaines des sciences, sciences de l'ingénieur, physique, traitement de textes et éducation.

Le langage est nommé d'après le savant fou fictif [[Professor Frink|Professeur John Frink]] de la série télévisée populaire ''[[Les Simpson]]'', qui a prédit, des années auparavant, ''&quot;Je prédis que d'ici 100 ans, les ordinateurs seront deux fois plus puissant, dix mille fois plus grand, et si chers que seulement les cinq rois les plus riches d'Europe les possèderont.&quot;''

L'une des caractéristique notable de Frink est qu'il conserve les unités de mesure à travers tous les calculs. Cela permet à toutes les valeurs de contenir une quantité et une unité de mesure. Frink comprend comment différentes unités sont reliées, comme une longueur élevée à la puissance trois est un volume, ou la puissance multipliée par le temps est de l'énergie. Différentes unités de mesure peuvent être mélangées dans les calculs, et Frink automatiquement, s'assure que les calculs aboutisse à un résultat dans les dimensions attendues.

&lt;code&gt;
 taille = 3 feet
 gravitation = 9.80665 m/s^2
 masse = 60 kg
 energie_potentielle = taille * gravitation * masse
 println[energie_potentielle -&gt; joules]  // Affiche en [[joule]]s
&lt;/code&gt;

La distribution standard vient avec un fichier de données contenant plusieurs milliers des unités de mesure les plus communes, avec des données telles que les masses des particules élémentaires, des données astronomiques et des mesures historiques. Le fichier de données standard utilise le système d'unité ([[SI]]) internationales comme base et l'étend avec des unités monétaires et informatiques (bits). Le fichier standard peut être complètement remplacé par l'utilisateur et de nouvelles unités peuvent être ajouté lors de l'utilisation.

La syntaxe de Frink essaie de suivre la notation mathématique standard lorsque sans ambiguïté. Par exemple, la déclaration ci-dessus peut être réécrite en utilisant la multiplication implicite entre les trois unités:

&lt;code&gt;&lt;pre&gt;
hauteur gravitation masse
&lt;/pre&gt;&lt;/code&gt;

{{Portail|Programmation informatique}}
[[Catégorie:Langage de programmation]]</text>
      <sha1>6ah0gbu7ffwr4r7w3dvwpdoftba0p5z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Portal (langage)</title>
    <ns>0</ns>
    <id>4619825</id>
    <revision>
      <id>96394134</id>
      <parentid>93360460</parentid>
      <timestamp>2013-09-04T16:38:28Z</timestamp>
      <contributor>
        <username>Ange Gabriel</username>
        <id>263831</id>
      </contributor>
      <minor/>
      <comment>Balise HTML &lt;u&gt; de soulignement ([[P:CS|Correction syntaxique]]) (v1.29)</comment>
      <text xml:space="preserve" bytes="1382">{{voir homonymes|Portal}}

'''Portal''' est un [[langage de programmation]] créé par R.Schild et H.Lienard du Laboratoire de recherche  de [[Siemens (entreprise)|LGZ Landis &amp; Gyr]] à [[Zoug (ville)|Zoug]]  en [[1978]], spécialisé pour la programmation temps réel et la [[programmation concurrente]].

Dérivé de Pascal, il adopte en matière d'entrée/sortie la politique suivie par le [[PDP11]], certains processeurs Motorola et le langage [[APL (langage)|APL]] : les entrées-sorties se ramènent à des affectations, dès qu'on a associé à chaque port nécessaire une variable de même adresse. 

Définir une procédure la crée comme type, dont les instanciations seront des tâches. 

Enfin, Portal permet de définir facilement des moniteurs.

== Bibliographie ==
*A. Businger, L. Zaffalon, ''Programmer en PORTAL'', Presses polytechniques et universitaires romandes, Lausanne (1986).
*R. Schild, H. Lienhard, ''Real-time programming in PORTAL'', April 1980 
*H. Lienhard ''The real-time programming language PORTAL, Introduction and Survey'' LANDIS &amp; GYR Review &lt;{{Souligner|2--78}}, 2--8 (1978) 
*R. Schild ''Parallel processes in PORTAL, exemplified in a group project''ref LANDIS &amp; GYR Review &lt;{{Souligner|2--78}}, 9--16 (1978)

{{Portail|programmation informatique|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Programmation concurrente]]</text>
      <sha1>nb86lgdt4v4be8j1rxa0bqrqmq7wr8b</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ABAL</title>
    <ns>0</ns>
    <id>1015539</id>
    <revision>
      <id>96103380</id>
      <parentid>65196515</parentid>
      <timestamp>2013-08-25T09:58:12Z</timestamp>
      <contributor>
        <username>Isaac Sanolnacov</username>
        <id>188230</id>
      </contributor>
      <minor/>
      <comment>corr. liens</comment>
      <text xml:space="preserve" bytes="3085">{{ébauche|informatique}}

'''ABAL''' est un [[langage de programmation|langage]] de [[programmation]] conçu et distribué par la société [[PROLOGUE|Prologue]] (aux [[les Ulis|Ulis]] en France).

ABAL (Avanced Business Application Language) est un langage procédural orienté objet.

ABAL est un [[Langage interprété informatique|langage interprété]], le [[code source]] est traduit en T-code par un traducteur (Atr) et un [[éditeur de liens]] (ald) sous forme d'un [[fichier informatique]] '''.at''' qui n'est pas exécutable directement.

Les programmes ABAL sont exécutables grâce à un exécuteur spécifique à chaque [[système d'exploitation]] ([[Windows]], Twinserver, Useit, [[Unix]]/SCO).

Il existe différents type d'exécuteurs : 16Bits et 32Bits pour répondre aux spécificités des différents systèmes d'exploitation et des besoins applicatifs.

L'exécuteur s'appuie sur des '''BDA''' (bibliothèques dynamiques) pour ajouter des fonctionnalités :
* Screener  : Bibliothèque interface graphique
* Visual    : Bibliothèque interface graphique
* FAC       : Bibliothèque accès fichier
* TTY       : Bibliothèque accès port COM
* MODEXT    : Bibliothèque [[Critéria]]/[[ODBC]]
* BDAMAIL   : Bibliothèque Communication avec [[serveur de messagerie électronique]] (envoi/réception, décodage/encodage pièces jointes, …)
* BDANET    : Bibliothèque pour utilisation de [[Berkeley sockets|sockets]] [[HTTP]] client et serveur
* GRAPHABAL : Bibliothèque gestion de graphique ([[diagramme circulaire|camembert]], [[histogramme]], etc.)
* …..à compléter…..

L'exécuteur s'appuie aussi sur des bibliothèques systèmes spécifiques à chaque système d'exploitation (DLL sous Windows, .so sous Useit, .xp sous Twinserver).

Le langage ABAL est une amélioration de BAL (Business Application Language). ABAL a évolué depuis de nombreuses années : ABAL, ABAL2 et maintenant ABAL3. ABAL se compose d'un éditeur de texte, d'un éditeur de lien, d'un traducteur et d'un débuggeur.

Il existe un intégré de développement qui regroupe l'éditeur, l'éditeur de lien, le traducteur et le débuggeur.
* WABAL2 pour ABAL2
* WABAL3 pour ABAL3

Un nouvel intégré nommé SING s'appuie sur la BDA VISUAL. Il permet de définir des formulaires (écran de saisie ou d'édition) et crée automatiquement le code ABAL3 et VISUAL correspondant au formulaire de saisie ou d'impression (… à développer…) et qui permet, coupler à la BDA BDANET de réaliser un [[serveur HTTP]] qui répond aux requêtes en produisant des pages [[Hypertext Markup Language|HTML]].

La société Prologue :
* est aussi l'auteur et le distributeur d'une [[base de données]] propriétaire : [[Critéria]]
* est concepteur et diffuseur de [[Useit]] (distribution [[Linux]] orientée gestion des entreprises)

== Bibliographie ==
* Antonio de Sousa &amp; Claude Moto'nGane, ''Le développement d'applications portables en ABAL'', 480 pages, édition [[Sybex]], 1993, {{ISBN|978-2-7361-1045-1}}

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>2vsim2nn6e186ybue2irg5jeo101esz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>TRAC (langage de programmation)</title>
    <ns>0</ns>
    <id>4686629</id>
    <revision>
      <id>90707527</id>
      <parentid>74799342</parentid>
      <timestamp>2013-03-18T00:50:21Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2842324]]</comment>
      <text xml:space="preserve" bytes="2443">{{voir homonymes|Trac (homonymie)}}
{{ébauche|informatique}}

{{Infobox Langage de programmation
|  couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
|  nom et logo                      = non
|  nom                              = TRAC
|  logo                             = 
|  paradigmes                       = 
|  auteur                           = [[Calvin Mooers]]
|  développeurs                     = [[Calvin Mooers]] et [[L. Peter Deutsch]]
|  date de première version         = Début des années [[1960]]
|  dernière version stable          = 
|  date de dernière version stable  = 
|  dernière version avancée         = 
|  date de dernière version avancée = 
|  typage                           = 
|  implémentations                  = 
|  normes                           =
|  dialectes                        = 
|  influencé par                    = [[Forth (langage)|FORTH]], [[Smalltalk]], [[Lisp]]
|  a influencé                      = [[SAM76]], MINT
|  système d'exploitation           = Machines [[PDP-10]]
|  licences                         = 
|  site web                         = 
|  date de mise à jour              = 9 septembre 2010
}}
'''TRAC''' (en anglais « ''Text Reckoning And Compiling'' ») est un [[langage de programmation]] conçu au début des années 60 par [[Calvin Mooers]]. 

[[L. Peter Deutsch]] implémente TRAC sur machines [[PDP-1]] en 1964 après avoir été recruté par Mooers au sein de la société [[Bolt, Beranek and Newman]] pour l'aider dans ses développements&lt;ref&gt;{{en}} [http://www.cbi.umn.edu/collections/inv/cbi00081.html Source sur le site de l'université de Minnesota] (département ingénierie informatique).&lt;/ref&gt;.

==Autres Implémentations==
* MINT ('''M'''INT '''I'''s '''N'''ot '''T'''RAC) est un interpréteur de ''chaînes de caractères pour [[Freemacs]] basé sur TRAC.

==Bibliographie==
* « ''TRAC, A Text-Handling Language'' » (Calvin Mooers et L. Peter Deutsch, 1965)&lt;ref&gt;{{en}} [http://portal.acm.org/citation.cfm?doid=800197.806048 Exposé présenté en août 1965] à [[Cleveland]] dans l'État de l'[[Ohio]] aux [[États-Unis]], lors de la 20{{ème}} conférence nationale de l'[[Association for Computing Machinery|ACM]].&lt;/ref&gt;.

==Voir aussi==
===Article connexe===
* [[SAM76]]

== Notes et références ==
{{Références}}

{{Portail|programmation informatique}}
[[Catégorie:Langage de programmation]]</text>
      <sha1>cyw0qo025909tdycfam2ztf9v0irz20</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>BLISS (langage de programmation)</title>
    <ns>0</ns>
    <id>4689676</id>
    <revision>
      <id>92909651</id>
      <parentid>90708025</parentid>
      <timestamp>2013-05-08T19:46:50Z</timestamp>
      <contributor>
        <username>OrlodrimBot</username>
        <id>1055871</id>
      </contributor>
      <minor/>
      <comment>Restauration des [[Projet:Restauration des ancres brisées|ancres brisées]]</comment>
      <text xml:space="preserve" bytes="2877">{{Voir homonymes|Bliss}}
{{ébauche|informatique}}


{{Infobox Langage de programmation
|  couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
|  nom et logo                      = non
|  nom                              = BLISS
|  logo                             = 
|  paradigmes                       = [[Programmation structurée|structuré]], [[Programmation impérative|impératif]], [[Programmation fonctionnelle|fonctionnel]]
|  auteur                           = [[William Wulf]], [[D. B. Russell]] et [[Nico Habermann]]
|  développeurs                     = [[Université Carnegie-Mellon]]
|  date de première version         = années [[1970]]
|  dernière version stable          = BLISS-64
|  date de dernière version stable  = 
|  dernière version avancée         = 
|  date de dernière version avancée = 
|  typage                           = [[Typage statique]]
|  implémentations                  = 
|  normes                           =
|  dialectes                        = 
|  influencé par                    = [[ALGOL]]
|  a influencé                      = 
|  système d'exploitation           = [[TOPS-10]], [[TOPS-20]] / [[PDP-10]], [[PDP-11]] / [[DEC Alpha]], [[DEC PRISM]], [[x86]], [[IA-64]], [[VAX]]
|  licences                         = 
|  site web                         = [http://pdp-10.trailing-edge.com/bb-m836d-bm/ BLISS-10]
|  date de mise à jour              =
}}

'''BLISS''' est un [[langage de bas niveau]] développé dans les années 1970 à l'[[université Carnegie-Mellon]] par [[William Wul]], [[D. B. Russell]] et [[Nico Habermann]]. Très populaire jusqu'à l'avènement du [[C (langage)|C]], certains [[Hacker (université)|hackers]] des [[Laboratoires Bell]] le comparaient encore avec ce dernier pour certains de leurs projets.

==Exemple de code==
Cet exemple est un extrait du manuel ''Bliss Language Manual'':

&lt;code&gt;&lt;pre&gt;
MODULE E1 (MAIN = CTRL) =
BEGIN
FORWARD ROUTINE
    CTRL,
    STEP;
ROUTINE CTRL =
!+
! This routine inputs a value, operates on it, and
! then outputs the result.
!-
    BEGIN
    EXTERNAL ROUTINE
        GETNUM,     ! Input a number from terminal
        PUTNUM;     ! Output a number to terminal
    LOCAL
        X,          ! Storage for input value
        Y;          ! Storage for output value
    GETNUM(X);
    Y = STEP(.X);
    PUTNUM(.Y)
    END;
ROUTINE STEP(A) =
!+
! This routine adds 1 to the given value.
!-
    (.A+1);
END
ELUDOM
&lt;/pre&gt;&lt;/code&gt;

== Versions ==

* BLISS-10
* BLISS-11 - un [[Compilateur#Compilation croisée|compîlateur croisé]] pour [[PDP-11]]
* BLISS-16
* BLISS-16C - version DEC du BLISS-11
* BLISS-32
* BLISS-36
* BLISS-64 
* Common BLISS - version portable

==Voir aussi==
===Articles connexes===
* [[FINE (Fine Is Not Emacs)]]


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>qy5osze12j3ioass45hx4to6vf3zi78</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>GNU Data Language</title>
    <ns>0</ns>
    <id>1774184</id>
    <revision>
      <id>99487929</id>
      <parentid>93410330</parentid>
      <timestamp>2013-12-23T00:09:42Z</timestamp>
      <contributor>
        <username>Hunsu</username>
        <id>970933</id>
      </contributor>
      <comment>Maintenance lien web</comment>
      <text xml:space="preserve" bytes="3402">{{Ébauche|informatique}}
{{sources secondaires}}
{{Infobox Logiciel
 | nom = GNU data language
 | logo = 
 | développeur = Marc Schellens
 | dernière version = 0.9.3
 | date de dernière version = {{date|27|décembre|2012}}
 | environnement = [[Linux]], [[Unix]], [[Mac OS X]], [[OpenSolaris]], [[Windows]]
 | type = compilateur incrémental compatible avec [[IDL (langage)|IDL]] (Interactive Data Language)
 | licence = [[GNU]] [[Licence publique générale GNU|GPL]]
 | site web = [http://gnudatalanguage.sourceforge.net/ gnudatalanguage.sourceforge.net]
}}
'''GNU Data Language'''&lt;ref name=&quot;GDL_homepage_CC-BY-SA&quot; /&gt; est un clone [[Logiciel libre|libre]] d'[[IDL (langage)|Interactive Data Language (IDL)]] sous licence [[Licence publique générale GNU|GNU GPL]]. IDL est un langage vectoriel de traitement de données et de visualisation très répandu dans l'industrie et la recherche, en particulier en [[astronomie]], [[géophysique]], [[télédétection]] et [[médecine]].

GNU Data Language est en cours de développement depuis 2004 ; à ce jour, il respecte la syntaxe d'IDL version 7.1, ainsi qu'une partie des fonctionnalités de la version 8.0. Il met en œuvre la plupart des procédures et fonctions intrinsèques et un certain nombre des programmes de la bibliothèque fournie à côté du code compilé&lt;ref name=&quot;Coulais_et_al_2010&quot; /&gt;{{,}}&lt;ref name=&quot;Coulais_et_al_2012&quot; /&gt;.

Sous réserve de bien préparer le code en syntaxe IDL&lt;ref name=&quot;Coulais_et_al_2012&quot; /&gt;, GDL permet de faire tourner de larges codes utilisant certaines librairies tierces
comme l'AstroLib&lt;ref&gt;[http://idlastro.gsfc.nasa.gov/ The IDL Astronomy User's Library], [[NASA Goddard Space Flight Center]]&lt;/ref&gt;.

==Références==
{{reflist|refs=

&lt;ref name=&quot;Coulais_et_al_2010&quot;&gt;{{lien conférence
|nom=Coulais
|prénom=Alain
|coauteurs=et al.
|conférence=Astronomical Data Analysis Software and Systems XIX
|année=2010
|titre=Status of GDL - GNU Data Language
|url=http://www.aspbooks.org/a/volumes/article_details/?paper_id=32122  
|éditeur=[[Astronomical Society of the Pacific]]
|page=187
|titre livre=Astronomical Society of the Pacific Conference Series
|volume=434 
|isbn=978-1-58381-748-3
|arxiv=1101.0679
}}&lt;/ref&gt;

&lt;ref name=&quot;Coulais_et_al_2012&quot;&gt;{{lien conférence
|nom=Coulais
|prénom=Alain
|coauteurs=Schellens, M.; Arabas, S.; Lenoir, M.; Noreskal, L.; Erard, S.
|conférence=Astronomical Data Analysis Software and Systems XXI
|année=2011
|titre=Space Missions: Long Term Preservation of IDL-based Software using GDL
|url=http://www.aspbooks.org/a/volumes/article_details/?paper_id=34743  
|éditeur=[[Astronomical Society of the Pacific]]
|page=615
|titre livre=Astronomical Society of the Pacific Conference Series
|volume=461
}}&lt;/ref&gt;

&lt;ref name=&quot;GDL_homepage_CC-BY-SA&quot;&gt;{{lien web|langue=en| nom =The GDL Team| prénom =| lien auteur =| coauteurs =| titre =GDL - GNU Data Language| série =| éditeur =[[SourceForge]]| année=2012| url =http://gnudatalanguage.sourceforge.net/ | doi =| consulté le =3 janvier 2013  }}&lt;/ref&gt;

}}

== Liens externes ==
* {{en}} [http://gnudatalanguage.sourceforge.net/ Site officiel]
* {{Projet SourceForge|gnudatalanguage}} (on y trouve notamment les sources)

{{Portail|logiciels libres}}

[[Catégorie:Logiciel de calcul scientifique]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Logiciel pour Unix]]</text>
      <sha1>j6387i3lkkuhu7fd3x511be4mndb3on</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>GNU Awk</title>
    <ns>0</ns>
    <id>4707911</id>
    <revision>
      <id>101683364</id>
      <parentid>81060168</parentid>
      <timestamp>2014-02-28T23:25:37Z</timestamp>
      <contributor>
        <username>Litlok</username>
        <id>38320</id>
      </contributor>
      <minor/>
      <comment>Introduction : simplification du titre de la page d'homonymie</comment>
      <text xml:space="preserve" bytes="5032">{{ébauche|logiciels libres}}
{{voir homonymes|AWK}}
{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                              = GNU Awk
 | logo                             = Official gnu.svg
 | paradigme                        = 
 | auteur                           = 
 | développeur                      = Aharon Robbins, Karl Berry ([[Projet GNU]])
 | date de première version         = 
 | dernière version stable          = &lt;!-- Utilisation du modèle « Modèle:Dernière version stable/GNU Awk » --&gt;
 | date de dernière version stable  = &lt;!-- idem --&gt;
 | dernière version avancée         = &lt;!-- Utilisation du modèle « Modèle:Dernière version avancée/GNU Awk » --&gt;
 | date de dernière version avancée = &lt;!-- idem --&gt;
 | typage                           = 
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[C (langage)|C]], [[String Oriented Symbolic Language|SNOBOL]], [[Bourne shell]]
 | a influencé                      = [[Perl (langage)|Perl]], [[Korn Shell]] (ksh93, dtksh, tksh), [[Lua]]
 | système d'exploitation           = [[GNU/Linux]], [[FreeBSD]], [[NetBSD]], [[OpenBSD]], [[UNIX]], [[GNU]], [[Mac OS X]], [[MS-DOS]], [[Microsoft Windows|MS Windows]], [[Atari#Ordinateurs_personnels|Atari]], [[BeOS]], [[Virtual Memory System|VMS]]
 | licence                          = [[GNU GPL]]{{laquelle}}
 | site web                         = {{Site officiel|en|http://www.gnu.org/software/gawk/}}
 | date de mise à jour              = 30 juin 2011
}}

'''GNU Awk''' (ou ''gawk'') est l'implémentation du langage de programmation [[awk]] par le [[projet GNU]]. C'est un [[logiciel libre]] distribué sous licence [[GNU GPL]]{{laquelle}}.

GNU Awk est l'implémentation [[awk]]&lt;ref&gt;''nawk'' est une implémentation différente du langage awk originel.&lt;/ref&gt; par défaut des distributions [[GNU/Linux]] actuelles.

GNU Awk est aujourd'hui [[Mainteneur|maintenu]] par '''Aharon Robbins''', un hacker travaillant pour [[Intel]]&lt;ref&gt;{{en}} [http://software.intel.com/en-us/blogs/author/aharon-robbins/ Aharon Robbins] (Intel)&lt;/ref&gt;.

== Histoire de awk et gawk ==
{{Article détaillé|awk}}
Le nom ''awk'' provient des initiales des concepteurs du langage: Alfred V. '''A'''ho, Peter J. '''W'''einberger et Brian W. '''K'''ernighan. La version originelle d’awk a été écrite en [[1977]] dans les [[laboratoires Bell]] d'[[AT&amp;T]]. En [[1985]], plusieurs nouveautés sont introduites dans une nouvelle version, parmi lesquelles, les {{Lien|fr=fonction définie par l'utilisateur|lang=en|trad=User-defined function|texte=fonctions définies par l'utilisateur}}. Cette nouvelle version est largement distribuée par les systèmes [[UNIX System V#System V Release 3 .28SVR3.29|SVR3]]. La version pour [[UNIX System V#System V Release 4 .28SVR4.29|SVR4]] ajoute d'autres nouveautés et, selon la documentation [[GNU]], est l'occasion de nettoyer le comportement du langage, très peu ou pas du tout documenté. Les spécifications du standard [[POSIX]] adopté vont clarifier le langage. Les concepteurs de gawk, comme leurs prédécesseurs des laboratoires Bell pour la conception d’awk, fournissent leur retour d'expérience pour la spécification POSIX.

[[Paul Rubin]] écrit gawk, l'implémentation du langage par le projet GNU, en [[1986]]. [[Jay Fenlason]] l'a complété selon les conseils de [[Richard Stallman]]. Un certain '''John Woods''' a également contribué à certaines parties du code. En 1988 et 1989, '''David Trueman''' refaçonna soigneusement gawk avec l'aide d'Arnold Robbins pour le rendre compatible avec la nouvelle version d’awk. Selon Arnold Robbins, qui travaille sur le projet depuis 1988 et est l’actuel mainteneur depuis 1994, David Trueman mérite une mention spéciale pour son travail inestimable sur l'évolution de gawk, de sorte qu'il fonctionne bien et sans bugs. Bien qu'il ne participe plus à gawk, travailler avec Trueman a été pour Robbins un plaisir considérable.

Depuis 1995, Arnold Robbins est le principal mainteneur du projet.

== Caractéristiques techniques ==

== Extensions ==
* xgawk&lt;ref name=&quot;xgawk&quot;&gt;[http://directory.fsf.org/project/xgawk/ « xgawk - Free Software Directory - Free Software Foundation »], ''directory.fsf.org'', 30 juin 2011.&lt;/ref&gt; est une extension pour GNU Awk visant au traitement des données [[XML]]. XMLgawk est l'une des extensions distribuée avec xgawk, d'autres sont dédiés à [[PostgreSQL]] et [[GNU MPFR]].

== Notes et références ==
{{références}}

== Voir aussi ==
=== Liens externes ===
* {{en}} [http://awk.info/?news/robbinsTalks Interview de Aharon Robbins].

{{DEFAULTSORT:Awk, Gnu}}

{{Palette GNU}}
{{Portail|logiciels libres|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel du projet GNU]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Logiciel pour Unix]]</text>
      <sha1>q3zr8ccwjlfavs91zgty2y0hbfhqdgn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>IDL (langage)</title>
    <ns>0</ns>
    <id>725938</id>
    <revision>
      <id>100536545</id>
      <parentid>100046683</parentid>
      <timestamp>2014-01-23T19:44:20Z</timestamp>
      <contributor>
        <ip>74.15.213.190</ip>
      </contributor>
      <text xml:space="preserve" bytes="3709">{{Voir homonymes|IDL}}
{{Confusion|texte=&quot;Ne doit pas être confondu avec [[Interface description language]]}}
{{ébauche|informatique}}
{{Infobox Langage de programmation
 | nom et logo                      = oui
 | nom                              = IDL (Interactive Data Language)
 | logo                             = 
 | paradigme                        = 
 | auteur                           = David Stern
 | développeur                      = David Stern &amp; ITT Visual Information Solutions (ITT VIS)
 | date de première version         = [[1977]]
 | dernière version stable          = 8.3
 | date de dernière version stable  = {{Date|8|janvier|2014|en informatique}}
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = [[Typage dynamique|dynamique]]
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = 
 | a influencé                      = 
 | système d'exploitation           = [[Multiplate-forme]]
 | licence                          = [[Logiciel propriétaire|propriétaire]]
 | site web                         = [http://www.exelisvis.com/ProductsServices/IDL.aspx]
 | date de mise à jour              = 
}}

'''IDL''', acronyme d'''Interactive Data Language'', est un langage de programmation propriétaire apparu à la fin des années 1970,
et qui est rapidement monté en puissance dans les domaines de la [[télédétection]] et de l'[[astronomie]]. IDL est un langage vectoriel de traitement de données et de visualisation très répandu dans l'industrie et dans la recherche.

== Un langage propriétaire innovant ==

IDL est un langage qui, au début des années 1990, présentait de nombreuses
avancées par rapport à d'autres langages ([[Fortran]], [[C (langage)|C]] et [[Pascal (langage)|Pascal]]) utilisés dans
certains laboratoires où la programmation était non pas un sujet de recherche
en soi mais un outil pour traiter des observations. Il offre,
à une époque où Fortran 90 n'était pas vraiment encore disponible, et C++
pas vraiment défini, une gestion objet des quantités (nombre, vecteur, tableau)
sans écrire de boucle, un affichage de traces (1D, 2D, 3D) à l'écran sans faire appel à des bibliothèques
graphiques alors limitées (pgplot) ou complexes (X11 Motif).

Quoiqu'interprété, un usage raisonnable (déjà en proscrivant les boucles explicites)
dans un contexte adéquat (opération globale sur des vecteurs ou des matrices)
ne donnait pas de différence notable en temps de calcul par rapport à du Fortran.

Les arguments majeurs en faveur d'IDL sont :
* une syntaxe claire
* un apprentissage très rapide en venant de [[Pascal (langage)|Pascal]], [[Fortran]], [[Caml]] ou [[C (langage)|C]]
* une rapidité de programmation
* la main sur les données (la commande HELP donnant accès à toutes les variables connues)
 
Les inconvénients :
* un langage propriétaire dont les licences sont coûteuses
* une évolution un peu chaotique des Widgets
* un délicat passage à une approche objet ''artificielle'' (non demandée par les utilisateurs)

== Comparaison avec des langages semblables ==
Des comparaisons sont aussi parfois faites avec [[matlab]] et [[GNU Octave|octave]].

== Une alternative libre ==

Depuis 2004, [[GNU Data Language]], un clone libre d'IDL sous licence [[GNU]]/[[Licence publique générale GNU|GPL]], est en cours de développement.

== Liens externes ==
*{{en}} [http://www.ittvis.com Site de l'éditeur du langage]

{{Portail|Programmation informatique}}

[[Catégorie:Logiciel de calcul scientifique]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>4n3df0oilbmm0e6v7qucdzvop6c785q</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ooc (langage)</title>
    <ns>0</ns>
    <id>4762587</id>
    <revision>
      <id>93375336</id>
      <parentid>87298102</parentid>
      <timestamp>2013-05-23T06:54:46Z</timestamp>
      <contributor>
        <ip>84.75.176.137</ip>
      </contributor>
      <comment>Défaire la mesquinerie...</comment>
      <text xml:space="preserve" bytes="7531">{{Redirect|ooc|homonymie=OOC}}
{{minuscule}}
{{Infobox Langage de programmation
| nom                    = ooc
| logo                   = Ooc-logo.png
| paradigme              = [[Programmation orientée objet]], [[Programmation structurée|structurée]], [[Programmation impérative|impérative]], [[Programmation fonctionnelle|fonctionnelle]]
| année                  = {{Date|17|mars|2009|en informatique}}
| typage                 = [[Typage statique|Statique]], [[Typage fort|fort]], [[Sûreté du typage|sûr]], [[Système nominatif de types|nominatif]]
| implémentations        = [[rock (compilateur)|rock]], [[j/ooc (compilateur)|j/ooc]]
| influencé par          = [[Io]], [[Ruby]], [[Scala]], [[Java (langage)|Java]] 
| système d'exploitation = [[Multiplateforme]]s
|licence                 = [[Licence BSD]]
| site web               = [http://ooc-lang.org ooc-lang.org]
}}

'''ooc''' est un [[langage de programmation]] compilé. Il permet d'allier la [[Programmation orientée objet|programmation orienté objet]] avec la [[Programmation fonctionnelle|programmation fonctionnelle]] avec une syntaxe simple qui favorise la lisibilité et la concision des programmes. L'implémentation principale traduit le code ooc en sources C puis utilise un compilateur C pour produire un exécutable.

Le langage '''ooc''' et la plupart de son écosystème sont placés sous la [[licence BSD]]. Il est conçu pour combiner une syntaxe simple avec la performance d'un langage compilé, tout en restant flexible. Il est développé par des individus dans leur temps libre. Sa bibliothèque standard est multiplateforme ([[Linux]], [[Mac OS X]], et [[Windows]] sont notamment supportés), grâce aux blocs de versions intégrés au langage.

== Caractéristiques ==

=== Syntaxe ===

ooc, tout comme le [[Python_(langage)|Python]], a été conçu pour être lisible, et pour être facilement écrit par un humain dans un simple éditeur de texte. Les blocs sont délimités par des accolades, comme en [[C_(langage)|C]].

Le principe [[Ne_vous_r%C3%A9p%C3%A9tez_pas|DRY]] est au cœur de la syntaxe ooc. Par exemple, l'opérateur '':='' permet de déclarer une variable à partir de l'expression à droite, en inférant son type:

{| class=&quot;wikitable&quot;
!width=&quot;50%&quot;|Déclaration de variables en ooc
!width=&quot;50%&quot;|Déclaration de variables en Java
|-valign=&quot;top&quot;
|
&lt;source lang=&quot;Java&quot;&gt;
  reponse := 42
  chiens := ArrayList&lt;Chien&gt; new()
&lt;/source&gt;
|
&lt;source lang=&quot;Java&quot;&gt;
  int reponse = 42;
  List&lt;Chien&gt; chiens = new ArrayList&lt;Chien&gt;();
&lt;/source&gt;
|}

=== Types de bases ===

'''ooc''' possède les mêmes types de bases que le langage C, toutefois, tous les types commencent par une majuscule, par convention.

La bibliothèque standard offre également de nombreuses structures de données telles que les tableaux-listes, les listes chaînées, les tables de hachages, les piles, etc. Les tableaux sont inclus dans le langage et, contrairement aux pointeurs C, sont sûrs (on ne peut y accéder en-dehors de leurs bornes).

On peut créer des types en définissant une classe, une interface, ou en faisant une '''cover''' d'un type défini en C.

=== Programmation objet ===

==== Héritage simple ====

Le modèle orienté objet d'ooc supporte [[Héritage (informatique)|l'héritage simple]].

&lt;source lang=&quot;Java&quot;&gt;
Animal: class {
    faireDuBruit: abstract func
}

Chien: class extends Animal {
    faireDuBruit: func {
      &quot;Wouf!&quot; println()
    }
}

Chat: class extends Animal {
    faireDuBruit: func {
      &quot;Miaou!&quot; println()
    }
}

toucher: func (animal: Animal) {
    animal faireDuBruit()
}

toucher(Chien new())
toucher(Chat new())
&lt;/source&gt;

==== Interfaces ====

Les [[Interface (programmation orientée objet)|interfaces]] permettent un semblant d'héritage multiple, à l'instar du [[Java (langage)|Java]].

&lt;source lang=&quot;Java&quot;&gt;
Representable: interface {
    toString: func -&gt; String
}

Printable: interface {
    print: func
}

Document: class implements Representable, Printable {
   data: String
   init: func (=data) {}

   toString: func -&gt; String { data }
   print: func { toString() println() }
}
&lt;/source&gt;

=== Programmation fonctionnelle ===

ooc supporte les [[Fonction anonyme|fonctions anonymes]] et les [[Fermeture (informatique)|fermetures]]. On peut manipuler les fonctions comme n'importe quelle valeur, grâce à une syntaxe claire et lisible :

&lt;source lang=&quot;Java&quot;&gt;
import structs/[ArrayList, List]

filter: func (list: List&lt;Int&gt;, f: Func (Int) -&gt; Bool) -&gt; List&lt;Int&gt; {
    copy := ArrayList&lt;Int&gt; new()
    for (x in list) if (f(x)) {
        copy add(x)
    }
    copy
}

list  := [7, 1, -3, 2, -12, 3, 42] as ArrayList&lt;Int&gt;
list2 := filter(list, |a| a &gt; 0 &amp;&amp; a &lt; 20)

print(list); print(list2)

print: func (list: List&lt;Int&gt;) {
    for (x in list) (x + &quot;, &quot;) print()
    println()
}
&lt;/source&gt;

Cet exemple utilise également des [[Généricité|types génériques]], montre une manière simple de créer des tableaux-listes (ArrayList), de parcourir des objets itérables, de retourner implicitement des objets, ainsi que la syntaxe courte pour les fonctions anonymes.

=== Modularité ===

Chaque fichier '''.ooc''' correspond à un module qui peut être importé depuis n'importe où. Les modules peuvent être organisés en paquetages (les dossiers où ils sont placés). Il est possible d'importer un module dans un [[Espace de noms (programmation)|espaces de noms]] donné, par exemple

&lt;source lang=&quot;Java&quot;&gt;
// on importe le module File dans l'espace de noms IO.
import io/File into IO

// on peut définir sa propre classe sans se soucier des conflits
File: class {}

// on utilise la classe importée
IO File new(&quot;C:\\windows\\iexplore.exe&quot;) remove()
&lt;/source&gt;

Contrairement au [[C (langage)|C]] il n'y a pas de fichiers d'en-tête séparés des fichiers sources. '''import''', plutôt que de copier/coller le contenu du fichier, définit une dépendance entre deux modules.

Le compilateur ayant ainsi une vue claire des dépendances entre modules, il supporte la recompilation partielle sans besoin de fichiers de projets du type [[make|Makefile]].

Les fichiers '''.use''' permettent également de spécifier des dépendances sur des bibliothèques externes, des options à passer au compilateur C, des informations de versions, etc. La directive '''use''' permet d'en faire usage dans du code ooc. Ainsi, utiliser par exemple la [[Simple DirectMedia Layer|SDL]], [[OpenGL]] est l'affaire d'une ligne de code source.

== Exemples de code ==

Le hello world classique :
&lt;source lang=&quot;Java&quot;&gt;
 println(&quot;Hello world!&quot;)
&lt;/source&gt;


Afficher le contenu d'un fichier :
&lt;source lang=&quot;Java&quot;&gt;
 File new(&quot;/etc/hosts&quot;) read() print()
&lt;/source&gt;


Afficher les 5 premières puissances de 2
&lt;source lang=&quot;Java&quot;&gt;
 for(i in 0..5) {
   &quot;2^%d = %d&quot; format(i, 2 pow(i)) println()
 }
&lt;/source&gt;

== Implémentations ==

L'implémentation principale d'ooc est [[rock (compilateur)|rock]], entièrement écrit en ooc et qui se compile lui-même. Il a été développé en quelques mois et a rendu obsolète [[j/ooc (compilateur)|j/ooc]], l'implémentation initiale en Java qui a permis au langage de [[Bootstrap (compilateur)|bootstrapper]] en {{Date||avril|2010|en informatique}}

Il existe également un effort pour implémenter un compilateur ooc écrit en [[Ruby]], nommé [[rooc (compilateur)|rooc]].

== Liens externes ==
[http://ooc-lang.org/ Site officiel]

[[b:en:Programming with ooc|Wikilivre de référence sur ooc]]

{{Portail|Programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>r0kmzp8bmdtw92i80a2qnpgi4vi09ll</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Langage K</title>
    <ns>0</ns>
    <id>263868</id>
    <revision>
      <id>79616784</id>
      <parentid>79616768</parentid>
      <timestamp>2012-06-09T18:53:23Z</timestamp>
      <contributor>
        <username>Le pro du 94 :)</username>
        <id>1061593</id>
      </contributor>
      <comment>[[WP:LRC|LiveRC]] : Révocation des modifications de [[Special:Contributions/82.234.181.70|82.234.181.70]] (retour à la dernière version de [[User:82.234.181.70|82.234.181.70]]) ; intérêt ?</comment>
      <text xml:space="preserve" bytes="1817">Le '''langage K''' est un langage d'abstraction des concepts de l'[[informatique]], un langage de formalisation des [[Structure de données|structures de données]] et un langage d'approche [[Mathématiques|mathématique]] et théorique de la [[programmation]].

== Présentation ==

Langage d'enseignement, il permet d'aller au-delà des distinctions de tout type (langage de programmation, déclaration de type, mots-clés par sa syntaxe extrêmement pauvre).

Ce langage étant à vocation pédagogique, il n'existe pas de notation stricte de langage.
Néanmoins, une norme a été définie à l'adresse [http://libe4.free.fr/langk/ libe4.free.fr].

Ce langage ne permet d'effectuer que des modifications sur des nombres, des listes ou des tableaux, son intérêt est de voir la trace des algorithmes écrits.

Un programme K se divise par fonctions définies récursivement. Elles sont constituées de cas, autrement dit des conditions suivies d'un rendu de résultat.

== Exemple ==

Déterminer la valeur maximum d'un [[tableau (structure de données)|tableau]] :

 Initialisation MAXIMUM(T, i, n, max)=  MAXIMUM(T, 2, |T|, T[1])
 Différents cas i ⇐ n ^ T[i] &gt;  max ⇒ MAXIMUM(T, i, n, max) = MAXIMUM(T, i + 1, n, T[i])
                i ⇐ n ^ T[i] ⇐ max ⇒ MAXIMUM(T, i, n, max) = MAXIMUM(T, i + 1, n, max)
                i &gt;  n               ⇒ MAXIMUM(T, i, n, max) = max
 Fin

== Interpréteurs ==

Plusieurs interpréteurs existent :
* K Teach Algorithmics (Algorithmique d'apprentissage par K.), développé en 2003 par une équipe de maîtrise d'informatique de l'université de Nice Sophia Antipolis (inspiré du projet Kinterpreter)
* [http://libe4.free.fr/langk/ek.html EKzecuteur], un projet très primitif

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation|K]]</text>
      <sha1>r3cwhdedcpoa70jyi8xjcq78ezfbfh6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Hollywood (langage de programmation)</title>
    <ns>0</ns>
    <id>4733204</id>
    <revision>
      <id>98802673</id>
      <parentid>97399061</parentid>
      <timestamp>2013-11-30T20:32:00Z</timestamp>
      <contributor>
        <username>Automatik</username>
        <id>1158343</id>
      </contributor>
      <minor/>
      <comment>/* Historique */ style</comment>
      <text xml:space="preserve" bytes="10455">{{Voir homonymes|Hollywood (homonymie)}}
{{Infobox Logiciel
 | nom = Hollywood
 | image = Hollywood-ide3.jpg
 | description = Environnement de développement Hollywood fonctionnant sur Windows XP
 | taille image = 
 | développeur = Andreas Falkenhahn
 | dernière version = 5.3
 | date de dernière version = {{Date|5|juillet|2013}}
 | environnement = [[AmigaOS]] (68k), [[AmigaOS 4]] (PPC), [[MorphOS]], [[WarpOS]], [[AROS]], [[Microsoft Windows|Windows]] partly, [[Mac OS X]]
 | type = [[langage de programmation]]
 | licence = [[licence propriétaire]]
 | site web = [http://www.hollywood-mal.com www.hollywood-mal.com]
}}
'''Hollywood''' est un langage de programmation commercial développé par Andreas Falkenhahn (Airsoft Softwair) qui se concentre sur la création d'applications orientées multimédia. Hollywood est disponible pour [[AmigaOS]] (68k), [[AmigaOS 4]] (PPC), [[MorphOS]], [[WarpOS]], [[AROS]] et [[Microsoft Windows|Windows]]. Il n'y a pas de version pour [[Mac OS X]] pour l'instant mais le logiciel peut compiler des exécutables pour cette plateforme.

Hollywood possède un compilateur croisé (en anglais ''[[:en:Cross Compiler|Cross Compiler]]'') intégré qui peut enregistrer automatiquement des exécutables pour toutes les plateformes supportées par le logiciel. Les exécutables générés fonctionnent de façon indépendante du système et sans aucune dépendance externe. Ils peuvent donc être utilisées directement depuis une [[clé USB]]&lt;ref&gt;{{en}} [http://www.hollywood-mal.com/features.html Fonctionnalités de Hollywood ]&lt;/ref&gt;.

Le logiciel Hollywood Designer est un module supplémentaire pour Hollywood avec lequel il est possible d'utiliser Hollywood comme un [[logiciel de présentation]].

== Historique ==
Hollywood a débuté sur ordinateur [[Amiga]]. Il est inspiré par des langages de programmation sur [[Amiga]] tels que [[AMOS BASIC|AMOS]], [[Blitz Basic]], et [[Amiga E]]. L'auteur d'Hollywood Andreas Falkenhahn a commencé le développement de Hollywood au printemps 2002. La version 1.0 du logiciel est sortie en novembre 2002, mais seulement pour les systèmes [[Amiga]] basés sur [[Motorola 68000|68000]]&lt;ref&gt;Johnson, Magnus: Interview with Andreas Falkenhahn. Total Amiga 21 (2005), pp. 14-15.&lt;/ref&gt;. Un mois plus tard, une version native pour le système [[MorphOS]] a suivi&lt;ref&gt;Test de Hollywood 1.5 : http://obligement.free.fr/articles/hollywood15.php&lt;/ref&gt;. Le support de [[WarpOS]] a été ajouté à partir de Hollywood qui est sorti au printemps 2004 en même temps que la première version de Hollywood Designer qui permet la création de présentations avec Hollywood. [[AmigaOS|AmigaOS 4]] est supporté depuis mars 2005. À partir de la version 2.0 (sortie en janvier 2006), Hollywood utilise le langage de programmation [[Lua (langage de programmation)|Lua]] en tant que sa [[machine virtuelle]], mais avec plusieurs modifications dans sa [[syntaxe]] et ses fonctionnalités&lt;ref&gt;{{en}} [http://www.inf.puc-rio.br/~roberto/lua-uses.html Liste des projets utilisant Lua.]&lt;/ref&gt;. À partir de la version 3.0 (janvier 2008), Hollywood fonctionne sur deux systèmes d'exploitation non typés [[Amiga]] : [[Microsoft Windows|Windows]] et [[Mac OS X]]. Depuis la version 4.5 (janvier 2010) Hollywood est disponible avec un [[environnement de développement intégré]] sur [[Microsoft Windows|Windows]].
La version 4.7 sortie en avril 2010 est encore plus indépendante de la plateforme sur laquelle l'application tourne&lt;ref&gt;  [http://www.amiga-ng.org/article.php?sid=427&amp;mode=&amp;order=0 Liste des nouveautés de la version 4.7]&lt;/ref&gt;.

== Introduction ==
Le but principal de Hollywood est la simplicité d'utilisation et aucune dépendance de la plateforme. Il a été développé principalement pour la création d'applications [[multimédia]] et de jeux. Le langage comprend environ 500 commandes dans les champs d'application : graphisme 2D, son, accès au système de fichiers, affichage de texte, animations, affichage de sprites, layers, effets de transition, manipulation d'images, enregistrement d'images et de fichiers vidéo, ... La programmation en Hollywood se fait via des scripts Hollywood (extension *.hws). Ces scripts sont compilés dynamiquement et peuvent être convertis en exécutables autonomes. Tous les programmes Hollywood fonctionnent dans une [[Sandbox]] qui permet de ne jamais planter le système&lt;ref&gt;{{en}} Preinsack, Anton: Interview with Andreas Falkenhahn. Amiga Future 78 (2009), p. 14.&lt;/ref&gt;.

=== Indépendance à la plateforme ===
Hollywood a été conçu comme un langage de programmation totalement indépendant de la plateforme. De ce fait, les scripts ne peuvent pas appeler directement une fonction de l'[[interface de programmation|API]] du système d'exploitation hôte et ils sont limités à la liste des commandes du langage. Même le rendu de texte est implémenté à travers un système de rendu de police complètement indépendant du système hôte. Cela permet à du texte en [[TrueType]] d'être visuellement identique sur toutes les plateformes. De plus, toutes les  versions de Hollywood gèrent les formats de fichier spécifiques [[Amiga]] comme les images [[ILBM|IFF ILBM]], les sons [[8SVX|IFF 8SVX]], ou les fichiers [[ANIM|IFF ANIM]] pour être entièrement compatibles avec les scripts écrits sur système Amiga&lt;ref&gt;{{en}} Christoph, Michael: Hollywood 3 on Windows. Amiga Future 71 (2008), pp. 26-27.&lt;/ref&gt;.

=== Compilateur ===
Une fonction intéressante du compilateur croisé (en anglais ''[[:en:Cross Compiler|Cross Compiler]]'') livré avec Hollywood est la possibilité d'inclure tous les fichiers externes (dont les polices) dans l'exécutable généré. Il est alors possible de créer des programmes qui auront la forme d'un unique fichier exécutable, qui sera ainsi facilement transportable et distribué. De plus le compilateur de Hollywood peut compiler des scripts sous forme d'[[Applet|applets]] Hollywood (avec un [[Extension de nom de fichier|extension de fichier]] *.hwa). Ces applets sont plus petits que des programmes Hollywood correspondants mais peuvent être utilisés uniquement sur des systèmes où Hollywood est installé.
Il est aussi possible d'exporter des scripts Hollywood en fichier [[Audio Video Interleave|AVI]]&lt;ref&gt;{{en}} Cornelius, Martin: Hollywood 4.5 or Multimedia is back. Amiga Future 83 (2010), pp. 30-31.&lt;/ref&gt;.

== Environnements de développement ==
Il n'y a pas d'[[environnement de développement intégré]] pour la version [[AmigaOS]] de Hollywood. Sur ces systèmes, il est possible d'utiliser un [[environnement de développement intégré|IDE]] tel que [[Cubic IDE]]&lt;ref&gt;Editeur Cubic IDE : http://devplex.awardspace.biz/&lt;/ref&gt; ou [[Codebench]]&lt;ref&gt;Editeur Codebench : http://codebench.co.uk/&lt;/ref&gt; qui permettent le développement en Hollywood grâce à des plugins. Sur [[Microsoft Windows|Windows]], Hollywood est disponible avec son propre [[environnement de développement intégré|IDE]]&lt;ref&gt;Hollywood plugin for Cubic IDE, http://code.google.com/p/hw4c/&lt;/ref&gt;{{,}}&lt;ref&gt; Codebench IDE with Hollywood support, http://codebench.co.uk/&lt;/ref&gt;.

== Un programme Hello World ==
Un programme [[Hello World]] en Hollywood s'écrit comme ceci :

   Print(&quot;Hello World!&quot;)
   WaitLeftMouse
   End

Ce code source ouvre une nouvelle fenêtre sur le bureau, affiche le texte &quot;Hello World!&quot; et attend qu'on presse le bouton gauche de la souris avant de quitter. L'ouverture de la fenêtre est faite automatiquement par Hollywood.

== Hollywood Designer ==
{{Infobox Logiciel
| nom=Hollywood Designer
| image=Hollywood-designer.jpg
| description=Hollywood Designer running on AmigaOS4
| développeur=Andreas Falkenhahn
| dernière version=4.0
| date de dernière version= {{Date|17|juin|2012}}
| environnement= [[AmigaOS]], [[MorphOS]], [[WarpOS]]
| type= [[Presentation]]
| licence= [[licence propriétaire]]
| site web= [http://www.hollywood-mal.com www.hollywood-mal.com]
}}

L'application Hollywood Designer est un logiciel supplémentaire qui permet la création de présentations informatives ou des applications interactives avec Hollywood. Ce logiciel utilise une interface [[WYSIWYG]] basée sur le principe des pages. Il est possible de créer autant de pages que désiré en utilisant du texte, des images ou des sons. Hollywood Designer pourra afficher les pages dans l'ordre séquentiel ou un ordre différent. Plusieurs effets de transition sont disponibles. Il est aussi possible de créer des applications qui nécessitent une interaction avec l'utilisateur comme pour des [[bornes interactives]]&lt;ref&gt;Exemple d'application interactive : {{no}} http://www.ferrule-media.no {{en}} Plus d'informations: http://www.amiga.org/forums/printthread.php?t=49890&lt;/ref&gt;.

Tous les projets créés avec Hollywood Designer peuvent être visualisés avec Hollywood et peuvent donc être compilés en exécutables indépendants ou en fichier [[Audio Video Interleave|AVI]]. Les utilisateurs avancés peuvent aussi importer leur propre code dans un projet. Au travers de tels ajouts de code, il est possible d'accéder à toutes les commandes de Hollywood&lt;ref&gt;{{en}} Williams, Robert : Hollywood 1.9 and Designer. Total Amiga 18 (2004), pp. 18-22.&lt;/ref&gt;.

Techniquement parlant, Hollywood Designer ne fait que donner à Hollywood des scripts construits à partir des actions de l'utilisateur dans l'interface graphique [[GUI]]&lt;ref&gt;Gutjahr, Christoph: Hollywood 1.9, Malibu and Hollywood Designer. The Triple Dream Factory. AMIGAplus 147 (2004), pp. 44-47.&lt;/ref&gt;. Ce processus de générer des scripts et de les exécuter par Hollywood est entièrement transparent pour l'utilisateur. Ce qui fait qu'aucune connaissance de la programmation n'est nécessaire pour utiliser Hollywood Designer&lt;ref&gt;Williams, Robert: Hollywood 2.0 The Sequel. Total Amiga 23 (2006), pp. 40-42.&lt;/ref&gt;.

== Notes et références ==
{{Références}}
{{Traduction/Référence|en|Hollywood (programming language)|type=note}}

==Liens externes==
* {{en}} [http://www.hollywood-mal.com/ Site principal et forums]
* {{en}} [http://www.airsoftsoftwair.com/ Site Internet du développeur]
* {{en}} [http://devplex.awardspace.biz/ Cubic IDE], un IDE pour Hollywood et d'autres languages
* {{en}} [http://www.codebench.co.uk/ CodeBench], un IDE AmigaOS 4 pour Hollywood et d'autres languages

{{Portail|Programmation informatique}}

[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>qw78m1yd6p8l68ytb6bu260x9ht897q</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>CEI 61131-3</title>
    <ns>0</ns>
    <id>354698</id>
    <revision>
      <id>95787649</id>
      <parentid>95784782</parentid>
      <timestamp>2013-08-13T21:34:24Z</timestamp>
      <contributor>
        <username>Jules78120</username>
        <id>903634</id>
      </contributor>
      <minor/>
      <comment>[[Projet:JavaScript/Notices/HotCatsMulti|HotCatsMulti]] :  ± [[Catégorie:Norme ou standard informatiques]]-&gt;[[Catégorie:Norme ou standard informatique]]</comment>
      <text xml:space="preserve" bytes="1282">{{Ébauche|informatique}}

La '''CEI 61131-3''', intitulée '''Automates programmables - Partie 3 : Langages de programmation''', est une [[Normes et standards industriels|norme industrielle]] de la [[Commission électrotechnique internationale]] (CEI) définissant cinq [[Langage de programmation|langages de programmation]] à utiliser pour les [[Automate programmable industriel|automates programmables]] :

* [[Langage Ladder]] (schéma à relais) ;
* [[Sequential function chart]] (SFC), proche du langage [[Grafcet]] ;
* [[Boîtes fonctionnelles]] (FBD), sous forme de [[diagramme]] ;
* [[Texte structuré]] (ST) ;
* [[Liste d'instructions]] (IL), un pseudo-[[assembleur]].

Elle a été publiée la première fois en [[1993]], et une seconde édition a vu le jour en [[2003]].

== Voir aussi ==
{{Autres projets|wikiversity=Automatisme : norme 1131-3 et GRAFCET|wikiversity titre=Automatisme : norme 1131-3 et GRAFCET}}
* [http://webstore.iec.ch/preview/info_iec61131-3%7Bed2.0%7Den.pdf Le sommaire officiel de la CEI 61131-3, version 2.0 (2003)], prévisualisation sur le site de la CEI

{{Portail|programmation informatique}}

[[Catégorie:Automatisme]]
[[Catégorie:Norme CEI|#61131-3]]
[[Catégorie:Norme ou standard informatique]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>fgxcvwu1yzyd0jhx5bs4o8loxah01al</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Suneido</title>
    <ns>0</ns>
    <id>4818370</id>
    <revision>
      <id>90728256</id>
      <parentid>88760278</parentid>
      <timestamp>2013-03-18T04:32:34Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3503881]]</comment>
      <text xml:space="preserve" bytes="2859">{{Infobox Langage de programmation
 | couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom et logo                      = 
 | nom                              = Suneido
 | logo                             = Suneido.jpg
 | paradigme                        = [[Programmation_orientée_objet|Objet]]
 | auteur                           = [[Andrew McKinlay]]
 | développeur                      = Axon Development Corporation
 | dernière version		    = October 21, 2007
 | date de première version         = [[2000]]
 | dernière version stable          =  
 | date de dernière version stable  = 
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = [[typage dynamique|dynamique]]
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = [[Python_(langage)|Python]], [[Tool_Command_Language|TCL]], [[Perl_(langage)|Perl]], [[Scheme]] et [[Ruby]]
 | a influencé                      = 
 | système d'exploitation           = [[Windows]] de [[Microsoft]]
 | licence                          = [[logiciel libre]] sous GNU General Public License (GPL), et gratuit
 | site web                         = [http://www.suneido.com/ www.suneido.com]
 | date de mise à jour              = 
}}

'''Suneido''' est un [[langage de programmation]] interprété et interactif pour [[Microsoft_Windows|Windows]] de [[Microsoft]]&lt;ref &gt; {{fr}} {{Lien web |url=http://www.framasoft.net/article1411.html |titre=Suneido|site=www.framasoft.net |consulté le=21 juillet  2010.}} &lt;/ref&gt; . 

Il a un [[typage dynamique]] et gère la mémoire automatiquement à l'aide d'un [[Ramasse-miettes_(informatique)|ramasse-miettes]] ; il est ainsi semblable à [[Python_(langage)|Python]], [[Tool_Command_Language|TCL]], [[Perl_(langage)|Perl]], [[Scheme]] et [[Ruby]]. Suneido est un [[logiciel libre]] (Open Source Software) et gratuit. Suneido est une plateforme d’application qui comprend un langage de programmation [[Programmation_orientée_objet|orientée objet]], une [[base de données relationnelle]] intégrée [[client-serveur]], et un [[environnement de développement intégré]] (EDI).

== Exemple Hello World ==

Le programme [[Hello world]] s'écrit en Suneido:

&lt;code&gt;
Window(#(Static,&quot;Hello world!&quot;))
&lt;/code&gt;

== Notes et références ==
{{Références}}

== Liens externes ==
* {{en}} [http://www.suneido.com/ Suneido : Site officiel]
* {{fr}} [http://suneidojo.free.fr/ SuneiDojo : Guide de découverte de Suneido]

{{Portail|informatique|programmation informatique}}

[[Catégorie:Environnement de développement intégré]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Système de gestion de base de données]]</text>
      <sha1>30zl8lemnkcl3ppv47n2rri6i6265zg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Noop</title>
    <ns>0</ns>
    <id>4849284</id>
    <revision>
      <id>93808375</id>
      <parentid>92254586</parentid>
      <timestamp>2013-06-05T22:47:50Z</timestamp>
      <contributor>
        <username>Vlaam</username>
        <id>268672</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.27 - [[P:HOM|Homonymies]] : Correction de 1 lien - [[Java]]</comment>
      <text xml:space="preserve" bytes="1983">{{Orphelin|date=octobre 2012}}
{{ébauche|informatique}}
{{Infobox Langage de programmation
 | couleur boîte                    = 
 | nom                              = Noop
 | logo                             = 
 | paradigme                        = 
 | auteur                           = [[Google]]
 | développeur                      = [[Google]]
 | date de première version         = 2009
 | dernière version stable          = 
 | date de dernière version stable  = 
 | dernière version avancée         = 
 | date de dernière version avancée = 
 | typage                           = 
 | implémentations                  = 
 | normes                           = 
 | dialectes                        = 
 | influencé par                    = 
 | a influencé                      = 
 | système d'exploitation           = 
 | licence                          = [[Licence Apache]] 2.0
 | site web                         = http://code.google.com/p/noop
 | date de mise à jour              = 
}}

'''Noop''' est un nouveau{{évasif}} projet de [[Google]] dans le but de développer un nouveau langage de programmation. Noop doit fonctionner sur la [[machine virtuelle Java]]&lt;ref&gt;{{en}} {{Lien web|url=http://www.h-online.com/open/news/item/Noop-a-new-language-for-the-JVM-772189.html|titre=Noop - a new language for the JVM|site=http://www.h-online.com/|en ligne le=17 septembre 2009|consulté le=25 juillet 2010}}&lt;/ref&gt;.

== Exemple ==
''[[Hello world]]'' en Noop :
&lt;pre&gt;
import noop.Application;
import noop.Console;

class HelloWorld(Console console) implements Application {

  Int main(List args) {
    String s = &quot;Hello World!&quot;;

    console.println(s);
    return 0;
  }
}
&lt;/pre&gt;

== Notes et références ==
&lt;references /&gt;

== Voir aussi ==
* [[Java (technique)|Java]]
* [[Machine virtuelle Java]]

=== Lien externe ===
* {{en}} [http://code.google.com/p/noop Noop sur Google Code]

{{Portail|Google}}

[[Catégorie:Google]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>67xhperflz6hpdgy1wfyfegbkkg1658</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Pastel (langage de programmation)</title>
    <ns>0</ns>
    <id>4902214</id>
    <revision>
      <id>86403042</id>
      <parentid>83473064</parentid>
      <timestamp>2012-12-10T18:49:06Z</timestamp>
      <contributor>
        <username>Silex6</username>
        <id>54008</id>
      </contributor>
      <comment>pas de fusion</comment>
      <text xml:space="preserve" bytes="810">{{Voir homonymes|Pastel (homonymie)}}
{{ébauche|informatique}}

'''Pastel''' est un dialecte du [[langage de programmation]] [[Pascal (langage)|Pascal]] et un [[compilateur]] développé au [[laboratoire national de Lawrence Livermore]].

{{...}}

== Pastel et le projet GNU ==
Le compilateur [[GNU Compiler Collection|GCC]] fut initialement écrit avec le langage de programmation Pastel&lt;ref&gt;[http://www.gnu.org/philosophy/stallman-kth.fr.html Discours de Richard Stallman] le 30 octobre 1986 en Suède.&lt;/ref&gt; avant d'être entièrement réécrit en [[C (langage)|C]].

== Notes et références ==
{{Références|colonnes=2}}

==Voir aussi==
===Articles connexes===
* [[GNU Compiler Collection|GCC]]


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Compilateur]]</text>
      <sha1>bpfqnqltifjyolwo5ztni9u9tnznfuy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>SRFI (informatique)</title>
    <ns>0</ns>
    <id>4925172</id>
    <revision>
      <id>91362344</id>
      <parentid>74610572</parentid>
      <timestamp>2013-03-27T21:13:58Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3459998]]</comment>
      <text xml:space="preserve" bytes="810">{{Voir homonymes|SRFI}}
{{ébauche|informatique}}

'''SRFI''' (en anglais « Scheme Requests for Implementation ») est un processus de [[standardisation]] des [[Bibliothèque logicielle|librairies]] et [[Extension (logiciel)|extensions]] du [[langage de programmation]] [[Scheme]], dans le but de faciliter l'implémentation du langage.

''SRFI'' s'est imposé en raison du manque de normes précises pour développer des [[Bibliothèque logicielle|bibliothèques]] Scheme avant l'avènement du standard Scheme [[R6RS]].

Le ''standard R6RS'' couvre désormais ce champ d'application.

==Voir aussi==
===Articles connexes===
* [[GNU Guile]]
* [[R6RS]]

=== Liens externes ===
{{en}} [http://srfi.schemers.org/ Site web officiel]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>169wcyhb12b9uvgoyekmo3uaw230ash</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>SAM76</title>
    <ns>0</ns>
    <id>4933441</id>
    <revision>
      <id>90747693</id>
      <parentid>71071564</parentid>
      <timestamp>2013-03-18T08:07:40Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3459179]]</comment>
      <text xml:space="preserve" bytes="1693">{{ébauche|informatique}}

{{Infobox Langage de programmation
|  couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
|  nom et logo                      = non
|  nom                              = SAM76
|  logo                             = 
|  paradigmes                       = 
|  auteur                           = 
|  développeurs                     = 
|  date de première version         = Fin des années [[1970]]
|  dernière version stable          = 
|  date de dernière version stable  = 
|  dernière version avancée         = 
|  date de dernière version avancée = 
|  typage                           = 
|  implémentations                  = 
|  normes                           =
|  dialectes                        = 
|  influencé par                    = [[TRAC (langage de programmation)|TRAC]], [[Lisp]], [[Forth (langage)|FORTH]]
|  a influencé                      = 
|  système d'exploitation           = Machines [[PDP-10]]
|  licences                         = 
|  site web                         = 
|  date de mise à jour              = 9 septembre 2010
}}
'''SAM76''' est un [[langage de programmation]] développé à la fin des années 70.

==Juridique==
Les auteurs seront poursuivis par [[Calvin Mooers]] pour violation de [[Brevetabilité du logiciel|brevets logiciels]]&lt;ref&gt;[http://c2.com/cgi/wiki?TracLanguage Les développeurs de SAM76 poursuivis pour violations de brevets].&lt;/ref&gt;, mais l'affaire sera classée sans suite.

==Voir aussi==
===Article connexe===
* [[Calvin Mooers]]

== Notes et références ==
{{Références}}

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>dwbpyd7kbixh98uhbv9y2uw2oqhl8nb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>GNU Pascal</title>
    <ns>0</ns>
    <id>4939372</id>
    <revision>
      <id>97364326</id>
      <parentid>90748570</parentid>
      <timestamp>2013-10-10T15:51:04Z</timestamp>
      <contributor>
        <username>Arbautjc</username>
        <id>1453191</id>
      </contributor>
      <minor/>
      <comment>il ne me semble pas qu'il ait jamais été livré dans la distribution de GCC</comment>
      <text xml:space="preserve" bytes="2355">{{ébauche|logiciels libres}}
{{Voir homonymes|Pascal}}
{{Infobox Langage de programmation
|  couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
|  nom et logo                      = GNU Pascal
|  nom                              = GNU Pascal
|  logo                             = GnuPascal-small.png
|  paradigmes                       = 
|  auteur                           = 
|  développeurs                     = [[Projet GNU]]
|  date de première version         = 
|  dernière version stable          = 
|  date de dernière version stable  = 2006
|  dernière version avancée         = 
|  date de dernière version avancée = 
|  typage                           = 
|  implémentations                  = 
|  normes                           = ISO 7185 et ISO 10206
|  dialectes                        = [[Pascal (langage)|Pascal]]
|  influencé par                    = [[Pascal (langage)|Pascal]]
|  a influencé                      = 
|  système d'exploitation           = [[GNU/Linux]], [[GNU]]/[[Hurd]], [[FreeBSD]], [[NetBSD]], [[OpenBSD]], [[Unix]], [[Mac OS X]], [[Microsoft Windows|MS Windows]], [[MS-DOS]]
|  licences                         = [[GNU GPL]]
|  site web                         = {{Site officiel|en|http://www.gnu-pascal.de/}}
|  date de mise à jour              = 15 octobre 2011
}}

'''GNU Pascal''' est l'implémentation du langage de programmation [[Pascal (langage)|Pascal]]&lt;ref&gt;Normes ISO 7185 et ISO 10206&lt;/ref&gt; par le [[projet GNU]]. C'est un [[logiciel libre]] distribué sous licence [[GNU GPL]].

Il comprend un compilateur connu sous l'appellation '''GPC''' (en anglais « ''GNU Pascal Compiler'' »), compatible avec plusieurs dialectes du langage Pascal, et utilisant [[GNU Compiler Collection|GCC]] comme ''back-end'' jusqu'à la version 3.4.

== Notes et références ==
{{références}}

== Voir aussi ==
=== Articles connexes ===
* [[GNU Compiler Collection|GCC]]

{{DEFAULTSORT:Pascal, Gnu}}

{{Palette GNU}}
{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Logiciel du projet GNU]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Compilateur Pascal]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Logiciel pour Unix]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour DOS]]
[[Catégorie:Langage Pascal]]</text>
      <sha1>g6pwfuokmvszk9tjvf8qn8ywe46f82p</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NumPy</title>
    <ns>0</ns>
    <id>4571372</id>
    <revision>
      <id>101631813</id>
      <parentid>100245714</parentid>
      <timestamp>2014-02-27T09:55:00Z</timestamp>
      <contributor>
        <username>Anne Bauval</username>
        <id>474773</id>
      </contributor>
      <minor/>
      <comment>résol homon</comment>
      <text xml:space="preserve" bytes="1080">{{ébauche|informatique}}
{{Infobox Langage de programmation
 | nom et logo = oui
 | nom =  Python
 | logo = 
 | système d'exploitation = [[Multiplate-forme]]
 | site web = [http://www.numpy.org/ www.numpy.org]
}}

'''NumPy''' est une extension du langage de programmation [[Python (langage)|Python]], destinée à
manipuler des [[Matrice (mathématiques)|matrices]] ou tableaux multidimensionnels ainsi que des fonctions mathématiques opérant sur ces tableaux.

Une bibliothèque très puissante, permettant de manipuler les tableaux, de multiples fonctions permettant notamment de créer directement un tableau depuis un fichier ou au contraire de sauvegarder un tableau dans un fichier.

Permet la manipulations des vecteurs, matrices et polynômes.

Utilisé de concert avec Matplotlib (gestion des graphiques) devient un outil scientifique parfait pour python.

== Liens externes ==
* {{en}} [http://www.numpy.org Site officiel]
* (en)  [http://docs.scipy.org/doc/numpy/reference/ Documentation complète]

{{Portail|Informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>fijzxpri93rb8jt625av3wb510pb8xi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NodeBox</title>
    <ns>0</ns>
    <id>4746721</id>
    <revision>
      <id>101587035</id>
      <parentid>90717947</parentid>
      <timestamp>2014-02-25T16:06:00Z</timestamp>
      <contributor>
        <username>Sebleouf</username>
        <id>141929</id>
      </contributor>
      <minor/>
      <comment>coquille</comment>
      <text xml:space="preserve" bytes="1567">{{Ebauche|informatique}}

'''Nodebox''' est un [[langage de programmation]] [[open source]] pour la création graphique statique ou animée, basé sur l'emploi de [[Python_(langage)|Python]]. Créé par Frederik De Bleser et Tom De Smedt dans le cadre de l'Experimental Media Group de l'école d'art [[Corporations_de_métiers_artistiques_(Pays-Bas)#Anvers|Saint-Luc]] d'[[Anvers]].

Nodebox est écrit en Python et fonctionne sur [[Mac OS X]] depuis la première version bêta. Une version plus récente fonctionne sous [[Microsoft Windows|Windows]] et peut également être [[Portage_informatique|portée]] sur [[Linux]]. Nodebox peut générer des [[Image_vectorielle|formes vectorielles]] : [[Courbe_de_Bézier|courbes de Bézier]], polygones (rectangles, étoiles…), ellipses et ovales. Il sait lire plusieurs formats d'image et enregistrer au format [[PDF]] ou [[QuickTime#Format_de_fichier|films QuickTime]] et dispose dès à présent de plusieurs bibliothèques qui étendent ses fonctionnalités. Le projet trouve son origine dans l'idée d'offrir un environnement d'apprentissage aux débutants en programmation, en particulier les graphistes et designers. En cela il s'inscrit dans la continuité de projets comme ''[[Design by Numbers]]'' (dbn) et [[Processing]].

== Liens externes ==
* [http://www.nodebox.net/ www.nodebox.net]
* [http://www.cityinabottle.org/nodebox/ NodeBox for OpenGL] une adaptation multi-plateforme utilisant OpenGL pour le rendu.

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>qy0wumbkaeyuxxbn4ff3w3wofp2hu21</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>KTurtle</title>
    <ns>0</ns>
    <id>4949180</id>
    <revision>
      <id>99799189</id>
      <parentid>99355693</parentid>
      <timestamp>2014-01-02T06:31:19Z</timestamp>
      <contributor>
        <username>JFG CA</username>
        <id>224871</id>
      </contributor>
      <minor/>
      <comment>Annulation des modifications 99355693 - hyperlien inapproprié</comment>
      <text xml:space="preserve" bytes="2811">{{ébauche|logiciel libre}}

{{Infobox Langage de programmation
| nom et logo = oui
| nom = KTurtle
| logo = KTurtle logo.svg
| capture = [[Image:KTurtle - Example.png|250px|center]]Captura de pantalla del KTurtle en català.
| légende =
| développeur = [[Cies Breijs]]
| dernière version = 0.8 (part del [[KDE]] 4.1.3)
| date de la dernière version = [[5 novembre]] [[2008]]
| environnement = [[Linux]], [[Unix]] i [[Microsoft Windows]]
| genre = [[Programmation]] [[Éducation]], [[langage de programmation]]
| licence = [[GNU General Public License|GPL]]
| site web = [http://edu.kde.org/kturtle http://edu.kde.org/kturtle]
}}
'''KTurtle''' est un environnement de programmation éducatif utilisant le dessin vectoriel. Il est sous [[Licence publique générale GNU]] (GPL) et fait partie de l'environnement de travail [[KDE]]. KTurtle comporte un [[langage de programmation]] basé sur le [[langage de programmation Logo|Logo]]. Il s'agit d'un des rares langages de programmation traduisible ; les instructions d'un programme peuvent être traduites dans la langue du développeur.

KTurtle est disponible en paquet pour la plupart des distributions de [[Linux]]/[[Berkeley Software Distribution|BSD]], dont [[Red Hat Linux]], [[SUSE Linux|Suse]], [[Kubuntu]], [[Mandriva Linux|Mandrake]], i [[Debian]]. KTurtle est disponible pour [[Windows]] comme paquet de [[Kdeedu]] de la distribution [[KDE 4]] pour Windows.

== Exemples ==
=== Polygones ===
{|width=&quot;70%&quot;
|
{|class=&quot;toc&quot;
|+Code
|-
|
 initialise
 apprends polygone $côtés,$longueur {
   répète $côtés {
      tournedroite 360 / $côtés
      avance $longueur
   }
 }
 apprends multipolygones $début,$fin,$longueur {
    pour $pol = $début à $fin {
       polygone $pol, $longueur
    }
 }
 va 20, 150
 multipolygones 3,12,75
|}
|align=&quot;right&quot;|
{|
|+Résultat
|-
|[[Image:KTurtle - Example 2.png|center|275px]]
|}
|}

=== Spirale carrée ===
{|width=&quot;70%&quot;
|
{|class=&quot;toc&quot;
|+Code
|-
|
 initialise
 taillecanevas 200, 200
 va 10, 10
 
 $epaisseur = 1
 $longueur = 180
 
 tantque $longueur &gt; 10 {
   largeurcrayon $epaisseur
   tournedroite 90
   avance $longueur
  
   # On rajoute de l'épaisseur
   $epaisseur = $epaisseur + 1
   $longueur = $longueur - 10
 }
|}
|align=&quot;right&quot;|
{|
|+Resultat
|-
|[[Fichier:KTutrtle-exemple3.png|center|275px]]
|}
|}
== Annexes ==
{{Autres projets
| commons= Category:KTurtle
}}
=== Liens externes ===
* {{en}} [http://edu.kde.org/kturtle Page officielle KTurtle]
* {{fr}} [http://docs.kde.org/stable/fr/kdeedu/kturtle/index.html Documentation de KTurtle]

{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Logiciel éducatif]]
[[Catégorie:Logiciel pour Unix]]
[[Catégorie:Logiciel pour Windows]]</text>
      <sha1>r20ostz894aa5pu35wd95iwcclml5n0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PILOT</title>
    <ns>0</ns>
    <id>5027765</id>
    <revision>
      <id>90796299</id>
      <parentid>62406772</parentid>
      <timestamp>2013-03-18T23:44:01Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2044212]]</comment>
      <text xml:space="preserve" bytes="258">'''PILOT''' ([[acronyme]] de ''Programmed Instruction, Learning, Or Teaching'') est un [[langage de programmation]] précurseur de l'[[apprentissage en ligne]] (''E-learning'').

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>j1emzk2fxkpj0watyccmtlt02ozc4pv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gibiane</title>
    <ns>0</ns>
    <id>5105774</id>
    <revision>
      <id>90811552</id>
      <parentid>62620111</parentid>
      <timestamp>2013-03-19T02:02:54Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3105355]]</comment>
      <text xml:space="preserve" bytes="376">'''Gibiane''' est un langage de programmation basé sur [[Fortran]] développé par le [[Commissariat à l'énergie atomique et aux énergies alternatives|Commissariat à l’énergie atomique]] (CEA). Ce langage est la base des codes de calcul [[neutronique]] déterministes APOLLO2 et CRONOS2.

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>t30qo6k8pigxr8f5zh8hqtc8yka0qra</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>JAL (compiler)</title>
    <ns>0</ns>
    <id>2127408</id>
    <revision>
      <id>93774112</id>
      <parentid>90345501</parentid>
      <timestamp>2013-06-04T20:56:44Z</timestamp>
      <contributor>
        <username>Barbe-sauvage</username>
        <id>23613</id>
      </contributor>
      <minor/>
      <comment>+{{Voir homonymes|JAL}}</comment>
      <text xml:space="preserve" bytes="2643">{{Voir homonymes|JAL}}
{{ébauche|informatique}}
'''JAL (Just Another Language)''' est un [[langage de programmation]] semblable au [[Pascal (langage)|Pascal]] et possède un [[compilateur]] qui génère le code exécutable pour les [[microcontrôleurs PIC]]. C'est un langage au format libre pour programmer les microcontrôleurs PIC et le compilateur fonctionne sous [[Linux]], [[Mac OS X]], et [[MS-Windows]]. JAL est le seul langage de ce type libre de droits et a des utilisateurs actifs dans différents pays. C'est un langage configurable qui peut être enrichi par des bibliothèques et peut être combiné avec de l'[[assembleur]].

== Historique ==

Créé par Wouter van Ooijen, il a été publié comme [[logiciel libre|logiciel libre de droits]] ([[Licence publique générale GNU]]) en 2003. En 2006, Stef Mientki entreprit le développement d'une nouvelle version : JAL V2. Kyle York est le programmeur de cette nouvelle version. Un groupe international d'utilisateurs constitua l'équipe du [[bêta test]] (par ordre alphabétique : Bert van Dam, Sunish Issac, Dave Lagzdin, Javier Martinez, Stef Mientki, Wouter van Ooijen, Michael Reynolds, André Steenveld, Joep Suijs, Vasile Surducan, and Michael Watterson).

== Exemple de code ==

 -- JAL 2.3
 include 16f877_bert
 
 -- définition des variables
 var byte resist
 
 -- définition des pins
 pin_a0_direction = input          -- entrée résistance variable
 pin_d7_direction = input          -- bouton poussoir
 pin_c2_direction = output         -- Led PWM (Pulse width modulation)
 
 -- activation de la modulation par impulsion (PWM)
 PWM_init_frequency (true, true)
 
 forever loop
 
     -- Numérise la valeur analogique sur a0 
    resist = ADC_read_low_res(0)
 
     -- met la valeur mesurée dans la mémoire flash et la relit
    program_eeprom_write(2000,resist)
    program_eeprom_read(2000,resist)
 
     -- met la valeur mesurée dans la mémoire de données et la relit
    data_eeprom_write(10,resist)
    data_eeprom_read(10,resist)
 
      -- Donne un nombre aléatoire si le bouton poussoir est appuyé.
     if pin_d7 == high then
       resist = random_byte
    end if
 
    -- Envoi la valeur de la variable &quot; résist &quot; vers un PC 
    serial_sw_write(resist)
    delay_100ms(1)
    -- paramétrage du rapport cyclique du PWM
    PWM_Set_DutyCycle (resist, resist)
 
 end loop

== Voir aussi ==
=== Article connexe ===

* [[Forme de Backus-Naur]]

=== Lien externe ===

* [http://jal.sourceforge.net/ site officiel de JAL]
* [http://www.casadeyork.com/jalv2/ site officiel de JAL 2]

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>i1nx3a7uawvchm861wyn0gqz7byacjn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Jasmin (langage)</title>
    <ns>0</ns>
    <id>274075</id>
    <revision>
      <id>89885465</id>
      <parentid>74230387</parentid>
      <timestamp>2013-03-12T23:04:36Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q740158]]</comment>
      <text xml:space="preserve" bytes="1229">{{Voir homonymes|Jasmin (homonymie)}}
{{ébauche|informatique}}
'''Jasmin''' est un [[assembleur|langage d'assemblage]] d'instructions de la [[machine virtuelle]] [[Java (langage)|Java]], ou de façon plus concise, un [[assembleur]] de [[Bytecode Java]].

'''Jasmin''' a été créé par Jon Meyer et Troy Downing pour accompagner leur ouvrage ''JAVA Virtual Machine''. 

Cet ouvrage est aussi connu sous le nom informel du &quot;livre au bocal à poisson rouge&quot; (en anglais &quot;goldfish bowl book&quot;) - en référence au classique sur la compilation, le &quot;[[Dragon book|livre au dragon rouge]]&quot; (en anglais &quot;[[:en:Compilers: Principles, Techniques and Tools|Red Dragon Book]]&quot;) de [[Alfred V. Aho]] ''et al.''

Le nom de ''Jasmin'' fait quant à lui référence au [[thé]] au [[jasmin]], clin d'œil au jeu de mot sur  le sens argotique de Java : café.

== Voir aussi ==
* [[Oolong (langage)|Oolong]], un assembleur de [[Bytecode Java]]

== Références ==
* Jon Meyer, Troy Downing, ''JAVA Virtual Machine'', O'Reilly, Mars 1997, ISBN 1-56592-194-1

== Lien externe ==
* {{en}} [http://jasmin.sourceforge.net/ Site officiel]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Plateforme Java]]</text>
      <sha1>en6svo3xrjfot0tw1u364v1mlsrl6ob</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ΛProlog</title>
    <ns>0</ns>
    <id>4921634</id>
    <revision>
      <id>91882599</id>
      <parentid>89492738</parentid>
      <timestamp>2013-04-09T09:00:37Z</timestamp>
      <contributor>
        <username>KLBot2</username>
        <id>1240933</id>
      </contributor>
      <minor/>
      <comment>Bot: Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[:d:Q3594646]]</comment>
      <text xml:space="preserve" bytes="1012">{{ébauche|informatique théorique}}
'''λProlog''' ou '''lambda prolog''' est un [[Langage de programmation|langage]] de [[programmation logique]] dérivé de [[prolog]]. λProlog est une double extension de prolog, dans un premier temps, en rajoutant les [[Lambda-calcul|λtermes]]&lt;ref&gt;D.A. MILLER ET G. NADATHUR, A Logic Programming Approach to Manipulating Formulas and Programs, IEEE Symp. Logic Programming, S. Haridi ed., p. 379-388, San Francisco, CA, USA, 1987.&lt;/ref&gt; et dans un second temps avec l'ajout de nouveaux connecteurs tels que l'implication et le quantificateur universel&lt;ref&gt;D.A. MILLER, Lexical Scoping as Universal Quantification, 6th Int. Conf. Logic Programming, G. Levi et M. Martelli ed., p. 268-283, MIT Press, 1989.&lt;/ref&gt;.
Il est à noter que lambda prolog introduit egalement la notion de type simple.

== Notes et références ==
{{Références}}

{{Portail|Informatique théorique|Programmation informatique}}

{{DEFAULTSORT:Lambda prolog}}
[[Catégorie:Langage de programmation]]</text>
      <sha1>4zjvnwxya0iu73l878dpt5nnxp7zyw1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Mel (langage)</title>
    <ns>0</ns>
    <id>632021</id>
    <revision>
      <id>62406683</id>
      <parentid>60729055</parentid>
      <timestamp>2011-02-18T10:26:20Z</timestamp>
      <contributor>
        <username>Léna</username>
        <id>29802</id>
      </contributor>
      <minor/>
      <comment>/* Syntaxe et concepts */portail informatique -&gt; portail programmation informatique using [[Project:AWB|AWB]]</comment>
      <text xml:space="preserve" bytes="3287">{{Voir homonymes|Mel}}
{{ébauche|informatique}}

{{Infobox Langage de programmation
| nom				= MEL
| logo				= 
| paradigme			= [[Programmation impérative|impérative]], [[Programmation procédurale|procédurale]]
| année				= Février [[1998]]
| auteur			= [[Alias Systems Corporation]]
| typage			= [[Typage statique|statique]], [[Typage faible|faible]]
| implémentations		= [[Maya (logiciel)|Maya]]
| dialectes			= 
| influencé par			= [[C (langage)|C]], [[Unix|UNIX Shell Scipting]]
| a influencé			= 
}}

'''Mel''', MEL ou ''Maya Embeded Language'' (langage incorporé de [[Maya (logiciel)|Maya]]) est le langage de programmation du logiciel 3D [[Maya (logiciel)|Maya]]. Il s'agit d'un [[Interprète (informatique)|langage interprété]]. Maya est caractérisé par sa possibilité d'être entièrement exploitable via des lignes de codes sachant qu'une grande partie du logiciel (dont son interface) est programmée en Mel, le reste en [[C++]]. On peut utiliser le Mel dans plusieurs environnements, par exemple, il est possible d'écrire des expressions qui agiront à chaque nouvelle image dans le temps ou d'associer un Mel à une collision. De façon générale, il permet d'avoir accès à la création d'interfaces (création de fenêtres, de boutons...) et à toutes les fonctions du logiciel, et c'est pour cette raison qu'il est un outil indispensable pour les utilisateurs de Maya.

== Syntaxe et concepts ==

La syntaxe du Mel se caractérise entre autres par l'utilisation du signe &lt;code&gt;$&lt;/code&gt; au début de chaque variables comme en [[PHP]]. Elle découle de la syntaxe du [[UNIX shell scripting]] : une commande en Mel est suivie de &lt;code&gt;flags&lt;/code&gt;, c’est-à-dire de données auxquelles on attribue une valeur. Parmi ces &lt;code&gt;flags&lt;/code&gt; on a souvent &lt;code&gt;-query&lt;/code&gt;, pour appeler une valeur d'une donnée, ou &lt;code&gt;-edit&lt;/code&gt;, pour éditer une valeur d'une donnée. Par exemple :
:&lt;code&gt;polyCube -height 1.0 -width 2.0 -depth 3.0&lt;/code&gt;
Cette commande crée un cube polygonal, ou plutôt un prisme droit, Cube de hauteur 1.0, de largeur 2.0 et de profondeur 3.0.
:&lt;code&gt;polyCube -edit -height 1.5 pCube1&lt;/code&gt;
Celle-ci modifie la hauteur du cube appelé pCube1, il n'y a pas de $ devant pCube1 car il ne s'agit pas d'une variable mais du nom de l'objet.

Le Mel ne respecte que le concept de [[programmation procédurale]], sachant que le terme de [[Procédure (informatique)|procédure]] (le mot clé est &lt;code&gt;proc&lt;/code&gt;) est employé à tort dans ce langage puisqu'il est possible de renvoyer une valeur, ce qui en principe ne l'est pas avec une [[Procédure (informatique)|procédure]] mais avec une [[Fonction (informatique)|fonction]]. Existe également la possibilité d'utiliser les fonctions Mel dans un environnement [[Python (langage)|Python]] pour étendre les possibilité de ce langage au paradigme de [[programmation orientée objet]] et de [[programmation modulaire]]. Mel propose toutes les structures de contrôle les plus utilisées comme les conditions (&lt;code&gt;if&lt;/code&gt; et &lt;code&gt;else&lt;/code&gt;), les boucles (&lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;) et les branchements (&lt;code&gt;switch ... case&lt;/code&gt;).

{{Portail|imagerie numérique|programmation informatique}}

[[Catégorie:Solution 3D]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>gqjrvbgjifqrsibr41cswkgluh7egir</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Oolong (langage)</title>
    <ns>0</ns>
    <id>274082</id>
    <revision>
      <id>60729991</id>
      <parentid>39377811</parentid>
      <timestamp>2010-12-30T21:28:45Z</timestamp>
      <contributor>
        <username>Silex6</username>
        <id>54008</id>
      </contributor>
      <text xml:space="preserve" bytes="722">{{Voir homonymes|Oolong}}
{{ébauche|informatique}}
'''Oolong''' est un [[Assembleur|langage d'assemblage]] d'instructions de la [[machine virtuelle]] [[Java (langage)|Java]], ou de façon plus concise, un [[assembleur]] de [[Bytecode Java]], créé par Joshua Engel.

Le nom d'''Oolong'' fait référence au [[thé Oolong]], clin d'œil au [[jeu de mots]] sur le sens argotique de Java : [[café]].

== Voir aussi ==

* [[Jasmin (langage)|Jasmin]], un assembleur de [[Bytecode Java]]

== Références ==

* Joshua Engel, ''Programming for the Java Virtual Machine'', Addison-Wesley, juin 1999, ISBN 0201309726

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Plateforme Java]]</text>
      <sha1>e8zrtkpxkp06aeme0m34ty0t6vor02z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>4e Dimension (langage)</title>
    <ns>0</ns>
    <id>356786</id>
    <revision>
      <id>101373833</id>
      <parentid>100549543</parentid>
      <timestamp>2014-02-18T17:40:08Z</timestamp>
      <contributor>
        <username>Julien1978</username>
        <id>363502</id>
      </contributor>
      <minor/>
      <comment>[[Projet:JavaScript/Notices/HotCatsMulti|HotCatsMulti]] :  + [[Catégorie:Produit lancé en 1984]]</comment>
      <text xml:space="preserve" bytes="11542">{{Titre mis en forme|{{4e}} Dimension (langage)}}
{{Voir homonymes|Quatrième dimension}}
{{Infobox Logiciel
 | nom = {{4e}} Dimension
 | logo = 4D logo.jpg
 | développeur = [http://www.4d.fr/ 4D]
 | dernière version = 4D v14
 | environnement = [[Microsoft Windows]], [[Mac OS X]]
 | type = [[SGBDR]]
 | politique de prix = [[Vente de licences de logiciels|vendu dans le commerce]]
 | licence = [[Logiciel propriétaire|Propriétaire]]
 | site web = [http://www.4d.com/fr www.4d.com]
}}
'''{{4e}} Dimension''' (ou '''4D''') est un [[système de gestion de base de données]] équipé d'un [[langage de programmation de quatrième génération]].

== Historique&lt;ref&gt;Voir [http://fadace.developpez.com/sgbdcmp/story/ Généalogie des SGBDR]&lt;/ref&gt; ==
Le logiciel 4D a été créé par [[Laurent Ribardière]] en [[1984]] et est l'un des premiers (sinon le premier) systèmes de base de données à voir le jour sur la plateforme [[Apple Macintosh]]&lt;ref&gt;Voir les articles : [http://www.uhb.fr/urfist/SerreDEF.htm DE PAUL OTLET A INTERNET], extrait : &quot;''Logiciel de base de données : 4D, développé par le Français Alain Ribardière ; il deviendra le standard SGBD pour les Macintosh d'Apple''&quot; / [http://www.aventure-apple.com/chrono/8489.html L'aventure Apple], extrait : &quot;''Heureusement pour Apple, lors de la sortie du Mac Plus, beaucoup de logiciels avaient fait leur apparition : Word 3, 4d, Excel ou Cricket Draw.''&quot; / [http://www.generation-nt.com/imprimer/apple-histoire-mac-article-24820-1.html L'histoire Apple], extrait : &quot;''En même temps que ce MacPlus arrivèrent de nombreuses applications comme Word 3, Excel ou 4D.''&quot;&lt;/ref&gt;. Cette particularité lui a d'ailleurs longtemps &quot;collé à la peau&quot;, mais en [[1995]] 4D devient multi-plateforme et fonctionne également sous [[Microsoft Windows]].

{| class=wikitable
!  Année
!  Version
! Remarques
|-----
| 1984
| ABCBase
|
|-{{ligne grise}}
| 1985
| 4D v1
|
|-----
| 1986
| 4D v2
|
|-{{ligne grise}}
| 1987
| 4D v3
|
|-----
| 1989
| 4D v4
| Utilisation multiposte - Compiler
|-{{ligne grise}}
| 1992
| 4D v5
| Environnement client/serveur intégré
|-----
| 1995
| 4D v5.5
| Multi-plateforme Mac OS et Windows
|-{{ligne grise}}
| 1997
| 4D v6
| Serveur Web intégré
|-----
| 1999
| 4D 6.5
| 4D 6.5.9r2 est la dernière version de cette ligne
|-{{ligne grise}}
| 2000
| 4D 6.7
| 4D 6.7.4 est la dernière version de cette ligne
|-----
| 2001
| 4D 6.8
| Certification Mac OS X (6.8.5) ; la version 6.8.6 est la dernière version de cette ligne.
|-{{ligne grise}}
| 2003
| 4D 2003
| XML, Web Services et Compilateur intégré ; la version 2003.8r2 est la dernière version de cette ligne.
|-----
| 2004
| 4D 2004
| Interface revue ; intégration des commandes ODBC haut niveau, 4D Customizer, 4D Backup et 4D Engine ; la version 2004.8 est la dernière version de cette ligne.
|-{{ligne grise}}
| 2007
| 4D v11 SQL
| Nouveau [[moteur de base de données]], SQL intégré, support Unicode, gestion SVG, centre de maintenance intégré, zone web ; 4D v11 SQL Release 9 (11.9) est la dernière version de cette ligne.
|-{{ligne grise}}
| 2010
| 4D v12
| Nouvelles fonctionnalités, améliorations de l'environnement de développement, multibases, système intégré de synchronisation entre plusieurs bases, support PHP ; 4D v12.4 est la dernière version de cette ligne.
|-{{ligne grise}}
| 2012
| 4D v13
| Nouveau serveur HTTP multithread, gestion des sessions automatique, nouveau client HTTP extensible, intégration de webkit et support étendu de Javascript, list box enrichie, gestion de documents externes. 
|-{{ligne grise}}
| 2014
| 4D v14
| Création de Web apps avec 4D Mobile: Applications multiplateforme disponibles sur Mobile, Tablette et tout type de navigateur. Objets structurés JSON, vues SQL, nouveaux outils de maintenance et de monitoring.
|}

== Logiciel 4D ==
4D est un Système de Gestion de Base de Données Relationnelle ([[SGBDR]]) disposant d'un langage de programmation de la quatrième génération ([[L4G]]).
[[Environnement de développement intégré]] (EDI ou IDE en anglais), 4D intègre un compilateur, un déboggeur, un système complet et automatisé de sauvegarde et de réplication, un serveur Web, un serveur et client de [[Service Web|services web]], un moteur d'exécution mono-poste et client-serveur multiplate-forme.
En 2009, 4D s'est vu enrichi de la suite 4D Web 2.0 Pack, intégrant le plugin 4D Live Window et le composant 4D Ajax Framework.
&lt;br /&gt;&lt;br /&gt;
4D comporte de nombreux [[Plugin|plug-ins]] :
* de productivité : 4D View (tableur), 4D Write (traitement de texte), 4D Chart (graphes)
* de connectivité : 4D ODBC, 4D for MySQL, 4D for ADO, 4D for OCI, 4D for PostgreSQL, 4D Internet Commands (ftp, [[courriel]], http), ODBC Driver for 4D, JDBC Driver for 4D, …
* d'extensions : 4D Pack (extensions du langage), 4D Live Window (affichage de documents), 4D Ajax Framework (composant), 4D Ajax for Dreamweaver (plugin pour [[Adobe Dreamweaver]]), 4D for Flex (bibliothèques pour application cliente [[Adobe Flex|Flex]]), 4D Plugin SDK (développement de plugin), …
&lt;br /&gt;
Le [[logiciel]] 4D possédait traditionnellement 3 modes :
* Le mode structure (ou mode Design) permettant de créer des [[formulaire]]s et des [[Méthode (informatique)|méthodes]], mais aussi de modifier la structure de la base de données, de compiler, de débugger.
* Le mode utilisation, permettant le lancement à l'unité des programmes réalisés et la modification du contenu de la base de données.
* Le mode dit menus créés dans lequel les utilisateurs peuvent visualiser une application sur-mesure entièrement « habillée ».

Depuis la version ''4D v11 SQL'', les modes Structure et Utilisation ont fusionné en un seul mode Développement. Le mode Menus Créés est devenu le mode Application.

== 4D en quelques notions ==
* Langage propriétaire de haut niveau indépendant du système d’exploitation
* Multi-plateforme : Mac OS X (y compris MacIntel depuis la version 4D 2004.5) et Windows (certification Vista depuis la version 4D 2004.6 et Windows Server 2008 depuis la version 4D v11 SQL 11.3, certification Windows 7 depuis la version 4D V11.5)
* Solutions mono-poste et client/Serveur
* Architecture extensible : plug-ins, bibliothèques d’objets, composants
* Possibilité de développer en client/Serveur (développement collaboratif)

Depuis ''4D v11 SQL'' :
* Moteur SQL natif
* Prise en charge du SVG
* Intégration d’Unicode
* Support étendu de ODBC, XML et des Web Services SOAP

== Fonctionnalités principales ==
* Ouverture de bases de données en code [[Interprète (informatique)|interprété]] ou [[Compilateur|compilé]]
* Générateur de formulaires
* Gestion des accès utilisateurs et mot de passe
* Éditeur de méthodes
* Éditeur de menus, [[Bulle d'aide|bulles d'aide (ou infobulles)]], de listes, de feuilles de styles, de filtres
* Correcteur orthographique multilingue
* Moteur de rendu HTML
* [[Débogueur]], vérificateur syntaxique
* [[Compilateur]] et générateur d'applications
* Système intégré de [[Stockage d'information|sauvegarde]] et de mirroring
* Serveur Web
* Serveur et Client de [[Web Services]]
* Serveur et Client de données ([[ODBC]], [[JDBC]], [[Oracle (base de données)|Oracle]], [[Structured Query Language|SQL]], [[MySQL]], …)

== Points forts de 4D V11 SQL ==
* Que ce soit pour des projets basiques en local ou des solutions en client-serveur avec de nombreux clients, l'évolution se fait en douceur : sans changer une ligne de code, le moteur de 4D prenant tout en charge. La version serveur de la version 11 donne d'excellents résultats en termes de réactivité.
* Multiplateforme : un même programme peut être porté de Mac OS à MS Windows (et vice-versa) sans changer une seule ligne de code. La compatibilité Linux est espérée
* Toute l'administration des bases et leur configuration sont centralisées en un seul point (le Centre de Support et Maintenance)
* Les sauvegardes sont soit déclenchables dans le code soit programmables à heures régulières
* l'indexation très puissante permet de faire des recherches en full-text
* 4D est conforme à toutes les normes du marché :
** SQL2 (la dernière) : la grande majorité des commandes existantes dans ce langage est implantée dans 4D
** XML : 4D est &quot;orientée&quot; XML. Les données et la structure sont directement exportables en XML pour une réutilisation avec d'autres produits.
** Webservices : un assistant permet d'utiliser simplement des Webservices.
** Web 2.0 : un framework Ajax a été développé afin de simplifier l'intégration des données issues de 4D à des pages web dynamiques
** Flex : des bibliothèques 4D pour Flex permettent de connecter les données 4D via SQL dans une application cliente riche
** Oracle : via le driver ODBC, 4D peut communiquer avec les bases oracle
** UTF8
* Un traitement de texte (4D Write) et un tableur (4D View) sont intégrés en natif dans 4D. Il existe en plus des objets 4D qui permettent de communiquer directement avec les applications de la suite Office.
* Un développement complet peut être réutilisé très simplement dans un autre par simple glisser-déposer, grâce à la prise en compte de la programmation orientée composants
* 4D est à la fois serveur de données, serveur Web, serveur de webservices et serveur SQL.
* le langage de programmation de 4D est tokennisé : un développement fait avec des commandes en français sera automatiquement traduit en anglais, en allemand, en espagnol ou en japonais selon la version de 4D utilisée.
* un framework permet de développer des pages web spécifiquement adaptées à l'iPhone
* Le déploiement client/serveur est d'une grande simplicité.

== Limites ==
* La plateforme 4D dont l'architecture intégrée permet une grande simplicité de développement ne destine pas 4D au développement d'applications de gestion visant à supporter plusieurs milliers d'utilisateurs concurrents intensifs.
* Le langage de programmation de 4D n'est pas orienté objet.
* 4D Server pour Mac n'est pas disponible à ce jour en version 64 bits. Seule 4D Server pour Windows est disponible en version [[32-bit|32]] et [[64-bit|64 bits]] (depuis la version 12 de 4D). Les versions 4D Server 32 bits ne pouvant adresser plus de 4 [[Gigaoctet|Go]] de [[mémoire RAM]], elle peuvent pénaliser les performances des applications&lt;ref&gt;[http://www.4d.com/fr/support/resources/features/64bit.html Présentation des avantages de la version 64 bits de 4D Server v12 Windows sur le site officiel 4D] Consulté le 06-08-2011&lt;/ref&gt; lors de la manipulation de grosses [[bases de données]] ou de la connexion simultanée de nombreux utilisateurs en mode [[client-serveur]].

== Liens externes ==
* {{fr}} [http://www.4d.fr Site officiel]
* {{fr}} [http://4d.developpez.com/ Centre de ressources techniques pour 4D] : Documentations, F.A.Q, Astuces, …
* {{fr}} [http://www.solutions4d.com Solutions 4D] : Ressources pour développeurs
* {{fr}} {{en}} [http://www.4dtoday.com/fr Portail 4DToday]

== Notes et références ==
&lt;references /&gt; &lt;!-- aide : http://fr.wikipedia.org/wiki/Aide:Notes et références --&gt;

{{Palette|Systèmes de gestion de base de données}}
{{Portail|bases de données|logiciel}}

[[Catégorie:Logiciel propriétaire]]
[[Catégorie:Outil de développement logiciel]]
[[Catégorie:Logiciel pour Mac OS]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Système de gestion de base de données]]
[[Catégorie:Produit lancé en 1984]]</text>
      <sha1>2osfl664qwzml6np89mn6zobgcyjouu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Profil Ravenscar</title>
    <ns>0</ns>
    <id>983665</id>
    <revision>
      <id>90137402</id>
      <parentid>77848066</parentid>
      <timestamp>2013-03-14T15:03:19Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3406871]]</comment>
      <text xml:space="preserve" bytes="3517">Le '''profil Ravenscar''' est un sous-ensemble du langage [[Ada (langage)|Ada]] dédié aux [[système temps réel|systèmes temps réel]] nécessitant une grande [[sûreté de fonctionnement]]. 
Il ne restreint que les fonctionnalités liées au [[parallélisme (informatique)| parallélisme]].

L'idée est de permettre de prouver formellement les propriétés [[système temps réel|temps-réel]] des programmes écrits selon ce profil. Le profil Ravenscar, en interdisant un certain nombre de caractéristiques du langage Ada, permet de rendre applicables les outils de preuve de programme.

Les restrictions apportées permettent également de réaliser des [[Système d'exploitation temps réel|exécutifs]] plus simples, et donc eux-mêmes certifiables. 

Ce profil a aussi été appliqué à la spécification temps réel [[RTSJ]] du langage [[Java (langage)|Java]]&lt;ref name=&quot;RavenscarJava&quot;&gt; J. Kwon, A. Wellings, and S. King, « Ravenscar-Java: A High Integrity Profile for Real-Time Java», York Technical Report (YCS 342), Department of Computer Science, University of York, 2002, {{lire en ligne |lien=http://www.cs.york.ac.uk/ftpdir/reports/YCS-2002-342.pdf}}&lt;/ref&gt;.

== Restrictions apportées par le profil==

Le profil Ravenscar est maintenant intégré à la norme Ada (2005). Il suffit d'appliquer la directive de compilation suivante:
&lt;source lang=&quot;ada&quot;&gt;
pragma Profile (Ravenscar);
&lt;/source&gt;
Ce profil est équivalent à l'ensemble de pragmas de configuration suivants:
&lt;source lang=&quot;ada&quot;&gt;
pragma Task_Dispatching_Policy (FIFO_Within_Priorities);
pragma Locking_Policy (Ceiling_Locking);
pragma Detect_Blocking;
pragma Restrictions (
                 No_Abort_Statements,
                 No_Dynamic_Attachment,
                 No_Dynamic_Priorities,
                 No_Implicit_Heap_Allocations,
                 No_Local_Protected_Objects,
                 No_Local_Timing_Events,
                 No_Protected_Type_Allocators,
                 No_Relative_Delay,
                 No_Requeue_Statements,
                 No_Select_Statements,
                 No_Specific_Termination_Handlers,
                 No_Task_Allocators,
                 No_Task_Hierarchy,
                 No_Task_Termination,
                 Simple_Barriers,
                 Max_Entry_Queue_Length =&gt; 1,
                 Max_Protected_Entries  =&gt; 1,
                 Max_Task_Entries       =&gt; 0,
                 No_Dependence =&gt; Ada.Asynchronous_Task_Control,
                 No_Dependence =&gt; Ada.Calendar,
                 No_Dependence =&gt; Ada.Execution_Time.Group_Budget,
                 No_Dependence =&gt; Ada.Execution_Time.Timers,
                 No_Dependence =&gt; Ada.Task_Attributes);
&lt;/source&gt;

== Références ==
* [[:en:Alan Burns|Alan Burns]] « The Ravenscar Profile » dans ''ACM SIGAda Ada Letters'' Décembre 1999, vol XIX issue= 4 pages= 49-52  {{lire en ligne |lien = http://polaris.dit.upm.es/~str/proyectos/ork/documents/RP_spec.pdf}}
* [[:en:Alan Burns|Alan Burns]], Brian Dobbing and Tullio Vardanega « Guide for the use of the Ada Ravenscar Profile in high integrity systems »  dans ''ACM SIGAda Ada Letters'', Juin 2004, vol.XXIV issue= 2 pages= 1-74 {{lire en ligne |lien = http://www.sigada.org/ada_letters/jun2004/ravenscar_article.pdf}}
* [http://www.ada-auth.org/cgi-bin/cvsweb.cgi/AIs/AI-00249.TXT?rev=1.15 AI95-00249 — Ravenscar profile for high-integrity systems]

=== Notes ===
{{Références}}

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>kfasrtyid0e6zcfvnchhiqk0smh9sas</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>OptimJ</title>
    <ns>0</ns>
    <id>5234325</id>
    <revision>
      <id>90831360</id>
      <parentid>66091630</parentid>
      <timestamp>2013-03-19T05:25:37Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3354460]]</comment>
      <text xml:space="preserve" bytes="1173">{{ébauche|logiciel}}

'''OptimJ''' est un langage de [[Modèle mathématique|modélisation mathématique]] orientée-objet destiné à faciliter l'intégration de modèles d'optimisation avec le monde Java.

OptimJ est conçu sous la forme d'une extension au langage Java avec support sous Eclipse. OptimJ possède toutes les fonctionnalités des langages de modélisation actuels et peut supporter tout moteur d'optimisation. OptimJ est disponible gratuitement avec les moteurs open source lp_solve et GLPK

Les modèles OptimJ travaillent directement sur les données de l'application, sans création d'objets intermédiaires. Ils peuvent être déployés directement sous forme compilée sur toutes les plateformes pour lesquelles un Java Runtime Environment est disponible.

== Liens externes ==
* [http://www.ateji.com/optimj site officiel]
* [http://www.euro2010lisbon.org/EUROXXIVProgramme.pdf European Conference on Operational Research - Technical Session ]

{{Portail|mathématiques|programmation informatique}}

[[Catégorie:Logiciel de calcul formel]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Optimisation]]
[[Catégorie:Recherche opérationnelle]]</text>
      <sha1>fiqfq5ien7ggvo2ruf0orjk4qpy53hm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Pharo</title>
    <ns>0</ns>
    <id>4605251</id>
    <revision>
      <id>98202936</id>
      <parentid>98202889</parentid>
      <timestamp>2013-11-09T20:52:50Z</timestamp>
      <contributor>
        <username>ReneMages</username>
        <id>4437</id>
      </contributor>
      <minor/>
      <comment>s / Un des intérêt principaux de Pharo / Un des intérêts principaux de Pharo /</comment>
      <text xml:space="preserve" bytes="9228">{{autre|le quartier de Marseille|Le Pharo}}
{{Infobox Langage de programmation
|  nom                    = Pharo
|  logo                   = Pharo_Logo_v0.9.svg
|  paradigmes             = [[Programmation orientée objet|POO]]
|  auteurs                = l'équipe du projet Pharo 
|  typage                 = [[Typage dynamique|dynamique]]
|  implémentations        = Pharo 
|  influencé par          = [[Smalltalk]], [[Simula]], [[Lisp]], [[Squeak]] 
|  système d'exploitation = [[Multiplate-forme]]
|  licence                = [[licence MIT|MIT]]
|  site web               = [http://www.pharo-project.org/ www.pharo-project.org]
}}

'''Pharo''' est un langage de programmation dynamique, épuré et sous licence MIT, créé en 2009.

== Introduction ==
[[Image:Pharo v2-0.png|left|thumb|Capture d'écran de l'environnement Pharo]]
Pharo est un langage de programmation largement inspiré de [[Smalltalk]]. Il est basé sur une [[machine virtuelle]], écrite en large partie en Pharo lui-même, ce qui lui permet d'être multiplateforme (Mac OS X, Windows, Linux, iOS, Android). 

La politique de Pharo oblige ses contributeurs à accepter de publier leur code sous [[licence MIT]].
Pharo possède les principales caractéristiques de Smalltalk : 

'''Tout est objet''', au sens de la programmation orientée objet,

Le système est '''[[Réflexion (informatique)|réflexif]]''' : un programme peut modifier sa structure et son comportement lors de l’exécution,

Le typage est un ''' [[typage dynamique]]''' : contrairement à certains langages à  [[typage statique]], qui forcent le développeur à indiquer de quel type est chaque variable (entier, chaîne de caractères…), les variables peuvent prendre n'importe quelle valeur,

'''L'héritage est simple''',

'''La gestion de la mémoire est automatique''' : Pharo  utilise '''un ramasse-miettes''' (''garbage collector'')&lt;ref name=&quot;unixgarden-smalltalk&quot; /&gt;, comme d'autres langages comme Lisp ou Java. 

La syntaxe de Smalltalk est '''minimaliste''' : elle tient sur une carte postale&lt;ref name=&quot;unixgarden-smalltalk&quot; /&gt;.

Un des intérêts principaux de Pharo est qu'il n'est pas nécessaire de recompiler tout le code pour dans le cas de la modification d'une méthode. Il est par exemple tout à fait possible de modifier ou de créer une méthode au sein du debugger et de reprendre le flot d'exécution juste avant la modification. Certains appellent cela la méthode 'edit and continue' an lieu de la traditionnelle méthode 'edit compile and run'.

== Communauté ==

La communauté de Pharo est assez vaste : 600 personnes sur la Pharo mailing list, {{formatnum:250000}} téléchargements de la version one-click depuis sa création.
Tous les 6 mois, de nombreux membres de la communauté se retrouvent durant une journée pour améliorer Pharo au cours d'un [[Sprint_(développement_logiciel)|sprint]].

Chaque année une conférence Pharo a lieu. Les utilisateurs de Pharo se réunissent au cours de cette conférence pour partager à la fois leurs projets de recherche et professionnels. En 2010, elle s'est déroulée à Annecy (France). En 2011 et 2012, elle a eu lieu à Lille en France. Enfin, en 2013, la conférence Pharo s'est déroulée à Berne en Suisse.

Régulièrement, des vidéos de programmation avec Pharo sont postés sur PharoCast&lt;ref&gt;http://www.pharocasts.com&lt;/ref&gt; ou sur la chaine youtube de Pharo.

Plus d'une vingtaine d'entreprises utilisent aujourd'hui Pharo pour leurs développements logiciels.
Les principales applications développées sont d'une part liés au développement d'application web (en utilisant par exemple le framework [[Seaside_(framework)]]) et d'autres
part à l'analyse et à la visualisation de système logiciel (en utilisant le framework MOOSE).
La communauté Pharo s'organise autour d'un consortium&lt;ref&gt;http://consortium.pharo.org/&lt;/ref&gt; rassemblant des industriels, des partenaires académiques utilisant la plateforme.
Pharo dispose également d'une association&lt;ref&gt;http://association.pharo.org/&lt;/ref&gt; à but non lucratif.

== Historique ==

Pharo est un fork de Squeak, un Smalltalk open-source développé par des membres de l'équipe originelle de Smalltalk-80 (Dan Ingals et Alan Kay). 

Se démarquant de l'aspect plus ludique de Squeak, les concepteurs de Pharo (chercheurs à l'INRIA) souhaitent développer un Smalltalk moderne tourné vers les besoins des entreprises et de la recherche en génie logiciel. Pharo est devenu l'implémentation de référence de [[Seaside]], framework web pour développer des applications web en Smalltalk&lt;ref&gt;http://code.google.com/p/pharo/&lt;/ref&gt;. Aujourd'hui, Pharo est soutenu par un consortium regroupant les utilisateurs industriels et une association pour les particuliers.

Fork en 2008.

La version 1.0 de Pharo est sortie le 15 avril 2010. 

La version 1.1 de Pharo est sortie le 26 juillet 2010&lt;ref&gt;http://linuxfr.org/2010/07/28/27175.html&lt;/ref&gt;.

La version 1.2 de Pharo est sortie le 29 mars 2011&lt;ref&gt;http://code.google.com/p/pharo/wiki/Pharo12FrenchAnnouncement&lt;/ref&gt;.

La version 1.3 de Pharo est sortie en août 2011.

La version 1.4 de Pharo est sortie en avril 2012.

La dernière version de Pharo, Pharo 2.0 est sortie le 18 mars 2013&lt;ref&gt;http://www.pharo-project.org/pharo-download/release-2-0&lt;/ref&gt;.

Le planning actuel prévoit une nouvelle version par an : Pharo 3.0 est donc prévu pour mars 2014. De plus, des versions de stabilisation (Pharo 2.1, 2.2) sont prévues tous les 4 mois.

== Enseignement et Recherche ==

=== Enseignement ===

Avec sa communauté active, sa licence MIT, son noyau stable et son fonctionnement multiplateforme, Pharo est un environnement idéal pour apprendre le langage Smalltalk. 

Un livre en français, ''Pharo par l'exemple'', est disponible en ligne&lt;ref&gt;{{fr}} [http://pharobyexample.org/fr/ ''Pharo par l'exemple''], de Andrew Black, Stéphane Ducasse, Oscar Nierstrasz et Damien Pollet, traduit par Martial Boniou, René Mages et Serge Stinckwich. Licence Creative Commons paternité, version 3.0 &lt;/ref&gt;. Il est gratuit et permet d'apprendre les bases de Pharo. Un second volume est en préparation. Il est dors et déjà possible d'accéder à certains chapitres de la version anglaise sur ce site : http://rmod.lille.inria.fr/pbe2/.

Pharo est de plus en plus utilisé dans le cadre de l'enseignement. Smalltalk est enseigné sous la forme de Pharo notamment à : 

* l'université de Bueno Aires (Argentine)
* l'université de Bern (Suisse) &lt;ref name=&quot;scq&quot;&gt;http://scg.unibe.ch&lt;/ref&gt;
* l'university de Bruxelles (Belgique) &lt;ref&gt;http://soft.vub.ac.be/soft/&lt;/ref&gt;
* l'école des mines de Douai (France) &lt;ref&gt;http://www.ensm-douai.fr&lt;/ref&gt;
* l'université de Savoie (France) &lt;ref&gt;http://www.imus.univ-savoie.fr&lt;/ref&gt;
* l'université de Lviv (Ukraine)
* l'université Northen Michigan (États-Unis) &lt;ref&gt;http://www.nmu.edu&lt;/ref&gt;
* l'université Catholique d'Argentine (Argentine) &lt;ref&gt;http://www.uca.edu.ar&lt;/ref&gt;
* l'université de Santiago (Chili) &lt;ref&gt;http://www.uchile.cl&lt;/ref&gt;
* l'université polytechnique de Catalunya (Espagne) &lt;ref&gt;http://www.upc.edu&lt;/ref&gt;

=== Recherche ===

De nombreuses équipes de recherche travaillent avec Pharo, notamment les équipes :

* Lafhis (Université de Bueno Aires, Argentine)
* Software Composition Group (Université de Bern, Suisse) &lt;ref name=&quot;scq&quot; /&gt;
* CAR (Mines de Douai, France) &lt;ref&gt;http://car.mines-douai.fr&lt;/ref&gt;
* RMOD (Inria, France) &lt;ref&gt;http://rmod.lille.inria.fr/web/&lt;/ref&gt;
* Ummisco (IRD, France) &lt;ref&gt;http://www.ummisco.ird.fr/index.php&lt;/ref&gt;
* Reveal (Université de Lugano, Suisse)
* Lysic (Université de Bretagne Occidentale, France) &lt;ref&gt;http://www.lisyc.univ-brest.fr/&lt;/ref&gt;
* Pleiad (Université de Santiago, Chili)
* CEA-List

La Pharo association a été récemment créée et regroupe tous les indépendants souhaitant soutenir le projet&lt;ref&gt;http://association.pharo.org&lt;/ref&gt;.

== Performance et machine virtuelle ==
Pharo est basé sur une [[machine virtuelle]] écrite en large partie en Smalltalk elle-même. Depuis 2008, une nouvelle machine virtuelle avec un niveau de performance comparable aux dialectes Smalltalk les plus rapides est disponible&lt;ref&gt;http://www.mirandabanda.org/cogblog/&lt;/ref&gt;. Cette machine virtuelle performante fonctionne sur Mac OS X, Windows et Linux. Une version simplifiée et un peu moins rapide fonctionne sur iOS et Android.

== Articles connexes ==
* [[Smalltalk]]
* [[Squeak]]
* [[GNU Smalltalk]]

== Notes et références ==

&lt;references&gt;
&lt;ref name=&quot;unixgarden-smalltalk&quot;&gt;http://www.unixgarden.com/index.php/programmation/smalltalk-le-pouvoir-et-la-simplicite-du-tout-objet&lt;/ref&gt;
&lt;/references&gt;

== Liens externes ==

* {{en}} [http://pharo-project.org/community Le site web de la communauté Pharo]
* {{en}} [http://pharo-project.org/documentation/faq La FAQ de Pharo]
* {{fr}} [http://pharobyexample.org/fr/ Pharo par l'exemple. Un livre d'introduction à Pharo ]
* {{fr}} [http://community.ofset.org/index.php/Pharo OFSET &amp; Pharo ]

{{Portail|programmation informatique}}

[[Catégorie:Dialecte Smalltalk]]
[[Catégorie:Environnement de développement intégré]]
[[Catégorie:Logiciel libre sous licence MIT]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>oa2zeyw4ucrdjga60qlo92zyiifcaue</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>UCBLogo</title>
    <ns>0</ns>
    <id>5469256</id>
    <revision>
      <id>89231562</id>
      <parentid>84313114</parentid>
      <timestamp>2013-02-25T15:31:29Z</timestamp>
      <contributor>
        <username>Silex6</username>
        <id>54008</id>
      </contributor>
      <comment>classement article</comment>
      <text xml:space="preserve" bytes="2845">{{ébauche|logiciel libre}}

{{Infobox Langage de programmation
|  couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
|  nom et logo                      = non
|  nom                              = UCBLogo
|  logo                             = 
|  paradigmes                       = 
|  auteur                           = [[Brian Harvey]]
|  développeurs                     = [[Brian Harvey]], [[Université de Californie à Berkeley]]
|  date de première version         = 
|  dernière version stable          = 6.0 &lt;!-- Utilisation du modèle « Modèle:Dernière version stable/UCBLogo » --&gt;
|  date de dernière version stable  = 14 Sep 2008 &lt;!-- idem --&gt;
|  dernière version avancée         = 
|  date de dernière version avancée = 
|  typage                           = 
|  implémentations                  = 
|  normes                           =
|  dialectes                        = 
|  influencé par                    = [[Lisp]]
|  a influencé                      = 
|  système d'exploitation           = [[Multiplateforme]]
|  licences                         = [[GNU GPL]]
|  site web                         = {{Site officiel|en|http://www.cs.berkeley.edu/~bh/logo.html}}
|  date de mise à jour              = 8 mai 2011
}}
'''UCBLogo''' (appelé aussi ''Berkeley Logo'') est une implémentation [[logiciel libre|libre]] du [[langage de programmation]] [[Logo (langage)|Logo]] concue  par [[Brian Harvey]] et ses étudiants au sein de l'[[université de Californie à Berkeley]].

Comme beaucoup d'autres implémentations, UCBLogo fournit un [[Interprète (informatique)|interpréteur]] Logo avec l'appel de [[récursion terminale|récursion finale]].

Écrit en [[C (langage)|C]], ''Berkeley Logo'' est un logiciel libre distribué selon les termes de la [[licence publique générale GNU]] et disponible sur plusieurs systèmes libres comme [[GNU/Linux]] ou [[FreeBSD]].

== implémentations Logo dérivées de Berkeley Logo==
* ''aUCBLogo'', une implémentation logo réalisée par ''Andreas Micheler''&lt;ref&gt;{{en}} [http://www.rz.uni-augsburg.de/~micheler/en/ aUCBLogo]&lt;/ref&gt; à partir de UCBLogo (Berkeley Logo).
* ''MSWLogo'', une implémentation pour MS Windows réalisée par ''George Mills''&lt;ref&gt;{{en}} [http://www.softronix.com/logo.html MSWLogo]&lt;/ref&gt;
* ''FMSLogo'', une version améliorée de MSWLogo, orientée multimédia, et réalisée par ''David Costanzo''&lt;ref&gt;{{en}} [http://fmslogo.sourceforge.net/ FMSLogo]&lt;/ref&gt;.

==Notes et références==
{{références}}

== Articles connexes ==
* [[Logo (langage)]]
* [[Logo_(langage)#Impl.C3.A9mentations|Implémentations]]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel éducatif]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Logiciel pour Linux]]</text>
      <sha1>4hucd20ufhjj0ib1iljk93ls2qg8u0i</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Next Byte Codes</title>
    <ns>0</ns>
    <id>5231460</id>
    <revision>
      <id>91635834</id>
      <parentid>90830863</parentid>
      <timestamp>2013-04-03T10:30:51Z</timestamp>
      <contributor>
        <username>Ltrlg</username>
        <id>791461</id>
      </contributor>
      <minor/>
      <comment>Lego → The Lego Group</comment>
      <text xml:space="preserve" bytes="4249">__NOTOC__
{{Infobox Langage de programmation
| nom                    = Next Byte Codes
| paradigme              = [[Programmation structurée|structuré]], [[Programmation impérative|imperatif]]
| auteur                 = John Hansen
| typage                 = [[Typage statique|statique]], [[Typage fort|fort]]
| influencé par          = [[C (langage)|C]]
| site web = [http://bricxcc.sourceforge.net/nbc/ bricxcc.sourceforge.net]
| licence = [[Mozilla Public License|MPL]]
| système d'exploitation           = [[Microsoft Windows|Windows]], [[Mac OS X]] et [[Linux]]
}}

Le '''{{lang|en|Next Byte Codes}}''' ou '''NBC'''  est un [[Assembleur|langage assembleur]] pouvant être utilisé pour programmer le [[Lego Mindstorms NXT]], la brique programmable de [[The Lego Group|Lego]], développé par John Hansen, un membre du ''{{lang|en|Mindstorms Developer Program}}''&lt;ref&gt;{{en}} [http://mindstorms.lego.com/MeetMDP/JohnHansen.aspx Mindstorms Developer Program: John Hansen] ([http://web.archive.org/web/20071205144531/http://mindstorms.lego.com/MeetMDP/JohnHansen.aspx archive])&lt;/ref&gt;.

Le [[compilateur]] NBC est disponible sous {{lang|en|[[Mozilla Public License]]}} pour [[Microsoft Windows|Windows]], [[Mac OS]] et [[Linux]]&lt;ref&gt;{{de}} [http://www.pcwelt.de/news/software/77325/index.html Update für NBC: Programmiersprache für Lego Mindstorms NXT]&lt;/ref&gt;. Son [[environnement de développement intégré]] est [[Bricx Command Center|BricxCC]].

Un [[débogueur]] a été développé par SorosyDotCom et est disponible en téléchargement gratuit.

== Exemples de programmes ==
Voici deux exemples de programmes réalisables avec le NBC, suivis de l'explication de leur effet.

{{exemple|nom=Allumage d’un moteur|1=&lt;nowiki/&gt;
 '''thread''' main
   {{bleu|OnFwd}}({{vert|OUT_A}})
   {{bleu|wait}} 1000 
   '''exit'''
 '''endt'''

L'[[actionneur]] relié à la prise « A » du [[Lego Mindstorms NXT|NXT]] démarre puis le programme s'arrête au bout d'une seconde.
}}

{{exemple|nom=Réaction à la lumière|1=&lt;nowiki/&gt;
 variables '''segment'''
   sensor_1 '''byte'''
   sensor_2 '''byte'''
 variables '''ends'''
 
 '''thread''' main
   {{bleu|SetSensorTouch}}({{vert|IN_1}})
   {{bleu|SetSensorLight}}({{vert|IN_2}})
   {{bleu|OnFwd}}({{vert|OUT_A}}, 100)
 debut:
   {{bleu|ReadSensor}}({{vert|IN_1}}, sensor_1)
   '''brtst''' {{vert|EQ}}, suite, sensor_1
   '''exit'''
 suite:
   {{bleu|ReadSensor}}({{vert|IN_2}}, sensor_2)
   '''brcmp''' {{vert|LT}}, debut, sensor_2, 50
   {{bleu|PlayTone}}({{vert|TONE_A4}}, 10)
   '''jmp''' debut
 '''endt'''

L'[[actionneur]] relié à la prise « A » du [[Lego Mindstorms NXT|NXT]] est démarré et le type des capteurs 1 et 2 est défini ; si l'on met le capteur 2 (capteur de luminosité) devant une source de lumière, le [[Lego Mindstorms NXT|NXT]] produit une tonalité (de fréquence {{unité|440|[[Hertz|Hz]]}} donc un [[A440|la&lt;sub&gt;3&lt;/sub&gt;]]) durant {{unité|10|[[Seconde (temps)|millisecondes]]}}. L'appui sur le capteur 1 (capteur de contact) provoque l'arrêt du programme.
}}

== Voir aussi ==
=== Articles connexes ===
* [[Lego]]
* [[Lego Mindstorms]]
* [[Lego Mindstorms NXT]]
* [[Bricx Command Center]]

=== Liens externes ===
* {{en}} [http://bricxcc.sourceforge.net/nbc/ Site du NBC et du NXC]
* {{en}} [http://www.tik.ee.ethz.ch/tik/education/lectures/PPS/mindstorms/sa_nxt/index.php?page=print Robotics lecture using NBC]
* {{en}} [http://www.sorosy.com/lego/nxtdbg/ NBC Debugger]
* {{en}}{{pdf}} [http://bricxcc.sourceforge.net/nbc/doc/NBC_Guide.pdf Guide du NBC]

=== Bibliographie ===
* {{ouvrage
 | langue = en
 | prénom1 = Michael
 | nom1 = Gasperi
 | prénom2 = Philippe
 | nom2 = Hurbain
 | prénom3 = Isabelle
 | nom3 = Hurbain
 | titre = Extreme NXT
 | sous-titre = Extending the Lego Mindstorms NXT to the Next Level (Technology in Action)
 | éditeur = APress
 | jour = 11
 | mois = avril
 | année = 2007
 | titre chapitre = In the Box
 | isbn = 1590598180
 | doi = 10.1007/978-1-4302-0211-0
}}

== Références ==
{{Traduction/Référence|en|Next Byte Codes}}
&lt;references /&gt;


{{Palette Langages de programmation}}

{{Portail|programmation informatique|Robotique}}

[[Catégorie:Lego Mindstorms]]
[[Catégorie:Robotique]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>i8e649t364lfh8fd9bwmfknjubpxcnc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rubinius</title>
    <ns>0</ns>
    <id>5557107</id>
    <revision>
      <id>92229860</id>
      <parentid>90883540</parentid>
      <timestamp>2013-04-18T22:12:04Z</timestamp>
      <contributor>
        <username>JackBot</username>
        <id>550160</id>
      </contributor>
      <minor/>
      <comment>[[Wikipédia:Bot/Requêtes/2012/11#Identifier les liens brisés (le retour ;-))|Vérification des liens externes]] et [[Wikipédia:Bot/Requêtes/2012/12#Remplacer_les_.7B.7BCite_web.7D.7D_par_.7B.7BLien_web.7D.7D|traduction de leurs modèles]]</comment>
      <text xml:space="preserve" bytes="4769">{{Infobox Langage de programmation
| nom                             = Rubinius
| développeur                     = Evan Phoenix
| dernière version stable         = 1.2.3
| date de dernière version stable = {{Date|15|mars|2011|en informatique}}
| système d'exploitation          = [[Multiplate-forme]]
| implémentation                  = [[Ruby]] et [[C++]]
| licence                         = [[Licence BSD|BSD]] 
| site web                        = [http://rubini.us/ rubini.us]
}}

'''Rubinius''' est une implémentation de l'interpréteur du langage de programmation [[Ruby]], conçue par [[Evan Phoenix]] et implémentée principalement dans le langage Ruby lui-même. Basé largement sur les concepts du ''Blue Book'' de [[Smalltalk]]-80&lt;ref&gt;{{Ouvrage|langue= anglais |prénom1=|nom1=|lien auteur1=|titre= Smalltalk-80: The Language and its Implementation |sous-titre=|lien titre=|numéro d'édition=|lien éditeur=|éditeur=|lieu=|année=|tome=|volume=|pages totales=|isbn=|passage=|lire en ligne= http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf |consulté le=|ISBN= 0-201-11371-6 }}&lt;/ref&gt;, Rubinius vise à fournir un &quot;environnement de développement riche et de haute performance pour exécuter du code Ruby&quot;&lt;ref name=&quot;readme&quot;&gt;{{lien web|langue=en
|url=http://github.com/evanphx/rubinius/tree/master/README
|titre=Rubinius README
|éditeur=Rubinius Project
|consulté le=2009-02-22
}}&lt;/ref&gt;.
Il s'agit d'un projet [[Logiciel libre|libre]] sous licence [[Licence BSD|BSD]].

== Objectifs ==

Le projet Rubinius perpétue la tradition de [[Lisp]]&lt;ref&gt;{{lien web|langue=en
|url=http://www.se-radio.net/2008/01/episode-84-dick-gabriel-on-lisp/
|titre=Episode 84: Dick Gabriel on Lisp
|extrait='Well, you know if I took that piece of code and hand compiled it, then that could be an interpreter for Lisp.' So he did that and it surprised John McCarthy and overnight they had a running implementation of Lisp.
|consulté le=2011-05-20
|nom=Gabriel|prénom=Dick
}}&lt;/ref&gt; et Smalltalk en tentant d'implémenter autant que possible un interpréteur Ruby en Ruby ; du [[C++]] est actuellement employé lorsque l'utilisation de Ruby n'est pas possible&lt;ref&gt;{{lien web|langue=en
|url=http://blog.headius.com/2008/04/promise-and-peril-for-alternative-ruby.html
|titre=Promise and Peril for Alternative Ruby Impls
| extrait=Evan Phoenix's Rubinius project is an effort to implement Ruby using as much Ruby code as possible.
| date=2008-04-27
| nom=Nutter|prénom=Charles
| consulté le=2009-02-22
}}&lt;/ref&gt;.
Il vise également à être ''[[Programme à fil sécurisé|thread-safe]]'' afin de pouvoir embarquer plus d'un interpréteur dans une même application.


== Sponsor ==

La société [[Engine Yard]] (spécialisée en gestion et déploiement d'application [[Ruby on Rails]]) emploie deux ingénieurs à temps plein pour travailler exclusivement sur le développement de Rubinius&lt;ref&gt;{{lien web|langue=en
|url=http://antoniocangiano.com/2008/01/15/why-engine-yard-rubinius-and-merb-matter/
|titre=Why Engine Yard, Rubinius, and Merb matter
|extrait=&quot;A while ago they also hired Evan Phoenix to work full-time on Rubinius, a promising alternative Ruby implementation and a rigorous spec for the language.&quot;
| date=2008-01-15
| nom=Cangiano|prénom=Anthony
| consulté le=2009-03-08
}}&lt;/ref&gt;.

== Voir aussi ==
=== Articles connexes ===
==== Implémentations du langage Ruby ====
* [[JRuby]]
* [[MacRuby]]
* [[YARV]]
* [[IronRuby]]

==== Machines virtuelles et projets similaires ====
* [[Parrot virtual machine]]
* [[Squeak]]
* [[Squawk virtual machine|Squawk]]


=== Références ===
&lt;references /&gt;

=== Liens externes ===
* {{en}} [http://rubini.us/ Site officiel de Rubinius]
* {{en}} [http://blog.fallingsnow.net/rubinius Blog d'Evan Phoenix]
* {{en}} [http://rubyconf2007.confreaks.com/d2t1p3_rubinius.html Vidéo d'Evan Phoenix à RubyConf 2007]
* {{en}} [http://mwrc2008.confreaks.com/01phoenix.html Vidéo d'Evan Phoenix à RubyConf MountainWest 2008]
* {{en}} [http://rubyconf2008.confreaks.com/rubinius.html Présentation d'Evan Phoenix à RubyConf 2008]
* {{en}} [http://github.com/evanphx/rubinius/tree/master Dépôt du code de Rubinius]
* {{en}} [http://antoniocangiano.com/2008/12/09/the-great-ruby-shootout-december-2008/ The Great Ruby Shootout (December 2008)]: Comparaison des performances de Rubinius par rapport à d'autres machines virtuelles pour Ruby
* {{en}} {{lien brisé|consulté le=2013-04-19|url=http://isitrubinius.com/|titre=Is It Rubinius?}} - Site communautaire pour la compatibilité des gems Ruby (bibliothèques logicielles) pour Rubinius


{{Portail|programmation informatique}}

[[Catégorie:Ruby|*]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]</text>
      <sha1>mswq8jy3q9pavby3thcvh84etct3c6n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Opa</title>
    <ns>0</ns>
    <id>5561174</id>
    <revision>
      <id>90885467</id>
      <parentid>84306829</parentid>
      <timestamp>2013-03-19T15:38:24Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 3 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3353033]]</comment>
      <text xml:space="preserve" bytes="5142">{{voir homonymes|OPA}}
{{ébauche|logiciel libre}}
{{Infobox Langage de programmation
| nom                    = Opa
| logo                   = Opa-logo-orange.png
| paradigme              = [[Paradigme (programmation)|multiparadigme]] : [[Programmation impérative|impérative]], [[Programmation fonctionnelle|fonctionnelle]]
| année                  = 2010 (Première citation), 2011 (Release open source)
| auteur                 = [[MLstate]]
| dernière version stable= 1.0.5
| date de dernière version stable = {{Date|2|août|2012|en informatique}}
| typage                 = [[Typage fort|Fort]], [[Typage statique|statique]]
| implémentations        = 
| influencé par          = [[OCaml]]
| système d'exploitation = [[Linux]], [[MacOSX]], [[Windows]]
| licence                = [[Affero GPL]]
| site web               = [http://opalang.org opalang.org]
}}

'''Opa''' est un [[langage de programmation]] d'[[Application Web|applications]] et [[Service Web|services]] web utilisable sous licence [[Affero GPL]] ou sous licence privée.

== Philosophie ==
Opa est une technologie de développement d’applications Web distribuées. C’est un nouveau langage de programmation fortement couplé à une bibliothèque Web standard qui remplit toutes les fonctions : de serveur d’applications Web, à serveur de base de données.

En un mot, Opa ne dépend pas des piles serveurs actuelles, comme par exemple [[Apache HTTP Server|Apache]] plus [[PHP]] plus [[MySQL]] plus [[Symfony]]. Un code source Opa est compilé en un binaire autonome du service, qui se contente d’une distribution GNU/Linux nue (même [[MiniLinux]]) pour l’exécution.

Opa est spécialement conçu pour le Web et spécifie l’ensemble des aspects de l’application :

* le code client comme le code serveur sont écrits en Opa : le compilateur détermine automatiquement les parties client et serveur (des annotations existent pour lui forcer la main), traduit le code client en [[JavaScript]] et automatise les échanges entre client et serveur ;
* la structure de la base de données et les requêtes sont également écrites en Opa : là aussi, le compilateur analyse les requêtes pendant la compilation et génère le code d’accès aux données.

== Exemple de code ==
L'exemple ci-dessous est le code complet d'un webchat minimal en Opa.

&lt;source lang = &quot;c&quot;&gt;
/**
 * Le type des messages échangés sur la chatroom
 */
type message = 
  { author: string // Le nom de l'auteur
  ; text: string }   // Le texte du message

/**
 * Le principal &quot;objet&quot; : la room des messages
 */
@publish room = Network.cloud(&quot;room&quot;): Network.network(message)

/**
 * Mise à jour de l'interface d'un utilisateur lors de l'arrivée d'un nouveau message
 *
 * @param x Le message
 */
user_update(x: message) =
  line = &lt;div class=&quot;line&quot;&gt;
            &lt;div class=&quot;user&quot;&gt;{x.author}:&lt;/div&gt;
            &lt;div class=&quot;message&quot;&gt;{x.text}&lt;/div&gt;
         &lt;/div&gt;
  do Dom.transform([#conversation +&lt;- line ])
  Dom.scroll_to_bottom(#conversation)

/**
 * Broadcast un message sur la room
 *
 * Lit le contenu de [#entry], envoie le message à [room] puis efface [#entry].
 *
 * @param author
 */
broadcast(author) =
   do Network.broadcast({~author text=Dom.get_value(#entry)}, room)
   Dom.clear_value(#entry)

/**
 * Construit l'interface client
 *
 * Choisit aléatoirement un nom d'auteur qui sera utilisé dans le chat
 *
 * @return L'interface utilisateur, envoyée par le serveur lors de la connexion d'un client.
 */
start() =
   author = Random.string(8)
   &lt;div id=#header&gt;&lt;div id=#logo&gt;&lt;/div&gt;&lt;/div&gt;
   &lt;div id=#conversation onready={_ -&gt; Network.add_callback(user_update, room)}&gt;&lt;/div&gt;
   &lt;div id=#footer&gt;
        &lt;input id=#entry  onnewline={_ -&gt; broadcast(author)}/&gt;
        &lt;div class=&quot;button&quot; onclick={_ -&gt; broadcast(author)}&gt;Post&lt;/div&gt;
   &lt;/div&gt;

/**
 * Programme principal
 *
 * Construit une application &quot;Chat&quot; (sera également le titre de la page),
 * inclut statiquement le répertoire &quot;resources&quot; qui contient CSS et images du style
 * et appelle la fonction [start] définie précédemment dès qu'un client se connecte.
 */
server = Server.one_page_bundle(&quot;Chat&quot;,
       [@static_resource_directory(&quot;resources&quot;)],
       [&quot;resources/css.css&quot;], start)
&lt;/source&gt;

== Liens externes ==
*[http://www.infoworld.com/d/developer-world/infoworld-review-tools-rapid-web-development-297 Article comparatif de nouvelles technologies web, dont une pré-version d'Opa, sur InfoWorld ] (inscription requise)
*[http://linuxfr.org/news/opa-un-nouveau-langage-pour-le-développement-d’applications-web Discussion sur linuxfr]
*[http://www.slideshare.net/IamYoric/opa-owasp-2010 Slides de la présentation à OWASP 2010]
*[https://www.owasp.org/index.php/Opa Page du projet à OWASP]
*[https://github.com/MLstate/opalang Dépôt sur github]

{{Palette Langages de programmation}}
{{Portail|logiciels libres|programmation informatique}}

[[Catégorie:Langage de script]]
[[Catégorie:Langage pour pages Web dynamiques]]
[[Catégorie:Logiciel sous licence libre]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour Unix]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>ksthkppfojg3znhputw3g8pne7y7nko</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Averest</title>
    <ns>0</ns>
    <id>5574783</id>
    <revision>
      <id>90886601</id>
      <parentid>67243889</parentid>
      <timestamp>2013-03-19T15:49:37Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q2874223]]</comment>
      <text xml:space="preserve" bytes="691">{{Ébauche|informatique}}

'''Averest''' est un [[langage de programmation]] [[programmation synchrone|synchrone]] conçu par un groupe de l'université technique de [[Kaiserslautern]] qui permet de spécifier, vérifier et implémenter des systèmes dit [[réactif|réactifs]].
Averest contient aussi des outils qui permettent la [[Model_checking|vérification automatique de systèmes dynamiques]] ainsi qu'un [[compiler|compilateur]].

==Liens externes==
*[http://www.averest.org/ Averest Toolbox] Site officiel
*[http://es.informatik.uni-kl.de/ Embedded Systems Group] Groupe qui développe Averest Toolbox

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>mxufdfbgoev6div8zratx7mr8y68cud</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>S (langage de programmation)</title>
    <ns>0</ns>
    <id>5620659</id>
    <revision>
      <id>97020706</id>
      <parentid>97020260</parentid>
      <timestamp>2013-09-26T12:20:09Z</timestamp>
      <contributor>
        <username>Genium</username>
        <id>82916</id>
      </contributor>
      <minor/>
      <comment>lien interne</comment>
      <text xml:space="preserve" bytes="3336">{{voir homonymes|S}}
{{ébauche|informatique}}

{{Infobox Langage de programmation
|  couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
|  nom et logo                      = non
|  nom                              = S
|  logo                             = 
|  paradigmes                       = 
|  auteur                           = [[John Chambers (statisticien)|John Chambers]]
|  développeurs                     = [[Laboratoires Bell]]
|  date de première version         = Années 1975–1976
|  dernière version stable          = 
|  date de dernière version stable  = 
|  dernière version avancée         = 
|  date de dernière version avancée = 
|  typage                           = 
|  implémentations                  = 
|  normes                           =
|  dialectes                        = 
|  influencé par                    = 
|  a influencé                      = [[GNU R|R]], [[S-PLUS]]
|  système d'exploitation           = [[General Comprehensive Operating System|GCOS]], [[UNIX/32V|32/V]], [[UNIX]], [[GNU/Linux]]
|  licences                         = 
|  site web                         = 
}}
'''S'''  est un [[langage de programmation]] de très haut niveau et un environnement d'analyse des données et des graphiques conçus dans les années 1975-1976 par [[John Chambers (statisticien)|John Chambers]]. En 1998,  l'[[Association for Computing Machinery|ACM]] offre son [[Association_for_Computing_Machinery#Autres_prix_d.27excellence|prix d'excellence logicielle]]&lt;ref&gt;{{en}} [http://www.acm.org/announcements/ss99.html « Software System Award »], ''acm.org'', 23 mars 1999.&lt;/ref&gt; à John Chambers pour le « ''le système S, lequel a changé à jamais la façon dont les gens analysent, visualisent et manipulent les données ''».

Les deux interpréteurs modernes de S sont [[GNU R]] et [[S-PLUS]].

== Historique ==
Une première version du langage est distribuée par les laboratoires Bell en 1980, et le code source disponible en  1981. Les deux ouvrages publiés en 1984 et 1985 par John Chambers et  Richard Becker témoignent de la popularité du langage&lt;ref&gt;John Chambers, Richard Becker, « ''S: An Interactive Environment for Data Analysis and Graphics'' », Éditions [[Chapman &amp; Hall]], {{ISBN|053403313X}} ({{1er}} février 1984).&lt;/ref&gt;{{,}}&lt;ref&gt;John Chambers, Richard Becker, « ''Extending the S System'' », Éditions ''Chapman &amp; Hall'', {{ISBN|0534050166}} ({{1er}} juin 1985).&lt;/ref&gt;. Le code source est alors distribué par [[American Telephone &amp; Telegraph|AT&amp;T ]] selon les termes d'une [[licence de logiciel |licence]] [[logiciel propriétaire|propriétaire]]{{#tag:ref|utilisation dans l'Éducation ou à des fins commerciales.|group=note|name=&quot;Bell Labs&quot;&quot;}}.

Les [[Dépôt (informatique)|dépôts]] de l'[[Université Carnegie-Mellon]] disposent d'une quantité importante de contributions de code pour S&lt;ref name=&quot;ghm&quot;&gt;{{en}} [http://lib.stat.cmu.edu/S/ « StatLib---Software and extensions for the S (Splus) language »], ''cmu.edu'', 5 novembre 2007.&lt;/ref&gt;.

== Notes et références ==
=== Références ===
{{Références}}

=== Notes ===
&lt;references group=note/&gt;

{{Palette
| Logiciels de calcul numérique
}}
{{Portail|programmation informatique|probabilités et statistiques}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>egnc1y383ahop370c50puhsacn2ahxc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Pôle Langage de programmation de l'ACM</title>
    <ns>0</ns>
    <id>4960653</id>
    <revision>
      <id>91367292</id>
      <parentid>67793498</parentid>
      <timestamp>2013-03-27T23:14:40Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3412172]]</comment>
      <text xml:space="preserve" bytes="1902">{{ébauche|informatique}}
Le '''Pôle Langage de programmation de l'ACM''' (de l'anglais '''SIGPLAN'''&lt;ref&gt;Littéralement « '''S'''pecial '''I'''nterest '''G'''roup on '''L'''ANGUAGE ».&lt;/ref&gt;) est le [[pôle d'intérêt commun]]&lt;ref&gt;Traduction de l'anglais « ''Special interest group'' ».&lt;/ref&gt; de l'[[Association for Computing Machinery|ACM]] dans le domaine de la [[programmation informatique]].

== Conférences ==
* '''POPL''' (en anglais « ''Principles of Programming Languages'')
* '''PLDI''' (en anglais « ''Programming Language Design and Implementation'')
* '''ISMM''' (en anglais « ''International Symposium on Memory Management'')
* '''LCTES''' (en anglais « ''Languages, Compilers, and Tools for Embedded Systems'')
* '''PPoPP''' (en anglais « ''Symposium on Principles and Practice of Parallel Programming'')
* '''ICFP''' (en anglais « ''International Conference on Functional Programming'')
* '''[[OOPSLA]]''' (en anglais « ''Object-Oriented Programming, Systems, Languages, and Applications'')
* '''HOPL''' (en anglais « ''History of Programming Languages'')
* '''DLS''' (en anglais « ''Dynamic Languages Symposium'')

== Prix d'excellence ==
* 2010 : [[Chris Lattner]], pour ses travaux sur le projet [[Low Level Virtual Machine|LLVM]], une infrastructure de compilation comprenant notamment le compilateur [[Clang]]&lt;ref&gt;{{en}} [http://www.nondot.org/sabre/Resume.html Site web personnel de Chris Lattner].&lt;/ref&gt;.
* 2009 : Rod Burstall
* 2008 : [[Barbara Liskov]]
* 2007 : [[Niklaus Wirth]]
* 2002 : [[John McCarthy]]

== Notes et références ==
&lt;References/&gt;

== Lien externe ==
* {{Site officiel|en|http://www.sigplan.org/}}

{{Portail|programmation informatique|États-Unis}}

{{DEFAULTSORT:Pole Langage De Programmation De L'Acm}}
[[Catégorie:Association ou organisme des États-Unis]]
[[Catégorie:Association d'informatique]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>bhiyjqek15c1melpsok5drw7bkzhjeo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>C (langage)</title>
    <ns>0</ns>
    <id>1711</id>
    <revision>
      <id>101955269</id>
      <parentid>101955264</parentid>
      <timestamp>2014-03-10T19:53:36Z</timestamp>
      <contributor>
        <username>Titlutin</username>
        <id>1183540</id>
      </contributor>
      <comment>[[WP:LRC|LiveRC]] : Révocation des modifications de [[Special:Contributions/109.22.32.232|109.22.32.232]] (retour à la dernière version de [[User:Titlutin|Titlutin]])</comment>
      <text xml:space="preserve" bytes="41527">{{Voir homonymes|C}}
{{Infobox Langage de programmation
| nom             = C
| nom et logo     = 
| paradigme       = [[Programmation impérative|Impérative]], [[Programmation procédurale|procédurale]], structurée
| année           = [[1972]]
| auteur          = [[Dennis Ritchie]]
| développeur     = Dennis Ritchie,  [[Bell Labs]]
| typage          = [[Typage statique|Statique]], [[Typage faible|faible]]
| normes          = {{Collapsible list|ANSI X3.159-1989 (ANSI C, C89)&lt;br /&gt;ISO/CEI 9899:1990 (C90)&lt;br /&gt;ISO/IEC 9899:1994 (C94)&lt;br /&gt;ISO/CEI 9899:1999 (C99)&lt;br /&gt;ISO/IEC 9899:2011 (C11)
}}
| implémentations = [[GNU Compiler Collection|GCC]], [[Visual C++|MSVC]], [[Turbo C|Borland C]], [[Watcom C compiler|Watcom C]]
| influencé par   = [[B (langage)|B]] ([[Combined Programming Language|CPL]], [[BCPL]]), [[ALGOL|ALGOL 60]], [[Lisp]]
| a influencé     = [[awk]], [[C shell|csh]], [[C++]], [[C Sharp|C#]], [[Objective C]], [[BitC]], [[D (langage)|D]], [[Concurrent C]], [[Java (langage)|Java]], [[JavaScript]], [[PHP]], [[Perl (langage)|Perl]]
}}

Le '''C''' est un [[langage de programmation]] [[Programmation impérative|impératif]], généraliste, issu de la [[programmation système]]. Inventé au début des [[années 1970]] pour réécrire [[UNIX]], C est devenu un des langages les plus utilisés. De nombreux langages plus modernes comme [[C++]], [[Java (langage)|Java]] et [[PHP]] reprennent des aspects de C.

== Caractéristiques générales ==
C est un [[langage de programmation]] [[Programmation impérative|impératif]] et généraliste. C est qualifié de [[langage de bas niveau]] dans le sens où chaque instruction du langage est conçue pour être [[compilateur|compilée]] en un nombre d'[[langage machine|instructions machine]] assez prévisible en termes d'occupation mémoire et de charge de calcul. Il propose un éventail de [[type (informatique)|types]] [[nombre entier|entiers]] et [[nombre flottant|flottants]] conçus pour pouvoir correspondre directement aux types supportés par le [[processeur]]. Il fait en outre un usage intensif de la notion de [[pointeur (programmation)|pointeur]]. Il a une notion de [[Type_(informatique)#Types_compos.C3.A9s|type composé]], mais ne propose aucune opération qui traite directement des objets de plus haut niveau ([[fichier informatique]], [[chaîne de caractères]], [[liste (informatique)|liste]]…). Ces types plus évolués doivent être traités en manipulant des pointeurs et des types composés. De même, le langage ne propose pas en standard la gestion de la [[programmation orientée objet]], ni de [[système de gestion d'exceptions]]. Il existe des fonctions standards pour gérer les [[entrées-sorties]] et les [[chaînes de caractères]], mais contrairement à d'autres langages, aucun [[opérateur (informatique)|opérateur]] spécifique pour améliorer l'ergonomie. Ceci rend aisé le remplacement des fonctions standards par des fonctions spécifiquement conçues pour un programme donné.

Ces caractéristiques en font un langage privilégié quand on cherche à maîtriser les ressources utilisées, le [[langage machine]] généré par les compilateurs étant relativement prévisible et parfois même [[Optimisation du code|optimal]] sur les machines d'architecture [[Reduced instruction set computer|RISC]] à grand nombre de registres. Ce langage est donc extrêmement utilisé dans des domaines comme la programmation embarquée sur [[microcontrôleur]]s, les calculs intensifs, l'écriture de systèmes d'exploitation et tous les modules où la rapidité de traitement est importante. Il constitue une bonne alternative au [[langage d'assemblage]] dans ces domaines, avec les avantages d'une syntaxe plus expressive et de la portabilité du [[code source]]. Le langage C a été inventé pour écrire le [[système d'exploitation]] [[UNIX]], et reste utilisé pour la programmation système. Ainsi le [[noyau de système d'exploitation|noyau de grands systèmes d'exploitation]] comme [[Windows]] et [[Linux]] sont développés en grande partie en C.

En contrepartie, la mise au point de programmes en C, surtout s'ils utilisent des structures de données complexes, est plus difficile qu'avec des langages de plus haut niveau. En effet, dans un souci de performance, le langage C impose à l'utilisateur de programmer certains traitements (libération de la mémoire, vérification de la validité des indices sur les tableaux…) qui sont pris en charge automatiquement dans les langages de haut niveau.

Dépouillé des commodités apportées par sa bibliothèque standard, C est un langage simple, et son [[compilateur]] l'est également. Cela se ressent au niveau du temps de développement d'un compilateur C pour une nouvelle [[architecture de processeur]] : Kernighan et Ritchie estimaient qu'il pouvait être développé en deux mois car {{citation|on s'apercevra que les 80 % du code d'un nouveau compilateur sont identiques à ceux des codes des autres compilateurs existant déjà.}}&lt;ref&gt;{{K&amp;R|1re éd}}, {{p.}}4&lt;/ref&gt;.

=== Qualités et défauts ===
C'est un des langages les plus utilisés car :
* il existe depuis le début des [[années 1970]], il est fondé sur un [[format ouvert|standard ouvert]], de nombreux informaticiens le connaissent, des [[compilateur]]s et [[bibliothèque logicielle|bibliothèques logicielles]] existent sur la plupart des [[Architecture matérielle|architectures]] ;
* il a influencé de nombreux langages plus récents dont [[C++]], [[Java (langage)|Java]] et [[PHP]], sa [[syntaxe]] en particulier est largement reprise ;
* il met en œuvre un nombre restreint de concepts, ce qui facilite sa maîtrise et l'écriture de compilateurs simples et rapides ;
* il ne spécifie pas rigidement le comportement du [[fichier exécutable]] produit, ce qui aide à tirer parti des capacités propres à chaque [[ordinateur]] ;
* il permet l'écriture de logiciels qui n'ont besoin d'aucun support à l'exécution (ni [[bibliothèque logicielle]] ni [[machine virtuelle]]), au comportement prédictible en temps d'exécution comme en consommation de [[mémoire vive]], comme des [[noyau de système d'exploitation|noyaux de système d'exploitation]] et des [[informatique embarquée|logiciels embarqués]].

Ses principaux inconvénients sont :
* la première version du langage (K&amp;amp;R C) offre particulièrement peu de vérifications lors de la compilation, et il n'offre aucune vérification pendant l'exécution, ce qui fait que des erreurs qui pourraient être automatiquement détectées lors du développement ne le sont que plus tard, souvent au prix d'un plantage du logiciel ;
* son approche de la modularité est inaboutie ;
* il ne facilite pas le développement de concepts informatiques plus récents comme la [[programmation orientée objet]] ou la [[gestion d'exceptions]] qui exigent un effort de rigueur supplémentaire de la part du développeur ;
* il est difficile d'écrire des programmes [[portabilité (informatique)|portables]] car le comportement exact des exécutables dépend de l'ordinateur cible ;
* le support de l'[[allocation de mémoire]] et des [[chaînes de caractères]] est minimaliste, ce qui oblige les programmeurs à s'occuper de détails fastidieux et sources de [[Bug informatique|bugs]] ; il n'y a notamment pas de [[ramasse-miettes (informatique)|ramasse-miettes]] standard ;
* des bugs communs comme le [[débordement de tampon]] constituent une [[faille de sécurité informatique]] et peuvent être [[exploit (informatique)|exploités]] par des [[Logiciel malveillant|logiciels malveillants]] si le développeur ne fait pas attention ;
* plusieurs genres d'erreurs ne peuvent être détectées automatiquement qu'à l'aide d'outils supplémentaires et non standardisés, comme ''[[Lint (logiciel)|lint]]'' puis ''splint''.

== Histoire ==

[[Fichier:Ken n dennis.jpg|thumb|[[Kenneth Thompson]] (à gauche) et [[Dennis Ritchie]] (à droite).]]

Le langage C est apparu au cours de l'année [[1972 en informatique|1972]] dans les [[Laboratoires Bell]]. Il était développé en même temps que [[UNIX]] par [[Dennis Ritchie]] et [[Ken Thompson]]. Ken Thompson avait développé un prédécesseur de C, le [[langage B]], qui est lui-même inspiré de [[BCPL]]. Dennis Ritchie a fait évoluer le langage B dans une nouvelle version suffisamment différente pour qu'elle soit appelée C. Par la suite, [[Brian Kernighan]] aida à populariser le langage. Il procéda aussi à quelques modifications de dernière minute. En [[1978 en informatique|1978]], il fut notamment le principal auteur du livre {{lang|en|''[[The C Programming Language]]''}} décrivant le langage enfin stabilisé ; Ritchie s'était occupé des appendices et des exemples avec Unix. On parle encore de '''C K&amp;amp;R''', '''''{{Lang|en|K&amp;amp;R C}}''''' en anglais (pour {{lang|en|''Kernighan and Ritchie C''}}) lorsqu'on se réfère au langage tel qu'il existait à cette époque.
=== Influences subies ===
Bien que C soit officiellement inspiré de B et de BCPL, on note une forte influence de [[PL/1]] (ou de PL360) ; on a pu dire que C était à Unix et au [[PDP11]] ce que PL1 fut pour la réécriture de [[Multics]].

Par ailleurs, l'expression conditionnelle semble directement inspirée de [[Lisp]] ou d'[[Algol 60]].

=== Normalisations ===

Inventé au début des [[années 1970]], le langage a été complètement décrit pour la première fois en [[1978 en informatique|1978]] dans le livre ''The C Programming Language'' de [[Brian Kernighan]] et [[Dennis Ritchie]]. On appelle généralement '''C traditionnel''' ou '''K&amp;amp;R C''' ce premier langage.

En [[1983 en informatique|1983]], l'[[American National Standards Institute|Institut national américain de normalisation]] (ANSI) a formé un comité de normalisation du langage qui a abouti en [[1989 en informatique|1989]] à la norme dite '''ANSI C''' ou '''C89''' (formellement ANSI X3.159-1989). En [[1990 en informatique|1990]], cette norme a également été adoptée par l'[[Organisation internationale de normalisation]] ('''C ISO''', formellement ISO/CEI 9899:1990). ANSI C est une évolution du C K&amp;amp;R qui reste extrêmement compatible. Elle reprend quelques idées de [[C++]].

En [[1995 en informatique|1995]], le groupe de travail de l'ISO a publié deux correctif et un amendement à C89. Ces changements assez modestes sont parfois appelés C89 avec amendement 1, ou C94 / C95&lt;ref&gt;{{en}}, Samuel P. Harbison III, Guy L. Steel Jr., ''A Reference Manual, fifth edition'', Upper Saddle River, Prentice Hall, 2002, p. 4, {{isbn|0-13-089592-X}}&lt;/ref&gt;{{,}}&lt;ref&gt;{{en}}, Thomas Wolf, ''The New ISO Standard for C (C9X), 2000''&lt;/ref&gt;. Trois fichiers d'entêtes ont été ajoutés, dont deux concernant les caractères larges et un autre définissant un certain nombre de macros en rapport avec la norme [[ISO 646]].

En [[1999 en informatique|1999]], une nouvelle évolution du langage est normalisée par l'[[Organisation internationale de normalisation|ISO]] : '''C99''' (formellement ISO/CEI 9899:1999). Parmi les ajouts, on notera du côté syntaxe des fonctionnalités (types [[nombre complexe|complexes]], mot-clef « restrict », directives agissant sur la simplification des instructions arithmétiques) souhaitables pour les calculs numériques intensifs, domaine habituel de [[Fortran]] ; ou encore le mélange des déclarations avec le reste du code. Au niveau de la sémantique, la gestion des tableaux dynamiques, ou encore des pointeurs restreints a été ajoutée. La [[Bibliothèque standard de C|bibliothèque standard]] du C99 s'est vue enrichir de six fichiers d'entêtes depuis la précédente norme.

En [[2011 en informatique|2011]], l'[[Organisation internationale de normalisation|ISO]] ratifie une nouvelle version&lt;ref&gt;http://www.iso.org/iso/fr/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=57853&lt;/ref&gt; du standard : '''C11''', formellement ISO/IEC 9899:2011.

== Éléments du langage ==

=== Sources ===
L'usage est de donner l'[[extension de nom de fichier]] &lt;code&gt;.c&lt;/code&gt; aux fichiers source C. En outre, des fichiers permettant de partager les interfaces, portent le même nom, avec l'extension (suffixe) &lt;code&gt;.h&lt;/code&gt; (''h'' pour ''header'' en anglais, soit ''en-tête'' en français). Chaque fichier &lt;code&gt;.c&lt;/code&gt; est compilé séparément.
Les rôles des fichiers &lt;code&gt;.c&lt;/code&gt; et &lt;code&gt;.h&lt;/code&gt; sont répartis ainsi :
* Les fichiers &lt;code&gt;.c&lt;/code&gt; contiennent l'implémentation des fonctions et variables globales.
* Les fichiers &lt;code&gt;.h&lt;/code&gt; contiennent uniquement des déclarations de type, de fonctions, de macros, de variables globales, etc.
* Lorsqu'un fichier &lt;code&gt;.c&lt;/code&gt; ou &lt;code&gt;.h&lt;/code&gt; utilise un identificateur déclaré dans un autre fichier &lt;code&gt;.h&lt;/code&gt;, alors il inclut ce dernier fichier.
* Le principe généralement appliqué consiste à écrire un fichier &lt;code&gt;.h&lt;/code&gt; pour chaque fichier &lt;code&gt;.c&lt;/code&gt;, et à déclarer dans le fichier &lt;code&gt;.h&lt;/code&gt; tout ce qui est exporté du fichier &lt;code&gt;.c&lt;/code&gt;.

=== Syntaxe ===
La syntaxe de C a été conçue pour être brève. Historiquement, elle a souvent été comparée à celle de [[Pascal (langage)|Pascal]], langage impératif également créé dans les [[années 1970]]. Voici un exemple avec une [[fonction (informatique)|fonction]] [[factorielle]] :
&lt;source lang=&quot;c&quot;&gt;
/* En C (norme ISO) */
int factorielle(int n)
{
	if (n &gt; 1) return n * factorielle(n - 1);
	else return 1;
}
&lt;/source&gt;
&lt;source lang=&quot;pascal&quot;&gt;
{ En Pascal }
function factorielle(n: integer) : integer
begin
	if n &gt; 1 then factorielle := n * factorielle(n - 1)
	else factorielle := 1
end.
&lt;/source&gt;

Là où Pascal utilise des mots clés comme &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt; et &lt;code&gt;then&lt;/code&gt;, C utilise des [[parenthèse]]s et [[accolade]]s.

==== {{lang|en|''Hello world''}} ====

Programme {{lang|en|''[[Hello world]]''}} proposé en exemple en [[1978]] dans {{lang|en|''The C Programming Language''}} de [[Brian W. Kernighan]] et [[Dennis M. Ritchie]] :
&lt;source lang=&quot;c&quot;&gt;
#include &lt;stdio.h&gt;
main()
{
    printf(&quot;hello, world\n&quot;);
}&lt;/source&gt;

Le même programme, conformément à la norme ISO :
&lt;source lang=&quot;c&quot;&gt;
#include &lt;stdio.h&gt;
int main(void)
{
    printf(&quot;hello, world\n&quot;);
    return 0;
}
&lt;/source&gt;

* &lt;code&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/code&gt; inclut l'[[Bibliothèque standard de C#Les en-têtes de la bibliothèque C ISO|en-tête standard]] &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;, contenant les déclarations des fonctions d'entrée-sortie de la [[bibliothèque standard de C]].
* &lt;code&gt;main&lt;/code&gt; est le nom de la [[Fonction (informatique)|fonction]] principale, aussi appelée [[point d'entrée]] du programme.
* &lt;code&gt;int&lt;/code&gt; est le [[Type (informatique)|type]] renvoyé par la fonction &lt;code&gt;main&lt;/code&gt;. Le type &lt;code&gt;int&lt;/code&gt; est implicite en K&amp;R C et en C89, mais plus en C99.
* Le mot clé &lt;code&gt;void&lt;/code&gt; entre les parenthèses signifie que la fonction &lt;code&gt;main&lt;/code&gt; ne prend aucun [[paramètre]].
* Les accolades &lt;code&gt;{&lt;/code&gt; et &lt;code&gt;}&lt;/code&gt; entourent les [[Instruction informatique|instructions]] constituant le [[Corps d'une fonction ou d'une procédure|corps de la fonction]] &lt;code&gt;main&lt;/code&gt;.
* &lt;code&gt;[[printf]]&lt;/code&gt; est une fonction d'écriture dans la sortie standard (la console par défaut).
* Le caractère &lt;code&gt;&quot;&lt;/code&gt; délimite une [[chaîne de caractères]] ; &lt;code&gt;&quot;hello, world\n&quot;&lt;/code&gt; dans ce cas.
* Un point-virgule &lt;code&gt;;&lt;/code&gt; termine toute instruction.
* L'instruction &lt;code&gt;return 0;&lt;/code&gt; indique que la fonction retourne la valeur 0.

Créer un programme affichant {{lang|en|''Hello World''}} est depuis devenu l'exemple de référence pour présenter les bases d'un nouveau langage.

=== Mots clés ===

&lt;code&gt;auto&lt;/code&gt;, &lt;code&gt;break&lt;/code&gt;, &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt; (C89), &lt;code&gt;continue&lt;/code&gt;, &lt;code&gt;default&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt; (C89), &lt;code&gt;extern&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt; (C99), &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;register&lt;/code&gt;, &lt;code&gt;restrict&lt;/code&gt; (C99), &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;signed&lt;/code&gt; (C89), &lt;code&gt;sizeof&lt;/code&gt;, &lt;code&gt;static&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;typedef&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, &lt;code&gt;unsigned&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt; (C89), &lt;code&gt;volatile&lt;/code&gt; (C89), &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;_Bool&lt;/code&gt; (C99), &lt;code&gt;_Complex&lt;/code&gt; (C99),
&lt;code&gt;_Imaginary&lt;/code&gt; (C99)&lt;ref&gt;{{Lien web
|url=http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf
|titre=ISO/IEC 9899:TC3, Section 6.4.1: Keywords
|éditeur=[[International Organization for Standardization]] JTC1/SC22/WG14
|date=2007-09-07
}}&lt;/ref&gt;.

Les termes ci-dessus sont réservés pour être exploités en tant que mots clés, et ne doivent pas être utilisés autrement.

=== Instructions du préprocesseur ===

&lt;code&gt;#include&lt;/code&gt;,
&lt;code&gt;#define&lt;/code&gt;,
&lt;code&gt;#pragma&lt;/code&gt; (C89),
&lt;code&gt;#if&lt;/code&gt;,
&lt;code&gt;#ifdef&lt;/code&gt;,
&lt;code&gt;#ifndef&lt;/code&gt;,
&lt;code&gt;#elif&lt;/code&gt; (C89),
&lt;code&gt;#else&lt;/code&gt;,
&lt;code&gt;#endif&lt;/code&gt;,
&lt;code&gt;#undef&lt;/code&gt;,
&lt;code&gt;#line&lt;/code&gt;,
&lt;code&gt;#error&lt;/code&gt;.

=== Types ===

Le langage C comprend de nombreux [[Type (informatique)|types]] de  [[nombre entier|nombres entiers]], occupant plus ou moins de [[bit]]s. La taille des types n'est que partiellement standardisée : le standard fixe uniquement une taille minimale et une magnitude minimale. Les magnitudes minimales sont compatibles avec d'autres représentations [[système binaire|binaires]] que le [[complément à deux]], bien que cette représentation soit presque toujours utilisée en pratique. Cette souplesse permet au langage d'être efficacement adapté à des [[processeur]]s très variés, mais elle complique la [[Portabilité (informatique)|portabilité]] des programmes écrits en C.

Chaque type entier a une forme « signée » pouvant représenter des nombres négatifs et positifs, et une forme « non signée » ne pouvant représenter que des [[nombre naturel|nombres naturels]]. Le type &lt;code&gt;char&lt;/code&gt;, généralement utilisé pour représenter un caractère, est un type entier comme les autres, si ce n'est que, selon l'implémentation, il équivaut à &lt;code&gt;signed char&lt;/code&gt; ou à &lt;code&gt;unsigned char&lt;/code&gt;.

{| class=&quot;wikitable&quot;
|+ Types entiers, en ordre croissant
! scope=&quot;col&quot; | Type !! scope=&quot;col&quot; | Taille !! scope=&quot;col&quot; | Magnitude ''signed''&lt;br /&gt;(magnitude ''minimale'' exigée par le standard&lt;ref name=&quot;5.2.4.2.1&quot;&gt;« Sizes of integer types », ''ISO-IEC 9899'', 5.2.4.2.1&lt;/ref&gt;) !! scope=&quot;col&quot; | Magnitude ''unsigned''&lt;br /&gt;(magnitude ''minimale'' exigée par le standard&lt;ref name=&quot;5.2.4.2.1&quot; /&gt;)
|-
|&lt;code&gt;[[Caractère (informatique)|char]]&lt;/code&gt;,&lt;br /&gt; &lt;code&gt;unsigned char&lt;/code&gt;,&lt;br /&gt; &lt;code&gt;signed char&lt;/code&gt; (C89)
| ≥ {{unité|8|bits}} || -127 à 127 || 0 à 255 (0xFF en [[hexadécimal]] noté avec le préfixe &lt;code&gt;0x&lt;/code&gt; de la syntaxe de C)
|-
| &lt;code&gt;short&lt;/code&gt; (identique à &lt;code&gt;signed short&lt;/code&gt;),&lt;br /&gt; &lt;code&gt;unsigned short&lt;/code&gt;
| ≥ {{unité|16|bits}} || {{formatnum:-32767}} à {{formatnum:+32767}} || 0 à {{formatnum:65535}} (0xFFFF)
|-
| &lt;code&gt;[[Entier (informatique)|int]]&lt;/code&gt; (identique à &lt;code&gt;signed int&lt;/code&gt;),&lt;br /&gt; &lt;code&gt;unsigned int&lt;/code&gt;
| ≥ 16 bits (taille d'un [[mot machine]]) || {{formatnum:-32767}} à {{formatnum:+32767}} || 0 à {{formatnum:65535}} (0xFFFF)
|-
| &lt;code&gt;{{lien |lang=en |trad=Long integer |texte=long}}&lt;/code&gt; (identique à &lt;code&gt;signed long&lt;/code&gt;),&lt;br /&gt; &lt;code&gt;unsigned long&lt;/code&gt;
| ≥ {{unité|32|bits}} || {{formatnum:-2147483647}} à {{formatnum:+2147483647}} || 0 à {{formatnum:4294967295}} (0xFFFFFFFF)
|-
| &lt;code&gt;long long&lt;/code&gt; (identique à &lt;code&gt;signed long long&lt;/code&gt;),&lt;br /&gt; &lt;code&gt;unsigned long long&lt;/code&gt; (C99)
| ≥ {{unité|64|bits}} || {{formatnum:-9223372036854775807}} à {{formatnum:+9223372036854775807}} || 0 à {{formatnum:18446744073709551615}} (0xFFFFFFFFFFFFFFF)
|}
Le type &lt;code&gt;enum&lt;/code&gt; est un [[type énuméré]].

Il existe des types de nombres à [[virgule flottante]], de précision, donc de longueur en bits, variable ; en ordre croissant :
{| class=&quot;wikitable&quot;
|+ Types décimaux, en ordre croissant
! scope=&quot;col&quot; | Type !! scope=&quot;col&quot; | Précision !! scope=&quot;col&quot; | Magnitude
|-
| &lt;code&gt;float&lt;/code&gt;
| ≥ 6 chiffres décimaux || environ 10{{exp|-37}} à 10&lt;sup&gt;+37&lt;/sup&gt;
|-
| &lt;code&gt;double&lt;/code&gt;
| ≥ 10 chiffres décimaux || environ 10{{exp|-37}} à 10&lt;sup&gt;+37&lt;/sup&gt;
|-
| &lt;code&gt;long double&lt;/code&gt;
| ≥ 10 chiffres décimaux || environ 10{{exp|-37}} à 10&lt;sup&gt;+37&lt;/sup&gt;
|-
| &lt;code&gt;long double&lt;/code&gt; (C89)
| ≥ 10 chiffres décimaux ||
|}

C99 a ajouté &lt;code&gt;float complex&lt;/code&gt;, &lt;code&gt;double complex&lt;/code&gt; et &lt;code&gt;long double complex&lt;/code&gt;, représentant les [[Nombre complexe|nombres complexes]] associés.

Types élaborés :
* &lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;union&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; pour les pointeurs ;
* &lt;code&gt;[&lt;/code&gt; … &lt;code&gt;]&lt;/code&gt; pour les tableaux ;
* &lt;code&gt;(&lt;/code&gt; … &lt;code&gt;)&lt;/code&gt; pour les fonctions.

Les versions du langage antérieures à C99 ne proposent pas de type booléen, mais il est possible d'en définir un :
&lt;source lang=&quot;C&quot;&gt;
enum boolean {false, true};
typedef enum boolean bool;
&lt;/source&gt;
ou, en version condensée :
&lt;source lang=&quot;C&quot;&gt;
typedef enum boolean {false, true} bool;
&lt;/source&gt;

C99 ajoute le type _Bool.

=== Commentaire ===

Dans les versions de C antérieures à C99, les commentaires devaient commencer par une [[barre oblique]] et un [[astérisque]] (« /* ») et se terminer par un astérisque et une barre oblique. Tout ce qui est compris entre ces symboles est du commentaire, saut de ligne compris :

&lt;source lang=&quot;c&quot;&gt;/* Ceci est un commentaire
   sur deux lignes 
   ou plus */&lt;/source&gt;

La norme C99 a ajouté la possibilité de faire des commentaires sur une seule ligne, de la même manière qu’en C++ :

&lt;source lang=&quot;c&quot;&gt;// Commentaire comme en C++, valable jusqu'à la fin de la ligne&lt;/source&gt;

=== Structures de contrôle ===

La syntaxe des différentes [[Structure de contrôle|structures de contrôle]] existantes en C est largement reprise dans plusieurs autres langages, comme le C++ bien sûr, mais également [[Java (langage)|Java]], [[C Sharp|C#]], [[PHP]] ou encore [[JavaScript]].

Les trois grands types de structures sont présents :
* les tests (également appelés branchements conditionnels) avec :
** &lt;code&gt;if (&lt;var&gt;expression&lt;/var&gt;) &lt;var&gt;instruction&lt;/var&gt; else if (&lt;var&gt;expression&lt;/var&gt;) &lt;var&gt;instruction&lt;/var&gt; else &lt;var&gt;instruction&lt;/var&gt;&lt;/code&gt;
** &lt;code&gt;switch (&lt;var&gt;expression&lt;/var&gt;) &lt;var&gt;instruction&lt;/var&gt;&lt;/code&gt;, avec &lt;code&gt;case&lt;/code&gt; et &lt;code&gt;default&lt;/code&gt; dans l'instruction
* les boucles avec :
** &lt;code&gt;while (&lt;var&gt;expression&lt;/var&gt;) instruction&lt;/code&gt;
** &lt;code&gt;for (&lt;var&gt;expression_optionnelle&lt;/var&gt; ; &lt;var&gt;expression_optionnelle&lt;/var&gt; ; &lt;var&gt;expression_optionnelle&lt;/var&gt;) &lt;var&gt;instruction&lt;/var&gt;&lt;/code&gt;
** &lt;code&gt;do &lt;var&gt;instruction&lt;/var&gt; while (&lt;var&gt;expression&lt;/var&gt;)&lt;/code&gt;
* les sauts (branchements inconditionnels) :
** &lt;code&gt;break&lt;/code&gt;
** &lt;code&gt;continue&lt;/code&gt;
** &lt;code&gt;return &lt;var&gt;expression_optionnelle&lt;/var&gt;&lt;/code&gt;
** &lt;code&gt;[[goto]] &lt;var&gt;étiquette&lt;/var&gt;&lt;/code&gt;

=== Comportements ambigus ===
La norme du langage C laisse la définition exacte du comportement de plusieurs opérations au choix du concepteur du compilateur. Ces comportements sont donc définis par l'implémentation. Cette propriété de C permet au compilateur d'utiliser directement les instructions proposées par le [[processeur]], donc de compiler des programmes exécutables courts et efficaces. En contrepartie, c'est parfois la cause de [[Bug informatique|bugs]] de [[portabilité (informatique)|portabilité]] des [[code source|codes source]] écrits en C. Prenons pour exemple&lt;ref&gt;donné dans {{lang|en|''Computer Architecture, a Quantitative Approach''}}, {{2e}} édition, de [[David A. Patterson]] et [[John L. Hennessy]], {{lang|en|Appendix}} A-12&lt;/ref&gt; la division entière d'un nombre négatif : -5 / 3. Alors que [[Fortran]], [[Pascal (langage)|Pascal]] et [[Ada (langage)|Ada]] spécifient un résultat de -1, et que [[Modula-3]] spécifie un résultat de -2, C&lt;ref&gt;La révision en 1999 de la norme spécifie explicitement que le résultat soit -1 [6.5.5 alinéa 6].&lt;/ref&gt; garantit simplement que la valeur absolue du reste est strictement inférieure à la valeur absolue du diviseur&lt;ref&gt;{{K&amp;R|2nd Ed}}, {{p.}}205&lt;/ref&gt;. La seule garantie dans cet exemple est donc que le résultat sera compris entre -2 et -1.

Pour le programmeur et l'efficacité de C, le plus important est sans doute le fait que les tailles des [[types de données]] de base ne doivent respecter que des ''garanties minimales''. Ainsi, le type &lt;code&gt;int&lt;/code&gt; correspondant au [[mot machine]] peut avoir une taille de {{unité|16|[[bit]]s}} sur un [[processeur]] {{unité|16|bits}} et une taille de {{unité|64|bits}} sur un processeur {{unité|64|bits}}.

Outre les comportements laissés au choix de l'implémentation, des constructions syntaxiquement valables ont un comportement lors de l'exécution complètement indéfini. En plus de la classique [[division par zéro]], on peut signaler l'affectation multiple d'une variable dans la même expression, avec l'exemple&lt;ref&gt;{{en}} [http://c-faq.com/expr/ieqiplusplus.html comp.lang.c FAQ list · Question 3.3]&lt;/ref&gt; :
&lt;source lang=&quot;c&quot;&gt;
 i = i++; /* Comportement indéfini. */
&lt;/source&gt;
Les meilleurs compilateurs décèlent certaines constructions problématiques et peuvent les signaler, mais aucun ne prétend à l'exhaustivité.

== Bibliothèques logicielles ==
=== La bibliothèque standard ===

{{Article détaillé|Bibliothèque standard du C}}

La [[bibliothèque standard]] normalisée, disponible avec toutes les implémentations, présente la simplicité liée à un langage bas-niveau. Voici une liste de quelques en-têtes déclarant des types et fonctions de la bibliothèque standard :
* [[Assert.h|&lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;]] : pour un diagnostic de conception lors de l'exécution (&lt;code&gt;assert&lt;/code&gt;)
* &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; : tests et classification des caractères (&lt;code&gt;isalnum&lt;/code&gt;, &lt;code&gt;tolower&lt;/code&gt;)
* &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; : gestion minimale des erreurs (déclaration de la variable &lt;code&gt;errno&lt;/code&gt;)
* &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; : fonctions mathématiques de base (&lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;) ; nombreux ajouts en C99
* &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; : gestion des signaux (&lt;code&gt;signal&lt;/code&gt; et &lt;code&gt;raise&lt;/code&gt;)
* &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; : définitions générales (déclaration de la constante &lt;code&gt;NULL&lt;/code&gt;)
* [[Stdio.h|&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;]] : pour les entrées/sorties de base (&lt;code&gt;[[printf]]&lt;/code&gt;, &lt;code&gt;scanf&lt;/code&gt;)
* &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; : fonctions générales (&lt;code&gt;[[malloc]]&lt;/code&gt;, &lt;code&gt;rand&lt;/code&gt;)
* [[String.h|&lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;]] : manipulation des chaînes de caractères (&lt;code&gt;strcmp&lt;/code&gt;, &lt;code&gt;strlen&lt;/code&gt;)
* [[Time.h|&lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;]] : manipulation du temps (&lt;code&gt;time&lt;/code&gt;, &lt;code&gt;ctime&lt;/code&gt;)

La bibliothèque standard normalisée n'offre aucun support de l'[[interface graphique]], du réseau, des entrées/sorties sur port série ou parallèle, des [[Système temps réel|systèmes temps réel]], des processus ou des {{lang|en|''threads''}}, ou encore de la gestion avancée des erreurs (comme avec des [[Système de gestion d'exceptions|exceptions]] structurées). Cela pourrait restreindre d'autant la portabilité pratique des programmes qui ont besoin de faire appel à certaines de ces fonctionnalités, sans l'existence de très nombreuses bibliothèques portables et palliant ce manque ; dans le monde [[UNIX]], ce besoin a aussi fait émerger une autre norme, [[POSIX]].1.

=== Les bibliothèques externes ===
Le langage C étant un des langages les plus utilisés en programmation, de nombreuses bibliothèques ont été créées pour être utilisées avec le C. Fréquemment, lors de l'invention d'un [[format de données]], une bibliothèque ou un logiciel de référence en C existe pour manipuler le format. C'est le cas pour [[libjpeg]], [[libpng]], [[Expat (XML)|Expat]], les décodeur de référence [[MPEG]], libsocket etc.

== Des sources à l'exécutable ==

La génération d'un [[Fichier exécutable|exécutable]], à partir des fichiers sources se fait en plusieurs étapes, qui sont souvent automatisées à l'aide d'outils comme [[make]], [[SCons]] (écrit en [[Python (langage)|Python]]), ou bien des outils spécifiques à l'[[environnement de développement intégré]] (IDE) utilisé.

Les étapes menant des sources au fichier exécutable sont au nombre de quatre : précompilation, compilation, assemblage, édition de liens.

=== Précompilation ===

Durant cette étape, le [[préprocesseur]] effectue plusieurs opérations sur les fichiers sources, en suivant des instructions incluses dans les fichiers eux-mêmes. Le préprocesseur produit alors des fichiers intermédiaires (qui ont généralement l'extension « .i ») pour chaque fichier source, qui seront utilisés dans l'étape suivante.

Le préprocesseur effectue des remplacements de textes, des inclusions de fichiers (généralement les fichiers d'en-têtes contenant diverses déclarations) avec la possibilité d'effectuer certaines opérations uniquement si certaines conditions sont remplies. C'est également durant cette étape que les commentaires sont supprimés.

=== Compilation ===
{{Article détaillé|Compilateur}}

La phase de compilation consiste généralement en la [[Génération de code natif|génération du code]] [[assembleur]] (encore lisible par un être humain, mais dépendant du processeur). Pour chaque [[fichier source]], on obtient un fichier en langage d'assemblage.

Cette étape est divisée en trois sous-étapes, qui sont :
* l'[[analyse lexicale]], qui est la reconnaissance des mots clés du langage
* l'[[analyse syntaxique]], qui analyse la structure du programme et sa conformité avec la norme
* l'écriture d'un code isomorphe à celui de l'assembleur (et parfois du code assembleur lui-même quand cela est demandé en option du compilateur)

Par abus de langage, on appelle compilation toute la phase de génération d'un [[fichier exécutable]] à partir des fichiers sources. Mais c'est seulement une des étapes menant à la création d'un exécutable.

Certains compilateurs C fonctionnent à ce niveau en deux phases, la première générant un fichier compilé dans un langage intermédiaire destiné à une machine virtuelle idéale (voir [[P-Code]]) portable d'une plate-forme à l'autre, la seconde convertissant le langage intermédiaire en langage d'assemblage dépendant du processeur utilisé sur la plate-forme cible.

D'autres compilateurs C permettent de ne pas générer de langage d'assemblage, mais seulement le fichier compilé en [[langage intermédiaire]], qui sera interprété ou compilé automatiquement en code natif à l'exécution sur la machine cible (par une [[machine virtuelle]] qui sera liée au programme final).

=== Assemblage ===

Cette étape consiste en la génération d'un fichier ''objet'' pour chaque fichier de code assembleur. Ces fichiers ''objet'' sont en [[langage machine]]. C'est un format binaire, dépendant du processeur. Les fichiers objets sont généralement d’extension « .o » sous Unix ou Linux, ou « .obj » avec les outils de développement pour plates-formes ''Microsoft'', ''Intel'', ''Digital'', ''IBM'' : DOS, Windows, VMS, CP/M… où les extensions se présentent usuellement sous la forme de trois caractères.

Cette phase est parfois regroupée avec la précédente (par établissement d'un flux de données interne sans passer par des fichiers en langage intermédiaire ou langage d'assemblage), dans ce cas le compilateur génère directement un fichier objet binaire.

Pour les compilateurs qui génèrent du code intermédiaire, cette phase d'assemblage peut aussi être totalement supprimée : c'est la machine virtuelle (liée au programme final, ou utilisée séparément comme chargeur du programme à exécuter sur une machine virtuelle partagée et optimisée spécialement sur la machine hôte) qui interprétera ou compilera ce langage en code machine natif directement sur la machine hôte. Dans ce cas, la machine virtuelle qui interprète le langage intermédiaire ou le compile en code natif optimisé pour la machine hôte, peut être un composant du système d'exploitation ou une [[Bibliothèque (logicielle)|bibliothèque]] partagée installée sur celui-ci, et cette machine virtuelle ne sera même pas incluse dans le programme final livrable.

=== Édition de liens ===

L'édition de liens est la dernière étape et a pour but de réunir tous les éléments d'un programme. Les différents fichiers objets sont alors réunis, ainsi que les bibliothèques statiques, pour ne produire qu'un fichier exécutable.

Le but de l'édition de liens est de sélectionner les éléments de code utiles présents dans un ensemble de codes compilés et de bibliothèques, et de résoudre les références mutuelles entre ces différents éléments afin de permettre à ceux-ci de se référencer directement à l'exécution du programme.

=== Optimiseurs ===

Des essais de comparaison entre le C et l'assembleur effectués depuis [[1990 en informatique|1990]] sur des machines [[Reduced instruction set computer|RISC]] montrent, de façon tout à fait contre-intuitive, un net avantage au C lorsque toutes les options d'optimisation du compilateur sont activées. Les optimiseurs construisent en effet un [[graphe chromatique]] qui leur permet d'allouer sans se tromper les usages de registres de façon quasi-optimale, là où un programmeur serait vite perdu. Ils regroupent de plus directement les instructions en réarrangeant les chargements et sauvegardes de registres pour bénéficier de l'effet {{lang|en|''[[pipeline (informatique)|pipeline]]''}}. La même opération effectuée sur un programme source serait envisageable, mais le rendrait quasi impossible ensuite à maintenir.

En revanche, les optimiseurs ont moins de latitude concernant la réorganisation d'instructions [[Complex instruction set computer|CISC]], plus complexes, et dans ce cas précis les résultats sont moins tranchés.

=== Environnements de développement ===
{{Article détaillé|Environnement de développement intégré}}

== Exemples ==

Voici quelques exemples présentant très succinctement quelques propriétés du C. Pour plus d'information, voir le [[b:Programmation C|WikiLivre &quot;Programmation C&quot;]].

=== Chaînes de caractères ===

Voici l'exemple de fonction de copie de [[chaîne de caractères]] donné dans ''The C Programming Language, {{2nd-en}} edition'', {{p.|106}}.
&lt;source lang=&quot;c&quot;&gt;
void strcpy(char *s, char *t)
{
    while (*s++ = *t++)
        ;
}
&lt;/source&gt;

Le principe est de copier les octets-caractères jusqu'à ce que l'on copie le caractère nul, qui marque par convention la fin d'une chaîne en C.  La [[bibliothèque standard de C]] offre une fonction &lt;code&gt;strcpy&lt;/code&gt; similaire, dont le prototype est &lt;code&gt;char *strcpy(char*, const char*)&lt;/code&gt;.

La boucle &lt;code&gt;while&lt;/code&gt; utilise une notation classique mais très brève permise par C, qui a contribué à lui donner une réputation de langage peu lisible. L'expression &lt;code&gt;*s++ = *t++&lt;/code&gt; copie un caractère, retourne sa valeur, et incrémente les pointeurs &lt;code&gt;s&lt;/code&gt; et &lt;code&gt;t&lt;/code&gt;. Cette boucle n'a pas de corps, car toutes les opérations sont effectuées dans l'expression de test du &lt;code&gt;while&lt;/code&gt;. On considère qu'il faut maîtriser ce genre de notation pour maîtriser C&lt;ref&gt;{{K&amp;R|2nd Ed}}, {{p.}} 106.&lt;/ref&gt;.

=== Allocation mémoire ===

La structure &lt;code&gt;int_list&lt;/code&gt; représente un élément d'une [[liste chaînée]], contenant des données de type &lt;code&gt;int&lt;/code&gt;. Les deux fonctions qui suivent (&lt;code&gt;insert_next&lt;/code&gt; et &lt;code&gt;remove_next&lt;/code&gt;) servent à ajouter et supprimer un élément de la liste.

&lt;source lang=&quot;c&quot;&gt;
/* La gestion de la mémoire n'est pas intégrée au langage
   mais assurée par des fonctions de la bibliothèque standard. */
#include &lt;stdlib.h&gt;
 
struct int_list {
    struct int_list *next; /* pointeur sur l'élément suivant */
    int value;             /* valeur de l'élément */
};
 
/* 
 * Ajouter un élément à la suite d'un autre.
 * node : élément après lequel ajouter le nouveau
 * value : valeur de l'élément à ajouter
 * Retourne : adresse de l'élément ajouté, ou NULL en cas d'erreur.
 */
struct int_list *insert_next(struct int_list *node, int value) {
    /* Allocation de la mémoire pour un nouvel élément. */
    struct int_list *const new_next = malloc(sizeof *new_next);
 
    /* Si l'allocation a réussi, alors insérer new_next entre node
       et node-&gt;next. */
    if (new_next) {
        new_next-&gt;next = node-&gt;next;
        node-&gt;next = new_next;
        new_next-&gt;value = value;
    }
 
    return new_next;
}
 
/*
 * Supprimer l'élément suivant un autre.
 * node : élément dont le suivant est supprimé
 * Attention : comportement indéterminé s'il n'y pas d'élément suivant !
 */
void remove_next(struct int_list *node) {
    struct int_list *const node_to_remove = node-&gt;next;

    /* Retire l'élément suivant de la liste. */
    node-&gt;next = node-&gt;next-&gt;next;
    /* Libère la mémoire occupée par l'élément suivant. */
    free(node_to_remove);
}
&lt;/source&gt;

Dans cet exemple, les deux fonctions essentielles sont &lt;code&gt;malloc&lt;/code&gt; et &lt;code&gt;free&lt;/code&gt;. La première sert à allouer de la mémoire, le paramètre qu'elle reçoit est le nombre de [[byte]]s que l'on désire allouer et elle retourne l'adresse du premier byte qui a été alloué, sinon elle retourne NULL. &lt;code&gt;free&lt;/code&gt; sert à libérer la mémoire qui a été allouée par &lt;code&gt;malloc&lt;/code&gt;.

== Références ==
&lt;references/&gt;

== Voir aussi ==
{{Autres projets
|wikibooks=Catégorie:C
|wikibooks titre=Le langage C
|wikiversity=Langage C
|wikiversity titre=La programmation en C
}}

=== Articles connexes ===

* [[Bibliothèque standard du C]]
* [[Alignement de données]]
* {{lang|en|''[[International Obfuscated C Code Contest]]''}}

;Quelques programmes célèbres écrits en C
* [[UNIX]]
* La suite de compilateurs [[GNU Compiler Collection]] (GCC)
* Le [[Noyau (informatique)|noyau]] [[Noyau Linux|Linux]]
* Le noyau de [[Microsoft Windows]]
* [[GNOME]]

=== Bibliographie ===

* {{K&amp;R}}
* [http://www.open-std.org/JTC1/SC22/WG14/www/standards The international standardization working group for the programming language C],
** {{en}} ''ISO/IEC 9899:TC2 WG14/N1124'', « Committee Draft », 6 mai 2005 {{lire en ligne|lien=http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf}} {{Commentaire biblio|Le dernier ''brouillon'' de la norme ISO C99 incluant le ''Technical Corrigendum 2''}}
** {{en}} ''ISO/IEC 9899:TC3 WG14/N1256'', « Committee Draft », 7 septembre 2007 {{lire en ligne|lien=http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf}} {{Commentaire biblio|Le dernier ''brouillon'' de la norme ISO C99 incluant le ''Technical Corrigendum 3''}}
* {{en}}[[Ivor Horton]], {{lang|en|''Beginning C''}}, Apress, 2006, {{ISBN|978-1-59059-735-4}}
* [[Jean-Michel Léry]], ''Le langage C'', Pearson Education, 2005, {{ISBN|978-2-7440-7086-0}}
* {{Ouvrage|titre=Méthodologie de la programmation en C|ref=Référence:Méthodologie de la programmation en C|auteur=[[Achille Braquelaire]]|éditeur=Dunod|année=2005}}, {{ISBN|978-2-10-049018-9}}
* [[Claude Delannoy]], ''Programmer en langage C - Cours et exercices corrigés'', Eyrolles, {{11e}} tirage - 2006, {{ISBN|978-2-212-11072-2}}
* [[Mathieu Nebra]], ''Apprenez à programmer en C - {{2e}} édition'', Édition [[Site du Zéro]] - 2009, {{ISBN|979-1090085008}}
* {{Ouvrage
| langue                 = fr
| prénom1                = Éric
| nom1                   = Berthomier
| lien auteur1           = 
| prénom2                = Daniel
| nom2                   = Schang
| lien auteur2           = 
| titre                  = Le C en 20 heures
| lien titre             = 
| sous-titre             = 
| numéro d'édition       = 3
| année première édition = 2010
| collection             = Framabook
| numéro dans collection = 6
| éditeur                = [[Framasoft]]
| lien éditeur           = 
| lieu                   = 
| jour                   = 
| mois                   = 
| année                  = 2013
| volume                 = 
| tome                   = 
| pages totales          = 196
| passage                = 
| isbn                   = 978-2-9539187-7-9
| lire en ligne          = 
| consulté le            = 
| présentation en ligne  = http://framabook.org/6-le-c-en-20-heures/
}}

=== Liens externes ===

* {{fr}} {{dmoz|Langage C|http://www.dmoz.org/World/Français/Informatique/Programmation/Langages/C/}}
* [http://code-reference.com/c Coding Programmer Page / C Library Reference and Examples&lt;nowiki&gt;&lt;/nowiki&gt;] (english)

&lt;!-- Wikipédia n'a pas vocation à être un annuaire, les liens externes sont limités ; DMOZ est un annuaire régi par un même esprit que celui de wikipédia et où vous êtes invités à enregistrer votre site plutôt que de l'ajouter ici --&gt;

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage C| ]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Norme ISO]]</text>
      <sha1>jv4onwggzi3jc5urowcmi95zo37bviz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>R (langage de programmation et environnement statistique)</title>
    <ns>0</ns>
    <id>91111</id>
    <revision>
      <id>101512244</id>
      <parentid>98525884</parentid>
      <timestamp>2014-02-23T03:51:30Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>formatage (REM. : p.-ê. d. c. de n. ??)</comment>
      <text xml:space="preserve" bytes="10330">{{Voir homonymes|R}}
{{Infobox Langage de programmation
|  couleur boîte                    = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
|  nom et logo                      = oui
|  nom                              = R
|  logo                             = Rlogo.png
|  paradigmes                       = Programmation multi-paradigmes : [[Programmation orientée objet|orientée objet]], [[programmation impérative|impérative]], [[programmation fonctionnelle|fonctionnelle]], [[programmation procédurale|procédurale]], [[Réflexion (informatique)|réflexive]]
|  auteur                           = [[Ross Ihaka]] et [[Robert Gentleman (statisticien)|Robert Gentleman]]
|  développeurs                     = [[Projet GNU]]
|  date de première version         = 
|  dernière version stable          = 3.0.2
|  date de dernière version stable  = {{date|25|septembre|2013}}
|  dernière version avancée         = 
|  date de dernière version avancée = 
|  typage                           = 
|  implémentations                  = 
|  normes                           =
|  dialectes                        = 
|  influencé par                    = [[S (langage de programmation)|S]], [[Scheme]]
|  a influencé                      = 
|  système d'exploitation           = [[Multiplate-forme]]
|  licences                         = [[Licence publique générale GNU|GNU GPL]]
|  site web                         = {{Site officiel|en|http://www.r-project.org/}}
|  date de mise à jour              = 22 juillet 2011
}}
'''R''' est un [[logiciel libre]] de traitement des données et d'[[statistiques|analyse statistiques]] mettant en œuvre le [[langage de programmation]] [[S (langage de programmation)|S]]. C'est un [[projet GNU]] fondé sur l'environnement développé dans les [[laboratoires Bell]] par [[John Chambers (statisticien)|John Chambers]] et ses collègues. Depuis plusieurs années, deux nouvelles versions apparaissent au printemps et à l'automne. Il dispose de nombreuses fonctions graphiques.

Le logiciel R est considéré par ses créateurs comme étant une exécution de S, avec la sémantique dérivée du langage [[Scheme]]. C'est un [[logiciel libre]] distribué selon les termes de la licence [[Licence publique générale GNU|GNU GPL]] et est disponible sous [[GNU/Linux]], [[FreeBSD]], [[NetBSD]], [[OpenBSD]], [[Mac OS X]] et [[Windows]]. Il représente aujourd'hui l'un des objectifs techniques majeurs de la communauté hacker [[GNU]]&lt;ref name=&quot;ghm&quot; /&gt;.

Une enquête menée par [[Rexer Analytics]] auprès de {{formatnum:1300}} analystes, retrouve que R est le logiciel le plus souvent utilisé lorsqu'il s'agit d'un travail en entreprise, dans le monde académique, au sein d'organismes publics ou d'ONG et chez les analystes travaillant comme consultants&lt;ref&gt;{{Article|titre=R users: Be counted in Rexer's 2013 Data Miner Survey|périodique=Revolution Analytics Blog|jour=30|mois=janvier|année=2013|url=http://blog.revolutionanalytics.com/2013/01/r-users-be-counted-in-rexers-2013-data-miner-survey.html|prénom1=David|nom1=Smith|langue=en}}.&lt;/ref&gt;.

== Les paquets ==

Si R dispose dans sa version de base de la plupart des fonctionnalités utiles pour la statistique courante, ses possibilités s'élargissent dès que l'on utilise les paquets (ou « extensions »), souvent écrits en R et mis librement à disposition. Ces paquets couvrent un très large champ et vont de la [[Analyse des données (statistiques)|statistique multivariée]] aux méthodes de ré-échantillonnage, de l'[[économétrie]] à la [[biométrie]], des modèles de régression sur [[Séries temporelles|séries chronologiques]] ou les modèles à équations simultanées, en passant par l'analyse de données écologiques ([[Ade4]] et vegan&lt;ref&gt;http://pbil.univ-lyon1.fr/ADE-4/.&lt;/ref&gt;), sans oublier l'[[Inférence bayésienne|approche bayésienne]]. 

Face au nombre toujours croissant de paquets (on comptait près de 80 nouveaux paquets d'octobre à décembre 2007&lt;ref&gt; Rnews Volume 7/3, décembre 2007, disponible sur le [http://cran.r-project.org/index.html site CRAN] sous « Newsletter ».&lt;/ref&gt;), une page offre des regroupements des paquets selon les domaines abordés&lt;ref&gt;Voir sous [http://cran.univ-lyon1.fr/index.html] puis « Task View ».&lt;/ref&gt;.

Parmi ces extensions, on peut également citer celles qui permettent d'interfacer directement R avec des bases de données comme [[PostgreSQL]] (via le langage procédural PL/R) et [[MySQL]] ou des [[Système d'information géographique|SIG]] comme [[GRASS GIS|GRASS]], celles qui permettent d'exporter ses résultats en [[LaTeX]] ou [[OpenDocument]], ou encore celles regroupant des fonctions décrites dans des ouvrages de référence, telles MASS, UsingR ou ISwR.

L'installation des extensions se fait de la manière suivante :

&lt;source lang=&quot;rsplus&quot;&gt;
install.packages(&quot;nom_du_paquet&quot;)
&lt;/source&gt;
Pour pouvoir l'utiliser, il suffit ensuite d'exécuter :
&lt;source lang=&quot;rsplus&quot;&gt;
library(nom_du_paquet)
&lt;/source&gt;

== Aide et support francophones ==

* [http://forums.cirad.fr/logiciel-R/ Forum Web] du Groupe des utilisateurs du logiciel R
* [http://www.developpez.net/forums/f1179/autres-langages/autres-langages/r/ Forum Web] consacré à R sur developpez.net     
* Canal [[Internet Relay Chat|IRC]] (''chat'') dédié à R : #Rfr sur le réseau [[Freenode]], également disponible via une [http://java.freenode.net/index.php?channel=Rfr interface Web]

== Interface graphique ==

[[Fichier:R Terminal.png|thumb|upright=1.5|R dans un Terminal sous Linux.]]
[[Fichier:Rstudio.png|thumb|upright=1.5|R avec l'environnement de développement intégré RStudio.]]
Il existe des interfaces graphiques pour R, comme 

* RGUI, l'interface graphique installée par défaut sous Windows. 
* [http://stats.math.uni-augsburg.de/JGR/ JGR] sur [[Java (technologie)|Java]], 
* [http://rattle.togaware.com/ Rattle] sur [[GTK+|GTK]], qui demande l'installation préalable de GTK,
* [http://socserv.mcmaster.ca/jfox/Misc/Rcmdr/ Rcmdr] une interface de commande en [[Tool Command Language|Tcl-Tk]], 
* [[RKWard]] sur [[KDE]], disponible seulement sous [[GNU/Linux]], propose la [[coloration syntaxique]] des scripts ainsi que de nombreuses fonctions dans les menus,
* [http://rstudio.org/ RStudio] un [[Environnement de développement intégré|IDE]] multiplateforme, 
* [http://www.sciviews.org/SciViews-R/ Sciviews R GUI] sur [[Microsoft Windows|Windows]],
* [http://cran.r-project.org/web/packages/Sim.DiffProcGUI/ Sim.DiffProcGUI] une interface graphique pour la simulation des processus de diffusion.
* [http://www.statistiklabor.de/en/ Statistical Lab].

Certains éditeurs de texte proposent également des modes pour R :
* [http://www.sciviews.org/Tinn-R/ Tinn-R], un éditeur de texte orienté R sur Windows,
* [http://ess.r-project.org/ Emacs ESS] (Emacs speaks statistics) Un mode pour [[GNU Emacs]] dédié (entre autres) à R.
* [http://www;lyx.org LyX] inclut un module [http://www.stat.uni-muenchen.de/~leisch/Sweave/ Sweave], outil d'insertion de code R dans les documents LaTeX.

Il est également possible d'exécuter des fonctions R directement sur le Web, sans installer le logiciel.
* [http://www.math.montana.edu/Rweb/ R Web],

* Le logiciel [[SAS (langage)|SAS]] interface également les fonctions R depuis [http://support.sas.com/rnd/app/studio/Rinterface2.html SAS/IML Studio 3.2], assurant l'interopérabilité entre SAS et R, comme le portage de R sur de grosses volumétries de données et le calcul distribué.

* Le projet [http://mars.wiwi.hu-berlin.de/mediawiki/sk/index.php/R_Extension_for_MediaWiki R for MediaWiki] qui permet de faire tourner R sur des [[wiki]]s (mais pas encore sous Wikipedia), [http://statwiki.wiwi.hu-berlin.de/index.php/Binomialverteilung voir un exemple].

* R est présent dans l'interface de [[Sage (logiciel de calcul formel)|Sage]], un logiciel libre de mathématiques diffusé sous la licence GPL

== Éléments permettant la réalisation technique du logiciel R ==

Les sources du logiciel R sont disponibles dans le dépôt [http://cran.r-project.org/ R sources]. Il est codé dans les langages [[C (langage)|C]], [[C++]], [[Fortran]] et [[Java (langage)|Java]]. Avant de penser à le recompiler, il faut donc installer un certain nombre de composants.

Sous Windows, la plupart des outils ont été regroupés dans un seul exécutable qui s'appelle R-tools ([http://www.murdoch-sutherland.com/Rtools/ R-tools]). De plus, pour travailler sur la documentation du logiciel, il faut installer le compilateur de fichiers d'aide Microsoft ([http://www.microsoft.com/office/ork/xp/appndx/appa06.htm HTML Help Workshop]). Il faut aussi l'outil [[LaTeX]] ([[MiKTeX]]). Enfin pour la création de l'exécutable d'installation, on utilise le classique inno-setup ([http://jrsoftware.org/isinfo.php inno-setup]). Pour retrouver ces quelques indications techniques et pour aller plus loin, on peut consulter le lien suivant : {{lien brisé|url=http://wwwmaths.anu.edu.au/~wangk/personal/pub/R/WinBook/node14.html|titre=Compile R source}}.

== Communauté ==

Le projet R a été représenté par Toby Dylan Hocking lors de la réunion hacker GNU organisée à [[Paris]] du 25 au 28 août 2011&lt;ref name=&quot;ghm&quot;&gt;{{en}} [http://www.gnu.org/ghm/2011/paris/ « GNU Hackers Meeting in Paris, 2011 »], ''gnu.org'', 22 juillet 2011.&lt;/ref&gt; dans les locaux de l'[[IRILL]].

== Références ==

{{Références|colonnes=2}}

== Liens externes ==
{{Autres projets|commons=Category:GNU R|commons titre=R}}
* {{en}} [http://www.r-project.org/ Site officiel du projet].
* {{en}} [http://directory.fsf.org/project/gnur/ GNU R] sur le [[répertoire du logiciel libre]].
* {{en}} {{Dmoz|R|http://www.dmoz.org//Science/Math/Statistics/Software/S/R//}}.
* {{en}} [http://www.nytimes.com/2009/01/07/technology/business-computing/07program.html?pagewanted=all&amp;_r=0 Data Analysts Captivated by R’s Power], [[New York Times]]

{{Palette
| GNU
| Logiciels de calcul numérique
}}
{{Portail|logiciels libres|programmation informatique|probabilités et statistiques}}

{{DEFAULTSORT:R, Gnu}}
[[Catégorie:R (logiciel)]]
[[Catégorie:Logiciel du projet GNU]]
[[Catégorie:Logiciel libre sous licence GPL]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Logiciel de statistiques]]
[[Catégorie:Exploration de données]]</text>
      <sha1>ou0lh4a2sgisexco4ivxep3yl3ej3ot</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Numerical Recipes</title>
    <ns>0</ns>
    <id>6016432</id>
    <revision>
      <id>101642625</id>
      <parentid>93868982</parentid>
      <timestamp>2014-02-27T15:26:30Z</timestamp>
      <contributor>
        <ip>78.228.234.205</ip>
      </contributor>
      <comment>changement de &quot;magnitude&quot; en grandeur (anglicisme)</comment>
      <text xml:space="preserve" bytes="10945">{{Infobox Livre
 | auteur             = [[William H. Press]], [[Saul Teukolsky]], William Vetterling et Brian Flannery
 | préface            = 
 | directeur          = 
 | genre              = Manuel mathématique
 | titre_orig         = Numerical Recipes
 | pays               = 
 | lieuparution_orig  = {{USA-d}} [[États-Unis]]
 | langue             = Anglais
 | éditeur_orig       = [[Cambridge University Press]]
 | collection_orig    = 
 | dateparution_orig  = 1986 ({{1re}} édition)
 | isbn_orig          = 
 | traducteur         = 
 | titre              = 
 | lieuparution       = 
 | éditeur            = 
 | collection         = 
 | dateparution       = 
 | image              = NumericalRecipes3rdEdCover.jpg
 | légende            = Couverture de ''Numerical Recipes: The Art of Scientific Computing'' ({{3e}} édition), en C++
 | artiste_couverture = 
 | série              = 
 | type_média         = 
 | pages              = 
 | isbn               = }}
'''''Numerical Recipes''''' est le titre générique d'une série d'ouvrages sur les [[algorithme]]s et l'[[analyse numérique]] par [[William H. Press]], [[Saul Teukolsky]], William Vetterling et Brian Flannery. Édité dans de nombreuses éditions, les livres sont imprimés depuis 1986, la dernière édition datant de 2007.

== Contenu ==
Les livres ''Numerical Recipes'' couvrent des sujets de l'[[analyse numérique]] ([[interpolation numérique]], [[Intégration numérique|intégration]], [[algèbre linéaire]], [[équations différentielles]], etc), traitement du signal ([[transformée de Fourier]], [[Filtre numérique|filtre]]), traitement des données statistique, ainsi que quelques points sur ''in machine learning'' ([[Modèle de Markov caché|modèles de Markov cachés]], [[machine à vecteurs de support]]). Le style d'écriture se veut accessible et sur un ton informel. L'accent est mis sur la compréhension des bases sous-jacentes des techniques, pas sur les raffinements qui peuvent, en pratique, être nécessaires pour atteindre des performances et une fiabilité optimale. Peu de résultats sont prouvés avec une réelle rigueur, même si les idées derrière les preuves sont souvent esquissées, et les références sont données.

Pratiquement toutes les méthodes qui sont présentées sont également rédigées en code, qui est imprimé dans le livre.

Selon l'éditeur, [[Cambridge University Press]], les livres ''Numerical Recipes'' sont les ouvrages sur les méthodes de programmation les plus vendus de tous les temps. Selon ''ISI Web of Knowledge'', ces dernières années, les livres ''Numerical Recipes'' ont été cités plus de 3000 fois par an dans la littérature scientifique (par exemple, 3962 fois dans les années 2008)&lt;ref&gt;[[Thomson Reuters]], [http://www.isiwebofknowledge.com/ Web of Knowledge], Cited Reference Search.&lt;/ref&gt;.

== Histoire ==
Édité pour la première fois en 1986 avec des codes en Fortran (rapidement suivi par des éditions en Pascal, BASIC et C), ''Numerical Recipes'' a pris, dès le départ, une position éditoriale en désaccord avec la sagesse conventionnelle de la communauté d'analyse numérique :

{{citation étrangère|langue=en|If there is a single dominant theme in this book, it is that practical methods of numerical computation can be simultaneously efficient, clever, and — important — clear.  The alternative viewpoint, that efficient computational methods must necessarily be so arcane and complex as to be useful only in « black box » form, we firmly reject&lt;ref&gt;{{ouvrage | prénom1=WH | nom1=Press | prénom2=SA | nom2=Teukolsky | prénom3=WT | nom3=Vetterling | prénom4=BP | nom4=Flannery | année=1986 | titre=Numerical Recipes: The Art of Scientific Computing | éditeur=Cambridge University Press | isbn=0521308119 | chapitre=Preface | page=xi}}.&lt;/ref&gt;}}

Toutefois, comme il s'est avéré que les années 1980 ont été fertiles pour le côté « [[boîte noire]] », ce qui donne des environnements intégrés importants tels que [[MATLAB]] et [[Mathematica]] qui restent des standards aujourd'hui. Au début des années 1990, lorsque les deuxièmes éditions de ''Numerical Recipes'' (avec des codes en C, Fortran 77 et Fortran 90) ont été publiées, il était clair que les utilisateurs de ''Numerical Recipes'' ne représentaient plus la majorité des scientifiques faisant de la programmation, mais a provoqué la scission ''entre'' ceux qui étaient plus orientés analystes numériques mathématiques et la plus grande communauté utilisant des environnements intégrés. Les deuxièmes éditions ont occupé un rôle stable dans cet environnement de niche&lt;ref name=cip&gt;W.H. Press and S.A. Teukolsky, « Numerical Recipes: Does This Paradigm Have a Future? », ''Computers in Physics'', 11, 416 (1997). [http://www.nr.com/whp/CIPso97.ps Preprint.]&lt;/ref&gt;.

Au milieu des années 2000, la pratique du calcul scientifique a été radicalement modifiée par l'usage régulier d'Internet et du Web. Reconnaissant que leurs livres ''Numerical Recipes'' ont été plus appréciés pour leurs textes explicatifs que pour leurs exemples de code, les auteurs ont considérablement élargi la portée de l'ouvrage, et considérablement réécrit une grande partie du texte. Ils ont continué d'inclure du code, toujours imprimé dans le livre, maintenant en C ++, pour chaque méthode discutée&lt;ref&gt;{{ouvrage | prénom1=WH | nom1=Press | prénom2=SA | nom2=Teukolsky | prénom3=WT | nom3=Vetterling | prénom4=BP | nom4=Flannery | année=2007 | titre=Numerical Recipes: The Art of Scientific Computing | édition={{3e}} | éditeur=Cambridge University Press | isbn=978-0-521-88068-8 | chapitre=Preface to the Third Edition | page=xi}}.&lt;/ref&gt;. La ''Third Edition'' a également été édité en version électronique&lt;ref&gt;{{ouvrage | prénom1=WH | nom1=Press | prénom2=SA | nom2=Teukolsky | prénom3=WT | nom3=Vetterling | prénom4=BP | nom4=Flannery | année=2007 | titre=Numerical Recipes: The Art of Scientific Computing | édition=3rd | éditeur=Cambridge University Press | isbn=978-0-521-88068-8 | url=http://apps.nrbook.com/empanel/index.html}}.&lt;/ref&gt;, et rendue par la suite accessible sur le Web gratuitement (avec une quantité de lecture limitée) ou par paiement ou abonnement (avec une quantité de lecture illimitée).

== Critiques ==
Étant donné le style de rédaction des livres, il n'est pas surprenant qu'ils étaient (et restent dans une certaine mesure) controversés au sein de la communauté de l'[[analyse numérique]]. Les premières critiques étaient centrées sur le « manque supposé de fiabilité » (la première édition contenait en effet quelques erreurs), l'exclusion de certains algorithmes, et l'affirmation des auteurs, pas toujours correcte, selon laquelle leurs programmes sont aussi efficaces et fiables que ceux des bibliothèques de type « boîte noire », comme les ''[[NAG Numerical Libraries]]''. Bien qu'il ne mentionne pas ''Numerical Recipes'' nommément, Whaley ''et al.''&lt;ref&gt;R. Clint Whaley, Antoine Petitet et Jack J. Dongarra, « Automated empirical optimization of software and the ATLAS project », ''Parallel Computing'' '''27''', 3-35 (2001).&lt;/ref&gt; démontrent que [[LAPACK]] avec une librairie [[BLAS]] hautement optimisé peut être d'un ordre de grandeur plus rapide qu'une routine simple directement inspirée de ''Numerical Recipes''. Comme autre exemple, Frigo et Johnson&lt;ref&gt;S. G. Johnson and M. Frigo, &quot;[http://cnx.org/content/m16336 Implementing FFTs in practice] in ''Fast Fourier Transforms'' (C. S. Burrus, ed.), ch. 11, Rice University, Houston TX: [[Connexions]], septembre 2008.&lt;/ref&gt; pointent le fait que le code de [[transformée de Fourier rapide]] (FFT) de ''Numerical Recipes'' est de 5 à 40 fois plus lent que les programmes hautement optimisés sur des architectures numériques modernes.

Un deuxième point de critiques notent le fait que, bien qu'imprimé dans des livres, les auteurs des ouvrages détiennent les droits d'auteur sur le code, et non disponible à l'usage sous une [[licence publique générale GNU]] ou similaire. En effet, une des premières motivations de la [[GNU Scientific Library]] était qu'une bibliothèque [[Logiciel libre|libre]] était en partie nécessaire comme à ''Numerical Recipes''. Sur ce point, rien n'a été épargné aux auteurs de ''Numerical Recipes''. Ils tirent leurs revenus de la vente de licences individuelles et d'entreprise pour le code, et gèrent clairement la marque ''Numerical Recipes'' comme une entreprise&lt;ref&gt;Site Internet de ''Numerical Recipes'', [http://www.nr.com/aboutNR3code.html Numerical Recipes Code]&lt;/ref&gt;.

Un troisième point critiqué est le style de code utilisé dans les livres, que certains lecteurs modernes trouvent « fortranisé », même quand le langage du livre est plus orienté objet. 
Certaines de ces critiques sont justifiés, et en raison de l'héritage historique des parties du code. Cependant, les auteurs ont défendu leur style comme nécessaire pour le format des livres, ce qui nécessite un style très laconique de codage en raison des limitations d'espace et du souci de lisibilité&lt;ref name=cip /&gt;.

== Liste partielle des différentes éditions ==
Les livres diffèrent par leur version d'édition (''1st'', ''2nd'' et ''3rd'') et par le langage informatique utilisé dans les codes donnés.

* ''Numerical Recipes. The Art of Scientific Computing, 3rd Edition'', 2007, ISBN 0-521-88068-8. (C++ code)
* ''Numerical Recipes in [[C (langage)|C]]. The Art of Scientific Computing, 2nd Edition'', 1992, ISBN 0-521-43108-5.
* ''Numerical Recipes in [[Fortran]] 77. The Art of Scientific Computing, 2nd Edition'', 1992, ISBN 0-521-43064-X.
* ''Numerical Recipes in Fortran 90. The Art of Parallel Scientific Computing, 2nd Edition'', 1996, ISBN 0-521-57439-0.
* ''Numerical Recipes in [[Pascal (langage)|Pascal]]. The Art of Scientific Computing, 1st Edition'', 1989, ISBN 0-521-37516-9.

Les livres sont édités par [[Cambridge University Press]].

==Références==
{{Traduction/Référence|en|Numerical Recipes|469516705}}
{{Références}}

== Liens externes ==
* [http://www.nr.com/ Site Web de Numerical Recipes].
* [http://apps.nrbook.com/empanel/index.html Version électronique actuelle de Numerical Recipes] (nombre de lectures gratuites limitée).
* [http://www.nr.com/oldverswitcher.html Anciennes versions de ''Numerical Recipes'' disponibles sur Internet] (liens vers les versions en C, Fortran 77 et Fortran 90, entre autres)
* [http://www.lysator.liu.se/c/num-recipes-in-c.html Reviews of Numerical Recipes]
* Norman Gray, [http://www.astro.gla.ac.uk/users/norman/star/sc13/sc13.htx/N-a2b3c1.html A balanced discussion of NR and its critics]
* [http://math.stanford.edu/~lekheng/courses/302/wnnr/nr-alt.html Alternatives to Numerical Recipes]

{{Portail|mathématiques|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Livre de mathématiques]]</text>
      <sha1>frf1f4h79yustvyuntitam4a3oob1o6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Information Processing Language</title>
    <ns>0</ns>
    <id>6070254</id>
    <revision>
      <id>91726815</id>
      <parentid>90965903</parentid>
      <timestamp>2013-04-05T16:11:38Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q776372]]</comment>
      <text xml:space="preserve" bytes="1888">{{ébauche|informatique}}

'''IPL''' (''{{lang|en|Information Processing Language}}'', c'est-à-dire « Langage de traitement de l'information ») est un [[langage de programmation]] développé par [[Allen Newell]], [[Shaw Cliff]] et [[Herbert Simon]] à la [[RAND Corporation]] et le [[Carnegie Institute of Technology]] à partir de [[1956]]. Newell avait le rôle de spécificateur-application programmeur, Shaw était le programmeur système et Simon a pris le rôle de programmeur-utilisateur.

Le langage comprend des fonctionnalités destinées à la résolution générale de problèmes, y compris des listes, des associations, des schémas (frames), l'[[Allocation de mémoire|allocation dynamique de mémoire]], les types de données, la [[récursivité]], la récupération associative, des fonctions comme arguments, les générateurs (flux), et le [[multitâche]] coopératif. 

IPL a lancé le concept de traitement de listes, mais dans un style en langage assembleur. Certains aspects d'IPL ont d'ailleurs influencé le [[LISP]]&lt;ref&gt;http://www-formal.stanford.edu/jmc/history/lisp/node2.html&lt;/ref&gt;.

==Publications==
*{{en}} Newell, A. and F.C. Shaw, « Programming the Logic Theory Machine », ''Proceedings of the Western Joint Computer Conference'', février 1957, p. 230-240.
*{{en}} Newell, Allen, et Fred M. Tonge, « An Introduction to Information Processing Language V »,  CACM 3(4), 1960, p. 205-211.
*{{en}} Newell, Allen, ''Information Processing Language-V Manual; Second Edition'', Rand Corporation [Allen Newell], Englewood Cliffs, NJ, Prentice-Hall, 1964.
*{{en}} Samuel, Arthur L., « Programming Computers to Play Games », in ''Advances in Computers'', vol. 1, 1960, p 165-192 (surtout p. 171-175).

== Notes et références ==
{{Références}}


{{Portail|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Intelligence artificielle]]</text>
      <sha1>pdu06go1myqo1cyirm6two1tzrinqqe</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MOLOG</title>
    <ns>0</ns>
    <id>6086987</id>
    <revision>
      <id>92188045</id>
      <parentid>91585614</parentid>
      <timestamp>2013-04-17T17:07:53Z</timestamp>
      <contributor>
        <username>Ange Gabriel</username>
        <id>263831</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.27 - Flèche en caractères de texte - Orthographe et typographie ([[P:CS|Correction syntaxique]])</comment>
      <text xml:space="preserve" bytes="10112">{{Infobox Langage de programmation
| nom                    = Molog
| paradigme              = [[Programmation logique]]
| année                  = [[1986]]
| auteur                 = [[Luis Farinas Del Cerro]], [[Andreas Herzig]] et [[Jean-Marc Alliot]]
| développeur            = 
| dernière version stable= 
| date de dernière version stable = [[1993]]
| typage                 = 
| implémentations        = 
}}
'''MOLOG'''&lt;ref&gt;Luis Fariñas del Cerro, MOLOG A system that extends PROLOG with modal logic, New Generation Computing, 4:35-50, 1986&lt;/ref&gt; est une généralisation du langage [[Prolog]] permettant d'étendre le paradigme de la [[Programmation logique]] à la [[logique non classique]] et en particulier à la [[logique modale]], la [[logique aléthique]] ou la [[logique temporelle]]. Le nom ''MOLOG'' est un [[acronyme]] de MOdal LOGic et également une référence à l'acronyme ''PROLOG'', PROgrammation 
LOGique. Il a été créé par [[Luis Fariñas Del Cerro]], [[Andreas Herzig]] et [[Jean-Marc Alliot]] entre [[1986]] et [[1994]].

== Contexte ==
Au milieu des années 80, le langage PROLOG est devenu une référence en matière de langage de programmation permettant d'utiliser l'expressivité de la logique mathématique en lieu et place de l'enchainement d'instructions ou de fonctions caractéristiques des langages impératifs ou fonctionnels. L'un des problèmes de PROLOG était sa limitation à l'utilisation des [[clause de Horn|clauses de Horn]] en [[calcul des prédicats du premier ordre]]. Plusieurs équipes se sont lancées dans la réalisation de méta-interpréteurs spécifiques, généralement écrits eux-mêmes en PROLOG, mais qui permettaient d'étendre PROLOG à d'autres logiques, comme [[Templog]]&lt;ref&gt;Marianne Baudinet, Temporal logic programming is complete and expressive, In Sixteenth ACM Symposium on Principles of Programming Language, 1989&lt;/ref&gt; ou [[Temporal Prolog]]&lt;ref&gt;Takashi Sakuragawa, Temporal PROLOG, In RIMS Conference on software science
and engineering, 1989&lt;/ref&gt; pour la logique temporelle, [[N-Prolog]]&lt;ref&gt;D Gabbay and U Reyle, N-prolog An extension of prolog with hypothetical implications, Journal of Logic Programming,1:319-355, 1984&lt;/ref&gt; pour les logiques hypothétiques, ou les extensions de contexte&lt;ref&gt;Luis Monteiro and Antonio Porto, Modules for logic programming based on
context extension, In International Conference on Logic Programming, 1988&lt;/ref&gt;.

== Principe et développement ==
Le premier but de MOLOG était d'être capable de traiter de façon générique toutes les formes de logique, contrairement aux méta-interpréteurs spécialisés sus-cités. Pour ce faire, le système se décomposait en trois parties (au lieu de deux pour un système PROLOG classique): 
* Le moteur d'inférence 
* Les règles de résolution
* La base de clauses
Le moteur d'inférence et la base de clauses de Horn sont également présents en PROLOG (le moteur d'inférence étant le mécanisme central de fonctionnement de PROLOG, et la base de clauses le &quot;programme&quot; rédigé par l'utilisateur). Mais en PROLOG les règles de résolution sont implicites (et incluses dans le moteur d'inférences) et se réduisent globalement au classique [[modus ponens]] en chainage arrière. L'idée centrale de MOLOG est d'externaliser les règles de résolutions, permettant ainsi de définir le fonctionnement du langage sur des clauses de Horn étendues comprenant des opérateurs modaux.

Les premières versions de MOLOG étaient également des méta-interpréteurs écrits en PROLOG&lt;ref&gt;Esprit Project &quot;ALPES&quot;, MOLOG Technical Report, Mai 1987, Esprit Technical Report&lt;/ref&gt;, mais la lenteur de PROLOG d'une part et la complexité beaucoup plus importante de la résolution en logique non-classique d'autre part ne permettaient pas de faire fonctionner les programmes MOLOG dans des temps raisonnables. 

En 1992, une version&lt;ref&gt;[http://www.alliot.fr/papers/thesejma.pdf Jean-Marc Alliot, Une machine parallèle pour l'implantation d'extensions de PROLOG, thèse de doctorat, Université Paul Sabatier, 1992]&lt;/ref&gt; de MOLOG fut développée en ADA faisant ainsi le pendant à C-PROLOG, une version de PROLOG écrite en C. Cette version était extrêmement rapide, capable de fonctionner en parallèle sur des réseaux d'ordinateurs, et permettait ainsi de faire de la résolution automatique en logique non-classique dans des temps raisonnables. Le système fut présenté à la grand-messe des systèmes dits de &quot;cinquième génération&quot;&lt;ref&gt;[http://www.alliot.fr/papers/fgcs92.pdf Jean-Marc Alliot, Andreas Herzig, Mamede Lima-Marques, Implementing Prolog Extensions: A Parallel Inference Machine, Fifth Generation Computer System'92 (Tokyo, Japan)] &lt;/ref&gt;.

== Exemple de programme ==
Un classique exemple d'utilisation de MOLOG est la formalisation en logique modale multi-S4 du problème connu en anglais sous le nom de ''Wise Men Problem'', dont voici l'énoncé:

''Un roi souhaitait choisir parmi ses trois fils, Gauvin, Lancelot et Arthur, lequel lui succèderait. Pour ce faire, il organisa une épreuve consistant à les réunir tous les trois dans la même pièce, puis à les coiffer chacun d'un heaume soit noir, soit blanc. Chacun des princes était capable de voir la couleur des heaumes des deux autres mais pas la couleur du sien. Le roi s'adressa alors à ses fils et leur dit: &quot;Je puis vous dire qu'il y a dans cette pièce au moins l'un d'entre vous qui porte un heaume blanc.&quot; Puis il s'adressa successivement à Gauvin, Lancelot puis Arthur, en leur demandant de quelle couleur était leur heaume. Le premier fut incapable de répondre ainsi que le second. Quant à Arthur, il sut évidemment que son heaume était blanc, et fut ainsi désigné héritier du royaume.''

Après avoir brièvement noté que notre roi est un fieffé chenapan qui avait tout arrangé pour qu'Arthur soit son successeur (Lancelot et Gauvin portent des heaumes noirs, et Arthur un heaume blanc, configuration qui garantit le résultat), voyons comment modéliser ce problème en MOLOG.

Nous allons tout d'abord exprimer que tout le monde sait que si le heaume de Gauvin est
noir et que le heaume d'Arthur est noir alors le heaume de Lancelot est blanc (hypothèse qu'il y a au moins un heaume blanc):
*NEC(_):((noir(gauvin) et noir(arthur)) → blanc(lancelot))
'''NEC(X)''' signifiant '''X sait que''', et '''NEC(_)''' signifie '''tout le monde sait que'''. '''NEC''' est un des opérateurs modaux étendant la logique classique dans le cadre des clauses de Horn étendues. Bien entendu, les deux clauses symétriques doivent être ajoutées au programme:
*NEC(_):((noir(gauvin) et noir(lancelot)) → blanc(arthur))
*NEC(_):((noir(lancelot) et noir(arthur)) → blanc(gauvin))

Il faut ensuite exprimer que tout le monde sait que, si, pour Lancelot, le heaume d'Arthur peut être blanc, alors il est blanc de façon certaine, puisque Lancelot voit le heaume d'Arthur:
*NEC(_):(POS(lancelot):blanc(arthur) → NEC(lancelot):blanc(arthur))
'''POS(X)''' est un autre opérateur modal signifiant '''il est possible pour X que'''. Cette clause signifie donc, en la lisant de gauche à droite, que tout le monde sait ('''NEC(_)''') que s'il est possible pour lancelot ('''POS(lancelot)''') que le heaume d'Arthur soir blanc ('''blanc(arthur)''') alors ('''→''') Lancelot sait ('''NEC(lancelot)''') que le heaume d'Arthur est blanc ('''blanc(arthur)'''). Cette clause doit être complétée par les clauses symétriques de celle-ci, les symétries concernant les trois princes et les deux couleurs. Il faut cependant faire bien attention de ne rien écrire de la forme:
*NEC(_):(POS(lancelot):blanc(lancelot) → NEC(lancelot):blanc(lancelot))
En effet, s'il est possible pour Lancelot que son heaume soit blanc, cela ne lui permet en rien de conclure, car il est incapable de voir son propre heaume, et donc la possibilité du fait n'entraine pas sa certitude.

Il ne reste plus qu'à rajouter les clauses correspondant aux réponses successives des trois princes, clauses qui créent l'asymétrie d'information et permettent ainsi à Arthur de trouver la solution alors que les deux premiers princes ne le peuvent pas:
*NEC(lancelot):POS(gauvin):noir(gauvin)
*NEC(arthur):NEC(lancelot):POS(gauvin):noir(gauvin)
*NEC(arthur):POS(lancelot):noir(lancelot)
La première clause signifie que Lancelot sait qu'il est possible pour Gauvin que Gauvin ait un heaume noir, puisque Gauvin n'a pas pu répondre. La seconde dit qu'Arthur sait que Lancelot sait qu'il est possible pour Gauvin que Gauvin ait un heaume noir. Et la troisième exprime que Arthur sait qu'il est possible pour Lancelot que Lancelot ait un heaume noir.

Le problème ainsi posé est résolu en quelques secondes par MOLOG. Une version du langage avec cet exemple déjà codé est disponible en [http://www.alliot.fr/code/molog.tgz ligne].

== Utilisation ultérieure ==
Le langage était rapide et puissant, mais il souffrait de deux défauts majeurs:
* D'une part, le codage de la base de règle de résolutions était complexe. Il devait se faire en ADA, et nécessitait une remarquable connaissance de la résolution automatique en logique modale pour correctement exprimer les règles (ainsi dans l'exemple ci-dessus le problème de la skolémisation des opérateurs modaux a été omis).
* D'autre part, l'expression de la base de clauses n'est pas chose facile dans les logiques non classiques. On voit bien dans l'exemple pourtant simplifié ci-dessus que rédiger un tel programme demande de la finesse et du soin.
MOLOG est donc une curiosité historique qui n'eut guère d'avenir, sauf peut-être à montrer que, malgré une expressivité potentielle bien supérieure à la logique classique, les logiques modales sont d'un emploi complexe qui en limite l'utilisabilité.

== Références ==
&lt;references/&gt;

== Liens externes ==
[http://www.alliot.fr/code/molog.tgz Source de la dernière version de MOLOG], nécessite un compilateur ADA.

{{Palette Langages de programmation}}
{{Portail|programmation informatique|logique}}
[[Catégorie:Langage de programmation]]</text>
      <sha1>6k5m9k5jh4cbazmtsqcdkor8m5tteuc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Julia (langage de programmation)</title>
    <ns>0</ns>
    <id>6120926</id>
    <revision>
      <id>98118556</id>
      <parentid>94639105</parentid>
      <timestamp>2013-11-07T13:24:02Z</timestamp>
      <contributor>
        <ip>128.178.192.135</ip>
      </contributor>
      <text xml:space="preserve" bytes="2119">{{Ébauche|informatique}}
{{Infobox Langage de programmation
| nom                    = Julia
| nom et logo            = non
| paradigme              = 
| année                  = [[2009]]
| auteur                 = 
| développeur            = 
| typage                 = [[Typage dynamique|dynamique]]
| influencé par          = [[Matlab]], [[R (langage de programmation et environnement statistique)|R]], [[Ruby (langage)|Ruby]], [[Perl (langage)|Perl]], [[Python (langage)|Python]]
| système d'exploitation = [[Multi- plateformes]]
| licence = [[Licence MIT]]&lt;ref&gt;[https://github.com/JuliaLang/julia/blob/master/LICENSE.md github.com/JuliaLang]&lt;/ref&gt;
| site web = [http://julialang.org/ www.julialang.org]
}}

'''Julia''' est un [[langage de programmation]] de haut niveau, performant et dynamique pour le calcul scientifique, avec une syntaxe familière aux utilisateurs d'autres environnements de développement similaires (Matlab, R, Scilab, Python, etc...). Il fournit un compilateur sophistiqué, une exécution parallèle distribuée, la précision numérique, et une bibliothèque de fonctions mathématique étendue. La bibliothèque, essentiellement écrite dans le langage Julia lui-même, intègre également des bibliothèques matures et le nec-plus-ultra des langages [[langage C|C]] et [[Fortran|langage Fortran]] pour l'[[algèbre linéaire]], la génération des [[nombre aléatoire|nombres aléatoires]], les [[Transformée de Fourier rapide|FFTs]], et le [[traitement de chaînes]]. Des bibliothèques continuent d'être ajoutées au fil du temps. Les programmes Julia sont organisés autour de la définition de fonctions, et de leur surcharge autour de différents types de combinaisons de types d'argument&lt;ref&gt;{{Lien web |langue=en|url=http://julialang.org/|titre=Julia Official Website}}&lt;/ref&gt;

== Références ==
{{Références}}

==Liens externes==
* [http://julialang.org/ Julia official website]
* [http://bioinfo-fr.net/julia-le-successeur-de-r Découverte de Julia]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>6ou4n8bdprc5ng3yqlg23jdvpv6shvv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>C++</title>
    <ns>0</ns>
    <id>7445</id>
    <revision>
      <id>101031771</id>
      <parentid>100650757</parentid>
      <timestamp>2014-02-08T13:08:13Z</timestamp>
      <contributor>
        <username>OrlodrimBot</username>
        <id>1055871</id>
      </contributor>
      <minor/>
      <comment>[[Wikipédia:Outil de retour des lecteurs/Retrait de l'outil|Retrait]] de l'outil de retour des lecteurs</comment>
      <text xml:space="preserve" bytes="32946">{{Infobox Langage de programmation
| nom                    = C++
| logo                   = C plus plus.svg
| paradigme              = [[Généricité|générique]], [[Programmation orientée objet|orienté objet]], [[Programmation procédurale|procédural]]
| année                  = [[1983]]&lt;ref&gt;{{en}} 
{{Ouvrage
|titre=Bjarne Stroustrup's FAQ
|sous-titre=FAQ de Bjarne Stroustrup
|date=Modified February 2, 2012.
|auteur=Bjarne Stroustrup
|éditeur=research.att.com
|lire en ligne=http://www2.research.att.com/~bs/bs_faq.html#invention
}}
]&lt;/ref&gt; (dernière révision en [[C++11|2011]] et prochaines révisions prévues pour [[C++14|2014]] et [[C++17|2017]])
| auteur                 = [[Bjarne Stroustrup]]
| typage                 = [[Typage statique|statique]], [[Sûreté du typage|unsafe]], [[Système nominatif de types|nominatif]]
| implémentations        = [[GNU Compiler Collection]], [[Visual C++|Microsoft Visual C++]], [[C++Builder|Borland C++ Builder]], [[Xcode|XCode Tools]]
| normes                 = ISO/CEI 14882:1998&lt;br /&gt;ISO/CEI 14882:2003&lt;br /&gt;ISO/CEI 14882:2011

| influencé par          = [[C (langage)|C]], [[Simula]], [[Ada (langage)|Ada 83]], [[Algol 68]], [[CLU (langage)|CLU]], [[ML (langage)|ML]]
| a influencé            = [[Ada (langage)|Ada 95]], [[C sharp|C#]], [[PHP]], [[D (langage)|D]], [[JavaScript]], [[Java (langage)|Java]], [[X++]]
}}

Le '''C++''' est un [[langage de programmation]] permettant la programmation sous de multiples [[paradigme (programmation)|paradigmes]] comme la [[programmation procédurale]], la [[programmation orientée objet]] et la [[programmation générique]]. Le langage C++ n'appartient à personne et par conséquent n'importe qui peut l'utiliser sans besoin d'une autorisation ou obligation de payer pour avoir le droit d'utilisation.&lt;br&gt;&lt;br&gt;
C++ est l'un des langages de programmation les plus populaires, avec une grande variété de plateformes matérielles et de systèmes d'exploitation.

== Histoire ==
[[Fichier:BjarneStroustrup.jpg|thumb|Bjarne Stroustrup, l'inventeur de C++]]
[[Bjarne Stroustrup]] a développé C++ au cours des [[années 1980]], alors qu'il travaillait dans le laboratoire de recherche [[Laboratoires Bell|Bell]] d'[[AT&amp;T]]. Il s'agissait en l'occurrence d'améliorer le [[langage C]]. Il l'avait d'ailleurs nommé ''C with classes'' (« {{lang|en|C avec des classes}} »). Les premières améliorations se concrétisèrent donc par la prise en charge des classes, ainsi que par de nombreuses autres fonctionnalités comme les fonctions virtuelles, la surcharge des opérateurs, l'héritage (simple ou [[Héritage multiple|multiple]]), les {{Citation étrangère|lang=en|templates}}, la gestion des exceptions, etc.

Le langage C++ est [[norme industrielle|normalisé]] par l'[[Organisation internationale de normalisation|ISO]]. Sa première normalisation date de [[1998]] (ISO/CEI 14882:1998). Le standard a ensuite été amendé par l'erratum technique de [[2003]] ISO/CEI 14882:2003. Le standard actuel a été ratifié et publié par [[ISO]] en septembre 2011 sous le nom de ISO/IEC 14882:2011. (aussi appelé [[C++11]])&lt;ref&gt;&lt;!-- 
{{cite web|title=ISO/IEC 14882:2011|url=http://www.iso.org/iso/fr/catalogue_detail?csnumber=50372|publisher=ISO}} --&gt;
{{Ouvrage
|titre=ISO/IEC 14882:2011
|présentation en ligne=http://www.iso.org/iso/fr/catalogue_detail?csnumber=50372
|sous-titre=Technologies de l'information -- Langages de programmation -- C++
|année=2011-09-01
|publisher=ISO}}
&lt;/ref&gt;.
Les prochains standards du langage devraient être publiés en 2014 (mise à jour mineure) et en 2017&lt;ref&gt;[http://www.h-online.com/open/news/item/Next-C-standard-to-arrive-in-2017-1743138.html Next C++ standard to arrive in 2017]&lt;/ref&gt;.

En [[C (langage)|langage C]], '''++''' est l'opérateur d'incrémentation, c'est-à-dire l'augmentation de la valeur d'une variable de 1. C'est pourquoi C++ porte ce nom : cela signifie que C++ est un niveau au-dessus du C. Il existe de nombreuses bibliothèques C++ en plus de la [[bibliothèque standard de C++]] ({{lang|en|''C++ Standard Library''}}) qui est incluse dans la norme. Par ailleurs, C++ permet l'utilisation de l'ensemble des [[bibliothèque logicielle|bibliothèques]] C existantes.

== Fonctionnalités introduites par C++ ==
On peut considérer que C++ « est du C » avec un ajout de fonctionnalités. Cependant, certains programmes syntaxiquement corrects en C ne le sont pas en C++.

Les fonctionnalités ajoutées sont :
* les déclarations reconnues comme instructions (repris dans C99) ;
* les opérateurs &lt;tt&gt;new&lt;/tt&gt; et &lt;tt&gt;delete&lt;/tt&gt; pour la gestion d'allocation mémoire ;
* le type de données &lt;tt&gt;bool&lt;/tt&gt; (booléen) ;
* les [[Référence (informatique)|références]] ;
* le mot clé &lt;tt&gt;const&lt;/tt&gt; pour définir des constantes (repris par C à la fin des [[années 1980]]) ;
* les fonctions &lt;tt&gt;inline&lt;/tt&gt; (repris dans C99) ;
* les paramètres par défaut dans les fonctions ;
* les référentiels lexicaux (''[[Espace de noms]]'') et l'opérateur de résolution &lt;tt&gt;::&lt;/tt&gt; ;
* les [[classe (informatique)|classes]], ainsi que tout ce qui y est lié : l'[[héritage (informatique)|héritage]], les fonctions membres, les fonctions membres virtuelles, les [[constructeur (programmation)|constructeurs]] et le [[destructeur]] ;
* la [[surcharge des opérateurs]] ;
* les [[Template (programmation)|template]]s ;
* la [[Système de gestion d'exceptions|gestion d'exceptions]] ;
* l'identification de type pendant l'exécution ([[RTTI]] : {{lang|en|''run-time type information''}}) ;
* le [[commentaire (informatique)|commentaire]] sur une ligne introduit par « &lt;tt&gt;//&lt;/tt&gt; » (existant dans [[BCPL]], repris dans C99);
* les fonctions lambda (C++11);

La [[Compilateur|compilation]] d'un programme en C++ effectue également un contrôle plus minutieux sur le typage.

== Histoire de C++ ==

[[Bjarne Stroustrup|Stroustrup]] a commencé à travailler sur C avec classes en [[1979]]. L'idée de créer un nouveau langage vient de l'expérience en programmation de Stroustrup pour sa thèse de doctorat. Stroustrup trouvait que [[Simula]] avait des fonctionnalités très utiles pour le développement de gros programmes mais qu'il était trop lent pour être utilisé en pratique (cela était dû à un problème d'implémentation du compilateur [[Simula]]), tandis que [[BCPL]] était rapide mais de trop bas niveau et non adapté au développement de gros logiciels. Quand Stroustrup commença à travailler aux laboratoires Bell, on lui demanda d'analyser le [[noyau (informatique)|noyau]] [[UNIX]] en vue de faire du calcul distribué. Se rappelant sa thèse, Stroustrup commença à améliorer le langage [[C (langage)|C]] avec des fonctionnalités similaires à celle de [[Simula]]. C fut choisi parce qu'il est rapide, portable et d'usage général. En outre, il était une bonne base pour le principe original et fondateur de C++ : « vous ne payez pas pour ce que vous n'utilisez pas ». Dès le départ, le langage ajoutait à C la notion de classe (avec encapsulation des données), de classe dérivée, de vérification des types renforcés (typage fort), d'« inlining », et d'argument par défaut.

Comme Stroustrup développait C avec classes, il écrivit CFront, un compilateur qui générait du code source C à partir de code source C avec classes. La première commercialisation se fit en octobre [[1985]].

En [[1983]], le nom du langage passa de ''C avec classes'' à celui de « C++ ». Parmi les nouvelles fonctionnalités qui furent ajoutées au langage, il y avait les fonctions virtuelles, la surcharge des opérateurs et des fonctions, les références, les constantes, le contrôle du typage amélioré et les commentaires en fin de ligne. En [[1985]] fut publiée la première édition de {{lang|en|''The C++ programming Language''}}, apportant ainsi une référence importante au langage qui n'avait pas encore de standard officiel. En [[1989]], c'est la sortie de la version 2.0 de C++. Parmi les nouvelles fonctionnalités, il y avait l'[[héritage multiple]], les classes abstraites, les fonctions membres statiques, les fonctions membres constantes, et les membres protégés. En [[1990]], {{lang|en|''The Annotated C++ Reference Manual''}} (« ARM ») fut publié apportant les bases du futur standard. Les ajouts de fonctionnalités tardifs qu'il comportait couvraient les modèles, les exceptions, les espaces de noms, les nouvelles conversions et le type booléen.

Comme le langage C++ évoluait, la bibliothèque standard évoluait de concert. La première addition à la bibliothèque standard de C++ concernait les flux d'entrées/sorties qui apportaient les fonctionnalités nécessaires au remplacement des fonctions C traditionnelles telles que ''printf'' et ''scanf''. Ensuite, parmi les additions les plus importantes, il y avait la [[Standard Template Library]].

Après des années de travail, un comité réunissant l'[[American National Standards Institute|ANSI]] et l'[[Organisation internationale de normalisation|ISO]] standardisa C++ en [[1998]] (ISO/CEI 14882:1998), l'année où le comité de standardisation se réunissait à [[Sophia Antipolis]] dans le sud de la France. Pendant quelques années après la sortie officielle du standard, le comité traita le rapport de problèmes et publia une version corrigée du standard C++ en [[2003]].

Personne ne possède le langage C++. Il est libre de droit. Le document de standardisation n'est quant à lui pas disponible gratuitement.

== La bibliothèque standard (C++ standard library) ==

La [[bibliothèque standard du C++]] est en grande partie un sur-ensemble des fonctions disponibles dans la [[bibliothèque standard du C]]. Elle englobe la [[Standard Template Library]] (STL) qui met à la disposition du programmeur des outils puissants comme les collections (conteneurs) et les itérateurs.

À l'origine, la STL était une bibliothèque développée par [[Alexander Stepanov]] qui travaillait pour [[Hewlett-Packard]]. Dans la norme, celle-ci n'est pas appelée STL, car elle est considérée comme faisant partie de la [[bibliothèque standard du C++]]. Toutefois, beaucoup de personnes l'appellent encore de cette manière pour distinguer d'une part, les fonctions d'entrées/sorties comprises dans cette bibliothèque et, d'autre part, celles fournies par la bibliothèque C.

Comme en C, l'utilisation d'une bibliothèque se fait par l'intermédiaire de la directive &lt;code&gt;#include&lt;/code&gt; (suivie du nom du fichier d'en-tête).

== La programmation orientée objet en C++ ==
[[Fichier:Stream class Hierarchy.tif|thumb|upright=1.5|Exemple de hiérarchie de classes type stream]]
C++ utilise les concepts de la [[programmation orientée objet]] et permet entre autres :
* La [[classification]],
* L'[[Encapsulation (programmation)|encapsulation]],
* La composition de  [[classe (informatique)|classes]],
* L'association de  [[classe (informatique)|classes]],
* L'[[héritage (informatique)|héritage]], qui permet le [[polymorphisme (informatique)|polymorphisme]],
* L'[[héritage multiple]],
* L'[[Abstraction (informatique)|abstraction]],
* La [[généricité]],
* La [[méta-programmation]]

== L'encapsulation en C++ ==
L'encapsulation permet de faire abstraction du fonctionnement interne (c'est-à-dire, la mise en œuvre) d'une classe et ainsi de ne se préoccuper que des services rendus par celle-ci. C++ met en œuvre l'encapsulation en permettant de déclarer les membres d'une classe avec le mot réservé &lt;code&gt;public&lt;/code&gt;, &lt;code&gt;private&lt;/code&gt; ou &lt;code&gt;protected&lt;/code&gt;. Ainsi, lorsqu'un membre est déclaré :
* ''public'', il sera accessible depuis n'importe quelle fonction.
* ''private'', il sera uniquement accessible d'une part, depuis les fonctions qui sont membres de la classe et, d'autre part, depuis les fonctions autorisées explicitement par la classe (par l'intermédiaire du mot réservé &lt;code&gt;friend&lt;/code&gt;).
* ''protected'', il aura les mêmes restrictions que s'il était déclaré ''private'', mais il sera en revanche accessible par les classes filles.

C++ n'impose pas l'encapsulation des membres dans leurs classes. On pourrait donc déclarer tous les membres publics, mais en perdant une partie des bénéfices apportés par la programmation orientée objet. Il est de bon usage de déclarer toutes les données privées, ou au moins protégées, et de rendre publiques les méthodes agissant sur ces données. Ceci permet de cacher les détails de la mise en œuvre de la classe.

=== {{Citation étrangère|lang=en|Hello, world}} ===
Voici l'exemple de '''''[[Hello world]]''''' donné dans ''The C++ Programming Language, Third Edition''&lt;ref&gt;''The C++ Programming Language, Third Edition'', chap. 1.1.1, page 5&lt;/ref&gt; de [[Bjarne Stroustrup]] :
&lt;!-- NE PAS MODIFIER LE SOURCE CI-DESSOUS, QUI DOIT RESTER IDENTIQUE A CELUI DU LIVRE --&gt;
&lt;source lang=&quot;cpp&quot;&gt;
#include&lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &quot;Hello, new world!\n&quot;;
}
&lt;/source&gt;
&lt;!-- NE PAS MODIFIER LE SOURCE CI-DESSUS, QUI DOIT RESTER IDENTIQUE A CELUI DU LIVRE --&gt;

Une importante notion de C++ sont les [[Espace de noms#En informatique|espaces de noms]] ({{lang|en|''namespaces''}}). Dans un espace de noms sont définis des noms de fonctions et de variables. Ce mécanisme permet de résoudre les ambiguïtés lorsque plusieurs variables provenant de différents composants sont homonymes.
Pour recourir à une fonction d'un espace de nom, l'opérateur de résolution de portée « :: » est utilisé.
&lt;source lang=&quot;cpp&quot;&gt;
std::cout
&lt;/source&gt;
Ce code source fait appel à la variable globale &lt;tt&gt;cout&lt;/tt&gt; définie dans l'espace de nom standard (&lt;tt&gt;std&lt;/tt&gt;).

== La directive &lt;tt&gt;using&lt;/tt&gt; ==
Il est possible de spécifier un espace de nom précis à utiliser afin d'éviter d'avoir à recourir à l'opérateur de résolution de portée. Pour cela, le mot clé &lt;tt&gt;using&lt;/tt&gt; est utilisé avec cette syntaxe :
&lt;source lang=&quot;cpp&quot;&gt;
using namespace nom_du_namespace;
&lt;/source&gt;
Ainsi, pour utiliser la variable &lt;tt&gt;cout&lt;/tt&gt; définie dans le ''namespace'' standard sans utiliser l'opérateur de résolution de portée, il est possible d'écrire :
&lt;source lang=&quot;cpp&quot;&gt;
using namespace std;
&lt;/source&gt;
Cela est valable pour tous les [[Espace de noms#En informatique|espaces de noms]]. Cette instruction se place en général avant le début du code source proprement dit :
&lt;source lang=&quot;cpp&quot;&gt;
#include &lt;iostream&gt;
using namespace std;

int main() {
    cout &lt;&lt; &quot;Hello, new world !&quot; &lt;&lt; endl;
}
&lt;/source&gt;

using peut aussi être utilisé dans les classes. Si une classe B hérite d'une classe A, elle peut passer des attributs protected en public :
&lt;source lang=&quot;cpp&quot;&gt;
class A {
  protected:
  void f() { /* code */ }
};

class B: public A {
  public:
  using A::f;
};

//quelque part dans le code
B b;
b.f(); // cet appel est possible
A a;
a.f(); // cet appel est impossible (membre de classe non accessible)
&lt;/source&gt;

== Déclaration et définition de classe ==

Il est d'usage de séparer prototype (déclaration) et implémentation (définition) de classe dans deux fichiers :
La déclaration se fait dans un fichier d'en-tête (dont l'extension varie selon les préférences des développeurs : sans extension dans le standard, .h comme en C, .hh ou .hpp pour différencier C et C++) alors que la définition de la classe se fera dans un fichier source (d'extension également variable, en général .C, .cc, .cpp ou .cxx).

=== Déclaration de classe ===
Exemple de la déclaration de la classe MessageInternet comportant des attributs privés et des [[méthode (informatique)|méthodes]] publiques dont le [[constructeur (informatique)|constructeur]] 'MessageInternet' :

&lt;source lang=&quot;cpp&quot;&gt;
// messageinternet.hpp
#include &lt;string&gt;

class MessageInternet
{
private:
   const std::string m_sujet, m_expediteur, m_destinataire; //attributs : toujours privés

public:
   MessageInternet(const std::string&amp; sujet, const std::string&amp; expediteur, const std::string&amp; destinataire); //constructeur
   std::string get_sujet() const; //méthode publique
   std::string get_expediteur() const; //méthode publique
   std::string get_destinataire() const; //méthode publique
};
&lt;/source&gt;

=== Implémentation (définition) de classe ===
Dans le fichier source, le nom d'une méthode définie par une classe doit nécessairement être précédé du nom de la classe suivi immédiatement des caractères &quot;::&quot;.

Par exemple, voici l'implémentation (définition) de la classe déclarée précédemment :
&lt;source lang=&quot;cpp&quot;&gt;
//messageinternet.cpp
#include &quot;messageinternet.hpp&quot;

MessageInternet::MessageInternet(const std::string&amp; sujet, const std::string&amp; expediteur, const std::string&amp; destinataire) : m_sujet(sujet), m_expediteur(expediteur), m_destinataire(destinataire)
{
    //constructeur
}

MessageInternet::~MessageInternet()
{
    //destructeur : libérer ici les ressources acquises. Dans notre cas, il n'y a rien à faire.
}

std::string MessageInternet::get_sujet() const
{
    return m_sujet; //Renvoie une copie de m_sujet.
}

std::string MessageInternet::get_expediteur() const
{
    return m_expediteur; //Renvoie une copie de m_expediteur
}

std::string MessageInternet::get_destinataire() const
{
    return m_destinataire; //Renvoie une copie de m_destinataire
}
&lt;/source&gt;

== Templates ==
=== À quoi servent les templates ? ===
Les templates permettent d'écrire des fonctions et des classes en paramétrant le type de certains de leurs constituants (type des paramètres ou type de retour pour une fonction, type des éléments pour une classe collection par exemple). Les templates permettent d'écrire du code générique, c'est-à-dire qui peut servir pour une ''famille'' de fonctions ou de classes qui ne diffèrent que par la valeur de ces paramètres.

=== Paramètres des templates ===

Les paramètres peuvent être de différentes sortes :
* Types simples : ''class'', ''struct'', types élémentaires comme ''int'', ''float'', etc.
* Tableaux de taille constante, dont la taille, déduite par le compilateur, peut être utilisée dans l'instanciation du [[template]].
* Constantes scalaires, c'est-à-dire de type dérivant des entiers (int, long, bool), mais pas double ou float (car leur représentation binaire ne fait pas partie de la norme du langage C++).
* Templates : La définition d'un template peut être passée à un template, ce qui permet notamment de s'appuyer sur la définition abstraite, par exemple, d'un conteneur.
* Pointeurs ou références, à condition que leur valeur soit définie à l'édition de liens.
* Fonction membre, dont la signature et la classe doivent être aussi passées en paramètres.
* Membre d'une classe, dont le type et la classe doivent être aussi passés en paramètres du template.

=== Pourquoi utiliser des templates ? ===
En programmation, il faut parfois écrire de nombreuses versions d'une même fonction ou classe suivant les types de données manipulées.

Par exemple, un tableau de &lt;tt&gt;int&lt;/tt&gt; ou un tableau de &lt;tt&gt;double&lt;/tt&gt; sont très semblables, et les fonctions de tri ou de recherche dans ces tableaux sont identiques, la seule différence étant le type des données manipulées.

En résumé, l'utilisation des templates permet de « paramétrer » le type des données manipulées.

=== Avantages à utiliser des templates ===
* écritures uniques pour les fonctions et les classes.
* moins d'erreurs dues à la réécriture.
* performances améliorées grâce à la spécialisation en fonction des types de données.

=== Exemple de templates ===
Dans la bibliothèque standard C++, on trouve de nombreux templates. On citera à titre d'exemple, les entrées/sorties, les chaînes de caractères ou les conteneurs. Les classes ''string'', ''istream'', ''ostream'' et ''iostream'' sont toutes des instanciations de type ''char''.

Les fonctions de recherche et de tri sont aussi des templates écrits et utilisables avec de nombreux types.

&lt;source lang=&quot;cpp&quot;&gt;
// La fonction template max peut être appelée avec tout type copiable
// et comparable avec l'opérateur &lt;.
template &lt;typename T&gt;
T max(T a, T b)
{
    return a &lt; b ? b : a;
}

# include &lt;string&gt;
int main()  // fonction main
{
    int i = max(3, 5);
    char c = max('e', 'b');
    std::string s = max(std::string(&quot;hello&quot;), std::string(&quot;world&quot;));
    float f = max&lt;float&gt;(1, 2.2f);
    return 0;
}
&lt;/source&gt;

Dans la ligne &lt;code&gt;float f = max&lt;float&gt;(1, 2.2f)&lt;/code&gt;, on doit explicitement donner le type &lt;code&gt;float&lt;/code&gt; pour le type paramétré &lt;code&gt;T&lt;/code&gt; car le compilateur ne déduit pas le type de &lt;code&gt;T&lt;/code&gt; lorsqu'on passe en même temps un &lt;code&gt;int&lt;/code&gt; (1) et un &lt;code&gt;float&lt;/code&gt; (2.2f).

=== Spécialisation des templates ===

Un template donné peut avoir plusieurs instanciations possibles selon les types donnés comme paramètres. Si un seul paramètre est spécialisé, on parle de ''spécialisation partielle''. Ceci permet par exemple :
* De choisir un type de calcul selon qu'un type est un entier, un nombre flottant, une chaîne de caractères, etc. Spécialisons l'exemple précédent pour le cas des pointeurs de chaines de caractères :
&lt;source lang=&quot;cpp&quot;&gt;
template &lt;&gt; const char* max(const char* a, const char* b)
{
    return (strcmp(a, b) &gt; 0 ? a : b);
}
&lt;/source&gt;

* D'effectuer au moment de la compilation des calculs arithmétiques, si et seulement si tous les arguments sont connus à ce moment. Un exemple classique est le calcul de la fonction [[factorielle]]:
&lt;source lang=&quot;cpp&quot;&gt;
template &lt;size_t N&gt;
struct CalcCompileTime
{
    const static size_t Fact = N * CalcCompileTime&lt;N - 1&gt;::Fact ;
};

template &lt; &gt;
struct CalcCompileTime &lt;0&gt;
{
    const static size_t Fact = 1 ;
};
&lt;/source&gt;

=== SFINAE ===
Le mécanisme décrit par l'abréviation '''SFINAE''' (''Substitution Failure Is Not An Error'') permet de surcharger un template par plusieurs classes, même si certaines spécialisations, par exemple, ne peuvent pas être utilisées pour tous les paramètres de templates. Le compilateur, lors de la substitution, ignore alors les instantiations inapplicables, au lieu d'émettre une erreur de compilation.

== Le polymorphisme et les méthodes virtuelles en C++ ==

Le [[Polymorphisme (informatique)|polymorphisme]] est mis en œuvre à l'aide du mécanisme des méthodes virtuelles en C++. Lorsqu'une méthode virtuelle est appelée, l'implémentation de la méthode exécutée est choisie en fonction du type réel de l'objet. L'appel n'est donc résolu qu'à l'exécution, le type de l'objet ne pouvant pas - a priori - être connu à la compilation.
Un mot clé est alors introduit : &lt;code&gt;virtual&lt;/code&gt;. Ce mot clé est placé devant la déclaration de la méthode.

Le mot clé &lt;code&gt;virtual&lt;/code&gt;, placé devant le prototype de la fonction, indique au compilateur que la fonction est susceptible d'être redéfinie dans une classe dérivée. Il suffit alors de dériver une classe et de définir une nouvelle fonction de même signature (même nom, paramètres compatibles - voir la notion de covariance).
Ainsi l'appel de cette fonction sur un objet dont on ignore le type, mais accédé en tant qu'objet de la classe de base, pourra donner lieu à l'appel de la fonction définie dans la classe dérivée.

Il est généralement conseillé d'utiliser le mot clé &lt;code&gt;virtual&lt;/code&gt; devant la déclaration du destructeur de la classe de base, afin que celui des sous-classes soit appelé également lorsque le programme utilise un pointeur d'instance de la classe de base au lieu d'un pointeur d'instance de la classe dérivée si et seulement si la classe de base peut être utilisée pour manipuler des classes dérivées.

Ce type de polymorphisme est dit dynamique. Le mécanisme de la [[Surcharge des opérateurs|surcharge]] est un polymorphisme statique. Dans les deux cas il faut appliquer une logique (par exemple : le nombre et le type des paramètres) pour résoudre l'appel. Dans le cas de la surcharge, la logique peut être entièrement calculée à la compilation. Ce calcul permet des [[Optimisation de code|optimisations]] rendant le polymorphisme statique &quot;plus rapide&quot; que sa version dynamique. La liaison dynamique de méthodes issues du mécanisme des méthodes virtuelles induit souvent une table cachée de résolution des appels. Cette table cachée des méthodes augmente le temps nécessaire à l'appel de méthode à l'exécution par l'ajout d'une [[indirection]] supplémentaire.

Le choix entre liaison dynamique et surcharge (polymorphisme dynamique et statique) est typiquement un problème de [[Calculable|calculabilité des appels]], ayant souvent pour conséquence finale un choix entre expressivité et performance.

== Bibliographie ==
=== Ouvrages en langue anglaise ===

* Deitel P., Deitel H., ''C++ How to program'', 20 Hall, 2011 ({{8th}} edition), {{ISBN|978-0-132-66236-9}}, 1104 pages
* Dawson M., ''Beginning C++ Through Game Programming'', Course Technology PTR, 2010 ({{3rd}} edition), {{ISBN|978-1-435-45742-3}}, 432 pages. Ouvrage pour débutants dont la pédagogie prend acte du fait que le C++ fait tourner la plupart des jeux vidéo actuels.
* Marc Gregoire, Nicolas A. Solter, Scott J. Kleper, ''Professional C++'', John Wiley, October 2011, {{ISBN|978-0470932445}}, 1104 pages. Cet ouvrage couvre la norme C++11.
* Nicolaï Josuttis, ''The C++ Standard Library, A Tutorial and Reference'', Addison-Wesley, 2011, Seconde Édition Révisée, {{ISBN|978-0-321-62321-8}}, 1099 pages. Cet ouvrage couvre la norme C++11.
* Koenig A., Moo B., ''Accelerated C++ - Practical Programming by Example'', Addison-Wesley, 2000 ({{1st}} edition), {{ISBN|978-0-201-70353-5}}, 352 pages
* Stanley B. Lippman, Josée Lajoie, Barbara E. Moo, ''C++ Primer'', août 2012, ({{5th}} edition), {{isbn|978-0-321-71411-4}}. Cet ouvrage couvre la norme C++11.
* Lischner R., ''C++ in a nutshell'', O'Reilly Media, 2003 ({{1st}} edition), {{ISBN|978-0-596-00298-5}}, 704 pages. L'auteur a aussi produit un petit manuel de référence sur la [[Standard Template Library|STL]], toujours aux éditions O'Reilly.
* Meyers S., ''Effective C++ - 55 Specific Ways to Improve Your Programs and Designs'', Addison-Wesley Professional, 2005 ({{3rd}} edition), {{ISBN|978-0-321-33487-9}}, 320 pages. Mêmes principes que les ouvrages de Sutter, et même public visé.
* Oualline S., ''Practical C++ programming'', O'Reilly Media, 2003 ({{2nd-en}} edition), {{ISBN|978-0-596-00419-4}}, 600 pages
* Lafore R., ''Object-oriented programming in C++'', Sams, 2001 ({{4th}} edition), {{ISBN|978-0-672-32308-9}}, 1040 pages
* Prata S., ''C++ Primer Plus (Developer's Library)'', Addison-Wesley Professional, 2011 (6th édition), {{ISBN|978-0-321-77640-2}}, 1200 pages. Cette édition couvre les nouveautés apportées par le standard C++11.
* [[Bjarne Stroustrup|Stroustrup B.]], ''Programming: Principles and Practice using C++'', Addison-Wesley 2009, {{ISBN|978-0321543721}}
* [[Bjarne Stroustrup|Stroustrup B.]], ''The C++ Programming Language'', Addison-Wesley Professional, 2013 ({{4th}} edition), {{ISBN|978-0-321-56384-2}}, 1368 pages
* [[Bjarne Stroustrup|Stroustrup B.]], ''The Design and Evolution of C++'', Addison-Wesley professional, 1994 ({{1st}} edition), {{ISBN|978-0-201-54330-8}}, 480 pages
* Sutter H., ''Exceptional C++'', Addison-Wesley Professional, 1999, {{ISBN|978-0-201-61562-3}}, 240 pages. Publié aux éditions Eyrolles en 2000 sous le titre ''Mieux programmer en C++ - 47 problèmes pratiques résolus''. Herb Sutter, spécialiste reconnu du C++, a produit deux suites à ce premier ouvrage, toujours basées sur des études de cas, à savoir : ''More exceptional C++'' (Addison-Wesley - 2001) et ''Exceptional C++ style'' (Addison-Wesley - 2004). Tous ces ouvrages concernent à priori des développeurs confirmés maîtrisant bien le langage C++.
* David Vandevoorde, Nicolaï Josuttis, ''C++ Templates: the Complete Guide'', Addison-Weslay, 2002, {{ISBN|978-0-201-73484-3}}
* Vandevoorde D., ''C++ Solutions: Companion to the C++ Programming Language'', Addison-Wesley, 1998 ({{3rd}} edition), {{ISBN|978-0201309652}}, 292 pages. Contient la correction de nombre des exercices de l'ouvrage de Stroustrup, ''Le langage C++''.

=== Ouvrages en langue française ===

* Chappelier J-C., Seydoux F., ''C++ par la pratique - Recueil d'exercices corrigés et aide-mémoire'', PPUR, 2005 ({{2e}} édition), {{ISBN|978-2-880-74732-9}}, 412 pages
* Deitel P., Deitel H., ''Comment programmer en C++'', Éditions Reynald Goulet, 2004, {{ISBN|978-2-893-77290-5}}, 1178 pages. La dernière traduction disponible de l'ouvrage des Deitel père et fils ; correspond à la troisième édition en langue anglaise.
* Delannoy C., ''Programmer en langage C++'', Éditions Eyrolles, 2011 ({{8e}} édition), {{ISBN|978-2-212-12976-2}}, 822 pages
* Delannoy C., ''Exercices en langage C++'', Éditions Eyrolles, 2007 ({{3e}} édition), {{ISBN|978-2-212-12201-5}}, 336 pages
* Geron A., Tawbi F., ''Pour mieux développer avec C++'', Éditions Dunod - 01 Informatique, [[2003]], {{ISBN|978-2-100-07348-1}}
* Guidet A., ''Programmation Objet en langage C++'', Ellipses Marketing, 2008, {{ISBN|978-2-729-83693-1}}, 364 pages
* Hubbard J., ''C++'', Éditions Dunod - Collection Mini Schaum's, 2002, {{ISBN|978-2-100-06510-3}}, 192 pages. Pour débutants pressés.
* Liberty J., Jones B., ''Le langage C++'', CampusPress, 2005, {{ISBN|978-2-744-01928-9}}, 870 pages
* Stephens R., Diggins C., Turkanis J., Cogswell J., ''C++ en action'', O'Reilly éditions, 2006, {{ISBN|978-2-841-77407-4}}, 555 pages. Traduction de l'ouvrage en langue anglaise ''C++ Cookbook - Solutions and Examples for C++ Programmers'' paru aux États-Unis chez O'Reilly en 2005.
* [[Bjarne Stroustrup|Stroustrup B.]], ''Programmation - Principes et pratique avec C++'', Pearson, {{ISBN| 978-2744074424}}, 2010. Traduction de ''Programming : Principles and Parameters Using C++'' (cf.supra).
* [[Bjarne Stroustrup|Stroustrup B.]], ''Le langage C++'', Pearson Education, 2003, {{ISBN|978-2-7440-7003-7}}, 1100 pages. Traduction de ''The C++ Programming Language: Special Edition'' (cf. supra).
* Sutter H., Alexandrescu A., ''Standards de programmation en C++'', Pearson Education, 2005, {{ISBN|978-2-744-07144-7}}, 226 pages. Traduction de l'ouvrage en langue anglaise ''C++ Coding Standards: 101 Rules, Guidelines, and Best Practices'' (Addison-Wesley - 2004).
* Guidet A., ''Programmation objet en C++'', édition Ellipses, 2008, {{ISBN|2729836934}}

== Construction ==

Un programme C++ peut être produit avec des outils qui automatisent le processus de construction. Les plus utilisés sont :
* [[Make]]
* [[Apache Ant|Ant]] (génération portable en XML)
* [[SCons]] (génération portable en Python).
* [[CMake]] génération de [[Makefile]] portable

=== Environnements de développement ===
* [[Anjuta|Anjuta DevStudio]]
* [[C++ Builder]] 
* [[Code::Blocks]] (open-source)
* [[Dev-C++]] et son extension [[Outils RAD|RAD]] [[WxDev-C++]]
* [[Eclipse (logiciel)|Eclipse]] avec le plugin CDT&lt;ref&gt;[http://www.eclipse.org/cdt/ Plugin CDT pour Eclipse]&lt;/ref&gt; (open-source)
* [[Emacs]] (Libre)
* [[KDevelop]]
* [[NetBeans]] (open-source)
* [[QtCreator]] (open-source)
* [[Sun Studio]]
* [[Visual Studio|Microsoft Visual C++]]
* [[Xcode]]

=== Compilateurs C++ ===

* ''[[GNU Compiler Collection]]'' ([[UNIX]], Windows, DOS, etc.)
* ''[[Microsoft Visual C++]]'' (Windows)
* [[C++ Builder|Borland C++ Builder]] (Windows)
* [[Intel C++ Compiler]] (Windows, [[Linux]], [[Mac OS X|MacOS]])
* {{Lien|Open64|lang=en}} compilateur [[opensource]] d'AMD ([[Linux]]) 
* [[Digital Mars]] C/C++ compiler (Windows)
* ''Comeau C++ Compiler
* [[Compilateurs C, C++ et Fortran Watcom|Watcom C++]]
* [[Clang]]

=== Bibliothèques C++ ===
* [[Boost (bibliothèques)|Boost]]
* [[Gtkmm]]
* [[Qt]]
* [[wxWidgets]]
* [[SFML]]
* [[OpenCV]]
* [[SDLmm]], surcouche C++ à la [[Simple DirectMedia Layer|SDL]]
* [[LLVM]]

== Notes et références ==
{{Références}}

== Voir aussi ==
{{Autres projets
  | wikiversity = Langage C++
  | wikibooks = Programmation C plus plus
  | wikibooks titre = La programmation C++
}}

=== Article connexe ===
* [[C (langage)|Le langage C]]

=== Liens externes ===
* {{dmoz|langage C++|http://www.dmoz.org/World/Fran%c3%a7ais/Informatique/Programmation/Langages/C%2b%2b/}}
* {{en}} {{dmoz|langage C++|http://www.dmoz.org/Computers/Programming/Languages/C++/}}
&lt;!-- Dans le but de limiter les liens externes puisque Wikipédia n'a pas vocation à être un annuaire, les liens externes sont limités aux catégories de DMOZ, qui est un annuaire régit par un même esprit que celui de wikipédia et où vous êtes invités à enregistrer votre site plutôt que de l'ajouter ici --&gt;

{{Palette|Langages de programmation|Normes ISO}}
{{Portail|programmation informatique|informatique}}

{{DEFAULTSORT:C plus plus}}
[[Catégorie:C++| ]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Norme ISO]]</text>
      <sha1>gm93o2wl30mnmjpgvxuhsinioyskpra</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>CoffeeScript</title>
    <ns>0</ns>
    <id>6181495</id>
    <revision>
      <id>98332330</id>
      <parentid>98332236</parentid>
      <timestamp>2013-11-13T20:19:58Z</timestamp>
      <contributor>
        <username>Felipe</username>
        <id>33087</id>
      </contributor>
      <minor/>
      <comment>/* fonctions et jQuery */ &quot;JavaScript&quot; et non &quot;javascript&quot;</comment>
      <text xml:space="preserve" bytes="9261">{{Infobox Langage de programmation
 | couleur boîte                    = eeeeee
 | nom et logo                      = oui
 | logo                             = CoffeeScript-logo.png
 | paradigme                        = [[Paradigme de programmation|Multi-paradigme]]
 | auteur                           = Jeremy Ashkenas
 | date de première version         = {{date|13|décembre|2009}}
 | typage                           = [[Typage dynamique|Dynamique]], [[Typage faible|faible]]
 | influencé par                    = [[JavaScript]], [[Python (langage)|Python]], [[Ruby]], [[Haskell]]&lt;ref name=&quot;changelog&quot; /&gt;, [[YAML]]&lt;ref name=&quot;smell&quot;&gt;{{article|langue=en|url=http://www.javaworld.com/javaworld/jw-10-2011/111018-coffeescript-vs-dart.html|titre=Turn up your nose at Dart and smell the CoffeeScript|nom=Heller|prénom=Martin|date=18 octobre 2011|périodique=JavaWorld|éditeur=InfoWorld|consulté le=9 février 2012}}&lt;/ref&gt;
 | a influencé                      = MoonScript
 | système d'exploitation           = [[Multiplate-forme]]
 | licence                          = [[Licence MIT]]
 | site web                         = [http://coffeescript.org/ coffeescript.org]
}}

'''CoffeeScript''' est un [[langage de programmation]], qui se [[Compilateur|compile]] en [[JavaScript]]. Le langage ajoute du [[sucre syntaxique]] inspiré par [[Python (langage)|Python]], [[Ruby]] et [[Haskell]]&lt;ref name=&quot;changelog&quot;&gt;The Changelog. [http://thechangelog.com/post/849754840/episode-0-2-9-coffeescript-with-jeremy-ashkenas Épisode 0.2.9 - CoffeeScript with Jeremy Ashkenas], Jul 23, 2010&lt;/ref&gt; afin d'améliorer la brièveté et la lisibilité du JavaScript, tout en ajoutant des fonctionnalités comme le [[filtrage par motif]] ou les [[liste en compréhension|listes en compréhension]].

Le résultat est compilé de façon prévisible en JavaScript, et les programmes peuvent être écrits avec moins de code (typiquement un tiers de lignes en moins) sans effet sur la vitesse d'exécution&lt;ref&gt;Read Write Hack. {{lien brisé|consulté le=2013-04-12|url=http://www.readwriteweb.com/hack/2011/01/interview-coffeescript-jeremy-ashkenas.php|titre=Interview with Jeremy Ashkenas}}, Jan 7, 2011&lt;/ref&gt;. Depuis le {{date|16|mars|2011}}, CoffeeScript est dans la liste des projets les plus populaires de [[GitHub]]&lt;ref&gt;Github. [http://github.com/popular/watched Popular Watched Repositories]&lt;/ref&gt;.

Le langage a une popularité relativement importante dans la communauté de Ruby. Le support de CoffeeScript est inclus dans la version 3.1 de [[Ruby on Rails]]&lt;ref&gt;Peek, Joshua. [http://twitter.com/joshpeek/status/58184348742074368 Tweet by Rails Core Team Member] on Apr 13, 2011&lt;/ref&gt;. De plus, [[Brendan Eich]] a cité CoffeeScript comme une influence sur son idée du futur du JavaScript&lt;ref&gt;Eich, Brendan. &quot;[http://brendaneich.com/2011/01/harmony-of-my-dreams/ Harmony of My Dreams]&quot;&lt;/ref&gt;{{,}}&lt;ref&gt;Eich, Brendan. &quot;[http://brendaneich.com/2011/05/my-jsconf-us-presentation/ My JSConf.US Presentation]&quot;&lt;/ref&gt;.

== Histoire ==
Le {{date|13|décembre|2009|en informatique}}, Jeremy Ashkenas a effectué le premier [[commit]] [[Git (software)|Git]] de CoffeeScript avec le commentaire : « ''{{lang|en|initial commit of the mystery language}}'' » (« premier commit du langage mystère »)&lt;ref&gt;Github. [https://github.com/jashkenas/coffee-script/commit/8e9d637985d2dc9b44922076ad54ffef7fa8e9c2  'initial commit of the mystery language']&lt;/ref&gt;. Le compilateur était écrit en Ruby. Le {{date|24|décembre|2009|en informatique}}, il a publié la première version numérotée et documentée, la 0.1.0. Le {{date|21|février|2010|en informatique}}, le version 0.5 a été publiée, remplaçant le compilateur Ruby par un compilateur écrit en pur CoffeeScript. {{refsou|À ce moment, le projet a attiré plusieurs autres contributeurs sur [[GitHub]], et les pages du site étaient vues plus de 300 fois par jour.}}

Le {{date|24|décembre|2010|en informatique}}, Ashkenas a annoncé la publication de la version stable 1.0.0 sur [[Hacker News]], le site où le projet a été annoncé pour la première fois&lt;ref&gt;Hacker News. [http://news.ycombinator.com/item?id=2037801 Annonce de CoffeeScript 1.0.0] publiée par Jeremy Ashkenas le {{date|24|décembre|2010|en informatique}}&lt;/ref&gt;{{,}}&lt;ref&gt;Hacker News. [http://news.ycombinator.com/item?id=1014080 Annonce originale de CoffeeScript] publiée par Jeremy Ashkenas le {{date|24|décembre|2009|en informatique}}&lt;/ref&gt;.

== Exemples ==

=== Tests et compréhensions ===

Pour calculer l'[[indice de masse corporelle|IMC]] de [[Barack Obama|Barry]], joueur de basket amateur, on fait d'habitude quelque chose comme ceci (ici en [[JavaScript]]):

&lt;source lang=&quot;javascript&quot;&gt;
var masse = 72;
var taille = 1.86;
var IMC = masse/taille/taille;
if ((18.5 &lt; IMC) &amp;&amp; (IMC &lt; 25)) {
    alert('Barry a une corpulence normale');
}
&lt;/source&gt;

CoffeeScript permet de combiner les deux tests en un seul:

&lt;source lang=&quot;coffeescript&quot;&gt;
masse = 72
taille = 1.78
IMC = masse/taille/taille
if 18.5&lt;IMC&lt;25 then alert 'Barry a une corpulence normale'
&lt;/source&gt;

ou, plus naturellement pour qui est habitué à la langue anglaise,

&lt;source lang=&quot;coffeescript&quot;&gt;
masse = 72
taille = 1.78
IMC = masse/Math.pow taille, 2 
alert 'Barry a une corpulence normale' if 18.5&lt;IMC&lt;25
&lt;/source&gt;

=== Boucles et compréhensions ===

En général, l'implémentation de l'[[algorithme d'Euclide]] utilise une boucle ''tant que'' (ici, en Python):

&lt;source lang=&quot;python&quot;&gt;
def pgcd(a,b):
    x,y=a,b
    while y&gt;1:
        x,y=y,x%y
    return x
&lt;/source&gt;

C'est également possible en CoffeeScript; mais celui-ci possède également une boucle ''jusqu'à'':

&lt;source lang=&quot;coffeescript&quot;&gt;
pgcd = (a,b) -&gt;
    [x,y] = [a,b]
    [x,y] = [y,x%y] until y is 0
    x
&lt;/source&gt;

Une boucle ''for'' peut souvent être remplacée par une [[liste en compréhension]]. Par exemple, pour calculer les carrés des premiers nombres impairs (c'est-à-dire dont le reste modulo 2 vaut 1), on peut utiliser l'une des propositions suivantes:

==== boucle classique ====

&lt;source lang=&quot;coffeescript&quot;&gt;
for n in [1..10]
    if n%2 is 1 then alert n*n
&lt;/source&gt;

==== liste en compréhension ====

&lt;source lang=&quot;coffeescript&quot;&gt;
alert [n*n for n in [1..10] when n%2 is 1]
&lt;/source&gt;

==== avec un pas de 2 ====

&lt;source lang=&quot;coffeescript&quot;&gt;
alert [n*n for n in [1..10] by 2]
&lt;/source&gt;


=== fonctions et [[jQuery]] ===


Le code JavaScript permettant d'initialiser la [[bibliothèque logicielle|bibliothèque]] [[jQuery]] est :

&lt;source lang=&quot;javascript&quot;&gt;
$(document).ready(function() {
  // Le code d'initialisation va ici
});
&lt;/source&gt;

Ou, plus simplement :

&lt;source lang=&quot;javascript&quot;&gt;
$(function() {
  // Le code d'initialisation va ici
});
&lt;/source&gt;

En CoffeeScript, le mot-clé &lt;code&gt;function&lt;/code&gt; est remplacé par le symbole &lt;code&gt;-&gt;&lt;/code&gt;, et l'indentation est utilisée à la place des accolades, comme en [[Python (langage)|Python]] ou en [[Haskell]]. Les parenthèses peuvent généralement être omises. Ainsi, le [[snippet]] ci-dessus peut être écrit, en CoffeeScript :

&lt;source lang=&quot;ruby&quot;&gt;
$(document).ready -&gt;
  # Le code d'initialisation va ici
&lt;/source&gt;

Ou bien :

&lt;source lang=&quot;ruby&quot;&gt;
$ -&gt;
  # Le code d'initialisation va ici
&lt;/source&gt;

== Compilation==
Le compilateur CoffeeScript est [[Auto-hébergement (informatique)|écrit en CoffeeScript]] depuis la version 0.5 et est disponible en tant qu'utilitaire [[Node.js]] ; cependant, la base du compilateur ne nécessite pas [[Node.js]] et peut être utilisée dans n'importe quel environnement [[JavaScript]]&lt;ref&gt;http://jashkenas.github.com/coffee-script/#installation&lt;/ref&gt;. Une des alternatives à l'utilitaire [[Node.js]] est [https://github.com/talios/coffee-maven-plugin Coffee Maven Plugin], un plugin pour le [[moteur de production]] [[Apache Maven]]. Ce plugin utilise [[Rhino (moteur JavaScript)|Mozilla Rhino]], un moteur JavaScript écrit en [[Java (langage)|Java]].

Le site officiel, [http://coffeescript.org CoffeeScript.org], dispose d'un bouton « Essayer CoffeeScript » dans la barre de navigation ; cliquer dessus ouvre une [[fenêtre modale]] qui permet d'entrer du code CoffeeScript, de voir le résultat en JavaScript, et de l'essayer directement dans le navigateur. Le site [http://js2coffee.org jscoffee] propose une traduction bidirectionnelle.

== Notes et références ==
&lt;references /&gt;

== Voir aussi ==
=== Articles connexes ===
* [[JavaScript]]
* [[Dart (langage informatique)|Dart]]
* [[Haxe]]
* [[TypeScript]]
* [[Préprocesseur]]

=== Liens externes ===
* {{officiel|en|http://coffeescript.org}}
* {{en}} [http://github.com/jashkenas/coffee-script/ Dépôt GitHub]
* {{en}} [http://coffeescriptcookbook.com/ CoffeeScript Cookbook]
* {{en}} [http://arcturo.github.com/library/coffeescript/ The Little Book on CoffeeScript]
* {{en}} [http://autotelicum.github.com/Smooth-CoffeeScript/ Smooth CoffeeScript]

{{Palette|Langages de programmation}}
{{Portail|logiciels libres|programmation informatique}}

{{DEFAULTSORT:Coffeescript}}
[[Catégorie:JavaScript]]
[[Catégorie:Logiciel libre sous licence MIT]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Langage fonctionnel]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage de script]]</text>
      <sha1>0nsb05roj5vbqqz4t9n3y7ad881osbd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Logtalk</title>
    <ns>0</ns>
    <id>6237862</id>
    <revision>
      <id>96720994</id>
      <parentid>90985063</parentid>
      <timestamp>2013-09-16T22:07:42Z</timestamp>
      <contributor>
        <username>WikiCleanerBot</username>
        <id>351003</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.29b - [[P:CS|Correction syntaxique]] - Caractères de contrôle</comment>
      <text xml:space="preserve" bytes="1040">{{Infobox Langage de programmation
 | nom = Logtalk
 | année = [[1998]]
 | auteur = [[Paulo Moura (informaticien)|Paulo Moura]]
 | logo = 
 | paradigmes = [[Programmation logique]]
 | développeur = 
 | typage = 
 | influencé par = [[Prolog]], [[Smalltalk]] ; [[programmation logique]], [[programmation orientée objet]], [[programmation orientée prototype]]
 | système d'exploitation = [[Multiplate-forme]]
 | dernière version avancée         = 2.44.0
 | date de dernière version stable  = {{Date|07|mars|2012|en informatique}}
 | licence = [[Artistic License|Artistic License 2.0]]
 | site web = http://logtalk.org
}}
{{ébauche|informatique}}

'''Logtalk''' est un langage de programmation logique, orienté objet, issu de [[Prolog]].

==Exemple==
&lt;source lang=&quot;text&quot;&gt;
?- write('Hello world'), nl.
Hello world
true.
&lt;/source&gt;

{{Palette|Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de programmation logique]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>au0zavqv177iwnhvt81x29g8q2fx8mz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Langage de programmation Red</title>
    <ns>0</ns>
    <id>5440456</id>
    <revision>
      <id>90863427</id>
      <parentid>81240213</parentid>
      <timestamp>2013-03-19T10:59:48Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 1 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3217187]]</comment>
      <text xml:space="preserve" bytes="4354">
{{sources|date=avril 2011}}
{{Infobox Langage de programmation
| nom                    = Red
| logo                   = Logo R Redlang.png
| année                  = [[2011]]
| auteur                 = [[Nenad Rakocevic]]
| développeur            = Nenad Rakocevic
| influencé par          = [[REBOL]], [[Scala]], [[Lua]]
| paradigmes             = [[Programmation impérative|impératif]], [[Programmation fonctionnelle|fonctionnel]]
| typage                 = [[Typage fort|Fort]], [[Typage statique|statique]]
| système d'exploitation = [[Multiplateforme]]
| licences               = [[Licence BSD modifiée]]
| site web               = {{Site officiel|en|http://www.red-lang.org}}
}}

'''Red''' est un langage de [[programmation impérative|programmation impératif]] et [[Programmation fonctionnelle|fonctionnel]] créé en [[2011]] par [[Nenad Rakocevic]]. Il est distribué en tant que [[logiciel libre]] selon les termes de la [[licence BSD modifiée]] avec un [[Interprète (informatique)|interpréteur]] [[Compilation à la volée|Juste-à-temps]], les deux étant respectivement basés sur le langage de programmation [[REBOL]] et l'interprète REBOL.

== Historique ==
Le [[langage de programmation]] Red est officiellement annoncé à la conférence ''REBOL &amp; Boron'' le 26 février 2011 aux [[Pays-Bas]] par son créateur Nenad Rakocevic&lt;ref&gt;[http://www.osnews.com/story/24798/New_Red_Programming_Language_Gets_Syllable_Backend « New Red Programming Language Gets Syllable Backend »], ''osnews.com'', May 2011.&lt;/ref&gt;. Ce programmeur français s'était lancé dans le développement de ce nouveau langage en octobre 2010 en réponse à la stagnation que connaissait alors [[REBOL]]. Rakocevic était par ailleurs connu au sein de cette communauté pour ses contributions, dont la création du [[serveur HTTP]] Cheyenne&lt;ref&gt;[http://development.syllable.org/news/2011-05-28-00-37-First-Red-program-on-SyllableDesktop.html « Red Alert! »], ''syllable.org'', May 2011.&lt;/ref&gt;. Le projet est un succès tant et si bien qu'il est élu par ses pairs « ''Rebol'' de l'année 2011 »&lt;ref&gt;[http://devcon.esperconsultancy.nl/ « Red &amp; REBOL DevCon Winter 2012 »], ''devcon'', winter 2012.&lt;/ref&gt;. Red repose en effet sur le langage de programmation REBOL qui lui sert également de « [[Bootstrap (compilateur)|bootstrapping]] ». Le langage Red est ensuite présenté à l'échelle internationale pour la [[journée du logiciel libre]] 2011&lt;ref name=&quot;sfd&quot;&gt;[http://www.softwarefreedomday.eu/2011/Red.html « Red »], ''softwarefreedomday.eu'', september 14, 2011.&lt;/ref&gt;{{,}}&lt;ref&gt;[http://www.red-lang.org/2011/09/red-at-software-freedom-day-2011.html « Red Programming Language: Red at Software Freedom Day 2011 »], ''red-lang.org'', september 14, 2011.&lt;/ref&gt;, ce qui confère au projet une certaine visibilité.

== Caractéristiques ==

Voici les principales caractéristiques de Red :

* « ''[Red]uced [[REBOL]] dialect'' » : dialecte REBOL réduit.
* {{Lien|fr=Bibliothèque statique|lang=en|trad=Static library|texte=Bibliothèque statique}} et [[compilation à la volée]] ([[JIT]]).
* Support de la [[programmation parallèle]].
* Langage général (support de la programmation système).
* Utilisable comme [[langage de script]] à l'instar de [[REBOL]] ({{Lien|fr=REPL|lang=en|trad=Read–eval–print loop|texte=console REPL}}).
* Facilement encapsulable dans d'autres applications (à l'instar de [[LUA]]).
* Micro Serveur Web intégré et évolutif.

== Schéma du langage ==

Voici un schéma détaillant les différents niveaux&lt;ref&gt;[http://static.red-lang.org/red-rebor2011.pdf Présentation officielle du langage Red]&lt;/ref&gt; du [[langage de programmation Red]] :

[[Fichier:Red_architecture_small.PNG]]

== Exemple ==

&lt;pre&gt;
Red/System [
  Title:   &quot;Red/System : Simple programme de démo&quot;
  Author:  &quot;RedChronicle&quot;
  File:    %bonjour.reds
]

print &quot;Coucou tout le monde !&quot;

&lt;/pre&gt;

Un exemple en couleur :

[[Fichier:first_helloworld.PNG]]


== Références ==
{{Références | colonnes = 1}}

== Lien externe ==
* [https://github.com/dockimbel/Red Code source] sur la plateforme [[GitHub]]

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Logiciel libre sous licence BSD]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour Unix]]</text>
      <sha1>4kqe6kz1oi6qvydx6v9gi2uu8765r7v</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Pawn (langage de programmation)</title>
    <ns>0</ns>
    <id>6251929</id>
    <revision>
      <id>94796532</id>
      <parentid>94796500</parentid>
      <timestamp>2013-07-08T18:01:22Z</timestamp>
      <contributor>
        <ip>83.112.254.33</ip>
      </contributor>
      <text xml:space="preserve" bytes="650">{{à sourcer|date=avril 2012}}
{{ébauche|informatique}}
Le '''pawn''' est un langage de programmation ''[[open source]]''.

''Info : Pawno est ce qu'on appelle un IDE : Integrated Development Environment. En Français, cela se traduit par Environnement de développement.
Il contient l'éditeur de code, le compilateur, et le débuggeur qui vous retournera les erreurs. Il vous évite donc d'éditer le texte et d'avoir à utiliser un autre logiciel pour compiler.''
'''Le Pawno sert à scripter un 'serveur' de jeu sur la plate-forme de Grand Theft Auto San Andreas Multiplayer.'''

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>0qn7nlcgel8t3k9d1w7cmt3179d9x0a</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>C++11</title>
    <ns>0</ns>
    <id>2482644</id>
    <revision>
      <id>100904359</id>
      <parentid>100080246</parentid>
      <timestamp>2014-02-04T17:57:51Z</timestamp>
      <contributor>
        <ip>2A01:E35:2E2B:E2C0:3EA9:F4FF:FE08:9F10</ip>
      </contributor>
      <comment>correction du code de LargeData x est une référence et non un pointeur et le constructeur de copie n'avait pas de corps et  *x.ptr que le constructeur de copie de LargeDataT soit appelé</comment>
      <text xml:space="preserve" bytes="40944">{{Ébauche|informatique}}

'''C++11''', anciennement connu sous le nom de '''C++0x'''&lt;ref&gt;Blog d'[[Herb Sutter]] : [http://herbsutter.wordpress.com/2010/03/13/trip-report-march-2010-iso-c-standards-meeting/ March 2010 ISO C++ Standards Meeting]&lt;/ref&gt;, est la nouvelle norme pour le [[C++|langage C++]] en [[informatique]]. Elle a été approuvée unanimement le 12 août 2011&lt;ref&gt;Blog d'[[Herb Sutter]] : [http://herbsutter.com/2011/08/12/we-have-an-international-standard-c0x-is-unanimously-approved/ We have an international standard: C++0x is unanimously approved]&lt;/ref&gt;. Elle remplace la précédente [[norme]], ISO/CEI 14882, publiée en 1998 et mise à jour en 2003. Ces dernières sont plus connues sous les noms informels de C++98 et C++03. C++11 introduit plusieurs nouveautés au langage initial, ainsi que de nouvelles fonctionnalités à la [[bibliothèque standard du C++]] comme la plupart des [[Bibliothèque logicielle|bibliothèques]] du Technical Report 1, à l'exception de la bibliothèque de [[Fonction (mathématiques)|fonctions mathématiques]] spéciales.

C++11 a été publié sous le nom de ISO/IEC 14882:2011 en septembre 2011. Une version payante est disponible sur le site de l'[[ISO]]&lt;ref&gt;{{lien web|langue=en|titre=ISO/IEC 14882:2011|url=http://www.iso.org/iso/fr/catalogue_detail?csnumber=50372|éditeur=ISO}}&lt;/ref&gt;. Le dernier ''working draft'' gratuit est le [http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf N3337], qui date du 12 janvier 2012, les seules différences avec le standard étant des corrections éditoriales.

Un [[langage de programmation]] comme le C++ suit une évolution qui permet aux programmeurs de coder plus rapidement, de façon plus élégante et permettant de faire du code maintenable. Ce processus soulève inévitablement des questions de compatibilité avec le [[Code source|code]] existant, ce qui s'est produit de temps en temps pendant le processus de développement du C++. Cependant, d'après l'annonce faite par [[Bjarne Stroustrup]] (l'inventeur du langage C++ et membre du comité), la nouvelle norme sera presque totalement compatible avec la norme actuelle.

== Changements prévus pour la mise à jour de la norme ==

Comme dit précédemment, les changements du langage C++ concernent aussi bien le langage initial que la [[bibliothèque standard]].

Durant le développement de chaque fonctionnalité de la nouvelle norme, le comité a appliqué les directives suivantes :
* Garder la stabilité et la compatibilité avec le C++98 et, si possible, avec le [[C (langage)|C]].
* Préférer l'introduction de nouvelles fonctionnalités par la bibliothèque standard, plutôt que par le langage lui-même.
* Préférer les changements qui peuvent faire évoluer les techniques de programmation.
* Améliorer le C++ pour faciliter la mise en place de systèmes et de bibliothèques, plutôt qu'introduire de nouvelles fonctionnalités seulement utiles pour des applications spécifiques.
* Augmenter la protection des types en fournissant des alternatives plus sécurisées que les actuelles, plutôt non sécurisées.
* Augmenter les performances et les capacités à travailler directement avec le matériel.
* Proposer des solutions propres aux problèmes actuels.
* Implémenter le principe du « [[zero-overhead]] » (on ne paye le coût d'une fonctionnalité que si l'on s'en sert).
* Rendre le C++ facile à apprendre et à enseigner sans enlever les fonctionnalités requises par les programmeurs experts.

== Extensions du langage ==
=== Multitâche ===
==== Mémoire locale pour un thread ====
La mémoire locale de thread ou [[Thread Local Storage]] n'est pas un concept inventé par la nouvelle norme : de nombreux compilateurs proposent déjà cette fonctionnalité, ainsi que la bibliothèque threads de [[Boost (bibliothèques)|Boost]]. C++11 introduit le mot-clef &lt;code&gt;thread_local&lt;/code&gt; pour déclarer qu'une variable doit être stockée dans une zone mémoire appartenant au thread. Chaque thread embarque ainsi sa propre copie d'une variable déclarée de la sorte, et les modifications d'une de ces copies n'affectent pas les copies appartenant aux autres threads.
Lorsqu'une variable statique (ou une variable de classe) est ainsi définie, sa durée de vie est alors réduite à celle du thread (le destructeur des objets, notamment, est appelé lorsque le thread s'achève).

==== Le modificateur &lt;code&gt;volatile&lt;/code&gt; ====
=== Les classes ===
==== Délégation du constructeur ====
En C++, un constructeur appartenant à une classe ne peut pas appeler un autre constructeur de cette même classe, ce qui peut entraîner de la duplication de code lors de l'initialisation de ses attributs. En permettant au constructeur de déléguer la création d'une instance à un autre constructeur, C++11 apporte donc une solution.

&lt;source lang=&quot;cpp&quot;&gt;
class une_classe {
    int nombre;

public:
    une_classe(int nouveau_nombre) : nombre(nouveau_nombre) {}
    une_classe() : une_classe(42) {}
};
&lt;/source&gt;
Dans l'exemple ci-dessus, on peut voir que le second constructeur appelle le premier constructeur, ce qui aurait conduit à une erreur de compilation en C++.

==== Héritage du constructeur ====
==== Initialiseurs d'attributs ====
==== Sizeof sur les attributs de classes sans objet explicite ====
En C++03, &lt;code&gt;sizeof&lt;/code&gt; peut être utilisé sur des types ou des objets, mais pas sur un membre de classe (excepté dans la bibliothèque Qt).
C++11 le rend possible. On peut donc maintenant faire :

&lt;source lang=&quot;cpp&quot;&gt;
struct UnType { UnAutreType membre; };
 
sizeof(UnType::membre); // Ne marche pas en C++03 mais en C++11
&lt;/source&gt;

Ce qui résultait en une erreur de compilation avant.

==== Suppression et mise à défaut des fonctions standards des objets ====
==== Opérateur de conversion explicite ====
==== Liste d'initialiseurs ====
Pour initialiser un conteneur à l'aide de valeurs connues, il fallait le faire élément par élément. C++11 introduit le patron de classe &lt;code&gt;std::initializer_list&lt;/code&gt; qui permet d'initialiser les conteneurs avec la même syntaxe que celle permettant en C d'initialiser les tableaux , donc à l'aide d'une suite de valeurs entre accolades.

==== Modification de la définition des POD ([[Plain Old Data]]) ====
=== Les Templates ===
{{Article détaillé|Template (programmation)}}

==== Alias de templates grâce au mot-clé &lt;code&gt;using&lt;/code&gt; (template typedef) ====
==== Les templates variadiques ====
Pour remplacer les [[Fonction variadique|fonctions variadiques]] du C (déconseillées en C++), C++0x introduit les templates variadiques. Ces templates étendent le concept précédent en lui ajoutant la possibilité de prendre un nombre quelconque d'arguments. Elles sont supportées par le compilateur [[GNU Compiler Collection|GCC]] depuis la version 4.3 car elles font partie de l'expérimentation du support de C++0x&lt;ref&gt;[http://gcc.gnu.org/gcc-4.3/cxx0x_status.html Status of Experimental C++0x Support in GCC 4.3 – GNU Project – Free Software Foundation (FSF)]&lt;/ref&gt;.

L'utilité de templates possédant un nombre quelconque d'arguments se perçoit aisément avec la classe &lt;code&gt;tuple&lt;/code&gt;, qui généralise le concept de paire (triplet, n-uplet, etc.) ou bien avec cet exemple d'implémentation de la fonction ''printf'' :

&lt;source lang=&quot;cpp&quot;&gt;
void printf(const char *s)
{
  while (*s) {
    if (*s == '%' &amp;&amp; *++s != '%') {
      throw std::runtime_error(&quot;too few arguments provided to printf&quot;);
    }
    std::cout &lt;&lt; *s++;
  }
}

template&lt;typename T, typename... Args&gt;
void printf(const char* s, const T&amp; value, const Args&amp;... args) {
  while (*s) {
    if (*s == '%' &amp;&amp; *++s != '%') {
      std::cout &lt;&lt; value;
      printf(++s, args...);
      return;
    }
    std::cout &lt;&lt; *s++;
  }
  throw std::runtime_error(&quot;extra arguments provided to printf&quot;);
}
&lt;/source&gt;

C++0x définit un certain nombre de concepts que nous pouvons approcher grâce au code source suivant :
&lt;source lang=&quot;cpp&quot;&gt;
template&lt;class ... T&gt; struct Tuple { };

template&lt;class ... T&gt; 
void f(T ... args);

template&lt;class ... T&gt; void g(T ... a); 
template&lt;class ... T&gt; void h(T ... b) 
{ 
   g(b ...); 
}
&lt;/source&gt;
* À la première déclaration, l'argument template &lt;code&gt;class ... T&lt;/code&gt; est appelé un '''pack de paramètres template''' car il regroupe un nombre fini d'arguments (déterminé à la compilation).
* À la seconde déclaration, &lt;code&gt;T ... args&lt;/code&gt; s'appelle un '''pack de paramètres de fonction'''. C'est un paramètre de fonction qui englobe un paramètre pour chaque argument contenu par le pack de paramètres template &lt;code&gt;class ... T&lt;/code&gt;.
* Enfin, la troisième déclaration nous apprend comment utiliser un '''pack étendu''' de paramètres. Le mot ''extension'' est utilisé car lors de l'appel à ''g'', le pack de paramètres sera étendu avant d'être passé à ''g''.

==== Les concepts ====
Les concepts ont été retirés de la norme.

==== Les chevrons (&lt;code&gt;&lt;&gt;&lt;/code&gt;) ====
Les compilateurs C++ actuels traitent toujours une séquence de deux signes ''supérieur à'' comme un opérateur de [[décalage binaire]] vers la droite. En conséquence, lors de l'imbrication de l'utilisation de patrons, les programmeurs sont obligés d'insérer un espace entre les deux [[Chevron (typographie)|chevrons]] fermants.

Par exemple, en C++03, ce code provoque une erreur de compilation :
&lt;source lang=&quot;cpp&quot;&gt;
#include &lt;vector&gt;
std::vector&lt;std::vector&lt;int&gt;&gt; matrix;
// Attention ! Écrire plutôt : “std::vector&lt;std::vector&lt;int&gt; &gt;”
&lt;/source&gt;

C++11 tentera de détecter automatiquement si les symboles doivent jouer le rôle de chevrons fermants ou d'opérateur de décalage binaire.

==== Template externe ====
Les templates ne sont actuellement pas pris en compte par l'éditeur de liens : il est nécessaire d'incorporer leur définition dans tous les fichiers sources les utilisant en [[programmation modulaire]]. Leur compilation était donc longue et gourmande puisque la classe était recompilée dans chaque fichier source, pour chaque type utilisé.

C++11 permettra l'utilisation du mot-clé &lt;code&gt;extern&lt;/code&gt; pour rendre les templates globaux. Les fichiers désirant utiliser le template n'ont qu'à le déclarer.

=== Autres nouvelles fonctionnalités du C++11 ===
==== Expressions constantes généralisées ====
==== Assertions statiques ====
La bibliothèque [[Boost (bibliothèques)|Boost]] propose déjà cette facilité à travers la macro &lt;code&gt;BOOST_STATIC_ASSERT&lt;/code&gt;. Cependant, son implémentation est étrange, basée sur la métaprogrammation et des comparaisons de taille de structures intermédiaires créées pour l'assertion sans trop de rapport avec le concept.
Par conséquent, intégrer la fonction dans le langage apporte une solution propre au problème.

En pratique, une assertion statique permet de vérifier à la compilation qu'une valeur est vraie. Par exemple, il est possible d'implémenter les concepts en utilisant &lt;code&gt;boost::traits&lt;/code&gt; et &lt;code&gt;BOOST_STATIC_ASSERT&lt;/code&gt;. Si une classe template nécessite que son type template soit un [[#Modification de la définition des POD (Plain Old Data)|POD]], elle peut faire une assertion statique sur &lt;code&gt;boost::is_pod&lt;T&gt;::type::value&lt;/code&gt;, ce qui est une constante intégrale de type &lt;code&gt;unspecified-bool-type&lt;/code&gt; et remplit dont le critère pour paraître dans une assertion statique.

En outre, en C++11, l'expression :
&lt;source lang=&quot;cpp&quot;&gt;
static_assert(sizeof(long) &gt; sizeof(int));
&lt;/source&gt;
permettrait à une bibliothèque d'être certaine qu'elle est compilée sur un système vérifiant cette condition (x86-64 par exemple).

&lt;code&gt;static_assert&lt;/code&gt; permet aussi de préciser un message d'erreur. Dans ce cas-là, l'assertion précédente ressemblerait à :
&lt;source lang=&quot;cpp&quot;&gt;
static_assert(sizeof(long) &gt; sizeof(int), &quot;La bibliothèque doit être compilée sous un système 64-BIT&quot;);
&lt;/source&gt;

==== Expressions et fonctions lambda ====
==== [[Inférence de types]] ====
Le mot clé '''&lt;code&gt;auto&lt;/code&gt;''' se voit assigner une nouvelle sémantique par le nouveau standard. Nous connaissions son unique sémantique d'indicateur de classe de stockage pour une variable. En effet, déclarer une variable automatique revenait à indiquer au compilateur qu'elle était valide seulement dans l'espace où elle était déclarée ; ce comportement étant aussi celui par défaut, le mot clé était inutile. Dans le nouveau standard, il change de sémantique et prend la place du type dans la déclaration. Le type sera alors automatiquement décidé par correspondance avec le type retourné par l'objet utilisé pour l'initialisation de la variable. Les variables étant déclarées avec &lt;code&gt;auto&lt;/code&gt; devront donc impérativement être initialisées. Exemple :
&lt;source lang=&quot;cpp&quot;&gt;
auto f = boost::bind(MyFunc, _1);
f(5);
&lt;/source&gt;
Le type de &lt;code&gt;f&lt;/code&gt; est un type interne de la bibliothèque surchargé environ quatre-vingts fois avec un script [[Perl (langage)|Perl]]. Trouver le type exact pour stocker le résultat d'un &lt;code&gt;bind&lt;/code&gt; dans un objet n'était pas pratique du tout avant le nouveau rôle du mot clé &lt;code&gt;auto&lt;/code&gt;, d'où son apparition.

Le nouveau standard ajoute le mot clé '''&lt;code&gt;decltype&lt;/code&gt;''' qui permet de typer une variable à partir du type d'une autre variable. Exemple:

&lt;source lang=&quot;cpp&quot;&gt;
int i;
decltype(i) j = 5;
&lt;/source&gt;

Le type de &lt;code&gt;j&lt;/code&gt; sera du même type que &lt;code&gt;i&lt;/code&gt;, soit &lt;code&gt;int&lt;/code&gt;. Cette déclaration automatique du type d'une variable peut être très utile dans les templates.

==== Sémantique des RValues Reference/Move ====
L'introduction de la sémantique ''move'' (déplacement) prend son sens en constatant qu'en C++, il n'y a aucune manière générique de déplacer un objet sans le copier. Par exemple lorsqu'une fonction retourne un objet de grosse taille, celui-ci est copié dans une zone temporaire avant d'être à nouveau copié là où le résultat de la fonction est affecté. Après chaque étape de copie l'objet copié devient inutile et est détruit. Cela est très peu efficace car il serait beaucoup plus rapide de déplacer l'objet plutôt que de le recopier et détruire l'original. C'est particulièrement vrai si l'objet est d'un type proche du type &lt;code&gt;T&lt;/code&gt; ci-dessous, où &lt;code&gt;LargeDataT&lt;/code&gt; est un type d'objet coûteux à dupliquer :
&lt;source lang=&quot;cpp&quot;&gt;
class T
{
    LargeDataT *ptr;
public:
    T(const T &amp;x) : ptr ( new LargeDataT (*x.ptr) ) {}
    ~T() { delete ptr; }
    void MoveFrom (T&amp; x) { ptr = x.ptr; x.ptr = nullptr; }
};
&lt;/source&gt;
En effet le déplacement d'un objet de ce type &lt;code&gt;T&lt;/code&gt; requiert simplement la recopie du membre &lt;code&gt;ptr&lt;/code&gt; alors que sa duplication alloue et copie un nouvel objet &lt;code&gt;LargeDataT&lt;/code&gt;. Le problème que résout C++11 par l'ajout des RValues reference est de pouvoir appeler la fonction &lt;code&gt;MoveFrom&lt;/code&gt; en lieu et place du constructeur de recopie dans les cas où la copie correspond à un déplacement.
Ceci s'obtient par l'ajout du constructeur de déplacement ci-dessous :
&lt;source lang=&quot;cpp&quot;&gt;
    T(T &amp;&amp;x) : ptr (x.ptr) { x.ptr = nullptr; }
&lt;/source&gt;
Le double &amp; marque la référence sur ''rvalue'' (parfois aussi appelée ''temporaire''). C'est-à-dire une référence sur quelque chose qui est temporaire ou est sur le point d'être détruit. Le constructeur de déplacement sera donc choisi par le compilateur à la place du constructeur de recopie en cas de copie d'un objet temporaire ou sur le point d'être supprimé. Sur tous les autres aspects une référence sur une rvalue est identique à une référence classique maintenant appelée référence sur ''lvalue'' (que l'on peut définir grossièrement par : tout ce qui a une adresse).
De cette définition ressort un fait qui peut sembler paradoxal : une variable de type référence sur une rvalue n'est généralement pas une référence sur une rvalue ! En effet à partir du moment où une référence sur une rvalue est écrite dans une variable, y compris si elle est de type référence sur rvalue, elle perd son caractère temporaire dans l'espace de définition de cette variable.

Mais parfois il est utile d'appeler le constructeur de déplacement même à partir d'une variable qui n'est pas temporaire. Par exemple la commande ''swap'' est souvent introduite par le patron de fonction ci-dessous :
&lt;source lang=&quot;cpp&quot;&gt;
template &lt;class T&gt;
void swap ( T&amp; a, T&amp; b )
{
  T c(a); 
  a=b; 
  b=c;
}
&lt;/source&gt;
Cette fonction a pour inconvénient d'appeler d'abord le constructeur de recopie, puis deux opérateurs d'assignation. Ce sont donc 3 copies au total, qui peuvent être des opérations extrêmement coûteuses, voire impossibles si les objets impliqués sont de taille importante. Ici le constructeur de déplacement n'est pas appelé car a, b et c comme source de la copie ne sont pas temporaires.
C++11 introduit la fonction &lt;code&gt;std::move()&lt;/code&gt; qui retourne une référence à une rvalue et prend pour paramètre une référence à une lvalue ou à une rvalue. Son patron est le suivant :
&lt;source lang=&quot;cpp&quot;&gt;
template &lt;class T&gt;
typename remove_reference&lt;T&gt;::type&amp;&amp;
move(T&amp;&amp; a)
{
    return a;
}
&lt;/source&gt;
La fonction &lt;code&gt;move()&lt;/code&gt; donne à ce qu'il retourne la valeur de son paramètre. La fonction move ne modifie pas l'objet qui lui est passé mais reçoit et fourni une référence sur un objet non constant. L'objet d'origine peut donc être modifié à partir du résultat de la fonction &lt;code&gt;move()&lt;/code&gt;. Le point important de ''move'' est qu'il n'y a aucune copie de faite. En utilisant ''move'', on peut ainsi réécrire de façon concise &lt;code&gt;swap()&lt;/code&gt;, sans qu'il n'y ait de copie.
&lt;source lang=&quot;cpp&quot;&gt;
template &lt;class T&gt; 
swap(T&amp; a, T&amp; b)
{
    T tmp(std::move(a));
    a = std::move(b);   
    b = std::move(tmp);
}
&lt;/source&gt;

==== Énumérations fortement typées ====
L'énumération du langage C était similaire à une liste de définitions de symboles ([[Macro-définition|macros]]) correspondant à des nombres entiers, et C++ n'avait répondu qu'en interdisant la conversion d'un type énumération dans un autre.

C++11 proposera des énumérations « fortement typées ». Ces énumérations seront obtenues en remplaçant &lt;code&gt;enum&lt;/code&gt; par &lt;code&gt;enum class&lt;/code&gt; ou &lt;code&gt;enum struct&lt;/code&gt;&lt;ref&gt;{{lien web|langue=en|titre=Strongly Typed Enums (revision 1)|url=http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1719.pdf}} : page 9, '&lt;code&gt;enum-key&lt;/code&gt;' est soit '&lt;code&gt;enum&lt;/code&gt;', soit '&lt;code&gt;enum class&lt;/code&gt;', soit '&lt;code&gt;enum struct&lt;/code&gt;'&lt;/ref&gt;.
La conversion d'éléments de ces énumérations vers les entiers sera prohibée et l'accès aux éléments se fera à l'aide de l'opérateur de résolution de portée. Voici un exemple d'utilisation :
&lt;source lang=&quot;cpp&quot;&gt;
enum class Chiffres { Zero, Un, Deux, Trois, Quatre, Cinq, Six, Sept, Huit, Neuf };
Chiffres chif;
chif = Chiffres::Sept;
int nb;
nb = (int) Chiffres::Trois;
&lt;/source&gt;
L'opérateur de résolution de portée sera optionnel avec des énumérations faiblement typées :
&lt;source lang=&quot;cpp&quot;&gt;
enum Enum2 { E_1, E_2 };
Enum2 e1 = E_1; // Comme en C++03
Enum2 e2 = Enum2::E_2; // Comme avec une enum class;
&lt;/source&gt;

De plus, C++11 vous permettra de choisir le type d'entier sous-jacent des énumérations (tous sauf &lt;code&gt;wchar_t&lt;/code&gt;):
&lt;source lang=&quot;cpp&quot;&gt;
enum class Enumeration : unsigned short { Valeur1, Valeur2 };
&lt;/source&gt;
Par défaut, ce type sera &lt;code&gt;int&lt;/code&gt;.
Ce comportement sera aussi possible avec les énumérations normalement typées, et il sera bien sûr toujours possible de définir la valeur d'une partie de l'énumération :
&lt;source lang=&quot;cpp&quot;&gt;
enum EnumerationNormale : UINT8 { ValeurDepart = 0, ValeurMoyenne = 127, ValeurMaximum = 255 };
&lt;/source&gt;

==== Boucles basées sur des intervalles ====
Le code nécessaire en C++ pour le parcours d'un intervalle et l'action sur ses éléments est répétitif et long. De nombreux langages, comme [[Langage Java|Java]], ont fourni à leurs utilisateurs un opérateur &lt;code&gt;foreach&lt;/code&gt; qui permet de parcourir une liste avec aisance&lt;ref&gt;L'algorithme &lt;code&gt;std::for_each&lt;/code&gt; du C++ ne sert qu'à appliquer une fonction à tous les éléments d'une séquence de conteneur (voir [http://www.cplusplus.com/reference/algorithm/for_each/ la documentation de cette fonction]).&lt;/ref&gt;. Pour répondre aux attentes, la norme C++11 fournira une nouvelle syntaxe de l'instruction &lt;code&gt;for&lt;/code&gt; qui s'implémentera de cette façon :
&lt;source lang=&quot;cpp&quot;&gt;
int mon_tableau[5] = {1, 2, 3, 4, 5};
for (int &amp;x: mon_tableau) {
    x *= 2;
}
&lt;/source&gt;
Ce code permet de doubler tous les éléments du tableau &lt;code&gt;mon_tableau&lt;/code&gt;. L'entier &lt;code&gt;x&lt;/code&gt; défini pour le corps de la boucle &lt;code&gt;for&lt;/code&gt; référence successivement chacun des éléments du tableau.

Ce type de parcours fonctionnera pour les listes classiques, les listes d'initialiseurs, ainsi que les conteneurs de la STL définissant les fonctions membres &lt;code&gt;begin&lt;/code&gt; et &lt;code&gt;end&lt;/code&gt;.

==== Nouveaux littéraux « chaînes de caractères » ====
==== Littéraux définis par l'utilisateur ====
==== Destruction des objets transparente ====
==== Pointeur &lt;code&gt;NULL&lt;/code&gt; ====

Le nouveau mot-clé &lt;code&gt;nullptr&lt;/code&gt; a été proposé comme constante du langage avec le caractère particulier d'être assignable à tous les types de pointeurs. En effet, contrairement au C où la macro préprocesseur est généralement définie avec &lt;code&gt;#define NULL ((void*)0)&lt;/code&gt;, en C++ il est interdit d'assigner un &lt;code&gt;void*&lt;/code&gt; à un pointeur d'un type différent. L'usage était donc de définir &lt;code&gt;NULL&lt;/code&gt; avec l'entier 0. Ce comportement restera compatible, mais il sera aussi possible d'écrire :
&lt;source lang=&quot;cpp&quot;&gt;T* ptr = nullptr;&lt;/source&gt;
La constante NULL définie comme l'entier 0 ne permettait pas au compilateur de déterminer quelle surcharge de &lt;code&gt;f&lt;/code&gt; choisir dans le code suivant:
&lt;source lang=&quot;cpp&quot;&gt;void f(int);
void f(void*);

f(0); // Entier 0 ou pointeur nul?&lt;/source&gt;
Le mot clé &lt;code&gt;nullptr&lt;/code&gt; est une constante du type &lt;code&gt;nullptr_t&lt;/code&gt;, non convertible en entier. Pour appeler la fonction f avec un pointeur NULL, la surcharge est correctement choisie en C++11 dans le code suivant:

&lt;source lang=&quot;cpp&quot;&gt;void f(int);
void f(void*);

f(0); // Entier 0, pas d'ambitguïté
f(nullptr); // Convertible en void*, mais pas en int.&lt;/source&gt;

== Extension de la bibliothèque standard ==
=== Threads ===

La bibliothèque standard a implémenté dans la nouvelle norme du C++, le modèle de classe '''std::thread''', celui-ci n'est qu'une implémentation des threads de la bibliothèque [[Boost (bibliothèques)|Boost]].

Voici, un exemple résumant quelque peu son utilisation:

&lt;source lang = &quot;cpp&quot;&gt;

void thread () { std::cout &lt;&lt; &quot;WikiFunction&quot; &lt;&lt; std::endl; }

int main ()
{
   std::thread wikifunction(thread); // Création et lancement du thread

   wikifunction.join(); // Attend la fin du thread
}

&lt;/source&gt;

=== Type tuple ===

Un tuple (ou encore isplate) est une collection de dimension fixe d'objets de types différents. Tout type d'objet peut être élément d'un tuple.
Cette nouvelle fonctionnalité est implémentée dans un nouvel [[en-tête]] et bénéficie des extensions de C++11 comme :
* [[#Les templates variadiques|Les templates variadiques]]
* Référence sur référence
* Arguments par défaut pour les fonctions template

Le patron de classe &lt;code&gt;tuple&lt;/code&gt; est déclaré par la ligne :
&lt;source lang=&quot;cpp&quot;&gt;
template &lt;class... Types&gt; class tuple;
&lt;/source&gt;

Un exemple de définition et d'utilisation du type &lt;code&gt;tuple&lt;/code&gt; :
&lt;source lang=&quot;cpp&quot;&gt;
typedef tuple&lt; int, double, long &amp;, const char * &gt; test_tuple ;
long lengthy = 12 ;
test_tuple proof( 18, 6.5, lengthy, &quot;Ciao!&quot; ) ;
lengthy = get&lt;0&gt;(proof) ;  // Assigne à ‘lengthy’ la valeur 18
get&lt;3&gt;(proof) = &quot; Beautiful!&quot; ;  // Modifie la 4ème valeur du tuple
&lt;/source&gt;

Il est possible de créer le tuple &lt;code&gt;proof&lt;/code&gt; sans définir son contenu si les éléments du tuple possèdent un constructeur par défaut. De plus, il est possible d'assigner un tuple à un autre tuple : si les deux tuples sont de même type, il est nécessaire que chaque élément du tuple ait un constructeur par copie, sinon il faut que le type de chaque élément de l'opérande de droite soit compatible avec le type correspondant dans l'opérande de gauche ou que l'élément correspondant de l'opérande gauche ait un constructeur approprié.
&lt;source lang=&quot;cpp&quot;&gt;
typedef tuple&lt; int , double, string       &gt; tuple_1 t1 ;
typedef tuple&lt; char, short , const char * &gt; tuple_2 t2( 'X', 2, &quot;Hola!&quot; ) ;
t1 = t2 ;  // OK : les deux premiers éléments peuvent être convertis,
           // le troisième peut être construit à partir du ‘const char *’.
&lt;/source&gt;

Les opérateurs relationnels sont disponibles (pour les tuples ayant le même nombre d'éléments).
Deux expressions sont introduites pour vérifier les caractéristiques d'un tuple (à la compilation) :
* &lt;code&gt;tuple_size&amp;lt;T&amp;gt;::value&lt;/code&gt; retourne le nombre d'éléments du tuple &lt;code&gt;T&lt;/code&gt;,
* &lt;code&gt;tuple_element&amp;lt;I, T&amp;gt;::type&lt;/code&gt; retourne le type de l'objet placé en position &lt;code&gt;I&lt;/code&gt; du tuple &lt;code&gt;T&lt;/code&gt;.

=== Table de hachage ===

Intégrer les [[Table de hachage|tables de hachage]] (conteneurs associatifs non ordonnés) dans la bibliothèque standard du C++ est l'une des demandes les plus récurrentes.
Cela n'avait pas été réalisé pour la norme actuelle (celle écrite en 1995 et approuvée en 1998) à cause des contraintes de temps.
Bien que cette solution soit moins efficace que les arbres équilibrés dans le pire des cas (en cas de collisions importantes), elle est cependant la meilleure dans la plupart des applications réelles.

Les collisions seront uniquement gérées par [[Table de hachage#Chaînage|chaînage]] linéaire car le comité ne considère pas opportun de standardiser des solutions d'[[Table de hachage#Adressage ouvert|adressage ouvert]] qui introduisent un nombre important de problèmes intrinsèques (en particulier quand la suppression d'éléments est permise).
Pour éviter les conflits de noms avec les bibliothèques non standards qui ont leur propre implémentation des tables de hachage, on utilisera le préfixe &lt;code&gt;unordered&lt;/code&gt;, au lieu de &lt;code&gt;hash&lt;/code&gt;.

Cette nouvelle fonctionnalité intégrera quatre types de tables de hachage, différentes selon qu'elles acceptent ou non des éléments de même clé (clé unique ou clé équivalente) et qu'elles associent chaque clé à la valeur associée.
{| class=&quot;wikitable&quot;
! Type de table de hachage !! Type associé arbitraire !! Clés équivalentes
|-
! unordered_set
| ||
|-
! unordered_multiset
| || align=&quot;center&quot; | &lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;•&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;
|-
! unordered_map
| align=&quot;center&quot; | &lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;•&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt; ||
|-
! unordered_multimap
| align=&quot;center&quot; | &lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;•&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt; || align=&quot;center&quot; | &lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;&lt;big&gt;•&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;
|}

Ces nouvelles classes remplissent toutes les demandes des [[Standard Template Library#Diagramme des conteneurs|classes de conteneurs]] et contiennent toutes les méthodes nécessaires pour accéder aux éléments : &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;.

Ces classes n'ont pas nécessité les nouvelles extensions du langage C++ mais seulement une légère extension du header &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; et l'introduction des headers &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; et &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;. 
Aucun autre changement aux classes de la norme actuelle n'est nécessaire et elles ne dépendent d'aucune autre extension de la bibliothèque standard.

=== Expressions régulières ===
La bibliothèque définie dans le fichier d'en-tête &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; est fait d'un ensemble de nouvelles classes :
* Les expressions régulières sont représentées par une instance de la classe template &lt;code&gt;std::regex&lt;/code&gt;
* Les résultats sont représentés par une instance de la classe template &lt;code&gt;std::match_results&lt;/code&gt;
La fonction &lt;code&gt;std::regex_search&lt;/code&gt; est utilisée pour une recherche.
&lt;code&gt;std::regex_replace&lt;/code&gt; est utilisée pour effectuer un &quot;chercher-remplacer&quot;, elle renvoie pour cela une nouvelle chaîne.

Les algorithmes &lt;code&gt;std::regex_search&lt;/code&gt; et &lt;code&gt;std::regex_replace&lt;/code&gt; prennent une expressions régulières et une chaîne et écrivent les occurrences trouvés dans la structure &lt;code&gt;std::match_results&lt;/code&gt;.

Voici, un exemple d'utilisation de &lt;code&gt;std::match_results&lt;/code&gt;:
&lt;source lang=&quot;cpp&quot;&gt;
const char *reg_esp = &quot;[ ,.\\t\\n;:]&quot;;  // Une liste de caractères séparateurs

// On pourrait aussi utiliser les chaînes littérales
// const char *reg_esp = R&quot;([ ,.\t\n;:])&quot;;

std::regex rgx(reg_esp);  // 'regex' est une instance de la classe
                      // 'basic_regex' avec un argument de type 'char'.
std::cmatch match;  // 'cmatch' est une instance de la classe
                // 'match_results' avec un argument de type 'const char *'.
const char *target = &quot;Unseen University - Ankh-Morpork&quot;;

// Trouve tous les mots de 'target' séparés par les caractères de 'reg_esp'.
if( std::regex_search( target, match, rgx ) ) {
    const size_t n = match.size();
    for( size_t a = 0; a &lt; n; a++ ) {
        std::string str( match[a].first, match[a].second );
        std::cout &lt;&lt; str &lt;&lt; &quot;\n&quot;;
    }
}
&lt;/source&gt;

Notez l'utilisation du double backslash, car le C++ utilise le backslash comme un caractère d'échappement. Les chaînes littérales en C++11 peuvent permettre d'éviter le problème.

L'utilisation de la bibliothèque &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ne requiert aucune dépendance explicite.

=== “Smart pointer” généraux ===
=== Amélioration des nombres aléatoires extensibles ===
La [[bibliothèque standard de C]] permet de générer des nombres pseudo-aléatoires grâce à la fonction &lt;code&gt;rand&lt;/code&gt;. L'algorithme de génération n'est pas standardisé mais laissé au choix du fournisseur de la bibliothèque. Le C++ n'y a rien changé, mais C++11 va fournir une manière différente de générer les nombres pseudo-aléatoires.

Cette fonctionnalité est découpée en deux parties qui forment un objet de génération de nombres aléatoires :
* un moteur de génération, qui contient l'état du générateur et produit les nombres pseudo-aléatoires ;
* une distribution, qui détermine les valeurs que le résultat peut prendre ainsi que sa [[loi de probabilité]].

C++11 définit trois algorithmes de génération, chacun ayant des avantages et des inconvénients.

{| class=&quot;wikitable&quot;
! Template !! Entier/flottant !! Qualité !! Vitesse !! Taille d'état
|-
! &lt;code&gt;[[Générateur congruentiel linéaire|linear_congruential]]&lt;/code&gt;
| align=&quot;center&quot; | Entier || align=&quot;center&quot; | Moyenne || align=&quot;center&quot; | Moyenne || align=&quot;center&quot; | 1
|-
! &lt;code&gt;[[Subtract with carry|subtract_with_carry]]&lt;/code&gt;
| align=&quot;center&quot; | Les deux || align=&quot;center&quot; | Moyenne || align=&quot;center&quot; | Rapide || align=&quot;center&quot; | 25
|-
! &lt;code&gt;[[Mersenne Twister|mersenne_twister]]&lt;/code&gt;
| align=&quot;center&quot; | Entier || align=&quot;center&quot; | Bonne || align=&quot;center&quot; | Rapide || align=&quot;center&quot; | 624
|}

C++11 fournira un certain nombre de lois standard : &lt;code&gt;[[Loi uniforme discrète|uniform_int_distribution]]&lt;/code&gt;, &lt;code&gt;[[Loi de Bernoulli|bernoulli_distribution]]&lt;/code&gt;, &lt;code&gt;[[Loi géométrique|geometric_distribution]]&lt;/code&gt;, &lt;code&gt;[[Loi de Poisson|poisson_distribution]]&lt;/code&gt;, &lt;code&gt;[[Loi binomiale|binomial_distribution]]&lt;/code&gt;, &lt;code&gt;[[Loi uniforme continue|uniform_real_distribution]]&lt;/code&gt;, &lt;code&gt;[[loi exponentielle|exponential_distribution]]&lt;/code&gt;, &lt;code&gt;[[Loi normale|normal_distribution]]&lt;/code&gt; et &lt;code&gt;[[Loi gamma|gamma_distribution]]&lt;/code&gt;.

Le générateur et la distribution se combinent comme dans l'exemple suivant :

&lt;source lang=&quot;cpp&quot;&gt;
std::uniform_int_distribution&lt;int&gt; distribution(0, 99);
std::mt19937 engine;
auto generator = std::bind(distribution, engine);
int random = generator();  // Generate a uniform integral variate between 0 and 99.
&lt;/source&gt;

=== Fonctions mathématiques spéciales ===

Le fichier header &lt;code&gt;&amp;lt;math&amp;gt;&lt;/code&gt; définit déjà plusieurs fonctions mathématiques usuelles :
* '''trigonométriques''' : &lt;code&gt;sin&lt;/code&gt;, &lt;code&gt;cos&lt;/code&gt;, &lt;code&gt;tan&lt;/code&gt;, &lt;code&gt;asin&lt;/code&gt;, &lt;code&gt;acos&lt;/code&gt;, &lt;code&gt;atan&lt;/code&gt;, &lt;code&gt;atan2&lt;/code&gt;;
* '''hyperboliques''' : &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;asinh&lt;/code&gt;, &lt;code&gt;acosh&lt;/code&gt;, &lt;code&gt;atanh&lt;/code&gt;;
* '''exponentielles''' : &lt;code&gt;exp&lt;/code&gt;, &lt;code&gt;exp2&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, &lt;code&gt;ldexp&lt;/code&gt;, &lt;code&gt;expm1&lt;/code&gt;;
* '''logarithmiques''' : &lt;code&gt;log10&lt;/code&gt;, &lt;code&gt;log2&lt;/code&gt;, &lt;code&gt;logb&lt;/code&gt;, &lt;code&gt;ilogb&lt;/code&gt;, &lt;code&gt;log1p&lt;/code&gt;;
* '''puissances''' : &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;sqrt&lt;/code&gt;, &lt;code&gt;cbrt&lt;/code&gt;, &lt;code&gt;hypot&lt;/code&gt;;
* '''spéciales''' : &lt;code&gt;erf&lt;/code&gt;, &lt;code&gt;erfc&lt;/code&gt;, &lt;code&gt;tgamma&lt;/code&gt;, &lt;code&gt;lgamma&lt;/code&gt;.

Le comité a décidé d'ajouter de nouvelles fonctions qui nécessitent actuellement l'utilisation de bibliothèques non-standards.
Ces nouvelles fonctions auront un intérêt principalement pour les programmeurs de disciplines scientifiques et pour l'ingénierie.

Le tableau suivant montre les 23 fonctions décrites dans TR1.
{| class=&quot;wikitable&quot;
! Nom de la fonction !! Prototype de la fonction !! Expression mathématique
|-
! [[Polynôme de Laguerre|Polynômes de Laguerre généralisés]]
| double '''assoc_laguerre'''( unsigned n, unsigned m, double x ) ; || &lt;math&gt;{L_n}^m(x) = (-1)^m \frac{d^m}{dx^m} L_{n+m}(x), \text{ pour } x \ge 0&lt;/math&gt;
|-
! [[Polynôme de Legendre|Polynômes de Legendre généralisés]]
| double '''assoc_legendre'''( unsigned l, unsigned m, double x ) ; || &lt;math&gt;{P_l}^m(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_l(x), \text{ pour } x \ge 0&lt;/math&gt;
|-
! [[Fonction bêta]]
| double '''beta'''( double x, double y ) ; || &lt;math&gt;B(x,y)=\frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}&lt;/math&gt;
|-
! [[Intégrale elliptique complète de premier genre]]
| double '''comp_ellint_1'''( double k ) ; || &lt;math&gt;K(k) = F\left(k, \textstyle \frac{\pi}{2}\right) = \int_0^{\frac{\pi}{2}} \frac{d\theta}{\sqrt{1 - k^2 \sin^2 \theta}}&lt;/math&gt;
|-
! [[Intégrale elliptique complète de deuxième genre]]
| double '''comp_ellint_2'''( double k ) ; || &lt;math&gt;E\left(k, \textstyle \frac{\pi}{2}\right) = \int_0^{\frac{\pi}{2}} \sqrt{1 - k^2 \sin^2 \theta}\; d\theta&lt;/math&gt;
|-
! [[Intégrale elliptique complète de troisième genre]]
| double '''comp_ellint_3'''( double k, double nu ) ; || &lt;math&gt;\Pi\left(\nu, k, \textstyle \frac{\pi}{2}\right) = \int_0^{\frac{\pi}{2}} \frac{d\theta}{(1 - \nu \sin^2 \theta)\sqrt{1 - k^2 \sin^2 \theta}}&lt;/math&gt;
|-
! [[Fonctions hypergéométriques confluentes]]
| double '''conf_hyperg'''( double a, double c, double x ) ; || &lt;math&gt;F(a, c, x) = \frac{\Gamma(c)}{\Gamma(a)} \sum_{n = 0}^\infty \frac{\Gamma(a + n) x^n}{\Gamma(c + n) n!}&lt;/math&gt;
|-
! [[Fonctions de Bessel cylindriques modifiées régulières]]
| double '''cyl_bessel_i'''( double nu, double x ) ; || &lt;math&gt;I_\nu(x) = i^{-\nu} J_\nu(ix) = \sum_{k = 0}^\infty \frac{(x/2)^{\nu + 2k}}{k! \; \Gamma(\nu + k + 1)}, \text{ pour } x \ge 0&lt;/math&gt;
|-
! [[Fonctions de Bessel cylindriques du premier genre]]
| double '''cyl_bessel_j'''( double nu, double x ) ; || &lt;math&gt;J_\nu(x) = \sum_{k = 0}^\infty \frac{(-1)^k \; (x/2)^{\nu + 2k}}{k! \; \Gamma(\nu + k + 1)}, \text{ pour } x \ge 0&lt;/math&gt;
|-
! [[Fonctions de Bessel cylindriques modifiées irrégulières]]
| double '''cyl_bessel_k'''( double nu, double x ) ; || &lt;math&gt;\begin{align}
K_\nu(x) &amp; = \textstyle\frac{\pi}{2} i^{\nu+1} \big(J_\nu(ix) + i N_\nu(ix)\big) \\
         &amp; = \begin{cases}
                 \displaystyle \frac{I_{-\nu}(x) - I_\nu(x)}{\sin \nu\pi}, &amp; \text{ pour } x \ge 0 \text{ et } \nu \notin \mathbb{Z} \\[10pt]
                 \displaystyle \frac{\pi}{2} \lim_{\mu \to \nu} \frac{I_{-\mu}(x) - I_\mu(x)}{\sin \mu\pi}, &amp; \text{ pour } x &lt; 0 \text{ et } \nu \in \mathbb{Z} \\
             \end{cases}
\end{align}&lt;/math&gt;
|-
! [[Fonctions de Neumann cylindriques]]
[[Fonctions de Bessel cylindriques du deuxième genre]]
| double '''cyl_neumann'''( double nu, double x ) ; || &lt;math&gt;
N_\nu(x) = \begin{cases}
                 \displaystyle \frac{J_\nu(x)\cos \nu\pi - J_{-\nu}(x)}{\sin \nu\pi}, &amp; \text{ pour } x \ge 0 \text{ et } \nu \notin \mathbb{Z} \\[10pt]
                 \displaystyle \lim_{\mu \to \nu} \frac{J_\mu(x)\cos \mu\pi - J_{-\mu}(x)}{\sin \mu\pi}, &amp; \text{ pour } x &lt; 0 \text{ et } \nu \in \mathbb{Z} \\
             \end{cases}
&lt;/math&gt;
|-
! [[Intégrale elliptique incomplète du premier genre]]
| double '''ellint_1'''( double k, double phi ) ; || &lt;math&gt;F(k,\phi)=\int_0^\phi\frac{d\theta}{\sqrt{1-k^2\sin^2\theta}}, \text{ pour } \left|k\right| \le 1&lt;/math&gt;
|-
! [[Intégrale elliptique incomplète du deuxième genre]]
| double '''ellint_2'''( double k, double phi ) ; || &lt;math&gt;\displaystyle E(k,\phi)=\int_0^\phi\sqrt{1-k^2\sin^2\theta}d\theta, \text{ pour } \left|k\right| \le 1&lt;/math&gt;
|-
! [[Intégrale elliptique incomplète du troisième genre]]
| double '''ellint_3'''( double k, double nu, double phi ) ; || &lt;math&gt;\Pi(k,\nu,\phi)=\int_0^\phi\frac{d\theta}{\left(1-\nu\sin^2\theta\right)\sqrt{1-k^2\sin^2\theta}}, \text{ pour } \left|k\right| \le 1&lt;/math&gt;
|-
! [[Exponentielle intégrale|Intégrale exponentielle]]
| double '''expint'''( double x ) ; || &lt;math&gt; \mbox{E}i(x)=-\int_{-x}^{\infty} \frac{e^{-t}}{t}\, dt&lt;/math&gt;
|-
! [[Polynôme d'Hermite|Polynômes d'Hermite]]
| double '''hermite'''( unsigned n, double x ) ; || &lt;math&gt;H_n(x)=(-1)^n e^{x^2}\frac{d^n}{dx^n}e^{-x^2}\,\!&lt;/math&gt;
|-
! [[Série hypergéométrique|Séries hypergéométriques]]
| double '''hyperg'''( double a, double b, double c, double x ) ; || &lt;math&gt;F(a,b,c,x)=\frac{\Gamma(c)}{\Gamma(a)\Gamma(b)}\sum_{n = 0}^\infty\frac{\Gamma(a+n)\Gamma(b+n)}{\Gamma(c+n)}\frac{x^n}{n!}&lt;/math&gt;
|-
! [[Polynômes de Laguerre]]
| double '''laguerre'''( unsigned n, double x ) ; || &lt;math&gt;L_n(x)=\frac{e^x}{n!}\frac{d^n}{dx^n}\left(x^n e^{-x}\right), \text{ pour } x \ge 0&lt;/math&gt;
|-
! [[Polynômes de Legendre]]
| double '''legendre'''( unsigned l, double x ) ; || &lt;math&gt;P_l(x) = {1 \over 2^l l!} {d^l \over dx^l } (x^2 -1)^l, \text{ pour } \left|x\right| \le 1 &lt;/math&gt;
|-
! [[Fonction zêta de Riemann]]
| double '''riemann_zeta'''( double x ) ; || &lt;math&gt;
\Zeta(x) = 
          \begin{cases}
                 \displaystyle \sum_{k = 1}^\infty k^{-x}, &amp; \text{ pour } x &gt; 1 \\[10pt]
                 \displaystyle 2^x\pi^{x-1}\sin\left(\frac{x\pi}{2}\right)\Gamma(1-x)\zeta(1-x), &amp; \text{ pour } x &lt; 1 \\
             \end{cases}
&lt;/math&gt;
|-
! [[Fonctions sphériques de Bessel du premier genre]]
| double '''sph_bessel'''( unsigned n, double x ) ; || &lt;math&gt;j_n(x) = \sqrt{\frac{\pi}{2x}} J_{n+1/2}(x), \text{ pour } x \ge 0&lt;/math&gt;
|-
! [[Fonctions sphériques de Legendre généralisées]]
| double '''sph_legendre'''( unsigned l, unsigned m, double theta ) ; || &lt;math&gt; Y_{l}^{m}(\theta, 0) \text{ avec } Y_{l}^{m}(\theta, \phi) = (-1)^{m}\left[\frac{(2l+1)}{4\pi}\frac{(l-m)!}{(l+m)!}\right]^{1 \over 2} P_{l}^{m}(cos \theta)e^{im\phi} \text{ pour } |m| \leq l&lt;/math&gt;
|-
! [[Fonctions sphériques de Neumann]]
[[Fonctions sphériques de Bessel du deuxième genre]]
| double '''sph_neumann'''( unsigned n, double x ) ; || &lt;math&gt; n_{n}(x) = \sqrt{\frac{\pi}{2x}} N_{n+1/2}(x) \text{ pour } x \geq 0&lt;/math&gt;
|}

Chacune de ces fonctions possède deux variantes supplémentaires. En rajoutant le suffixe ‘'''f'''’ ou ‘'''l'''’ au nom de la fonction, on obtient les mêmes fonctions agissant sur des &lt;code&gt;float&lt;/code&gt; ou des &lt;code&gt;long double&lt;/code&gt; respectivement. Par exemple :
&lt;source lang=&quot;cpp&quot;&gt;
float sph_neumannf( unsigned n, float x ) ;
long double sph_neumannl( unsigned n, long double x ) ;
&lt;/source&gt;

=== Conversion de références ===
=== Conversion polymorphe pour les objets fonctions ===
=== Type traits pour la métaprogrammation ===
=== Méthode uniforme pour calculer le type de retour des objets fonctions ===

== Notes et références ==
{{Références}}

== Liens externes ==
* [http://www.open-std.org/jtc1/sc22/wg21/ Le Comité du Standard C++]
* [http://www.research.att.com/~bs/ Page personnelle de Bjarne Stroustrup]
* [http://www2.research.att.com/~bs/C++0xFAQ.html La FAQ de C++0x, par Bjarne Stroustrup]
* [http://www.informit.com/guides/content.asp?g=cplusplus&amp;seqNum=216&amp;rl=1 C++0x : Le nouveau visage du Standard C++]
* [http://www.pvv.org/~oma/cpp0x_aquadi_nov_2007.pdf Introduction rapide au C++0x (novembre 2007)]

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Norme ISO]]
[[Catégorie:C++]]

[[sv:C++#Historia]]</text>
      <sha1>leftnjqkiwrgdu94xyyxlt4cfm0sniu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Object-PL/SQL</title>
    <ns>0</ns>
    <id>6615370</id>
    <revision>
      <id>101396670</id>
      <parentid>99519887</parentid>
      <timestamp>2014-02-19T13:58:23Z</timestamp>
      <contributor>
        <username>Fthevenet</username>
        <id>1766334</id>
      </contributor>
      <minor/>
      <comment>Petite correction grammaticale</comment>
      <text xml:space="preserve" bytes="10748">'''Object-PL/SQL''' ('''[[Programmation orientée objet|Object]]-Procedural Language/[[Structured Query Language]]''' ou tout simplement '''O-PL/SQL''') est une méthodologie d'usage de l'extension [[programmation procédurale|procédurale]] pour le [[langage de programmation|langage]] [[SQL]] dans la [[Oracle Database|Base de Données Oracle]]&lt;ref name=&quot;CITDK&quot;&gt;{{lien web|url=http://www.cit.dk/cot/reports/reports/Case4/18/cot-4-18.pdf|titre=Experiences with Object Oriented Development in PL/SQL|auteur=Lassan, Alan R., Due, Jacob Steen|jour=13|mois=juin|année=2000|éditeur=The danish National Center for IT Research|consulté le=15 avril 2012}}&lt;/ref&gt;. Les particularités additionnelles de la version 7 au-delà d'autres améliorations ultérieures sont orientées vers l'usage du [[paradigme]] de la [[base de données orientée objet]]&lt;ref name=&quot;DBAORA&quot;&gt;{{lien web|url=http://www.dba-oracle.com/t_edb_pl_sql_features_release.htm|titre=PL/SQL Features by Release|auteur=Cunningham, Lewis|éditeur=Burleson Consulting|consulté le=15 avril 2012}}&lt;/ref&gt;.

Bien que la syntaxe générale du langage [[PL/SQL]] ressemble à celle du [[Pascal (langage de programmation)|Pascal]] et de l'[[Ada (langage)|Ada]], il y a eu beaucoup d'améliorations, qui incluent surtout le ''code java intégré''&lt;ref name=&quot;STKOVER&quot;&gt;{{lien web|url=http://stackoverflow.com/questions/70072/when-should-you-use-java-stored-procedures-with-an-oracle-database-what-are|titre=When Should you use Java procédures stockées with an Oracle Database, what are the Drawbacks?|éditeur=Stack Overflow|consulté le=15 avril 2012}}&lt;/ref&gt; et la ''syntaxe orientée objet''&lt;ref name=&quot;ETUT&quot;&gt;{{lien web|url=http://etutorials.org/SQL/Oracle+PL+SQL+Language+Pocket+Reference/Chapter+1.+Oracle+PLSQL+Language+Pocket+Reference/1.16+Oracles+Object-Oriented+Features/|titre=Oracle's Object-Oriented Features|éditeur=etutorial.org|consulté le=16 avril 2012}}&lt;/ref&gt; dans le SQL.

L'intégration de [[déclencheur]]s et de [[procédure stockée|procédures stockées]] constituent conjointement une des plus grandes percées qui ont favorisé l'usage du PL/SQL dans un paradigme orienté objet&lt;ref name=&quot;SAMS&quot;&gt;Benett, 2002:144&lt;/ref&gt;. L'inclusion pour le syntaxe SQL de déclarations comme &lt;nowiki&gt;[class].[object]&lt;/nowiki&gt;, et aussi l'implementation de l'objet ''type''&lt;ref name=&quot;TOP10&quot;/&gt; (similaire à presque tous les langages OO), ont complété le minimum d'articles nécessaires pour la démarche d'une extension du SQL sans l'usage d'aucun [[Persistance (informatique)|logiciel particulier de projection]] ou ''persistence framework'' &lt;ref name=&quot;BALES&quot;&gt;Bales, 2007:107-209&lt;/ref&gt;.

== Autonomie, notorieté et importance de l'O-PL/SQL ==
L'O-PSL/SQL n'est pas simplement l'usage d'une version d'un langage de programmation, mais c'est le ''modus faciendi'' qui définit l'autonomie du thème&lt;ref name=&quot;JAVA2&quot;&gt;{{lien web|url=http://www.java2s.com/Tutorial/Oracle/0620__Object-Oriented/UseObjectPLSQL.htm|titre=Use Object PL/SQL|éditeur=java2s.com|consulté le=19 avril 2012}}&lt;/ref&gt; Chacune des versions du PL/SQL, en débutant de la {{7e}}, apporte de si nombreuses innovations que c'est impossible de traiter ces usages-ci de sub-thèmes du PL/SQL. Il y a eu une vraie révolution qui a établi la frontière entre le langage usé jadis et l'aspect orienté objet dans ce nouveau langage. C'est précisément cet abord qui a provoqué l'emploi à large échelle de l'O-PL/SQL&lt;ref name=&quot;STEVE&quot;&gt;Feuerstein, 2009&lt;/ref&gt;.

== Une confusion d'objets ==
On ne doit pas confondre les notions d&lt;nowiki&gt;'&lt;/nowiki&gt;''objet de base de données'' avec celles-là d'''objet de classe''. Il faut, en chaque situation, identifier qu'est-ce que c'est un ''objet'' dans un contexte donné.

''Objet de base de données'' est un concept qui concerne la base de données [[Modèle relationnel|relationnelle]] ou séquentielle et qui est utilisé dans les nouveaux modèles. ''Tables'', ''déclencheurs'', ''colonnes'', ''indices'' sont des exemples d'objets de base de données&lt;ref name=&quot;TOP10&quot;&gt;{{lien web|url=http://www.codeproject.com/Articles/43629/Top-10-steps-to-optimize-data-access-in-SQL-Server|titre=Optimize Database Files and Apply Partitioning|auteur=Shubho, Al-Farooque|jour=8|mois=novembre|année=2009|éditeur=The Code Project|consulté le=19 avril 2012}}&lt;/ref&gt; qui sont rencontrés dans Object-PL/SQL, mais les mêmes éléments peuvent être traités dans l'autre contexte, de la notion des objets [[Java (langage)|Java]], spécifiquement un élément d'un ensemble dont le début de son existence se passe à partir de l'''instanciation'' d'une classe.

== The PL/SQL ==
{{Article détaillé|PL/SQL}}
le PL/SQL est le langage SQL étendu utilisé par la [[Oracle Database|Base de données Oracle]].

PL/SQL est disponible dans l'Oracle (depuis version 7) et dans l'[[IBM DB2]] (depuis version 9.7)&lt;ref name=&quot;IBM&quot;&gt;{{lien web|url=http://www.ibm.com/developerworks/data/library/techarticle/dm-0907oracleappsondb2/index.html|titre=DB2 10: Run Oracle applications on DB2 10 for Linux, UNIX, and Windows|éditeur=IBM|consulté le=20 avril 2012}}&lt;/ref&gt;.

O-PL/SQL permet de définir des classes et les ''instancier'' comme objets, de créer des types de données définis par l'utilisateur (programmateur) et ''[[Constructeur (programmation informatique)|constructeurs]]'', au-delà d'écrire des procédures stockées et des déclencheurs en Java, et aussi de la création de types ''user-defined'' et de constructeurs.

== Exemples d'usage de la syntaxe de l'O-PL/SQL ==
Il y a ici un petit ensemble d'exemples extraites de la documentation officielle&lt;ref name=&quot;ORADOC&quot;&gt;{{lien web|url=http://docs.oracle.com/|titre=Oracle Documentation|éditeur=Oracle|consulté le=19 avril 2012}}&lt;/ref&gt; et d'autres sources:

=== Exemple 1 ===

Un exemple simple d'''object-oriented PL/SQL''&lt;ref&gt;{{lien web|url=http://www.adp-gmbh.ch/ora/plsql/oo/example_1.html|titre=Object Oriented Oracle, example 1|éditeur=René Nyffenegger's collection of things on the web|consulté le=19 avril 2012}}&lt;/ref&gt;&lt;source lang=&quot;SQL&quot;&gt;

create or replace type base_type as object (
  a number,
  constructor function base_type return self as result,
  member function  func return number,
  member procedure proc (n number)
) instantiable not final;
/&lt;/source&gt;
Maintenant, la codification du type est accomplie. Donc, il est défini comment se conduisent-ils les fonctions de type, les procédures et les constructeurs:&lt;source lang=&quot;SQL&quot;&gt;
create or replace type body base_type as 
  constructor function base_type return self as result is
  begin
    a:=0;
    return;
  end base_type;

  member function func return number is
  begin
    return a;
  end func;

  member procedure proc (n number) as
  begin
    a:=n;
  end proc;
end;
/&lt;/source&gt;
On est prêt à dériver de ''base_type''. Le mot-clé ''under'' est utilisé pour la dérivation. Le type dérivé definit un nouveau attribut (nommé ''m''), qui superpose ''func''.&lt;source lang=&quot;SQL&quot;&gt;
create or replace type deriv_type under base_type (
  m number,
  overriding member function func return number
);
/&lt;/source&gt;
Bien comme les types bases, il faut codifier les méthodes superposées au type dérivé:&lt;source lang=&quot;SQL&quot;&gt;
create or replace type body deriv_type as
  overriding member function func return number is
  begin
    return m*a;
  end;
end;
/&lt;/source&gt;
Les types créés peuvent être instanciés et les méthodes peuvent être demandées:&lt;source lang=&quot;SQL&quot;&gt;
declare
  b1 base_type :=base_type();
  b2 base_type :=base_type(4);
  d1 deriv_type:=deriv_type(5,6);
  d2 deriv_type:=deriv_type(5,6);
begin
  dbms_output.put_line(b1.func);
  dbms_output.put_line(b2.func);

  d1.proc(4);
  dbms_output.put_line(d1.func);
  dbms_output.put_line(d2.func);
end;
/&lt;/source&gt;
Résultats
* 0
* 4
* 24
* 30
Les types créés sont devenus des types ''réels'' et on les peut utiliser pour attributs dans tables:&lt;source lang=&quot;SQL&quot;&gt;
create table table_base (
  b base_type
);
declare
  base  base_type := base_type();
  deriv deriv_type:= deriv_type(8,9);
begin
  insert into table_base values(base);
  insert into table_base values(deriv);
end;
/
select t.b.func() from table_base t;
T.B.FUNC()&lt;/source&gt;
Résultats:
* 0
* 72
&lt;source lang=&quot;SQL&quot;&gt;
select avg(t.b.func()) from table_base t;
AVG(T.B.FUNC())&lt;/source&gt;
Résultat:
* 36

=== Exemple 2 ===
Un autre exemple de procédure stockée en Java intégré est rencontré dans Oracle Documentation&lt;ref name=&quot;ORA2&quot;&gt;{{lien web|url=http://docs.oracle.com/cd/B19306_01/java.102/b14187/chthree.htm#CACFGDCI|titre=Calling Java Methods in Oracle Database|éditeur=Oracle|consulté le=20 avril 2012}}&lt;/ref&gt;.

== Bibliographie ==
* {{ouvrage|lang=en|présentation en ligne|url=http://books.google.com.br/books?id=1RwFA-vlwX8C&amp;pg=PA144&amp;lpg=PA144&amp;dq=mixing+java+in+pl/sql+procedures+and+triggers&amp;source=bl&amp;ots=Vw7l1H7TUe&amp;sig=bykIRLXpPkVPYucWr3fJhpYjzfY&amp;hl=pt-BR&amp;sa=X&amp;ei=L2WMT5ukDYio8gST1JHFCQ&amp;ved=0CCMQ6AEwAA#v=onepage&amp;q=mixing%20java%20in%20pl%2Fsql%20procedures%20and%20triggers&amp;f=false|nom=Bennett|prénom=Mathew|titre=Programming Oracle Developer|numéro d'édition=1|lieu=Indianapolis|éditeur=Sams|année=2002|pages totales=348|isbn=0672321106}}
* {{ouvrage|lang=en|présentation en ligne|url=http://books.google.com.br/books?id=FqUKI3MSuHYC&amp;printsec=frontcover&amp;hl=pt-BR&amp;source=gbs_ge_summary_r&amp;cad=0#v=onepage&amp;q&amp;f=false|nom=Bales|prénom=Donals|titre=PL/SQL from Novice to Professional|numéro d'édition=1|lieu=New York|éditeur=Apress|année=2007|isbn=10590598822|pages totales=469}}
* {{ouvrage|lang=en|présentation en ligne|url=http://my.safaribooksonline.com/book/databases/oracle-pl-sql/9780596805401|titre=Oracle PL/SQL Programming|nom=Feuerstein|prénom=Steven|nom2=Pribyl|prénom2=Bill|lieu=Sebastopol|éditeur=O'Reilly Media, Inc.|année=2009|pages totales=978-0-596-51446-4|isbn=9780596514464}}
*{{ouvrage|lang=en|présentation en ligne|url=http://218.92.71.5:1085/trebook/book/book36/2009986047703.pdf|nom=Rahayu|prénom=Wenny|nom2=taniar|prénom2=David|nom3=Pardede|prénom3=Eric|titre=Object-Oriented Oracle|lieu=Hershey|éditeur=IRM Press|année=2006|pages totales=345|isbn=1591406080}}

== Articles connexes ==
* [[Base de données relationnelle]]
* [[Transact-SQL]]
* [[Système de gestion de base de données]]

== Sources ==
* {{Traduction/Référence|en|Object-PL/SQL|511448747}}

== Notes et références ==
{{Références}}

== Liens externes ==
[http://elearning.algonquincollege.com/coursemat/dat2355d/oracle-oo.html Examples d'O-Pl/SQL]

{{DEFAULTSORT:Object-Plsql}}
[[Catégorie:Programmation orientée objet]]
[[Catégorie:Système de gestion de base de données]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Langage de requête]]

{{Portail|bases de données|programmation informatique}}</text>
      <sha1>n6ykmlcmu9poi8wglauht0upswyneza</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tea (langage de programmation)</title>
    <ns>0</ns>
    <id>6671779</id>
    <revision>
      <id>91049691</id>
      <parentid>84580925</parentid>
      <timestamp>2013-03-20T16:20:15Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 2 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q3516674]]</comment>
      <text xml:space="preserve" bytes="1874">{{Infobox Langage de programmation
|  nom                    = Tea
|  paradigmes             = [[Programmation impérative|Impératif]], [[Programmation fonctionnelle|fonctionnel]], [[Programmation orientée objet|objet]]
|  année                  = [[1997]]
|  auteur                 = Jorge Nunes
|  développeurs           = Jorge Nunes
|  typage                 = [[Typage dynamique|dynamique]]
|  implémentations        = Tea
|  dialectes              = 
|  influencé par          = Java, Scheme, [[Tool Command Language|Tcl]]
|  système d'exploitation = [[Multi-plateforme]]
|  licence                = Propriétaire
|  site web               = [http://www.pdmfc.com/tea/ http://www.pdmfc.com/tea/]
}}

Tea est un langage de script pour l'environnement Java inventé par Jorge Nunes en 1997. 
Il combine les fonctionnalités de Java, Scheme et [[Tool Command Language|Tcl]].

== Caractéristiques ==

Tea est un langage de [[Programmation fonctionnelle| programmation fonctionnel]] intégrant les fonctions comme [[Programmation orientée objet|objets]].

== Exemples ==

Une fonction carré :
&lt;source lang=&quot;scheme&quot;&gt;
define carre ( x ) { * $x $x }
echo [carre 4]
&lt;/source&gt;

Une liste :
&lt;source lang=&quot;scheme&quot;&gt;
define liste (1 2 3 &quot;quatre&quot; &quot;cinq&quot;)
&lt;/source&gt;

Un objet cercle :

&lt;source lang=&quot;scheme&quot;&gt;
class Cercle (
     _rayon
     _centre_x
     _centre_y
)

method Cercle Surface () {
      * 3.1416 $_rayon $_rayon
}

method Cercle constructor ( r x y ) {
      set! _rayon $r
      set! _centre_x $x
      set! _centre_y $y
}

define c1 [new Cercle 7 0 0]
define c2 [new cercle 10 1 1]

echo &quot;Aire c1 : &quot; [$c1 Surface]
&lt;/source&gt;

== Lien externe ==
* {{en}} [http://www.pdmfc.com/tea Site du langage Tea]

{{Palette Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]</text>
      <sha1>luh9wba8oi8cacoe6yq2qbg5vkd7rqx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Liste d'instructions</title>
    <ns>0</ns>
    <id>6696997</id>
    <revision>
      <id>91053250</id>
      <parentid>84933026</parentid>
      <timestamp>2013-03-20T16:49:29Z</timestamp>
      <contributor>
        <username>Addbot</username>
        <id>1504326</id>
      </contributor>
      <minor/>
      <comment>Retrait de 4 liens interlangues, désormais fournis par [[d:|Wikidata]] sur la page [[d:q613332]]</comment>
      <text xml:space="preserve" bytes="1233">{{Voir homonymes|IL}}

La '''liste d'instruction''', ou '''''{{lang|en|Instruction List}}''''' ('''IL''') en [[anglais]], est un des cinq [[Langage de programmation|langages de programmation]] pour [[Automate programmable industriel|automates programmables industriels]] (API) définis par la norme [[CEI 61131-3]]. C'est un [[langage de bas niveau]], comparable à l'[[assembleur]]&lt;ref&gt;{{article|titre=Langages de programmation pour systèmes automatisés|sous-titre=Norme CEI 61131-3|nom1=Jouvray|prénom1=Nicolas|périodique=Techniques de l'ingénieur. Informatique industrielle|lien périodique=Éditions techniques de l'ingénieur|ISSN=1632-3831|année=2008|volume=S3|numéro=S8030}}.&lt;/ref&gt;.

== Langages dérivés ==

[[Siemens (entreprise)|Siemens]] propose, pour programmer ses API, un langage dérivé d'IL appelé ''{{lang|en|Statement List}}'' (STL) en anglais, et ''{{lang|de|Anweisungs-Liste}}'' (AWL) en allemand.

{{Autres projets
 | wikiversity = Automatisme : norme 1131-3 et GRAFCET/Le langage IL de la norme 1131-3
 | wikiversity titre = Le langage IL de la norme 1131-3
}}

== Références ==
{{Références}}

{{Portail|industrie|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Automatisme]]</text>
      <sha1>b8h8m0hbvbtwj9ytdcim0r05ruwaozk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rust (Mozilla)</title>
    <ns>0</ns>
    <id>6719375</id>
    <revision>
      <id>100376713</id>
      <parentid>99687262</parentid>
      <timestamp>2014-01-18T22:01:01Z</timestamp>
      <contributor>
        <username>Olemaire</username>
        <id>1350470</id>
      </contributor>
      <minor/>
      <comment>rust is in 0.9 release now</comment>
      <text xml:space="preserve" bytes="7426">{{Voir homonymes|Rust}}
{{Ébauche|informatique}}
{{Infobox Langage de programmation
 | couleur boîte = b7410e
 | nom = {{blanc|Rust}}
 | logo = 
 | paradigmes = [[Programmation impérative|impératif]], [[Programmation orientée objet|Objet]], [[Programmation fonctionnelle|fonctionnel]], [[Programmation concurrente|concurrent]]
 | année = [[2010]]
 | auteur = Graydon Hoare
 | développeurs = [[Mozilla]]
 | typage = [[Typage fort|Fort]], [[Typage statique|Statique]]
 | dernière version = 0.8 (26 septembre 2013)
 | implémentations = 
 | dialectes = 
 | influencé par = [[C++]], [[Erlang (langage)|Erlang]], [[Haskell]], [[Scala (langage)|Scala]], ...
 | a influencé = 
 | extension = .rs
 | système d'exploitation = [[Multiplate-forme]]
 | licence = [[Licence MIT|MIT]] / [[Licence Apache|Apache 2]]
 | site web = [http://www.rust-lang.org/ rust-lang.org]
}}

'''Rust''' est un [[langage de programmation]] compilé multi-paradigme expérimental développé par Mozilla Research&lt;ref name=&quot;lamda&quot;&gt;{{lien web|langue=en|url=http://lambda-the-ultimate.org/node/4009|titre=The Rust Language|prénom=Noel|date=2010-07-08|éditeur=Lambda the Ultimate|consulté le=2010-10-30}}&lt;/ref&gt;. Il a été conçu pour être « un langage sécurisé, [[programmation concurrente|concurrent]], pratique »&lt;ref name=&quot;rust-lang&quot;&gt;{{lien web|langue=en|url=http://www.rust-lang.org/|titre=The Rust Programming Language|consulté le=2012-10-21}}&lt;/ref&gt;{{,}}&lt;ref name=&quot;language-faq&quot;&gt;{{lien web|langue=en|url=https://github.com/mozilla/rust/wiki/Doc-language-FAQ|titre=Doc language FAQ|consulté le=2012-10-21}}&lt;/ref&gt;, supportant les styles de programmation [[purement fonctionnel|purement fonctionnelle]], [[modèle d'acteur]], [[programmation procédurale|procédurale]] et [[programmation orientée objet|orientée objet]].

Le langage s'est développé à partir d'un projet personnel du développeur en chef Graydon Hoare, qui commença à travailler dessus en 2006. Son employeur [[Mozilla]] commença sa participation en 2009&lt;ref name=&quot;proj-faq&quot;&gt;{{lien web|langue=en|url=https://github.com/mozilla/rust/wiki/Doc-project-FAQ|titre=Project FAQ|date=2010-09-14|consulté le=2012-01-11}}&lt;/ref&gt; et révéla officiellement leurs travaux pour la première fois en 2010&lt;ref name=&quot;future-tense&quot;&gt;{{lien web|langue=en|url=http://www.slideshare.net/BrendanEich/future-tense-7782010|titre=Future Tense|date=2011-04-29|consulté le=2012-02-06|extrait=At Mozilla Summit 2010, we launched Rust, a new programming language motivated by safety and concurrency for parallel hardware, the “manycore” future which is upon us.}}&lt;/ref&gt;. La même année, le projet passa du compilateur initialement utilisé (écrit en [[OCaml]]) au compilateur [[auto-hébergement (informatique)|auto-hébergé]] écrit en Rust&lt;ref name=&quot;rust-in-rust&quot;&gt;{{lien web|langue=en|url=http://blog.mozilla.com/graydon/2010/10/02/rust-progress/|titre=Rust Progress|nom=Hoare|prénom=Graydon|date=2010-10-02|consulté le=2010-10-30}}&lt;/ref&gt;. Ce compilateur, connu sous le nom de ''rustc'', s'est compilé avec succès en 2011&lt;ref name=&quot;rust-compiles-rust&quot;&gt;{{lien web|langue=en|url=https://mail.mozilla.org/pipermail/rust-dev/2011-April/000330.html|titre=[rust-dev&amp;#93; stage1/rustc builds|nom=Hoare|prénom=Graydon|date=2011-04-20|consulté le=2011-04-20|extrait=After that last change fixing the logging scope context bug, looks like stage1/rustc builds. Just shy of midnight :)}}&lt;/ref&gt;. Le compilateur auto-hébergé utilise [[LLVM]] pour son [[Backend]].

La première [[Version_d'un_logiciel#Phases_de_d.C3.A9veloppement|version alpha]] numérotée du compilateur Rust apparait en janvier 2012&lt;ref name=&quot;rustc-0.1&quot;&gt;{{lien web|langue=en|url=http://www.reddit.com/r/programming/comments/opgxd/mozilla_and_the_rust_community_release_rust_01_a/|titre=Mozilla and the Rust community release Rust 0.1 (a strongly-typed systems programming language with a focus on memory safety and concurrency)|auteur=catamorphism|date=2012-01-20|consulté le=2012-02-06}}&lt;/ref&gt;. La version actuelle est la version 0.9, sortie en janvier 2014&lt;ref name=&quot;release&quot;&gt;{{lien web|url=https://github.com/mozilla/rust/blob/master/RELEASES.txt|titre=Rust  Release Notes}}&lt;/ref&gt;.

De par la politique de Mozilla&lt;ref name=&quot;moz-manifesto&quot;&gt;{{lien web|langue=en|url=http://www.mozilla.org/about/manifesto.en.html|titre=The Mozilla Manifesto|consulté le=2012-04-09}}&lt;/ref&gt;, Rust est entièrement développé de façon ouverte (les ingénieurs de Mozilla Research publient leurs idées et les décisions prises lors des meetings) et sollicite les remarques et contributions de la communauté. La conception du langage est graduellement améliorée au travers des retours de l'équipe travaillant sur le [[moteur de rendu]] [[Servo (moteur de rendu)|Servo]]&lt;ref name=&quot;rustinservo&quot;&gt;{{lien web|langue=en|url=http://arstechnica.com/information-technology/2013/04/samsung-teams-up-with-mozilla-to-build-browser-engine-for-multicore-machines/|titre=Samsung teams up with Mozilla to build browser engine for multicore machines|auteur=Peter Bright|date=2013-04-03|consulté le=2013-04-04}}&lt;/ref&gt; et de façon pragmatique lors de l'écriture du compilateur.

==Points forts==
Rust repose sur des concepts connus et éprouvés (d'où le nom ''Rust'', « la rouille » en anglais) et n'intègre pas de concepts nouveaux et non testés&lt;ref&gt;{{lien web|langue=fr|url=http://lea-linux.org/documentations/Rust|titre=Présentation de Rust sur Léa-Linux|consulté le=2013-12-11}}&lt;/ref&gt;. Ces concepts ont été empruntés à des langages de programmation existants et assemblés dans un seul langage&lt;ref&gt;{{lien web|langue=fr|url=http://linuxfr.org/news/presentation-de-rust-0-8|titre=Sortie de Rust 0.8|consulté le=2013-15-10}}&lt;/ref&gt; :
* Orienté bas niveau, il permet malgré tout de choisir la gestion mémoire adaptée au programme: [[Pile d'exécution|pile]], [[Tas (allocation dynamique)|tas]] ([[Pointeur intelligent|unique_ptr, shared_ptr]]), [[Ramasse-miettes (informatique)|ramasse-miettes]] ; 
* Gestion de la concurrence intégrée dans le langage ;
* Sûr par défaut, avec la possibilité de contourner cette sûreté dans les blocs ''unsafe'' ;
** [[Typage statique]] sans [[Conversion de type|conversion]]s implicites ;
** Accès mémoire validés [[Analyse statique de programmes|statiquement]] par le [[compilateur]] ;
** [[Objet immuable|Variables immuables]] par défaut ;
** [[Passage de messages]] entre tâches concurrentes pour éviter des erreurs liées aux accès concurrents à la mémoire ;
* [[Inférence de types]] ;
* [[Filtrage par motif]] ;
* [[Généricité]].
Rust est souvent décrit comme l'un des successeurs potentiels de [[C++]] (avec [[D (langage)|D]] et, dans une moindre mesure, [[Go  (langage)|Go]]) notamment grâce à sa sûreté — c'est un objectif clairement affiché par les développeurs.

==Exemples de code==
Le classique [[Hello world|Hello World]], valide avec la version 0.8:
&lt;source lang=&quot;cpp&quot;&gt;
fn main()
{
    println!(&quot;Hello World!&quot;);
}
&lt;/source&gt;

== Références ==
{{Traduction/Référence|en|Rust (programming language)|548666626}}
{{Références}}

== Liens externes ==
* [http://www.rust-lang.org/ Site officiel]

{{Palette|Langages de programmation}}

{{Portail|informatique|logiciels libres|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage impératif]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Langage fonctionnel]]</text>
      <sha1>pvct74yfyoryvae4jsomrx6cw576xm6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Dependency Constraint Language</title>
    <ns>0</ns>
    <id>6734198</id>
    <revision>
      <id>96852091</id>
      <parentid>85568528</parentid>
      <timestamp>2013-09-21T11:09:30Z</timestamp>
      <contributor>
        <username>Lomita</username>
        <id>621253</id>
      </contributor>
      <minor/>
      <comment>[[WP:WPC|WPCleaner]] v1.29 - Lien interne avec cible identique au texte ([[P:CS|Correction syntaxique]])</comment>
      <text xml:space="preserve" bytes="1792">En informatique, le langage DCL ('''Dependency Constraint Language''') permet de localiser dans le code source d'un [[logiciel]] des décisions d'implémentation qui représentent des violations à l'[[Architecture logicielle|architecture]] décrite au départ&lt;ref&gt;{{Harvsp|Terra|2012|id=TerraValenteCzarneckiBigonha2012}}&lt;/ref&gt;.

Il permet de contrôler deux types de violations :
* les divergences (quand une dépendance existante dans le code n'est pas prévue dans l'architecture de départ),
* les absences (quand une dépendance existante dans l'architecture de départ n'existe pas dans le code source).

==Utilisation==

Le langage DCL spécifie quatre primitives pour définir les contraintes :
* only can (divergence)
&lt;pre&gt;only Factory can-create Product&lt;/pre&gt;
* can only (divergence)
&lt;pre&gt;Util can-only-depend $java, Util&lt;/pre&gt;
* cannot (divergence)
&lt;pre&gt;View cannot-access Model&lt;/pre&gt;
* must (absence)
&lt;pre&gt;Product must-implement Serializable&lt;/pre&gt;

Il se complète par d’autres primitives pour des besoins spécifiques : access, declare, create, extend, implement, throw, annotate.

== Références ==
{{Références|colonnes=4}}

== Bibliographie ==

* {{article
|langue     = en
|id         = TerraValenteCzarneckiBigonha2012
|prénom1    = Ricardo
|nom1       = Terra
|prénom2    = Marco Tulio
|nom2       = Valente
|prénom3    = Krzysztof
|nom3       = Czarnecki
|prénom4    = Roberto S.
|nom4       = Bigonha
|titre      = Recommending Refactorings to Reverse Software Architecture Erosion
|périodique = 16th European Conference on Software Maintenance and Reengineering
|année      = 2012
|mois       = mars
|pages      = 335-340
|isbn       = 978-0-7695-4666-7
|doi        = 10.1109/CSMR.2012.40
}}

{{portail|informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>01i89cyowxc19rulk50xv5m49u6cfst</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>HaXe</title>
    <ns>0</ns>
    <id>6413486</id>
    <revision>
      <id>99003505</id>
      <parentid>99003491</parentid>
      <timestamp>2013-12-07T19:19:21Z</timestamp>
      <contributor>
        <username>Jmax</username>
        <id>68688</id>
      </contributor>
      <comment>/* Liens  externes */ suppr. liens non encyclopédiques cf [[WP:LE]]</comment>
      <text xml:space="preserve" bytes="2692">{{Infobox Langage de programmation
| nom                      = Haxe
| nom et logo              = non
| date de première version = 2005
| auteur                   = [[Nicolas Cannasse]]
| influencé par            = [[Java (langage)|Java]], [[Actionscript]]
| site web                 = [http://haxe.org/ Site officiel]
}}

{{Minuscule}}
{{Ébauche|informatique}}
{{à sourcer|date=juin 2012}}
'''Haxe''' est un [[langage de programmation]] développé par [[Nicolas Cannasse]] et la société [[Motion-Twin]] qui, dans le cadre d’une utilisation pour le Web, permet d’écrire la partie serveur et la partie client dans un même langage.

À cette fin, Haxe permet de :
* créer des fichiers [[Adobe Flash|SWF]] qui utilisent les [[Interface de programmation|APIs]] pour les lecteurs [[Adobe Flash Player|Flash Player]] 6 à 11 ;
* créer du code [[JavaScript]] utilisant les API DHTML des navigateurs, ainsi que des applications AJAX. Il est aussi possible d'utiliser des bibliothèques extérieures, tels que jQuery qui est directement inclus au téléchargement de Haxe ;
* créer du [[bytecode]] pour la [[Neko (langage)|NekoVM]] qui peut être employé côté serveur (grâce à un plug-in [[Apache HTTP Server|Apache]]) ou empaqueté dans un exécutable autonome ;
* créer du code PHP qui peut être déployé sur n’importe quel serveur supportant le langage PHP 5.

Haxe permet donc d'assurer l’interopérabilité entre ces différentes plateformes en fournissant des bibliothèques communes.

Il permet, par ailleurs, de créer du code [[C++]], et des cibles [[Java (langage)|Java]]&lt;ref&gt;http://haxe.org/com/meeting&lt;/ref&gt; et [[C sharp|C#]] sont en préparation (courant 2012  - 2013) 	{{référence souhaitée}}.

== Voir aussi ==

=== Liens internes ===
[[Neko (langage)]]

=== Bibliographie ===
* {{Ouvrage
| langue      = en
| prénom1     = Franco 
| nom1        = Ponticelli
| prénom2     = Lee
| nom2        = McColl Sylvester
| titre       = Professional Haxe and Neko Book
| éditeur     = Wrox
| mois        = février
| année       = 2008
| pages       = 619
| isbn        = 978-0-470-12213-6
}}
* {{Ouvrage
| langue      = en
| prénom1     = Benjamin 
| nom1        = Danois
| titre       = haXe 2 Beginner's Guide
| éditeur     = PacktPublishing
| mois        = juillet
| année       = 2011
| pages       = 246
| isbn        = 978-1-849512-56-5
}}


=== Liens externes ===
* {{en}} [http://www.haxe.org/ Haxe]
* {{en}} [http://www.nme.io/ NME], outil open source basé sur le langage Haxe

=== Références ===
&lt;references/&gt;

{{portail|informatique|programmation informatique|internet}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Technologie web]]</text>
      <sha1>f4pycnpeljl1xgkmzrn4fhc9ap2xuaz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MMIX</title>
    <ns>0</ns>
    <id>3716608</id>
    <revision>
      <id>100978223</id>
      <parentid>100967745</parentid>
      <timestamp>2014-02-06T20:32:33Z</timestamp>
      <contributor>
        <username>Cantons-de-l'Est</username>
        <id>502332</id>
      </contributor>
      <minor/>
      <comment>Introduction : Mise en page.</comment>
      <text xml:space="preserve" bytes="24671">{{Infobox Architecture CPU
| nom          = [[Image:Mmix.png|220px|MMIX]]
| concepteur   = [[Donald Knuth]]
| bits         = 64
| lancement    = 1999
| version      = 
| architecture = RISC
| type         = 
| encodage     = Fixe
| branchement  = 
| endianness   = [[Endianness|Gros-boutiste]]
| taille page  = 
| extensions   = 
| libre        = Oui
| registres    = 32 registres spéciaux
| généraux     = 256
| vflottante   = 
}}
'''MMIX''', prononcé {{API|/ɛm.mɪks/}} et usuellement [[typographie|typographié]] dans une [[Police d'écriture|police]] à [[Chasse (typographie)|chasse fixe]] ({{MMIX}}), est à la fois un [[jeu d'instructions]] [[64-bit]] [[Reduced instruction set computer|RISC]] et une [[architecture informatique]] conçu par [[Donald Knuth]], avec une aide importante de {{Lien
  |fr   = John LeRoy Hennessy
  |lang = en
  |trad = John L. Hennessy
  |texte= John LeRoy Hennessy
}}, un des concepteurs de l'architecture [[MIPS]], et de [[Richard L. Sites]], un des concepteurs de l’architecture [[DEC Alpha|Alpha]]. Knuth lui-même présente ce projet en ces mots :

{{Citation bloc|{{MMIX}} est un ordinateur destiné à illustrer les aspects de la programmation au niveau machine. Dans mes livres ''[[The Art of Computer Programming]]'', il remplace &lt;tt&gt;[[MIX]]&lt;/tt&gt;, une machine répliquant le style des années 1960, laquelle jouait un tel rôle... J'ai tenté de concevoir {{MMIX}} de façon à ce que son langage machine soit simple, élégant et facile à apprendre. En parallèle, j'ai fait attention d'inclure toutes les complexités nécessaires pour obtenir une haute performance dans la pratique, de sorte que {{MMIX}} pourrait en principe être construit et peut-être faire concurrence à certains des langages généraux les plus rapides disponibles commercialement&lt;ref group=&quot;trad&quot;&gt;{{en}} « ''{{lang|en|{{MMIX}} is a computer intended to illustrate machine-level aspects of programming. In my books ''[[The Art of Computer Programming]]'', it replaces &lt;tt&gt;[[MIX]]&lt;/tt&gt;, the 1960s-style machine that formerly played such a role... I strove to design {{MMIX}} so that its machine language would be simple, elegant, and easy to learn. At the same time I was careful to include all of the complexities needed to achieve high performance in practice, so that {{MMIX}} could in principle be built and even perhaps be competitive with some of the fastest general-purpose computers in the marketplace.''}} »&lt;/ref&gt;{{,}}&lt;ref&gt;{{Ouvrage |langage=en 
| nom1=Knuth | prénom1=Donald E. |lien auteur1=Donald Knuth
| date=octobre 1999 
| titre=MMIXware: A RISC Computer for the Third Millennium 
| volume=1750 
| collection=''Lecture Notes in Computer Science Tutorial'' 
| lieu=Heidelberg 
| éditeur=Springer-Verlag 
| isbn=3-540-66938-8}}.&lt;/ref&gt;}}

== Architecture ==

En termes d’architecture informatique {{MMIX}} est un ordinateur RISC 64 bits, avec 256 [[Registre de processeur|registres]] 64 bits généraux et 32 registres 64 bits à usage spécifique. {{MMIX}} est une machine [[Endianness|gros-boutiste]] avec des [[Instruction machine|instructions]] 32 bits et un {{Lien
  |fr   = Espace d'adressage virtuel
  |lang = en
  |trad = Virtual address space
  |texte= espace d’adressage virtuel
}} 64 bits. Son [[jeu d'instructions]] comprend 256 codes opérations, dont un est réservé pour un potentiel usage futur. Les nombres à virgule flottante sont implémentés conformément au standard [[IEEE 754]].

=== Instructions ===

Les instructions de {{MMIX}} sont toutes définies et utilisables à partir de leur code opération, qui est un nombre d’un [[octet]], généralement noté sous forme [[hexadécimal]]e. Cependant pour améliorer la lisibilité du code assembleur, une [[Marqueur (métadonnée)|étiquette]] [[mnémotechnique]] unique est associé à chacun des codes. Ainsi l’étiquette &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;ADD&lt;/source&gt; est équivalente à l’instruction numéro {{hexadécimal|32}}, qui est le code opérateur de l’addition.
La plupart des instructions sont de la forme ''[[opérateur]] X Y Z'', où ''opérateur'' spécifie l’instruction, X est un registre servant d’[[accumulateur]], c’est-à-dire utilisé pour stoker le résultat de l’instruction, et Y et Z désignent les registres servant d’[[opérande]]s à l’instruction. Par exemple &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;ADD $0,$1,3&lt;/source&gt; signifie ''[[Affectation (informatique)|affecter]] à &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$0&lt;/source&gt; la [[Somme (arithmétique)]] du nombre stocké dans le registre &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$1&lt;/source&gt; et du nombre &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;3&lt;/source&gt;''.

La plupart des instructions peuvent prendre soit des valeurs immédiates, soit utiliser le contenu d’un registre ; ainsi un seul mnémonique peut correspondre à un ou deux codes opérations.

Typiquement, les [[Programme informatique|programmes]] {{MMIX}} sont construits en utilisant le [[langage assembleur]] {{MMIXAL}}.  L’exemple ci-dessous est un programme écrit en {{MMIXAL}} qui affiche [[Hello world]] :
&lt;source lang=&quot;mmix&quot;&gt;
Main    GETA  $255,string               ; Get the address of the string
                                        ; in register 255.

        TRAP  0,Fputs,StdOut            ; Put the string pointed to
                                        ; by register 255 to file StdOut.

        TRAP  0,Halt,0                  ; End process.

string  BYTE  &quot;Hello, world!&quot;,#a,0      ; String to be printed.
                                        ; #a is newline,
                                        ; 0 terminates the string.
&lt;/source&gt;

=== Registres ===

Dans une puce d’architecture {{MMIX}} il y a 256 registres généraux ,
auxquels on accède par le référence noté de &lt;source enclose=&quot;none&quot; enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$0&lt;/source&gt; à &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$255&lt;/source&gt; et 32 registres spéciaux. Deux des registres spéciaux, &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rL&lt;/source&gt; et &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rG&lt;/source&gt;, déterminent quels sont les registres locaux et lesquels sont globaux. Tous les registres, de &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$0&lt;/source&gt; à &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$(rL-1)&lt;/source&gt; sont des registres locaux. Les registres de [rL] à [rG]-1 sont des ''registres marginaux'' qui retournent toujours 0 s'ils sont utilisés comme source dans une opération. Utiliser un registre marginal en tant que destination d’une opération déclenchera une incrémentation automatique de &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rL&lt;/source&gt; pour inclure ce registre. Tous les registres de [rG] à &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$255&lt;/source&gt; sont appelés registres globaux et ne sont pas sauvegardés sur la pile de registre.



==== Pile de registre local ====

La pile de registre local fournit à chaque [[procédure (informatique)|procédure]] ses propres registres locaux &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rL&lt;/source&gt;, notés de &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$0&lt;/source&gt; à &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$(rL - 1 )&lt;/source&gt;. Si une procédure est appelée, les registres locaux sont ajoutés sur la pile. Les arguments de la procédure sont placés dans les registres locaux restants. Quand une procédure se termine, elle retire les registres précédemment ajoutés. Comme il n’y a que 256 registres physiques, il peut être nécessaire de stocker une partie de la pile en mémoire. Cette action est implémentée avec les registres spéciaux &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rO&lt;/source&gt; et &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rS&lt;/source&gt; qui enregistrent quelle partie de la pile de registre local est en mémoire et quelle partie est toujours dans les registres physiques locaux. Le registre de pile assure également la {{Lien
  |fr   = registre de liaison
  |lang = en
  |trad = Link register
  |texte= liaison rapide de procédures
}}.

==== Registres spéciaux ====

Les 32 registres spéciaux de l’architecture physique sont définis comme suit :
&lt;ol&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rB&lt;/source&gt;, le registre d’[[Amorce (informatique)|amorçage]] (déclencheur), avec un ''b'' comme dans l’anglais ''{{Lang|en|''b''ootstrap}}'' :&lt;/dt&gt;
&lt;dd&gt;lorsqu’un déclenchement se produit, &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rB&lt;/source&gt; est affecté de la valeur stockée dans le registre &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$255&lt;/source&gt; et le registre &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$255&lt;/source&gt; est affecté de la valeur stockée dans le registre &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rJ&lt;/source&gt;, sauvegardant ainsi &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rJ&lt;/source&gt; dans un registre général.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rD&lt;/source&gt;, le registre de ''d''ividende :&lt;/dt&gt;
&lt;dd&gt;La [[division entière]] [[Signe d'une représentation numérique|non-signée]] utilise ce registre en tant que moitié gauche du numérateur (dividende) codé sur 128 bits qui est à diviser par le dénominateur (diviseur).&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rE&lt;/source&gt;, le registre [[epsilon|''e''psilon]], ou registre de la marge d’''e''rreur :&lt;/dt&gt;
&lt;dd&gt;Utilisé dans la comparaison de nombres à virgule flottante tolérant une [[Valeur approchée|marge d’erreur]]&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rH&lt;/source&gt;, nommé registre ''himult'' :&lt;/dt&gt;
&lt;dd&gt;Le terme ''himult'', prononcé {{API|/haɪ.mʌlt/}}, est la contraction de l’anglais ''{{Lang|en|high multiplication}}'', littéralement ''haute multiplication'', où ''haute'' suggère la partie contenant les [[Bit de poids fort|bits de poids les plus forts]] d’un nombre stocké dont la représentation est distribuée sur plusieurs registres distincts. Ce registre est utilisé pour stocker la moitié droite du [[produit (mathématiques)|produit]] de la [[multiplication]] [[nombre entier|entière]] non-signé.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rJ&lt;/source&gt;, le registre de retour de saut, avec un ''j'' comme dans l’anglais ''{{Lang|en|''j''ump}}'' :&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé par &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;PUSH&lt;/source&gt; et &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;POP&lt;/source&gt; pour sauvegarder l’adresse de la prochaine instruction au retour d’un &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;PUSH&lt;/source&gt;.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rM&lt;/source&gt; est le registre de [[Masque (informatique)|masque]] de [[multiplexage]]&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé par les instructions multiplexes &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;MUX&lt;/source&gt; et &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;MUXI&lt;/source&gt;&lt;ref&gt;[http://www-cs-faculty.stanford.edu/~uno/mmop.html MMIX Op Codes]&lt;/ref&gt;.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rR&lt;/source&gt; est le registre de ''r''este :&lt;/dt&gt;
&lt;dd&gt;Il est affecté de la valeur du reste lors des divisions exécutées par &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;DIV&lt;/source&gt;, &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;DIVI&lt;/source&gt;, &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;DIVU&lt;/source&gt;, &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;DIVUI&lt;/source&gt; ou &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;FDIV&lt;/source&gt;.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rBB&lt;/source&gt;, le registre d’amorçage du [[Noyau de système d'exploitation|noyau]], avec ''BB'' comme ''{{Lang|en|''b''ootstrap ''b''is}}'' :&lt;/dt&gt;
&lt;dd&gt;Lors d’une capture par l’instruction &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;TRAP&lt;/source&gt;, ''{{Lang|en|trap}}'' désignant un ''dispositif de capture'' en anglais, &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rBB&lt;/source&gt; est affecté du registre &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$255&lt;/source&gt; et le registre &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;$255&lt;/source&gt; est affecté de la valeur stockée dans &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rJ&lt;/source&gt;, sauvegardant ainsi &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rJ&lt;/source&gt; dans un registre général.&lt;/dd&gt;&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rC&lt;/source&gt;, le ''c''ompteur de cycle :&lt;/dt&gt;
&lt;dd&gt;Il est incrémenté à chaque [[Signal d'horloge|cycle]].&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rN&lt;/source&gt;, le registre de ''n''uméro de série :&lt;/dt&gt;
&lt;dd&gt;Une constante qui identifie le processeur {{MMIX}} courant.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rO&lt;/source&gt;, le registre d’[[Offset (informatique)|offset]] de la [[Pile (informatique)|pile]]&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé pour implémenter la pile de registre.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rS&lt;/source&gt;, avec un ''s'' comme ''{{Lang|en|''s''tack}}'', pile en anglais :&lt;/dt&gt;
&lt;dd&gt;C’est le registre utilisé pour stocker un pointeur vers l’adresse courante de la pile.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rI&lt;/source&gt;, le compteur d’''i''nterval :&lt;/dt&gt;
&lt;dd&gt;Il est décrémenté à chaque cycle et déclenche une [[Interruption (informatique)|interruption]] lorsqu’il atteint zéro.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rT&lt;/source&gt;, avec un ''t'' comme ''{{Lang|en|''t''rap}}'', ''dispositif de capture'' en anglais :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé pour stocker l’adresse du [[Vecteur de démarrage|vecteur]] de déclencheur.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rTT&lt;/source&gt;, avec un ''t'' également en référence à l’anglais ''{{Lang|en|''t''rap}}'', mais il s’agit cette fois du registre de déclencheur dynamique (''{{Lang|en|dynamic trap adress register}}'')&lt;/dt&gt;
&lt;dd&gt;Il est utilisé pour stocker l’adresse du [[Vecteur de démarrage|vecteur]] de déclencheur.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rK&lt;/source&gt;, le registre de masque d’interruption, ''{{Lang|en|interrupt mas''k'' register}}'' en anglais :&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé pour enclencher et déclencher des interruptions spécifiques.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rQ&lt;/source&gt;, le registre de re''q''uête d'interruption :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé pour enregistrer les interruptions au fur et à mesure de leurs survenues.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rU&lt;/source&gt;, le compteur d'''u''tilisation :&lt;/dt&gt;
&lt;dd&gt;Le compte du nombre d'instructions exécutées est stocké dans ce registre.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rV&lt;/source&gt;, le registre de traduction ''v''irtuelle :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé pour la traduction entre [[Mémoire virtuelle|adresses virtuelles]] et physiques. Il mémorise le nombre de [[Segmentation (informatique)|segments]], la taille allouée pour chaque segment, la position de la racine de la {{Lien
  |fr   = table des pages
  |lang = en
  |trad = Page table
}}&lt;/dd&gt; et le nombre {{Lien
  |fr   = Espace d'adresses
  |lang = en
  |trad = Address space
  |texte= d'espaces d'adresses
}}.&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rG&lt;/source&gt;, le registre de seuil ''g''lobal :&lt;/dt&gt;
&lt;dd&gt;Toutes les références de registres généraux codées avec un nombre supérieur ou égal au seuil défini par &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rG&lt;/source&gt; font référence à des registres globaux.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rL&lt;/source&gt;, le registre de seuil ''l''ocal :&lt;/dt&gt;
&lt;dd&gt;Toutes les références de registres généraux codées avec un nombre strictement inférieur au seuil défini par &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rL&lt;/source&gt; font référence à des registres locaux.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rA&lt;/source&gt; le registre de statut ''a''rithmétique :&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé pour la gestion des exceptions arithmétiques : enregistrement, enclenchement et déclenchement. Ces exceptions incluent notamment le {{Lien
  |fr   = Dépassement arithmétique
  |lang = en
  |trad = Arithmetic overflow
  |texte= dépassement arithmétique
}} et la [[division par zéro]].&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rF&lt;/source&gt; le registre de positionnement d'erreur :&lt;/dt&gt;
&lt;dd&gt;Lorsque le système détecte qu'une instruction ne s'est pas exécutée correctement, l'adresse de l'instruction est stockée dans ce registre. Le mnémotechnique ''f'' est lié à l'anglais ''{{Lang|en|''f''ailure location register}}'', où {{Lang|en|failure location register}} peut être traduit par échec. En français on peut se référer aux mots ''f''redaine ou ''f''aux-pas.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rP&lt;/source&gt;, le registre de [[Prédiction de branchement|prédiction]] :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé par l'instruction &lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;CSWAP&lt;/source&gt; de [[Permutation (informatique)|permutation]] [[Permutation conditionnelle|conditionnelle]].&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rW&lt;/source&gt;, le registre de lieu d'interruption :&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé lors d’un déclenchement pour stocker l’adresse de l’instruction après celle qui a été interrompue. Le ''W'' fait référence au nom anglais ''{{Lang|en|''w''here-interrupted register}}'', littéralement le ''registre où-interrompue''.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rX&lt;/source&gt;, le registre d’e''x''écution (déclencheur) :&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé lors de déclenchement pour stocker l’instruction qui a été interrompue.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rY&lt;/source&gt; l’opérande Y (déclencheur) :&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé, lors d’un déclenchement, pour stocker la première opérande de l’instruction. ''Y'' fait référence au nom générique usuel en mathématique.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rZ&lt;/source&gt; l’opérande Z (déclencheur) :&lt;/dt&gt;
&lt;dd&gt;Ce registre est utilisé, lors d’un déclenchement, pour stocker le premier opérande de l’instruction. ''Z'' fait référence au nom générique usuel en mathématique.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rWW&lt;/source&gt;, le registre de lieu d'interruption (capture) :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé, lors d’une capture, pour stocker l’adresse de l’instruction après celle qui a été interrompue. Le ''W'' fait référence au mot ''{{Lang|en|where}}'', comme précédemment.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rXX&lt;/source&gt;, le registre d’exécution (capture) :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé, lors d’une capture, pour stocker l’instruction qui a été interrompue.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rYY&lt;/source&gt;, l’opérande Y (capture) :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé, lors d’une capture, pour stocker l’opérande Y de l’instruction interrompue.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;li&gt;&lt;dl&gt;
&lt;dt&gt;&lt;source enclose=&quot;none&quot; lang=&quot;mmix&quot;&gt;rZZ&lt;/source&gt;, l’opérande Z (capture) :&lt;/dt&gt;
&lt;dd&gt;Il est utilisé, lors d’une capture, pour stocker l’opérande Z de l’instruction interrompue.&lt;/dd&gt;
&lt;/dl&gt;&lt;/li&gt;
&lt;/ol&gt;

== Implémentation matérielle ==

Il n’existe actuellement aucune implémentation matérielle de l’architecture à jeu d’instruction {{MMIX}}. Cependant, le projet [[fpgammix]] fournie implémente une implémentation [[Verilog]], ce qui ouvre la possibilité de l’utiliser dans un [[circuit logique programmable]]&lt;ref&gt;[http://repo.or.cz/w/fpgammix.git Site officiel de fpgammix]&lt;/ref&gt;.

==Outils logiciels==
L’architecture de jeu d’instruction {{MMIX}} est utilisable à travers tout une panoplie d’outils logiciels pour la recherche en développement logiciel et en architecture d’ordinateur.


===Simulateurs et assembleurs ===

Knuth a développé un ensemble de logiciels nommé [[MMIXware|{{MMIXware}}]] comprenant un simulateur comportemental simple de la machine, et [[MMIXAL|{{MMIXAL}}]], un logiciel d’assemblage, une suite de tests, des programmes d’exemples, une documentation complète, et un simulateur de [[pipeline (informatique)|pipeline]] de l’architecture {{MMIX}} &lt;ref&gt;[http://www-cs-faculty.stanford.edu/~knuth/mmix-news.html Site officiel de MMIXware]&lt;/ref&gt;.

[[Andrew Pochinsky]], membre de l’équipe du centre de recherche théorique en [[physique]] du {{Lang|en|[[Massachusetts Institute of Technology]]}} à développé [[MMIXX|{{MMIXX}}]] un [[paquet (logiciel)|paquet]] implémentant un [[Interface graphique|serveur graphique]] basé sur [[X Window System|X11]]. Elle peut être combiné avec la machine virtuelle de {{MMIXware}} pour fournir un affichage de [[Résolution spatiale des images matricielles|640×480]] [[pixe]]s en [[Profondeur des couleurs|vrai couleur]] pour [[Linux]] et [[UNIX]].

===Compilateur===

Le projet [[GNU Compiler Collection|''{{Lang|en|GNU Compiler Collection}}'']] (GCC) comprend une partie envers&lt;ref group=&quot;trad&quot;&gt;Ici ''envers'' est utilisé comme traduction de ''{{Lang|en|back end}}'', qui exprime une idée d’arrière plan, par opposition à un ''{{Lang|en|front end}}'' qu’on traduira ''avers'', , exprimant l’idée d’avant plan.&lt;/ref&gt; de {{MMIX}} pour ses  [[compilateur]]s [[C (langage)|C]]/[[C++]], initialement développé par [[Hans-Peter Nilsson]], et qui fait partie de la distribution standard du projet depuis la fin [[2001]]. Il continue d’être activement développé et [[Informatique#Maintenance_d.27un_syst.C3.A8me_informatique|maintenu]] par des volontaires.

L’ensemble des outils existant devraient théoriquement permettre de compiler, construire et amorcer un noyau de système d’exploitation comme [[Linux]] sur un processeur {{MMIX}} si une implémentation matériel venait à exister.

* {{en}} [http://bitrange.com/mmix/install.html Manuel d’installation des outils {{MMIX}}  pour  GCC] rédigé par Hans-Peter Nilsson.
* {{en}} [http://gcc.gnu.org/onlinedocs/gcc-4.5.2/gcc/MMIX-Options.html Liste des options spécifiques à {{MMIX}} dans GCC].
* {{en}} [http://sourceware.org/binutils/docs-2.21/as/MMIX_002dDependent.html §9.25.{{nbsp}} Liste des fonctionnalités spécifiques à {{MMIX}} dans ''as''] l’[[GNU Assembler|assembleur GNU]] .


== Voir aussi ==
* [[Langage de programmation éducatif]]
* [[DLX]]
* [[LC-3]]
* [[Little man computer]]
* [[MikroSim]]
* [[MIX|{{MIX}}]]



== Notes et références ==
=== Traduction ===
&lt;references group=&quot;trad&quot; /&gt;

=== Références ===
{{Traduction/Référence|en|MMIX|371075642}}
{{Références|colonnes=2}}
{{reflist}}
* [http://www-cs-faculty.stanford.edu/~knuth/mmixware.html Errata de ''{{Lang|en|MMIXware: A RISC Computer for the Third Millennium}}''].
* Donald E. Knuth (2005). ''{{Lang|en|The Art of Computer Programming Volume 1 Fascicle 1: {{MMIX}} A RISC Computer for the New Millennium''}}. Addison-Wesley. ISBN 0-201-85392-2 [http://www-cs-staff.stanford.edu/~uno/taocp.html#err1f1 (errata)]

== Liens externes ==
* {{en}} Donald Knuth, [http://www-cs-faculty.stanford.edu/~knuth/mmix.html ''MMIX 2009''] une courte introduction à MMIX et les raisons qui ont poussé l’auteur à inventer et utiliser {{MMIX}} pour l’écriture de ''[[The Art of Computer Programming]]'' (TAOCP).
* {{en}} Donald Knuth, [http://www-cs-faculty.stanford.edu/~knuth/mmix-news.html ''MMIX News''], un simulateur libre écrit en [[CWEB]], un mode d'emploi et des exemples de programmes.
* {{en}} [http://mmixmasters.sourceforge.net/ ''MMIXmasters''], un site alimenté pour les bénévoles (''MMIXmasters'') qui traduisent tous les programmes de TAOCP, Volumes 1 à 3, du langage {{MIX}} au langage {{MMIX}}.
* {{en}} [http://www007.upp.so-net.ne.jp/eiji-y/vmmmix/vmmmix.html ''VMMMIX''], une machine virtuelle pour {{MMIX}} qui dispose d’une console et d’[[Entrées-sorties|entrées/sorties]] pour les [[Mémoire de masse|périphériques de masse]] et l’[[ethernet|périphériques ethernet]]. Actuellement elle n’est exécutable que sous [[Windows]] mais peut être utilisé pour exécuter un noyau Linux dans un environnement {{MMIX}}.
* {{en}} [http://mmix.cs.hm.edu/index.html Site officiel du projet {{MMIX}}], celui-ci à migré de [[Stanford]] à [[Munich]] en 2011.
*[http://vmb.sourceforge.net/index.html Site officiel du projet ''VMB''], {{Lang|en|The Virtual Motherboard Project}}, le projet de carte mère virtuel, propose une collection de périphériques ''[[Plug and Play|{{Lang|en|Plug and Play}}]]'' qui peuvent être utilisés avec des versions appropriées de processeur {{MMIX}}.

{{DEFAULTSORT:Mmix}}

{{Palette Donald Knuth}}

{{Portail|informatique}}

[[Catégorie:Donald Knuth]]
[[Catégorie:Machines abstraites éducatives]]
[[Catégorie:Langage de programmation]]
[[Catégorie:Architecture informatique]]</text>
      <sha1>bsjpp1ehj4str1xdoarpr2fvn1pjffi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>REALbasic</title>
    <ns>0</ns>
    <id>306482</id>
    <revision>
      <id>101840934</id>
      <parentid>93510393</parentid>
      <timestamp>2014-03-06T15:29:11Z</timestamp>
      <contributor>
        <username>Rbcafe</username>
        <id>1213522</id>
      </contributor>
      <comment>/* Généralités */</comment>
      <text xml:space="preserve" bytes="11911">{{sources à lier}}
{{sources secondaires}}
{{Infobox Logiciel
 | couleur boîte            = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                      = REALBasic
 | logo                     = 
 | image                    = 
 | description              = 
 | développeur              = REAL Software
 | date de première version = 
 | dernière version         = 
 | date de dernière version = 
 | version avancée          = 
 | date de version avancée  = 
 | état                     =
 | langage de programmation = 
 | environnement            = [[Windows]], [[Unix]]
 | langue                   = 
 | type                     = [[langage de programmation]] [[Visual Basic]]
 | licence                  = [[Logiciel commercial|Commercial]]
 | site web                 = http://www.realsoftware.com/realstudio/
}}

'''REALbasic''', est un [[langage de programmation]] inspiré du [[Visual Basic]] 6 de [[Microsoft]] qui fonctionne sur [[Mac OS X]], [[Microsoft Windows|Windows]] et [[Linux]]. ''REALbasic'' fut créé par Andrew Barry. Il s'appelait originellement CrossBasic (cross=transversal) car il était capable de compiler le même code de programmation pour [[Macintosh|Mac]] et [[Java (langage)|Java]] (le système de développement était uniquement sur Mac). En 1997, CrossBasic fut racheté par FYI Software qui changea son nom en REALbasic tandis que la société s'appela REAL Software. Suite à ceci, la version Java fut abandonnée.

== Généralités ==
'''REALbasic''', est le langage de l'environnement de développement Real Studio. Ce langage de programmation s'inspire du visual basic 6 de Microsoft. Il en est cependant une version moderne. Il est totalement orienté objet, typé et multi thread. Cet outil de développement fonctionne sur [[Mac OS X]], [[Microsoft Windows|Windows]] et [[Linux]], et est capable de compiler des logiciels pour les mêmes plateformes, sous réserve d'avoir acheté la version Pro.

Actuellement, c'est la version 2011 R4 qui est commercialisée. Cet outil de développement permet notamment de générer des applications pour Mac au format Universal Binary, Intel ou Power PC. REALbasic est pratique, il permet de développer facilement et rapidement, et surtout pour plusieurs plateformes ce qui évite de redévelopper plusieurs fois les mêmes applications.  En fonction de la complexité de ses dernières, on ne pourra cependant se passer de vérifier la compatibilité et surtout la pertinence de votre code (notamment de l'interface utilisateur) avec tous les systèmes. RealBasic offre heureusement la possibilité de faire varier le code en fonction de la plateforme cible.

Realbasic permet de développer des applications consoles, graphiques ou web.
Il est disponible en 4 versions : personnelle, professionnelle, entreprise et web.

== Base de données ==
Ce langage inclut des connecteurs aux bases de données les plus répandus : sqlite, mysql, oracle, Microsoft Sql Server, ODBC...
Les utilisateurs de la version personnelle devront cependant se contenter de sqlite et mysql community edition.

== Enrichissement du langage par plug'in ==
Il existe toute sorte de modules du gratuit  jusqu'à plusieurs milliers d'euros qui vous permettrons d'enrichir les fonctionnalités du langage.
C'est d'ailleurs à la fois un avantage et un inconvénient. Si bien évidemment l'enrichissement du langage par module permet d'ouvrir de nouvelles perspectives elles augmentent considérablement le cout de votre solution de développement. Or un des grands avantages de RealBasic c'est le prix : {{unité|79|€}} HT pour la version personnelle et {{unité|249|€}} HT pour la version professionnelle. Si l'on est tenté d'acheter des modules supplémentaires le cout totale peut vite atteindre le même niveau que des environnements de développement ultra professionnel contre qui realbasic aura du mal à lutter.

L'achat de modules n'est pas non plus indispensable car RealBasic est très complet, cela constitue néanmoins un option intéressante et viable dans certains cas.

== Facilité de déploiement chez le client==
Un des très grand avantages de ce langage c'est que l'application qu'il génère ne nécessite aucune installation sur l'ordinateur de l'utilisateur final. Les applications RealBasic fonctionnent donc parfaitement sur une clef USB. C'est une des raisons principale du succès de ce langage.
On peut déposer par copier coller l'application n'importe où sur un disque externe ou interne : elle fonctionnera de façon identique.

== Deboguage à distance==
Avec RealBasic vous pouvez deboguer une application qui s'exécuterai sur un poste distant  depuis votre poste de développeur.
Cela permet de cerner et de résoudre plus rapidement et facilement les problèmes.

== Liens avec pack office de Microsoft==
Si vous optez pour la version Windows vous aurez à votre disposition des contrôles qui vous permettrons de piloter Excel, Word et PowerPoint.
il vous sera donc possible par exemple de générer des document excel avec realbasic.

== GUI (Graphic User Interface) et Code ==

Dans REALbasic on peut noter deux grandes interfaces notables. Le code et l'interface graphique, en anglais le 'Graphic User Interface'. Le principal système de l'interface graphique est le système de 'drag &amp; drop' (Glissez et déposer) qui s'avère être très simple. Il suffit de glisser les outils vers une fenêtre qui représente votre programme.

L'intégration du code dans la GUI est extrêmement bien faite et surpasse dans ce cadre beaucoup d'autres outils de développement plus onéreux. La façon dont les fonctions, procédures, classes, module, variables ... sont visualisés permet non seulement de mieux concevoir le projet, mais elle apporte aussi une vision claire de la structure de chaque éléments.  Il devient ainsi plus facile de reprendre un programme que l'on a laissé de côté plusieurs mois ou de lire le code d'un autre programmeur.

== Exemple de code ==
Voici un exemple de surcharge d'opérateur pour une hypothétique classe de nombre complexe afin d'additionner un nombre réel ou complexe à un autre nombre complexe :

&lt;source lang=&quot;vbnet&quot;&gt;
Function Operator_Add (rhs As Single) As Complex
  Dim ret As New Complex
  ret.Real = Self.Real + rhs
  ret.Imaginary = Self.Imaginary
  Return ret
End Function

Function Operator_Add (rhs As Complex) As Complex
  Dim ret As New Complex
  ret.Real = Self.Real + rhs.Real
  ret.Imaginary = Self.Imaginary + rhs.Imaginary
  Return ret
End Function
&lt;/source&gt;

La même fonction peut être définie pour accepter des nombres en double précision. Ce code montre comme utiliser cette classe de complexe pour additionner un réel à un complexe :

 &lt;source lang=&quot;vbnet&quot;&gt;
 Dim Premier As New Complex (0, 1)
 Dim Second As New Complex (1, 1)
 Dim Somme As Complex
 Somme = Premier + 5.0 + Second
 // Somme donnera comme résultat (6, 2)
&lt;/source&gt;

== Types de projets envisageables ==
Realbasic fera des merveilles pour les personnes qui désirent développer des applications de saisies de données standard. On développera avec  des programmes de gestion de fichiers clients, des gestions de compte bancaire ou de documents comptables, interrogations de bases de données etc... Il conviendra aussi bien au développeur de shareware qu'à l'informaticien d'une PME qui désire développer des applications internes.  Les difficultés surviendrons plutôt lorsque l'on voudra développer des applications qui nécessitent la collaboration de beaucoup de développeurs ou des projets ambitieux. Realbasic n'est pas reconnus comme un outil majeur dans le monde du développement. Il n'est pas facile par exemple d'éditer des états papiers très complexes ( étiquettes avec images etc... ). Le programmeur devra donc avoir un recours plus grand à la ligne de code pour rivaliser avec des logiciels qui ont été développés avec des outils plus puissants ( Visual studio, Windev etc...).

Il  existe cependant une vieille controverse chez les programmeurs pour qui le basic est longtemps resté synonyme de langage de débutant. Soyons clair il n'existe pas de logiciel poids lourds de l'informatique développé en basic. Mais ce type de langage a fortement bénéficié de l'évolution de puissance des ordinateurs et on ne peut plus dire de nos jours que programmer en basic constitue un désavantage. Le développeur basic recherche la simplicité du langage et veut un résultat rapide souvent dans le cadre d'un projet à l'ambition moyenne. RealBasic ne requiert pas la même technicité que le c++, c sharp ou objective c, ni le même investissement intellectuel. Il cherche simplement à proposer un outil généraliste et efficace dans les projets les plus communs. En s'appuyant sur une interface utilisateur très ergonomique, realbasic s'éloigne des basics des années 1980 avec qui finalement il ne partage plus rien.

Realbasic est actuellement l'une des très rares solutions de développement multiplateforme très facile d'accès autant au niveau de l'utilisation qu'au niveau du prix.

== Un potentiel pédagogique important ==
RealBasic conviendra aussi aux professeurs qui enseignent la programmation dans les collèges et lycées par le fait qu'il permet par un apprentissage rapide d'accéder à des préceptes de programmation avancés. Le professeur pourra donner à ses élèves le goût de la programmation. Ces derniers pourront en quelques heures s'étonner de leur création. L'avantage est double : les élèves ne sont pas découragés et la durée d'apprentissage étant réduite, il reste plus de temps pour se concentrer sur les objectifs à atteindre.

== Un système communautaire intégré ==
RealBasic inclut un système ingénieux (et gratuit) de rapport d'erreur. Si l'on rencontre un bogue dans realbasic, si l'on souhaite une évolution ou si l'on désire partager des idées, on peut utiliser &quot;Feedback&quot;. Il s'agit d'un logiciel qui met en contact avec la communauté (anglophone) de realbasic.  Les ingénieurs de Real software scrutent les questions et y répondent quand cela est nécessaire.

== Logiciels développés sous REALbasic ==
* RealCADD, logiciel de [[Dessin assisté par ordinateur|CAO 2D]] pour l'[[Architecture (homonymie)|Architecture]] (en particulier les plans d'exécution).
* [[ohmiGene]], logiciel de [[généalogie]] ( http://ohmi.celeonet.fr/ohmiGene/indexFR.html )
* Des interfaces pour utiliser des programmes existant dans les distributions GNULinux utilisant REALbasic avec [[Python (langage)|Python]] : [[HTMLtoPDF]], [[Package converter]], [[DivX Converter]], [[APT sources Manager]], etc. (http://code.google.com/p/foxoman/)

== Rythme et cout des mises à jour ==
Real Software procède à une mise à jour majeure par an. Puis au cours de l'année le produit évoluera par une mise à jour mineure (correction de bugs) tous les 90 jours environ. L'achat d'une licence entraine 6 mois de mises à jour gratuites. Passé ce délai les mises à jour seront payantes.

En fait l'utilisateur devra souscrire s'il veut bénéficier des évolutions du produits d'un plan de mise à jour pour une durée de une à deux années (renouvelable). Le coût des mises à jour est d'environ à {{unité|39|€}} par an pour la version personnelle, {{unité|120|€}} par an pour la professionnelle et {{unité|415|€}} par an pour la version entreprise.

== Notes et références ==
== Voir aussi ==
=== Liens externes ===
* {{fr}} [http://www.realbasic.com/ REALbasic]

=== Articles connexes ===

* [[WinDev]] : autre [[environnement de développement intégré]] propriétaire, créé par la société française [[PC Soft]].
* [[Qt]] : Autre outil de développement multiplateformes.

{{Portail|programmation informatique|logiciel}}

[[Catégorie:Langage de programmation|RealBasic]]
[[Catégorie:Logiciel pour Windows]]
[[Catégorie:Logiciel pour Unix]]</text>
      <sha1>g5lcl0nzmpah0vot528etf3y045solw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>TMG (langage)</title>
    <ns>0</ns>
    <id>7029317</id>
    <revision>
      <id>99565784</id>
      <parentid>91788111</parentid>
      <timestamp>2013-12-25T19:17:42Z</timestamp>
      <contributor>
        <username>Hunsu</username>
        <id>970933</id>
      </contributor>
      <comment>Maintenance lien web</comment>
      <text xml:space="preserve" bytes="1615">{{Ébauche|informatique}}

Le '''TMG''' est un [[compilateur de compilateur]]&lt;ref name=&quot;McIlroy&quot;&gt;{{en}}{{lien web |url=http://www.cs.dartmouth.edu/~doug/ |titre=Page personnelle de Douglas McIlroy |consulté le=20 décembre 2012}}&lt;/ref&gt; créé par Robert M. McClure&lt;ref name=&quot;multicians&quot;&gt;{{en}}{{lien web |url=http://www.multicians.org/tmg.html |titre=TMG |site=multicians.org}}&lt;/ref&gt; et présenté à l'[[Association for Computing Machinery]] en 1968&lt;ref name=&quot;bell-early&quot;&gt;{{en}}{{lien web |url=http://cm.bell-labs.com/cm/cs/who/dmr/hist.html |site=bell-labs.com |titre=Early Unix history and evolution |date=9 avril 2004}}&lt;/ref&gt;{{,}}&lt;ref&gt;{{article |langue=en |auteur=R. M. McClure |titre=TMG--A Syntax-Directed Compiler |périodique=Proc 20th ACM National Conf. |année=1968 |pages=262-74}}&lt;/ref&gt;, implémenté par Douglas McIlroy&lt;ref name=&quot;bell-early&quot; /&gt;. TMG fonctionnait en particulier sur [[OS/360]] et les premiers systèmes [[UNIX]], et fut utilisé pour créer l'EPL, une version primitive du langage [[PL/I]]&lt;ref name=&quot;multicians&quot; /&gt;.

En 1970, [[Ken Thomson]] voulut écrire un [[compilateur]] de [[fortran]] en TMG sur un [[PDP-7]], mais créa à la place le [[B (langage)|langage B]], précurseur du [[langage C]] fortement influencé par le [[BCPL]]&lt;ref name=&quot;bell-early&quot; /&gt;.

==Voir aussi==
* [[Yacc]], un compilateur de compilateur moderne utilisé également sur les systèmes Unix

==Notes et références==
{{Traduction/Référence|en|TMG (language)|546429224}}
&lt;references/&gt;

&lt;!--==External links==--&gt;

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Compilateur]]</text>
      <sha1>jb94ugf36zhd2zyzwln7tt5vbkeun8o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Concurrent C</title>
    <ns>0</ns>
    <id>7044700</id>
    <revision>
      <id>101560304</id>
      <parentid>93114214</parentid>
      <timestamp>2014-02-24T17:08:07Z</timestamp>
      <contributor>
        <username>MattF</username>
        <id>332001</id>
      </contributor>
      <comment>/* Description */ Implémentation</comment>
      <text xml:space="preserve" bytes="2485">{{Ébauche|informatique}}
{{Infobox Langage de programmation
 | nom                              = Concurrent C
 | paradigme                        = [[programmation impérative|impératif]], [[programmation concurrente|parallèle]]
 | développeur                      = N. Gehani, W. Roome
 | date de première version         = 1984
 | typage                           = [[typage faible|faible]], [[typage statique|statique]]
 | influencé par                    = [[C (langage)|C]], [[Ada (langage)|Ada]]
 | système d'exploitation           = [[Unix]]
}}

Le '''concurrent C''' est une extension du [[C (langage)|langage de programmation C]]&lt;ref&gt;{{en}}{{lien web |url=http://cm.bell-labs.com/cm/cs/who/dmr/chist.html |titre=The Development of the C Language |auteur=Denis Ritchie}}&lt;/ref&gt; développée aux [[laboratoires Bell]] d'[[AT&amp;T]] en [[1984 en informatique|1984]]. Elle a pour but de faciliter l'implémentation d'[[parallélisme (informatique)|algorithmes parallèles]] en C, qui ne supporte la [[programmation concurrente]] que par le biais d'extensions (même si certaines, comme les [[Threads POSIX]], sont très répandues).


== Description ==

Le concurrent C est compatible avec le C (la plupart des programmes écrits en C sont valables en concurrent C). S'inspirant de l'[[Ada (langage)|Ada]]&lt;ref name=&quot;bellmemo&quot;&gt;{{en}}{{pdf}}{{lien web |url=http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.47.850&amp;rep=rep1&amp;type=pdf |titre=Concurrent C |date=janvier 1985 |auteur1=N. H. Gehani |auteur2=W. D. Roome}}&lt;/ref&gt;, le concurrent C permet la [[communication inter-processus]] entre les [[thread (informatique)|threads]] par échange de données [[synchronisation (multitâches)|synchrone]] : l'émetteur est bloqué par les fonctions de communication inter-processus tant que le récepteur n'a pas lu les données transférées&lt;ref name=&quot;concurrent_c_pl&quot;&gt;{{en}}{{ouvrage |titre=The Concurrent C Programming Language |pages={{p.}} 6 |isbn=0-929306-00-7 |auteur1=N. H. Gehani |auteur2=W. D. Roome}}&lt;/ref&gt;.

Il était implémenté par AT&amp;T sous la forme d'un préprocesseur, qui produisait du code en C ensuite compilé normalement&lt;ref&gt;{{lien web |url=http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=E74EEEB4B19241EC1D4C857E69C04DF0?doi=10.1.1.14.5110&amp;rep=rep1&amp;type=pdf |titre=Implementing Concurrent C |auteur1=N. Gehani |auteur2=W. Room}}&lt;/ref&gt;.

== Notes et références ==
&lt;references /&gt;

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>38xv0fqs2msxbxtfba7m88ntnrjglwu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>F Sharp</title>
    <ns>0</ns>
    <id>1806643</id>
    <revision>
      <id>99858682</id>
      <parentid>99060377</parentid>
      <timestamp>2014-01-03T17:57:18Z</timestamp>
      <contributor>
        <username>Vincent Lefèvre</username>
        <id>20813</id>
      </contributor>
      <comment>Mise à jour de l'URL du site web (devenue invalide), prise sur la version en anglais</comment>
      <text xml:space="preserve" bytes="7895">{{Voir homonymes|F}}

{{Infobox Langage de programmation
| nom                    = F♯
| logo                   = 
| paradigme              = [[Programmation fonctionnelle|Fonctionnel]], [[Programmation impérative|impératif]], [[Programmation orientée objet|orienté objet]]
| année                  = [[2002]] (dernière révision en [[2012]])
| auteur                 = Don Syme, [[Microsoft Research]]
| développeur            = 
| typage                 = [[Typage statique|Statique]], [[Typage fort|fort]], [[Système nominatif de types|nominatif]], [[Inférence de types|inféré]]
| implémentations        = [[.NET Framework]], [[Mono (informatique)|Mono]]
| dialectes              = 
| influencé par          = [[OCaml]], [[C Sharp|C♯]], [[Haskell]]
| a influencé            = 
| système d'exploitation = 
| licence                = 
| site web               = [http://fsharp.org/ fsharp.org]
}}

'''F♯''' est un [[langage de programmation]] [[Programmation fonctionnelle|fonctionnel]], [[Programmation impérative|impératif]] et [[Programmation orientée objet|orienté objet]] pour la plate-forme [[Microsoft .NET|.NET]]. F♯ est développé par [[Microsoft Research]] dont le noyau est dérivé du langage [[OCaml]] (avec lequel il est fortement compatible). Ces deux langages de programmation font partie de la famille des [[ML (langage)|langages ML]].

C'est un langage qui a été conçu spécifiquement pour la plate-forme [[Microsoft .NET|.NET]] et est donc fortement orienté-objet. Depuis novembre 2010, [[Microsoft]] a mis à la disposition de tous les bibliothèques core et son compilateur F♯, sous la [[licence Apache]] 2&lt;ref&gt;[http://www.presence-pc.com/actualite/F-41269/ Le langage F♯ devient open source]&lt;/ref&gt;.

== Présentation ==

F♯ est un langage fortement typé utilisant l'[[inférence de types]]. Ce mécanisme délègue le typage des variables et des fonctions au compilateur. Néanmoins, le langage permet au développeur d'indiquer explicitement le type à la déclaration. Intégré à l'écosystème .NET, F♯ supporte les types primitifs de la plate-forme ainsi que ses objets. De plus il étend le système de type et permet de faire la distinction entre les types dits immuables et ceux dits modifiables. Les objets sont considérés comme des types modifiables (en place), et sont utilisés pour la mise en place du modèle de programmation objet au sein du langage. Les types immuables sont utilisés principalement lorsque l'on programme de manière fonctionnelle ; la modification d'un type immuable crée une nouvelle instance sans pour autant écraser l'ancienne.

Comme tous les langages dérivé de [[ML (langage)|ML]], F♯ utilise par défaut le mécanisme de l'[[évaluation stricte]]. Cependant il peut, à l'instar de [[Haskell]], mettre en œuvre l'[[évaluation paresseuse]] des expressions grâce à l'utilisation du mot-clé &lt;code&gt;lazy&lt;/code&gt;. Pour la programmation fonctionnelle, il fournit plusieurs constructions et un ensemble de types immuables : les n-uplets, des enregistrements, des types sommes et des listes&lt;ref name=&quot;presentation&quot;&gt;{{Lien web | url =http://tomasp.net/articles/fsharp-i-introduction/article.pdf | titre =F♯ Language Overview | consulté le = 2007-12-14}}.&lt;/ref&gt;.

Un '''n-uplet''' représente une collection de n valeurs, n ≥ 0. La valeur correspond à l'arité du n-uplet. Le type unit représente le n-uplet vide et dont l'unique valeur possible est (). Ce type est utilisé pour typer des fonctions qui ne prennent pas en entrée de valeur et/ou n'en renvoient pas. Le 3-uplet (ou triplet) est représenté par &lt;code&gt;(A, B, C)&lt;/code&gt;, où A, B, et C peuvent être de n'importe quel type. Un n-uplet peut être utilisé pour stocker des valeurs uniquement lorsque le nombre de valeurs est connu au moment du codage et reste constant tout au long de l'exécution.

Un '''enregistrement''' est une version spécialisée des n-uplets où les champs sont nommés, comme dans {{nowrap|&lt;code&gt;{ Nom:string; Age:int }&lt;/code&gt;}}. Les enregistrements peuvent être créés de la façon suivante : &lt;code&gt;{ Nom=&quot;Toto&quot;; Age=1 }&lt;/code&gt;. Le mot-clé &lt;code&gt;with&lt;/code&gt; est utilisé pour créer une copie de l'enregistrement : &lt;code&gt;{ r with Nom=&quot;CD&quot; }&lt;/code&gt; crée un nouvel enregistrement à partir d'un précédent enregistrement nommé r et dont il change la valeur du champ Nom.
  
Le '''type liste''' est une liste chainée qui peut se représenter soit à l'aide de la notation &lt;code&gt;head::tail&lt;/code&gt; (composé à l'aide de l'opérateur &lt;code&gt;::&lt;/code&gt;, l'équivalent de l'opérateur cons des langages [[Lisp]]/[[Scheme]]), soit dans une notation abrégée : &lt;code&gt;[item1; item2; item3]&lt;/code&gt;. Une liste vide est notée &lt;code&gt;[]&lt;/code&gt;.

La dernière sorte de [[type algébrique de données]], les '''types sommes''' (qui sont, fonctionnellement, des équivalents typés des unions du langage C) peuvent être définis comme une somme de n'importe lequel des types immuables évoqués précédemment. Par exemple,
&lt;source lang=&quot;ocaml&quot;&gt;
type A = 
   | ConstructorX of string
   | ConstructorY of int
&lt;/source&gt;
peut contenir des valeurs instanciées soit par &lt;code&gt;ConstructorX&lt;/code&gt; soit par &lt;code&gt;ConstructorY&lt;/code&gt;. Le type des valeurs retournées par les constructeurs peut lui aussi être défini.

== Exemples ==

Voici le traditionnel [[hello world]] :
&lt;source lang=&quot;ocaml&quot;&gt;
(* Ceci est un commentaire *)
printfn &quot;Hello World!&quot;
&lt;/source&gt;

Cet autre exemple traditionnel chez les langages fonctionnels a pour objectif de montrer la concision que l'on peut obtenir avec ce type de langages :
&lt;source lang=&quot;ocaml&quot;&gt;
let rec factorielle n =
    match n with
    | 0 -&gt; 1
    | _ -&gt; n * factorielle (n - 1)
&lt;/source&gt;

Cette variante, avec un accumulateur, met en œuvre la [[récursion terminale]], une optimisation commune parmi les langages fonctionnels :
&lt;source lang=&quot;ocaml&quot;&gt;
let factorielle n =
    let rec factorielle_recursive n accu =
        match n with
        | 0 -&gt; accu
        | _ -&gt; factorielle_recursive (n - 1) (n * accu)
    factorielle_recursive n 1
&lt;/source&gt;

== Notes et références ==
{{Références}}

== Voir aussi ==

=== Articles connexes ===
* [[C sharp|C♯]]
* [[Caml]]
* [[Haskell]]

=== Bibliographie ===
* {{Ouvrage|langue=anglais|titre=Expert F♯ 3.0|prénom1=Antonio|nom1=Cisternino|prénom2=Adam|nom2=Granicz|prénom3=Don|nom3=Syme|année=2012|éditeur=Apress|pages=626|isbn=978-1-4302-4650-3|numéro d'édition=3}}
* {{Ouvrage|langue=anglais|titre=Foundations of F♯|prénom1=Robert|nom1=Pickering|année=2007|éditeur=Apress|pages=360|isbn=978-1-5905-9757-6}}
* {{Ouvrage|langue=anglais|titre=F♯ for scientists|prénom1=Jon|nom1=Harrop|mois=août|année=2008|éditeur=Wiley-Interscience|préface=Don Syme|pages=368|isbn=978-0-4702-4211-7}}
* {{Ouvrage|langue=anglais|titre=Functional Programming for the Real World|sous-titre=With Examples in F♯ and C♯|prénom1=Tomas|nom1=Petricek|prénom2=Jon|nom2=Skeet|mois=décembre|année=2009|éditeur=Manning Publications|préface=Mads Torgersen|pages=560|isbn=978-1-9339-8892-4}}
* {{Ouvrage|langue=anglais|titre=Programming F♯|sous-titre=A comprehensive guide for writing simple code to solve complex problems |prénom1=Chris|nom1=Smith|mois=octobre|année=2012|éditeur=O'Reilly|lien éditeur=O'Reilly Media|pages=476|isbn=978-1-4493-2029-4|numéro d'édition=2}}
* {{Ouvrage|langue=anglais|titre=Professional F♯ 2.0|prénom1=Ted|nom1=Neward|prénom2=Aaron|nom2=Erickson|prénom3=Talbott|nom3=Crowell|prénom4=Rick|nom4=Minerich|mois=novembre|année=2010|éditeur=Wrox|pages=432|isbn=978-0-470-52801-3}}

=== Liens externes ===
* [http://fsharp.net Microsoft F♯ developer center (en)]

{{Palette|Langages de programmation}}

{{Portail|informatique|logiciel|programmation informatique|Microsoft}}

[[Catégorie:ML]]
[[Catégorie:.NET Framework]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>tsshhwnvlb32wsp50p3iftqigrbq7wo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>SETL</title>
    <ns>0</ns>
    <id>7081003</id>
    <revision>
      <id>92384098</id>
      <parentid>92384084</parentid>
      <timestamp>2013-04-23T11:40:56Z</timestamp>
      <contributor>
        <username>Jerome66</username>
        <id>35967</id>
      </contributor>
      <minor/>
      <comment>Jerome66 a déplacé la page [[Isetl]] vers [[SETL]] : Fusion d'historiques</comment>
      <text xml:space="preserve" bytes="3038">{{Ébauche|informatique}}

''' SETL ''' est un [[langage de programmation]] de très-haut niveau basé sur la [[théorie des ensembles|théorie mathématique des ensembles]]. Il a été à l'origine développé près {{Lien|Jacob T. Schwartz}} au [[Courant Institute of Mathematical Sciences]] de la [[Université de New York|NYU]]. Il existe une variante nommée ''ISETL'' (de l'anglais ''{{Lang|en|Interactive SET Language}}'') permettant de faire de la programmation sur des [[théorie des ensembles|ensembles mathématiques]].

SETL fournit deux types de données de base : Les ''ensembles non ordonnés'' et les ''suites'' (appelées également ''tuples''). Les éléments des ensembles et des tuples peuvent être de n'importe quel type arbitraire, y compris les ensembles et les tuples eux-mêmes. Le ''fonctions'' sont fournis en tant qu'ensembles de ''paires'' (c.-à-d., tuples de longueur 2) et peuvent avoir des domaines et de codomaines de types arbitraires.  Les opérations primitives dans SETL incluent, entre d'autres, l'appartenance ensembliste, l'union, l'intersection et la puissance d'ensembles. SETL permet d'exprimer des expressions booléennes quantifiées construites en utilisant le [[calcul des prédicats]] du premier ordre, les [[Quantificateur (logique)|quantificateurs universels]] et [[Quantificateur (logique)|quantificateurs existentiels]]. SETL fournit aussi plusieurs itérateurs pour produire diverses [[Structure de contrôle|boucles]] sur des structures de données. 

== Échantillon de code ==
Retourner tous les nombres premiers inférieurs à n : 

   NbPremiers := func(n);
      return {x: x in {2..n} | forall y in {2..x-1} | x mod y /=0};
   end;
   NbPremiers(100);

La notation est semblable à la [[Liste en compréhension|compréhension de liste]].

== Historique ==
[[ABC (langage)|ABC]], le précurseur de [[Python (langage)|Python]], a été inspiré par SETL  à {{Lien|Lambert Meertens}}, qui a passé une année avec le groupe de SETL à NYU avant de proposer la version finale d'ABC.

== Bibliographie ==
* Jacob T. Schwartz, ''{{Lang|en|Set Theory as a Language for Program Specification and Programming}}''. Courant Institute of Mathematical Sciences, New York University, 1970.
* Jacob T. Schwartz,''{{Lang|en|On Programming, An Interim Report on the SETL Project}}'', Computer Science Department, Courant Institute of Mathematical Sciences, New York University (1973).
* Jacob T. Schwartz, R. B. K. Dewar, E. Dubinsky, E. Schonberg, ''{{Lang|en|Programming With Sets: An Introduction to SETL}}'', 1986 {{ISBN|0-387-96399-5}}

== Voir aussi ==
=== Liens externes ===
* {{en}} [http://setl.org/setl/ About GNU SETL] 
* {{en}} [http://cs1.cs.nyu.edu/bacon/setlprog.ps.gz The SETL programming language], par Robert Dewar
* {{en}} [http://web.archive.org/web/20071025062000/http://archives.math.utk.edu/software/msdos/discrete.math/isetl/.html Site officiel d’ISETL]

{{Traduction/Référence|en|SETL|93316998}}

{{portail informatique|}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>80fbvfzzvm5z8jhpxaf189bsoukx0qf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MapBasic</title>
    <ns>0</ns>
    <id>7085138</id>
    <revision>
      <id>101787415</id>
      <parentid>101787392</parentid>
      <timestamp>2014-03-04T17:50:27Z</timestamp>
      <contributor>
        <username>Gustavi</username>
        <id>1431370</id>
      </contributor>
      <minor/>
      <comment>Syntaxe</comment>
      <text xml:space="preserve" bytes="1697">{{Infobox Logiciel
 | couleur boîte            = &lt;!-- pour adapter la couleur de la boîte au logo --&gt;
 | nom                      = MapBasic
 | logo                     = 
 | image                    = 
 | taille image             = 
 | description              = 
 | développeur              = [[Pitney Bowes|Pitney Bowes Software]]
 | date de première version = 
 | dernière version         = 12.0
 | date de dernière version = {{date|14|juin|2013|en informatique}}
 | version avancée          = 
 | date de version avancée  = 
 | état                     = En développement actif
 | langage de programmation = 
 | environnement            = [[Microsoft Windows|Windows]]
 | langue                   = 
 | type                     = [[Système d'information géographique|SIG]]
 | politique de prix        = 
 | licence                  = [[Licence propriétaire|propriétaire]]
 | site web                 = [http://www.infosig.net/mapinfo-professional/la-gamme-mapinfo/mapbasic www.infosig.net]
}}

'''MapBasic''' est un [[langage de programmation]] utilisé pour la création d'outils et de fonctionnalités pour la suite logicielle ([[Système d'information géographique|SIG]]) [[MapInfo]]. MapBasic est basé sur la famille de langages de programmation [[BASIC]]&lt;ref&gt;{{lien web|titre=MapBasic|url=http://www.i-signum.com/MapBasic.html}}&lt;/ref&gt;.

MapBasic est intégrable dans des programmes développés dans des langages tels que [[Visual Basic]], [[C (langage)|C]] ou encore [[C++]].

==Voir aussi==
*[[MapInfo]]

==Références==
&lt;references/&gt;


{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Système d'information géographique]]</text>
      <sha1>dmtxfb978ujdhvsic7tceixhsat1239</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>C++14</title>
    <ns>0</ns>
    <id>7094718</id>
    <revision>
      <id>101366532</id>
      <parentid>101366129</parentid>
      <timestamp>2014-02-18T13:29:33Z</timestamp>
      <contributor>
        <ip>93.6.88.12</ip>
      </contributor>
      <comment>Précision sur pourquoi std::make_unique n'était pas présent en C++11 alors que std::make_shared l'était + TS</comment>
      <text xml:space="preserve" bytes="3309">'''C++14''' est le nom de la prochaine norme du [[langage C++]]. Elle est annoncée comme une mise à jour mineure du langage, faisant suite à la norme de 2011 connue sous le nom de [[C++11]].
Une mise à jour plus importante est aussi déjà annoncée sous le nom de [[C++17]].

== Améliorations possibles ==
Les propositions d'améliorations suivantes ont été faites :
* Améliorations des fonctions &lt;code&gt;constexpr&lt;/code&gt;
* Généricité et polymorphisme des fonctions lambda
* Introduction de &lt;code&gt;make_unique&lt;/code&gt; par symétrie avec l'ajout de &lt;code&gt;make_shared&lt;/code&gt; dans le C++11. Ceci afin d'éviter des problèmes lors d'un appel comme &lt;code&gt;f(std::unique_ptr&lt;int&gt;(new int), g())&lt;/code&gt;, en effet, le compilateur peut très bien faire l'allocation dynamique puis l'appel à &lt;code&gt;g&lt;/code&gt; avant de créer le pointeur intelligent, causant de possible fuite de mémoire si &lt;code&gt;g&lt;/code&gt; lance une exception. L'introduction de &lt;code&gt;std::make_shared&lt;/code&gt; en C++11 avait été faite pour éviter deux allocations dynamiques (une pour l'objet partagé, une pour le compteur de référence), d'où l'absence de &lt;code&gt;std::make_unique&lt;/code&gt; dans le standard précédent.
* Tableaux dynamiques (sans allocation dynamique). Il serait alors possible d'écrire quelque chose comme : &lt;code&gt;int n; std::cin&gt;&gt;n; int tab[n];&lt;/code&gt;
* Possibilité d'écrire des nombres binaires dans le code source en commençant par 0b ou 0B. Eg. &lt;code&gt;0b1101100011&lt;/code&gt;

L'ajout de deux &quot;headers&quot; à la bibliothèque standard, &lt;code&gt;filesystem&lt;/code&gt; et &lt;code&gt;networking&lt;/code&gt;, ont dans un premier temps été espérés pour C++14, mais quelques jours après la conférence de [[Bristol (Angleterre)|Bristol]] (avril 2013), suivant les sources&lt;ref&gt;[http://herbsutter.com/2013/04/20/trip-report-iso-c-spring-2013-meeting/ D'après Herb Sutter, il est toujours possible que filesystem et networking apparaissaient dans le C++14]&lt;/ref&gt;{{,}}&lt;ref&gt;[http://meetingcpp.com/index.php/br/items/the-bristol-papers-the-state-of-c.html D'après Jens Weller, filesystem et networking seront repoussés au C++17]&lt;/ref&gt;, il est possible que ces nouveautés soient repoussées pour C++17. Ces API ainsi que d'autres pourraient sortir sous la forme de ''Technical Specifications'' d'ici là&lt;ref&gt;{{Lien web|langue=en|url=http://isocpp.org/std/status|titre=Current Status : Standard C++|consulté le=18 février 2014}}&lt;/ref&gt;.

== Références ==
{{références}}

== Liens externes ==
* [http://www.open-std.org/jtc1/sc22/wg21/ Le Comité du Standard C++]
* Présentation de nombreuses propositions pour C++14 par [[Jens Weller]] sur son blog : [http://www.meetingcpp.com/index.php/br/items/a-look-at-cpp14-papers-part-1.html 1{{ère}}], [http://www.meetingcpp.com/index.php/br/items/a-look-at-c14-papers-part-2.html 2{{ème}}], [http://www.meetingcpp.com/index.php/br/items/a-look-at-c14-and-beyond-papers-part-3.html 3{{ème}}] et [http://www.meetingcpp.com/index.php/br/items/a-look-at-c14-and-beyond-papers-part-4.html 4{{ème}}] partie.
* [http://herbsutter.com/2013/04/20/trip-report-iso-c-spring-2013-meeting/ Bilan de la conférence de Bristol] par [[Herb Sutter]]

{{portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Norme ISO]]
[[Catégorie:C++]]</text>
      <sha1>c1j8cds1llvu2op40ieispx8az1mgm5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Langage Ladder</title>
    <ns>0</ns>
    <id>182608</id>
    <revision>
      <id>96938288</id>
      <parentid>89825850</parentid>
      <timestamp>2013-09-23T15:03:56Z</timestamp>
      <contributor>
        <ip>88.161.149.215</ip>
      </contributor>
      <comment>/* ajout catégorie Langages de programmation */</comment>
      <text xml:space="preserve" bytes="5158">{{Voir homonymes|LD|Ladder}}
{{Ébauche|technologie}}
{{sommaire à droite}}

'''Ladder Diagram''' ('''LD''') ou '''Langage Ladder'''  ou '''schéma à contacts''' est un langage graphique très populaire auprès des [[automaticien]]s pour programmer les [[Automate Programmable Industriel|Automates Programmables Industriels]]. Il ressemble un peu aux [[schéma électrique|schémas électriques]], et est facilement compréhensible.

''Ladder'' est le mot anglais pour échelle.

==Origine==
L'idée initiale du Ladder est la représentation de fonction logique sous la forme de [[schéma électrique|schémas électriques]]. Cette représentation est originalement matérielle : quand l'[[Automate Programmable Industriel]] n'existait pas, les fonctions étaient réalisées par des câblages. Par exemple, pour réaliser un ET logique avec des interrupteurs, il suffit de les mettre en série. Pour réaliser un OU logique, il faut les mettre en parallèle.

Le Ladder a été créé et normalisé dans la norme [[CEI 61131-3]]. Il est, depuis, très utilisé dans la programmation des Automates Programmables Industriels.

==Principe==
Un programme Ladder se lit de haut en bas et l'évaluation des valeurs se fait de gauche à droite. Les valeurs correspondent en fait, si on le compare à un [[schéma électrique]], à la présence ou non d'un potentiel électrique à chaque nœud de connexion.

En effet, le Ladder est basé sur le principe d’une alimentation en tension représentée par deux traits verticaux reliée horizontalement par des bobines, des contacts et des blocs fonctionnels, d'où le nom 'Ladder' (échelle).

==Les composants du langage==
Il existe 3 types d'élément de langage :
* les entrées (ou contact), qui permettent de lire la valeur d'une variable booléenne ;
* les sorties (ou bobines) qui permettent d'écrire la valeur d'une variable booléenne ;
* les blocs fonctionnels qui permettent de réaliser des fonctions avancées.

===Les entrées (ou contacts)===
Il existe deux types de contact :
* Le contact normalement ouvert (NO) (en: NO normally open) :
    X
 &lt;nowiki&gt;--| |-- &lt;/nowiki&gt; 
Ce contact est fermé lorsque la variable booléenne associée (X ici) est vraie, sinon, il est ouvert.

* Le contact normalement fermé (NF) (en: NC normally closed) :
    X
 &lt;nowiki&gt;--|/|-- &lt;/nowiki&gt;
Ce contact est ouvert lorsque la variable booléenne associée (X ici) est vraie, sinon il est fermé.

===Les sorties (ou bobines)===
Il existe, de même que pour les contacts, deux types de bobines :
* la bobine normalement ouverte (NO) (en: NO normally open) :
    X    
 &lt;nowiki&gt;--( )-- &lt;/nowiki&gt; 
Si cette bobine est soumise à un potentiel, c’est-à-dire qu'il existe un circuit fermé reliant cette bobine des deux côtés du potentiel, alors la variable booléenne associée (X ici) est mémorisée à 'vraie', sinon elle est mémorisée à 'fausse'.

* la bobine normalement fermée(NF) (en: NC normally closed) :
    X
 &lt;nowiki&gt;--(/)-- &lt;/nowiki&gt;
Si cette bobine est soumise à un potentiel, c’est-à-dire qu'il existe un circuit fermé reliant cette bobine des deux côtés du potentiel, alors la variable booléenne associée (X ici) est mémorisée à 'fausse', sinon elle est mémorisée à 'vraie'.

==Réalisation de fonction logique==
Comme dit précédemment, les fonctions logiques sont dérivées de leurs réalisations électriques. Donc chaque fonction logique ([[Fonction ET|AND]], [[Fonction OU|OR]], [[Fonction OU exclusif|XOR]], [[Fonction NON-ET|NAND]], [[Fonction NON-OU|NOR]], [[Fonction NON|NOT]]) a une représentation qui correspond à son équivalent électrique.

C'est-à-dire :

  &lt;nowiki&gt;---| |-----| |---&lt;/nowiki&gt;
      X       Y 
équivaut à X [[Fonction ET|AND]] Y

  &lt;nowiki&gt;---|\|-----| |---  &lt;/nowiki&gt;  
      X       Y
équivaut à [[Fonction NON|NOT]](X) [[Fonction ET|AND]] Y

  &lt;nowiki&gt;----|---| |---|------&lt;/nowiki&gt;
      |    X    |
      |         |
      &lt;nowiki&gt;+---| |---+&lt;/nowiki&gt;
           Y          
équivaut à X [[Fonction OU|OR]] Y 

Plus complexe :

  &lt;nowiki&gt;----| |---------|--| |--|------( )--&lt;/nowiki&gt;
       X          |   Y   |       S
                  |       |
                  &lt;nowiki&gt;+--| |--+&lt;/nowiki&gt;
                      Z

équivaut à S = X.(Y+Z)

==Exemple de lecture==

 |----| |----+----|/|------------------------------------------( )----|
 |     A     |     F                                            S     |
 |           |                                                        |
 |----| |----+                                                        |
       B

Dans ce réseau, si A [[Fonction OU|OU]] B est actionné [[Fonction ET|ET]] si F n'est pas actionné, la sortie S est active; soit S = (A+B)./F

 S := (A + B) . (/F) ;
Le signe &quot;/F&quot; signifie l'inversion de l'entrée &quot;F&quot;, cela se prononce &quot;F barre&quot;.

==Voir aussi==
{{Autres projets|wikiversity=Automatisme : norme 1131-3 et GRAFCET|wikiversity titre=Automatisme : norme 1131-3 et GRAFCET}}
=== Article connexe ===
* [[Grafcet]]
* [[Boîtes fonctionnelles]]

{{Portail|électricité et électronique}}
[[Catégorie:Automatisme]]
[[Catégorie:Langage de programmation]]</text>
      <sha1>iernyexyvxt2bj0ya8sktkda7vq8ykz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Haxe</title>
    <ns>0</ns>
    <id>1229314</id>
    <revision>
      <id>97074053</id>
      <parentid>80606231</parentid>
      <timestamp>2013-09-28T18:19:18Z</timestamp>
      <contributor>
        <ip>82.244.111.171</ip>
      </contributor>
      <comment>haXe =&gt; Haxe</comment>
      <text xml:space="preserve" bytes="2825">{{Infobox Langage de programmation
| nom                      = Haxe
| nom et logo              = non
| date de première version = 2005
| auteur                   = [[Nicolas Cannasse]]
| influencé par            = [[Java (langage)|Java]], [[Actionscript]]
| site web                 = [http://haxe.org/ Site officiel]
}}

{{Minuscule}}
{{Ébauche|informatique}}
{{à sourcer|date=juin 2012}}
'''Haxe''' est un [[langage de programmation]] développé par [[Nicolas Cannasse]] et la société [[Motion-Twin]] qui, dans le cadre d’une utilisation pour le Web, permet d’écrire la partie serveur et la partie client dans un même langage.

À cette fin, Haxe permet de :
* créer des fichiers [[Adobe Flash|SWF]] qui utilisent les [[Interface de programmation|APIs]] pour les lecteurs [[Adobe Flash Player|Flash Player]] 6 à 11 ;
* créer du code [[JavaScript]] utilisant les API DHTML des navigateurs, ainsi que des applications AJAX. Il est aussi possible d'utiliser des bibliothèques extérieures, tels que jQuery qui est directement inclus au téléchargement de Haxe ;
* créer du [[bytecode]] pour la [[Neko (langage)|NekoVM]] qui peut être employé côté serveur (grâce à un plug-in [[Apache HTTP Server|Apache]]) ou empaqueté dans un exécutable autonome ;
* créer du code PHP qui peut être déployé sur n’importe quel serveur supportant le langage PHP 5.

Haxe permet donc d'assurer l’interopérabilité entre ces différentes plateformes en fournissant des bibliothèques communes.

Il permet, par ailleurs, de créer du code [[C++]], et des cibles [[Java (langage)|Java]]&lt;ref&gt;http://haxe.org/com/meeting&lt;/ref&gt; et [[C sharp|C#]] sont en préparation (courant 2012  - 2013) 	{{référence souhaitée}}.

== Voir aussi ==

=== Liens internes ===
[[Neko (langage)]]

=== Bibliographie ===
* {{Ouvrage
| langue      = en
| prénom1     = Franco 
| nom1        = Ponticelli
| prénom2     = Lee
| nom2        = McColl Sylvester
| titre       = Professional Haxe and Neko Book
| éditeur     = Wrox
| mois        = février
| année       = 2008
| pages       = 619
| isbn        = 978-0-470-12213-6
}}
* {{Ouvrage
| langue      = en
| prénom1     = Benjamin 
| nom1        = Danois
| titre       = haXe 2 Beginner's Guide
| éditeur     = PacktPublishing
| mois        = juillet
| année       = 2011
| pages       = 246
| isbn        = 978-1-849512-56-5
}}


=== Liens externes ===
* {{en}} [http://www.haxe.org/ Haxe]
* {{en}} [http://www.nme.io/ NME], outil open source basé sur le langage Haxe
* {{fr}} [http://www.razaina.fr/ RAZAINA.FR] - Site développé en Haxe proposant des tutoriels en français et diverses ressources.

=== Références ===
&lt;references/&gt;

{{portail|informatique|programmation informatique|internet}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Technologie web]]</text>
      <sha1>iszc2hmropqpsfgk00e026h8va0k6rq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>CHIP-8</title>
    <ns>0</ns>
    <id>7470234</id>
    <revision>
      <id>101603120</id>
      <parentid>97935524</parentid>
      <timestamp>2014-02-26T08:57:57Z</timestamp>
      <contributor>
        <username>Amine Brikci N</username>
        <id>51132</id>
      </contributor>
      <minor/>
      <comment>/* Histoire */</comment>
      <text xml:space="preserve" bytes="5801">[[Image:PONG CHIP8.png|framed|[[Pong]] implémenté en CHIP-8]]
'''CHIP-8''' est un [[langage de programmation]] hexadécimal [[Interprète (informatique)|interprété]] utilisant une [[machine virtuelle]], développé par [[Joseph Weisbecker]] en [[1978]]. Il était spécifiquement conçu pour faciliter la conception de [[jeu vidéo|jeux vidéo]] sur les [[micro-ordinateurs]] [[8-bits]] bas de gamme de cette époque, comme le [[COSMAC VIP]], le [[Telmac 1800]] ou le [[DREAM 6800]].

Le CHIP-8 a connu un regain d'intérêt en 1990, lorsqu'un interpréteur avait été développé pour la calculatrice graphique [[HP-48]], inspirant des évolutions du langage (Super Chip-48).

Des interpréteurs du CHIP-8 et ses évolutions ont été développées pour un grand nombre de plateformes. Ceci est en partie dû au fait que le court jeu d'instruction, la simplicité des caractéristiques, ainsi qu'une bonne documentation technique et une grande communauté ont fait de la machine virtuelle du CHIP-8 un cas d'école pour les programmeurs désirant débuter dans le développement des [[Émulation|émulateurs]].

== Histoire ==

En décembre 1978, Joseph Weisbecker introduit dans un article de [[Byte (magazine)|Byte Magazine]] le CHIP-8 pour démontrer la puissance des langages de programmation hexadécimaux interprétés.

Le CHIP-8 se veut alors comme étant un langage de plus haut niveau que l'[[assembleur]] tout en restant un pseudo-[[langage machine]], mais utilisable sur les machines bas de gamme de l'époque, n'ayant que 1 ou 2 kB de mémoire adressable, des terminaux monochromes basse résolution de quelques dizaines de pixels, et des claviers 16 touches.

Non seulement l'interpréteur CHIP-8 pouvait s'exécuter sur du matériel bas de gamme, ses programmes occupant 5 à 10 fois moins de place que des programmes équivalents en [[BASIC]], à une époque où la [[mémoire RAM]] coutait extrêmement cher.

A titre comparatif, l'interpréteur BASIC le plus léger nécessitait au moins 8 kB de mémoire, un clavier complet et un terminal capable d'afficher des caractères alphanumériques, autrement dit un matériel dont le prix était encore hors de portée des particuliers.

Le langage CHIP-8 offre des boucles de contrôle, arithmétique, affichage de graphiques monochromes, émission de bips sonores, et support des claviers 16-touches hexadécimaux. De nombreux jeux phares de l'époque ([[Pong]], [[Space Invaders]], [[Pac-Man]], etc.) sont vite adaptés en CHIP-8.

En 1990, Andreas Gustafsson développe un interpréteur en CHIP-8 pour la calculatrice graphique HP-48 qui manque alors de moyens de créer facilement des jeux. Ceci lance regain d'intérêt au langage, et entraine des évolutions baptisées Chip-48, puis Super Chip-48 visant à tirer parti des possibilités de la calculatrice HP-48, notamment une plus grande résolution des graphismes. Par la suite, la machine virtuelle de CHIP-8 a souvent été utilisée comme cas pratique pour les gens souhaitant s'initier à la programmation d'émulateurs, et des implémentations de l'interpréteur de CHIP-8 et ses évolutions ont été développés sur une grande variété de plateformes.

== Caractéristiques de la machine virtuelle ==

CHIP-8 peut adresser 3584 octets de mémoire sur la plage 0x200 - 0xFFF. Sur les premiers ordinateurs où CHIP-8 était implémenté, l'interpréteur occupait les 512 octets de la plage 0x000 à 0x1FF. De plus la plage 0xF00 à 0xFFF était réservée à l'affichage, et la plage 0xEA0 à 0xEFF à la pile d'appel et les variables.

La machine virtuelle du CHIP-8 implémente 16 registres de données de 8 bits, nommés V0 à VF. Le registre VF sert d'indicateur de retenue et son contenu est modifié par certaines fonctions. CHIP-8 comprend également un registre d'index de 16 bits exploité par certaines fonctions de mémoire. Enfin, il existe des registres utilisés par l'interpréteur mais inaccessibles aux programmes qui comprennent un compteur de programme de 16-bits et un pointeur de pile de 8-bits qui pointe vers le plus haut niveau de la pile.

CHIP-8 utilise également une pile stockant les adresses de retour des sous-routines. Originellement, 48 octets étaient alloués pour cette pile, permettant jusqu'à 12 niveaux d'appels.

CHIP-8 comporte deux timers :
* le timer de délai permet de chronométrer des évènements. Sa valeur peut être réglée et lue.
* le timer de son provoque un bip lorsque sa valeur atteint zéro.
Les tiers sont décrémentés à une cadence de 60 hertz jusqu'à ce qu'ils atteignent zéro.

Les entrées sont faites à l'aide de claviers à 16 touches prenant les valeurs 0x0 à 0xF. Les touches 2,4,6 et 8 sont usuellement utilisées comme flèches directionnelles. CHIP-8 fournit des fonctions permettant de détecter qu'une touche a été pressée ou non, ou d'attendre qu'une touche soit pressée.

CHIP-8 supporte une résolution d'affichage de 64x32 pixels monochromes. L'affichage des graphiques se fait uniquement par [[Sprite (jeu vidéo)|sprite]] de 8 pixels de large pour 1 à 15 de haut. L'affichage des sprites se fait uniquement en mode [[XOR]], et si un pixel est désactivé lors de l'affichage d'un sprite, l'indicateur de retenue est fixé à 1, ce qui permet la détection de collision.

CHIP-8 comporte originellement 35 [[codes opérations]] (CHIP-48 ayant ajouté dix instructions supplémentaires). Les instructions ont une longueur de deux octets. Les bits de poids fort des adresses sont stockés en premier.

== Références ==
* ''[[Byte (magazine)|BYTE magazine]]'', December 1978, pp. 108–122. ''An Easy Programming System'', Joseph Weisbecker.

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Virtualisation]]
[[Catégorie:Calculatrice graphique]]</text>
      <sha1>99qw36xdf4ae0loq7di6b6kin1942rz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>JADE (langage de programmation)</title>
    <ns>0</ns>
    <id>7590815</id>
    <revision>
      <id>99110994</id>
      <parentid>99035762</parentid>
      <timestamp>2013-12-11T01:49:44Z</timestamp>
      <contributor>
        <username>Jul.H</username>
        <id>118720</id>
      </contributor>
      <comment>éb + wikif + cat</comment>
      <text xml:space="preserve" bytes="342">{{ébauche|informatique}}

'''JADE''' est une plateforme de [[Programmation informatique|programmation]] multi-agent implémentée en [[Java (langage)|java]]. Les agents qui tournent sous JADE communiquent via le langage ''Agent Communication Language'' ou ACL.

{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>gcw5wt6nc64mxatd3tisy3pyvh55mep</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Java (langage)</title>
    <ns>0</ns>
    <id>6469</id>
    <revision>
      <id>101937258</id>
      <parentid>101439264</parentid>
      <timestamp>2014-03-10T09:02:23Z</timestamp>
      <contributor>
        <username>Alband85</username>
        <id>23366</id>
      </contributor>
      <minor/>
      <comment>/* Contenu et évolutions */</comment>
      <text xml:space="preserve" bytes="72944">{{Voir homonymes|nohr=1|Java}}
{{Confusion|JavaScript}}
{{Infobox Langage de programmation
| nom                    = Java
| logo                   = Java Logo.svg
| paradigme              = [[Programmation orientée objet|Orientée objet]], [[Programmation structurée|structurée]], [[Programmation impérative|impérative]]
| année                  = {{date|23|mai|1995|en informatique}}
| auteur                 = [[Sun Microsystems]]
| développeurs           = [[Oracle Corporation]]
| typage                 = [[Typage statique|Statique]], [[Typage fort|fort]], [[Sûreté du typage|sûr]], [[Système nominatif de types|nominatif]]
| implémentations        = [[Machine virtuelle Java|Liste de JVM]]
| dialectes              =
| influencé par          = [[Objective-C]], [[C++]], [[Smalltalk]], [[Eiffel (langage)|Eiffel]]&lt;ref&gt;{{lang|en|''In Java 5.0, several features (the [[foreach|enhanced for loop]], [[autoboxing]], [[varargs]], [[Annotation (Java)|annotations]] and [[enumerated type|enums]]) were introduced, after proving themselves useful in the similar (and competing) language [[C Sharp|C#]].''}} [http://www.barrycornelius.com/papers/java5/][http://www.levenez.com/lang/][http://eclipsezone.com/eclipse/forums/t54318.html]&lt;/ref&gt;, [[Ada 83]], [[C sharp|C#]], [[Mesa (langage)|Mesa]], [[Modula-3]], [[Oberon (langage)|Oberon]], [[UCSD Pascal]]

| a influencé            = [[C Sharp|C#]], [[D (langage)|D]], [[J sharp|J#]], [[Ada (langage)|Ada 2005]], [[Gambas (langage)|Gambas]], [[BeanShell]], [[Clojure]], [[ECMAScript]], [[Groovy (langage)|Groovy]], [[JavaScript]], [[PHP]], [[Python (langage)|Python]]&lt;ref&gt;http://www.python.org/dev/peps/pep-0318/&lt;/ref&gt;, [[Scala (langage)|Scala]], [[Seed7]], [[Vala (langage de programmation)|Vala]]

| système d'exploitation = [[Multiplateforme]]s
| licence                = [[Licence publique générale GNU|GNU GPL]]
| version actuelle       = 1.7 update 21
| site web               = [http://www.java.com/fr www.java.com]
}}
Le langage '''Java''' est un [[langage de programmation]] [[informatique]] [[orienté objet]] créé par [[James Gosling]] et [[Patrick Naughton]], employés de [[Sun Microsystems]], avec le soutien de [[Bill Joy]] (cofondateur de [[Sun Microsystems]] en [[1982]]), présenté officiellement le {{date|23|mai|1995|en informatique}} au ''SunWorld''.

La société Sun a été ensuite rachetée en 2009 par la société [[Oracle Corporation|Oracle]] qui détient et maintient désormais [[Java (technique)|Java]].

La particularité et l'objectif central de Java est que les logiciels écrits dans ce langage doivent être très facilement [[Portabilité (informatique)|portables]] sur plusieurs [[système d'exploitation|systèmes d’exploitation]] tels que [[UNIX]], [[Microsoft Windows|Windows]], [[Mac OS]] ou [[GNU/Linux]], avec peu ou pas de modifications. Pour cela, divers [[plate-forme Java|plateformes]] et [[Liste de frameworks Java|frameworks]] associés visent à guider, sinon garantir, cette portabilité des [[logiciel|applications]] développées en Java.

== Aperçu ==
Le langage Java reprend en grande partie la syntaxe du langage [[C++]], très utilisée par les informaticiens. Néanmoins, Java a été épuré des concepts les plus subtils du [[C++]] et à la fois les plus déroutants, tels que les pointeurs et références, ou l’[[héritage multiple]] contourné par l’implémentation des [[Interface (programmation orientée objet)|interfaces]]. Les concepteurs ont privilégié l’[[programmation orientée objet|approche orientée objet]] de sorte qu’en Java, tout est objet à l’exception des [[Type (informatique)|types]] primitifs (nombres entiers, nombres à virgule flottante, etc.).

Java permet de développer des applications [[client-serveur]]. Côté client, les [[applet]]s sont à l’origine de la notoriété du langage. C’est surtout côté serveur que Java s’est imposé dans le milieu de l’entreprise grâce aux [[servlet]]s, le pendant serveur des applets, et plus récemment les JSP ([[JavaServer Pages]]) qui peuvent se substituer à [[PHP]], [[Active Server Pages|ASP]] et [[ASP.NET]].

Java a donné naissance à un système d'exploitation ([[JavaOS]]), à des environnements de développement ([[Eclipse (logiciel)|eclipse]]/[[Java Development Kit|JDK]]), des [[machine virtuelle|machines virtuelles]] ({{Lien|fr=MSJVM|lang=en|trad=Microsoft Java Virtual Machine|texte=MSJVM}}, [[Environnement d'exécution Java|JRE]]) applicatives multiplate-forme ([[Machine virtuelle Java|JVM]]), une déclinaison pour les périphériques mobiles/embarqués ([[Java 2 Micro Edition|J2ME]]), une bibliothèque de conception d'interface graphique ([[Swing (Java)|AWT/Swing]]), des applications lourdes (Jude, Oracle SQL Worksheet, etc.), des technologies web (servlets, applets) et une déclinaison pour l'entreprise ([[Java 2 Enterprise Edition|J2EE]]). La [[Portabilité (informatique)|portabilité]] du bytecode Java est assurée par la [[machine virtuelle]] Java, et éventuellement par des bibliothèques standard incluses dans un JRE.
Cette machine virtuelle peut [[Interprète (informatique)|interpréter]] le bytecode ou le [[compilation à la volée|compiler à la volée]] en langage machine.
La portabilité est dépendante de la qualité de portage des JVM sur chaque OS.

== Historique ==
{{Traduction/Référence|en|Java programming language}}
''N’hésitez pas à vérifier la qualité de la traduction pour être certain qu’il n’y ait pas de contresens.''

=== L'origine du langage ===
[[Fichier:Duke3D.png|thumb|'''Duke''', la mascotte de Java.]]
Le langage Java est issu d’un projet de Sun Microsystems datant de 1990 : l’ingénieur Patrick Naughton n’était pas satisfait par le langage C++ utilisé chez Sun, ses [[Interface de programmation|interfaces de programmation]] en langage C, ainsi que les outils associés. Alors qu’il envisageait une migration vers NeXT, on lui proposa de travailler sur une nouvelle technologie et c’est ainsi que le '''Projet {{lang|en|Stealth}}''' ([[Furtivité|furtif]]) vit le jour.

Le '''Projet {{lang|en|Stealth}}''' fut rapidement rebaptisé '''{{lang|en|Green Project}}''' avec l’arrivée de James Gosling et de Mike Sheridan. Ensemble, aidés d’autres ingénieurs, ils commencèrent à travailler dans un bureau de la rue Sand Hill à Menlo Park en Californie. Ils essayèrent d’élaborer une technologie pour le développement d’applications d’une nouvelle génération, offrant à Sun la perspective d’opportunités uniques.

L’équipe envisageait initialement d’utiliser le langage C++, mais l’abandonna pour différentes raisons. Tout d’abord, ils développaient sur un système embarqué avec des ressources limitées et estimaient que l’utilisation du C++ demandait un investissement trop important et que cette complexité était une source d’erreur pour les développeurs. L'absence de [[Ramasse-miettes (informatique)|ramasse-miettes]] impliquait que la gestion de la mémoire devait être programmée manuellement, un défi mais aussi une source d’erreur(s).

L’équipe était aussi troublée par les lacunes du langage C++ au niveau de la sécurité, de la programmation distribuée, du {{lang|en|''[[Simultaneous Multi Threading|multi-threading]]''}}. De plus, ils voulaient une plate-forme qui puisse être portée sur tout type d’appareils ou de plate-forme.

Bill Joy avait envisagé un nouveau langage combinant le meilleur du langage de programmation [[Mesa (langage)|Mesa]] et du [[langage C]]. Dans un article appelé ''Plus loin ({{lang|en|Further}})'', il proposa à Sun que ses ingénieurs développent un environnement orienté objet basé sur le langage C++. À l’origine, Gosling envisageait de modifier et d’améliorer le langage C++, qu’il appelait C++ ++ --, mais l’idée fut bientôt abandonnée au profit du développement d’un nouveau langage de programmation qu’ils appelèrent '''{{lang|en|''Oak''}} (chêne)''' en référence, selon la légende, à un arbre planté devant la fenêtre de leur bureau.

L’équipe travailla avec acharnement et, à l’été 1992, ils furent capables de faire une démonstration constituée d'une [[Plate-forme (informatique)|plate-forme]] incluant le système d’exploitation [[Green]], le langage Oak (1992), les bibliothèques et le matériel. Leur première réalisation, présentée le {{date|3|septembre|1992|en informatique}}, fut la construction d’un [[PDA]] appelé '''Star7''' ayant une interface graphique et un agent intelligent appelé '''Duke''' pour prêter assistance à l’utilisateur.

En novembre de la même année, le {{lang|en|'''Green Project'''}} fut abandonné pour devenir '''FirstPerson, Inc''', appartenant en totalité à Sun Microsystems et l’équipe fut relocalisée à Palo Alto. L’équipe '''FirstPerson''' était intéressée par la construction d’outils hautement interactifs et quand Time Warner publia un appel d’offres en faveur d’un décodeur multifonctions, FirstPerson changea d’objectif pour proposer une telle plate-forme.

Cependant, l’industrie de la télévision par câble trouva qu’elle offrait trop de possibilités à l’utilisateur et FirstPerson perdit le marché au profit de [[Silicon Graphics]]. Incapable d’intéresser l’industrie audiovisuelle, la société fut réintégrée au sein de Sun.

=== Java rencontre Internet ===
De juin à {{date||juillet|1994|en informatique}}, après trois jours de remue-méninges avec John Gage, James Gosling, Joy, Naughton, Wayne Rosing et [[Eric Schmidt]], l’équipe recentra la plate-forme sur le [[web]]. Ils pensaient qu’avec l’avènement du navigateur [[Mosaic]], Internet était le lieu où allait se développer le même genre d’outil interactif que celui qu’ils avaient envisagé pour l’industrie du câble. Naughton développa comme prototype un petit navigateur web, WebRunner qui deviendra par la suite [[HotJava]].

La même année le langage fut renommé Java après qu’on eut découvert que le nom {{lang|en|'''Oak'''}} était déjà utilisé par un fabricant de carte vidéo.
==== Origine du nom Java ====
Le nom Java fut inventé dans un petit bar fréquenté par quelques membres de l’équipe. Il n’a pas été déterminé clairement si ce nom est un [[Acronymie|acronyme]] :
* certains prétendent qu’il signifie '''J'''ames Gosling, '''A'''rthur '''V'''an Hoff et '''A'''ndy Bechtolsheim ;
* ou tout simplement {{lang|en|'''J'''ust '''A'''nother '''V'''ague '''A'''cronym}} (littéralement « juste un acronyme vague de plus »).

La croyance selon laquelle Java doit son nom aux produits vendus dans le bar tient au fait que le code sur {{unité|4|octets}} (également appelé [[Nombre magique (programmation)|nombre magique]]) des [[Class (format de fichier)|fichiers de classe]] est en hexadécimal 0xCAFEBABE.

Certaines personnes prétendent également que le nom de Java vient du fait que le programme était destiné à pouvoir tourner sur des systèmes embarqués, comme des cafetières (Java signifiant [[café]] en argot américain). De là vient le logo actuel de Java, schématisant une tasse de café fumant.

==== Lancement public de Java ====
En {{date||octobre|1994|en informatique}}, HotJava et la plate-forme Java furent présentés pour Sun Executives. Java 1.0a fut disponible en téléchargement en 1994 mais la première version publique du navigateur HotJava arriva le {{date|23|mai|1995|en informatique}} à la conférence '''SunWorld'''&lt;ref&gt;{{en}} [http://web.archive.org/web/20100105045840/http://java.sun.com/features/1998/05/birthday.html ''Java Technology: The Early Years'']&lt;/ref&gt;.

L’annonce fut effectuée par John Gage, le directeur scientifique de Sun Microsystems. Son annonce fut accompagnée de l’annonce surprise de Marc Andressen, vice-président de l’exécutif de Netscape que Netscape allait inclure le support de Java dans ses navigateurs. Le {{date|9|janvier|1996|en informatique}}, le groupe Javasoft fut constitué par Sun Microsystems pour développer cette technologie&lt;ref&gt;{{en}} [http://www.sun.com/smi/Press/sunflash/1996-01/sunflash.960109.14048.html {{lang|en|''Sun Microsystems Announces Formation Of Javasoft''}}&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;. Deux semaines plus tard la première version de Java était disponible.

=== Avènement de Java 2 ===
L'apparition de la version 1.2 du langage marque un tournant significatif : c'est en 2000 qu'apparait simultanément la déclinaison en deux plateformes Java :
* Java 2 Standard Edition (J2SE), plateforme avec les API et bibliothèques de bases, devenue depuis [[Java SE]] ;
* Java 2 Enterprise Edition (J2EE), extension avec des technologies pour le développement d'applications d’entreprise, devenue [[Java EE]].

Sun les qualifie alors de plateforme Java 2 par opposition aux premières générations 1.0 et 1.1. Toutes les versions ultérieures, de J2EE 1.2 à Java SE ou Java EE 7 restent désignées sous le qualificatif de plateformes Java 2, bien que le '2' ait été depuis officiellement abandonné.

=== Histoire récente ===
==== Utilisation Web ====
===== Côté client =====
'''Applets'''

Historiquement, la possibilité des navigateurs Web de lancer des [[Applet Java|applets Java]] était la seule solution pour afficher des applications clientes riches (RIA pour [[Rich Internet Application]]). Puis des technologies concurrentes ont émergé parmi lesquelles [[Macromedia]] [[Adobe Flash|Flash]], le DHTML [[JavaScript]], [[Silverlight]] basé sur [[XAML]] ou [[XML-based User interface Language|Xul]].

Les applets sur le poste Client peuvent communiquer avec des [[servlet]]s sur le Serveur, tout comme Javascript peut communiquer avec le Serveur au moyen d’[[Ajax (informatique)|AJAX]]. [[Adobe Flex|Flex]] utilise quant à lui la technologie Flash par le biais du [[Adobe Flash Player]].

À une époque où [[Javascript]] souffrait de problèmes de compatibilité inter-navigateur, les applets Java avaient l'avantage de la portabilité car le portage d'interfaces complexes était difficile à assurer pour tous les navigateurs du marché.

Mais les progrès faits dans les technologies concurrentes à Java ont amené la plupart des développeurs à se détourner des applets Java et des problèmes inhérents à cette technologie (incompatibilités entre les JVM, mauvaises performances, pauvreté des bibliothèques graphiques, complexité), outre la retombée de la « mode » Java. Enfin, les navigateurs modernes n'incluent plus systématiquement l'environnement Java à cause de sa taille importante, et le taux de machines capables d'afficher des applets n'était plus que de 70 % en 2010, bien plus faible que pour Flash par exemple&lt;ref&gt;http://riastats.com/&lt;/ref&gt;. En 2010, la quasi-totalité des applications clients riches utilisent des technologies alternatives ; Flash pour l'essentiel mais aussi [[GWT]].

Enfin, la perspective de l'arrivée prochaine de [[HTML5]], destiné à embarquer de nombreuses fonctionnalités RIA et [[multimédia]], rend également les applets caduques.

'''JavaFX'''

[[JavaFX]] est une plateforme pour [[Rich Internet Application]]s, un peu comme [[Adobe Flash]]. Cependant, là encore, la concurrence est rude. [[Microsoft]] [[Silverlight]], et la convergence de [[Adobe Flash]] et de [[JavaScript]]/[[Ecmascript]] en [[ActionScript]], sont également bien positionnées dans ce nouveau domaine.

===== Côté serveur =====
Avec les [[serveur d'applications|serveurs d’applications]], on utilise des [[Enterprise JavaBeans|EJB]] pour encapsuler les classes définies précédemment. Ces éléments sont utilisés dans des architectures [[J2EE]] pour des applications multicouches.
L'avantage qu'on tire de ce travail est de pouvoir cacher au client l'implémentation du code côté serveur.

==== Utilisation sur poste de travail ====
L’utilisation native du langage Java pour des applications sur un poste de travail restait jusqu'à présent relativement rare à cause de leur manque de rapidité. Cependant, avec l’accroissement rapide de la puissance des ordinateurs, les améliorations au cours de la dernière décennie de la machine virtuelle Java et de la qualité des compilateurs, plusieurs technologies ont gagné du terrain comme [[Netbeans]] et l’environnement [[Eclipse (logiciel)|Eclipse]], les technologies de fichiers partagés [[LimeWire]], [[Vuze (logiciel)|Vuze (ex Azureus)]], et [[I2P]]. Java est aussi utilisé dans le programme de mathématiques [[Matlab]], au niveau de l’interface homme machine et pour le calcul formel. Les applications [[Swing (Java)|Swing]] apparaissent également comme une alternative à la technologie .NET.

==== Utilisation avec les mobiles ====
[[Fichier:CyanogenMod 10 homescreen screenshot.png|thumb|upright|[[Android]] utilise beaucoup les technologies Java]]
[[Oracle (entreprise)|Oracle]] annonce début octobre 2012 à la conférence JavaOne sa volonté de proposer des solutions Java pour le domaine des logiciels embarqués, pour processeurs moins puissants que ceux habituellement disponibles sur les PC. Oracle fédère autour d'elle tout un éco-système d'entreprises spécialistes de ces segments de marchés, comme l'éditeur [http://www.is2t.com IS2T] ou encore STMicroelectronics qui propose du [http://www.stm32java.com Java sur ses STM32] dont le cœur est un CortexM3/M4.

Java, notamment via [[Eclipse (projet)|Eclipse]] et [[NetBeans]], offre déjà des environnements de développement intégrés pour mobile. Java est le principal langage utilisé pour développer des applications pour le système d'exploitation libre pour Mobile de [[Google]] : [[Android]].

[[JavaFX]] peut aussi permettre l'utilisation de Java sur mobiles, bien que ce ne soit pas son objectif principal.

==== OS Windows, Mac OS X et Linux ====
[[Microsoft]] a fourni en 2001 un environnement de travail de type Java, dénommé [[Visual J++|J++]], avec ses systèmes d’exploitation avant la sortie de [[Windows XP]]. Suite à une décision de justice{{refnec}}, et au vu du non-respect des spécifications de ce langage, Microsoft a dû abandonner celui-ci et créer un nouveau langage, de nom [[C sharp|C#]] (cf. chapitre « [[#Indépendance vis-à-vis de la plate-forme|Indépendance vis-à-vis de la plate-forme]] » plus bas)

Beaucoup de fabricants d’ordinateurs continuent d’inclure un environnement JRE sur leurs systèmes Windows.

Java apparaît également comme un standard au niveau du Mac[[OS X]] d’[[Apple]] aussi bien que pour les distributions [[Linux]]. Ainsi, de nos jours, la plupart des utilisateurs peuvent lancer des applications Java sans aucun problème.
Toutefois, sur ordinateur Apple, la distribution de Java 5 à Java 6 fut assurée directement par Apple, et non par Oracle&lt;ref&gt;[http://www.java.com/fr/download/faq/java_6.xml Apple Java 6 pour Mac OS X] FAQ www.java.com/fr/download&lt;/ref&gt;. Cette politique entraîna des retards et des restrictions de version :
:Ainsi J2SE 1.4 ne fut pas disponible avant [[Mac OS X v10.2]] (nom de code ''Jaguar''), J2SE 5.0 à partir de [[Mac OS X v10.4]] (''Tiger''), Java SE 6 fonctionne uniquement sous [[Mac OS X v10.5]] (''Leopard'') équipé de processeur [[Intel#Microprocesseurs x86|Intel]]&lt;ref&gt;[https://developer.apple.com/library/mac/#technotes/tn2002/tn2110.html#TABLES Technical Notes TN2110] developer.apple.com&lt;/ref&gt;, et Java 7 exige un ordinateur Mac Intel exécutant la version [[Mac OS X v10.7]].3 (''Lion'').

==== Passage sous licence open-source ====
Le {{date|11|novembre|2006|en informatique}}, le code source du compilateur &lt;tt&gt;javac&lt;/tt&gt; et de la machine virtuelle {{Lien|fr=HotSpot|lang=en}} ont été publiés en Open Source sous la [[Licence publique générale GNU]]&lt;ref&gt;{{en}} {{lang|en|''&quot;Q: What components of the JDK software are you open sourcing today? A: We’re open sourcing the Java programming language compiler (&quot;javac&quot;), and the Java HotSpot virtual machine.&quot;''}}[http://www.sun.com/software/opensource/java/faq.jsp#b2 {{lang|en|''Free and Open Source Java FAQ''}}]; {{lang|en|the source is being released via the [https://openjdk.dev.java.net/ OpenJDK] project}}.&lt;/ref&gt;.

Le {{date|13|novembre|2006|en informatique}}, Sun Microsystems annonce le passage de Java, c’est-à-dire le [[JDK]] (JRE et outils de développement) et les environnements Java EE (déjà sous licence CDDL) et Java ME sous licence [[Licence publique générale GNU|GPL]] d’ici mars 2007, sous le nom de projet [[OpenJDK]]&lt;ref&gt;{{Lien web
| url=http://www.sun.com/smi/Press/sunflash/2006-11/sunflash.20061113.1.xml
| titre=Sun Open Sources Java Platform
| publisher=Sun Microsystems
| date={{date|13|novembre|2006}}
| consulté le=13 novembre 2006}}&lt;/ref&gt;.

En {{date||mai|2007|en informatique}}, Sun publie effectivement OpenJDK sous licence libre. Cependant OpenJDK dépend encore de fragments de code non libre que Sun ne détient pas. C'est pourquoi la société Redhat lance en {{date||juin|2007|en informatique}} le projet {{Lien|fr=IcedTea|lang=en}} qui vise à remplacer les fragments de code non libre et ainsi rendre OpenJDK utilisable sans aucun logiciel propriétaire. En {{date||juin|2008|en informatique}}, le projet IcedTea a passé les tests rigoureux de compatibilité Java (TCK)&lt;ref&gt;http://blog.softwhere.org/archives/196&lt;/ref&gt;. 
IcedTea est donc une implémentation open-source des spécifications de Java. Sun, puis Oracle, garde toutefois le contrôle de la technologie par le biais d'un catalogue de brevets s'appliquant à Java, ainsi que par le maintien du TCK sous une licence propriétaire.

==== Acquisition par [[Oracle Corporation|Oracle]] ====
La société [[Oracle Corporation|Oracle]] a acquis en 2009 l'entreprise [[Sun Microsystems]]. On peut désormais voir apparaître le logo Oracle dans les documentations de l'api Java.

Le 12 avril 2010, [[James Gosling]], le créateur du langage de programmation Java démissionne d’Oracle pour des motifs qu’il ne souhaite pas divulguer. Il était devenu le directeur technologique de la division logicielle client pour Oracle.

=== Historique des versions ===
Le langage Java a connu plusieurs évolutions depuis le JDK 1.0 ({{lang|en|''Java Development Kit''}}) avec l’ajout de nombreuses classes et packages à la bibliothèque standard. Depuis le J2SE1.4, l’évolution de Java est dirigée par le JCP ({{lang|en|''Java Community Process''}}) qui utilise les JSR ({{lang|en|''Java Specifications Requests''}}) pour proposer des ajouts et des changements sur la plate-forme Java. Le langage lui-même est spécifié par le JLS ({{lang|en|''Java Language Specification''}}), les modifications du JLS étant gérées sous le code JSR 901&lt;ref&gt;{{en}} [http://www.jcp.org/en/jsr/detail?id=901 {{lang|en|''The Java Community Process(SM) Program - JSRs : Java Specification Requests - detail JSR# 901''}}&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;.

Il faut noter que les évolutions successives du langage ne portent guère sur sa syntaxe -relativement stable depuis le début- mais principalement sur l'enrichissement de ses fonctions, avec l'embarquement et l'optimisation de bibliothèques logicielles ([[Interface de programmation|API]]) dans des domaines très variés de l'informatique : bases de données, gestion XML, informatique distribuée et web, multimédia, sécurité…
==== Numérotation des versions ====
Il faut distinguer la version du langage Java de celles des plateformes et du JRE :
* Le numéro majeur de version du langage (''par exemple '''Java 5''''') spécifiée par le JLS, est ainsi le [[Versionnement#Forme générale|numéro mineur]] pour le JRE ou la plateforme (par ex JRE 1.5 ou Java SE 1.5)&lt;ref&gt;[http://www.java.com/en/about/brand/naming.jsp Java Naming]http://www.java.com&lt;/ref&gt;;
* Le JRE et la plateforme Java SE sont eux identifiés depuis Java 5 par un même numéro de version : ainsi Java SE 1.6.0.43, et le JRE 1.6.0.43, sont tous deux conformes au langage Java 6, mais ont fait l'objet notamment de [[Patch (informatique)|correctifs]] de sécurité;
* Java FX (orienté ''[[Rich Internet Application|RIA]]''), constitué essentiellement d'un sous-ensemble de JavaSE, suit également le même numéro de version : Java FX en est ainsi sa version 2.7 pour 1.7&lt;ref&gt;http://www.oracle.com/technetwork/java/javafx/downloads/index.html&lt;/ref&gt;(également compatible JRE 1.6)
* En revanche les plateformes ''Enterprise Edition'' (Java EE) et ''Mobile Edition'' (Java ME) sont identifiées par le numéro de version de leur propre [[Kit de développement|SDK]]; ainsi début 2013 :
** Java EE en était encore à la version 6 (Java EE 6 SDK Update 4), mais fonctionnait avec les JDK 6 ou 7&lt;ref&gt;http://www.oracle.com/technetwork/java/javaee/downloads/index.html&lt;/ref&gt;; il n'est réellement passé à Java 7 que mi-juin 2013&lt;ref&gt;[http://www.oracle.com/us/corporate/press/1957557 Oracle Announces Availability of Java Platform Enterprise Edition 7]Oracle Press Release June 12, 2013&lt;/ref&gt;
** Java ME en est à sa version 3.3 (SDK v. 3.3)&lt;ref&gt;http://www.oracle.com/technetwork/java/javame/javamobile/download/sdk/index.html&lt;/ref&gt;;

==== Versions successives ====
{| class=&quot;wikitable&quot;
|-
! Version !! Last update  !! Dénomination JSE/JRE !! Nom de code !! Spécifications !! JDK  !! Statut août-2013 !! Période de maintenance
|-
| 1.8 || -  || Java SE 8 || Wolf{{refnec}} || - || [https://jdk8.dev.java.net 1.8]  || {{lang|en|''Developer Preview''}}&lt;ref&gt;[http://openjdk.java.net/projects/jdk8 Roadmap Java8]java.net - 19/06/2013&lt;/ref&gt; ||
|-
| 1.7 || 0_51  || Java SE 7 || Dolphin || {{en}} [http://www.jcp.org/en/jsr/detail?id=336 JSR 336] || [http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html 1.7.0_51] || Stable, actuel, version 1.7.0.51 proposée aux développeurs || 2011- 2015&lt;ref name=&quot;:34&quot;&gt;Oracle Java SE Support Roadmap, 13 mai 3013, http://www.oracle.com/technetwork/java/eol-135779.html&lt;/ref&gt; 
|-
| 1.6 || 0_45/0_51  || Java SE 6 || Mustang || {{en}} [http://www.jcp.org/en/jsr/detail?id=270 JSR 270] || [http://java.sun.com/javase/6 1.6] || Stable, actuel, version 1.6.0.43&lt;ref&gt;[http://www.oracle.com/technetwork/java/javase/releasenotes-136954.html Java SE 6 Update Release Notes]&lt;/ref&gt; (1.6.0_51 sur Mac OS X&lt;ref&gt;[http://www.macg.co/news/voir/260278/mises-a-jour-java-pour-snow-leopard-lion-et-mountain-lion Mises à jour Java pour Snow Leopard, Lion et Mountain Lion]MacGeneration&lt;/ref&gt;) proposée aux utilisateurs || ''2005-2013''&lt;ref name=&quot;:34&quot; /&gt;
|-
| 1.5 || 0_18  || J2SE 5.0 || Tiger || {{en}} [http://www.jcp.org/en/jsr/detail?id=176 JSR 176] || [http://java.sun.com/j2se/1.5.0 1.5] || En fin de vie || ''2002-2009''&lt;ref name=&quot;:34&quot; /&gt;
|-
| 1.4 || 2_30  || J2SE 1.4 || Merlin || {{en}} [http://www.jcp.org/en/jsr/detail?id=59 JSR 59] || [http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase14-419411.html#j2sdk-1.4.2_30-sol-JPR 1.4.2_30] || ''Obsolète'' || ''2000-2008''&lt;ref name=&quot;:34&quot; /&gt;
|-
| 1.3 || 1_29  || J2SE 1.3 || Kestrel ||  {{en}} [http://www.jcp.org/en/jsr/detail?id=58 JSR 58] || [http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase13-419413.html#j2sdk-1.3.1_29-sol-JPR 1.3.1_29] || ''Obsolète'' || ''2000-2001''
|-
| 1.2 || 2_017  || J2SE 1.2 || Playground  ||  {{en}} [http://www.jcp.org/en/jsr/detail?id=52 JSR 52] || [http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase12-419414.html#7740-j2sdk-1.2.2_017-oth-JPR 1.2] || ''N'est plus soutenu de façon active'' || ''2000-2006'' 
|-
| 1.1 || 8_16  || Java 1.1 || ||  {{en}} [http://www.jcp.org/en/jsr/detail?id=1 JSR 52] || [http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase11-419415.html#7040-jdk-1.1.8_16-oth-JPR] || ''N'est plus soutenu de façon active'' || ''1997-2000'' 
|-
| 1.0 || 1.0.2  || Java 1.0 || Oak ||  {{en}} [http://www.jcp.org/en/jsr/detail?id=52 JSR 52] || JDK 1.0.2 || ''N'est plus soutenu de façon active'' || ''1996-2000'' 
|}

==== Contenu et évolutions ====
* '''JDK 1.0''' ({{date|23|janvier|1996|en informatique}} - 211 classes et interfaces) — Version initiale&lt;ref&gt;{{en}} [http://www.sun.com/smi/Press/sunflash/1996-01/sunflash.960123.10561.html communiqué de presse]&lt;/ref&gt;.

* '''JDK 1.1''' ({{date|19|février|1997|en informatique}} - 477 classes et interfaces) — De nombreux ajouts&lt;ref&gt;{{en}} [http://www.sun.com/smi/Press/sunflash/1997-02/sunflash.970219.0001.html communiqué de presse]&lt;/ref&gt; avec notamment :
** une refonte complète du modèle événementiel [[AWT]].
** Les classes internes sont ajoutées au langage.
** [[JavaBeans]].
** [[JDBC]].
** Java Remote Invocation ([[Remote method invocation (Java)|RMI]]).

* '''J2SE 1.2''' ({{date|9|décembre|1998|en informatique}} - {{formatnum:1524}} classes et interfaces) — Nom de code {{lang|en|''Playground''}}. Cette version et les suivantes jusque J2SE 7.0 sont rebaptisées '''Java 2''' et la version nommée J2SE ({{lang|en|''Java 2 Platform, Standard Edition''}}) remplace JDK pour distinguer la plate-forme de base de la version J2EE ({{lang|en|''Java 2 Platform, Enterprise Edition''}}) et de la version J2ME ({{lang|en|''Java 2 Platform, Micro Edition''}}). Plusieurs ajouts&lt;ref&gt;{{en}} [http://www.sun.com/smi/Press/sunflash/1998-12/sunflash.981208.9.html communiqué de presse]&lt;/ref&gt; dont :
** le mot-clé &lt;code&gt;strictfp&lt;/code&gt; ({{lang|en|strict floating-point}} : [[virgule flottante]] stricte)
** la [[Réflexion (informatique)|réflexion]]
** l’API graphique Swing est intégrée.
** Pour la première fois, la machine virtuelle Java de Sun inclut un compilateur « Juste à temps » ({{lang|en|''Just in Time''}}).
** Java Plug-in
** Java IDL, une implémentation de IDL pour l’interopérabilité avec CORBA.
** le {{lang|en|''framework Collections''}}.

* '''J2SE 1.3''' ({{date|8|mai|2000|en informatique}} - {{formatnum:1840}} classes et interfaces) — Nom de code ''Kestrel''. Changements principaux&lt;ref&gt;{{en}} [http://www.sun.com/smi/Press/sunflash/2000-05/sunflash.20000508.3.html communiqué de presse] - {{en}} [http://java.sun.com/j2se/1.3/docs/relnotes/features.html liste complète des changements]&lt;/ref&gt; :
** HotSpot JVM inclus (La machine virtuelle HotSpot sortit en {{date||avril|1999|en informatique}} pour la machine virtuelle du J2SE 1.2)
** Changement pour les RMI pour être basé sur CORBA.
** JavaSound
** [[JNDI]] ({{lang|en|''Java Naming and Directory Interface''}}) inclus de base (disponible auparavant comme [[bibliothèque logicielle|extension]])
** JPDA ({{lang|en|''Java Platform Debugger Architecture''}})

* '''J2SE 1.4''' ({{date|6|février|2002|en informatique}} - {{formatnum:2723}} classes et interfaces) — Nom de code ''Merlin''. Ce fut la première révision de la plate-forme sous JCP ({{lang|en|''Java Community Process''}})&lt;ref&gt;{{en}} [http://www.jcp.org/en/jsr/detail?id=59 JSR 59]&lt;/ref&gt;. Les principaux changements&lt;ref&gt;{{en}} [http://www.sun.com/smi/Press/sunflash/2002-02/sunflash.20020206.5.html communiqué de presse] - {{en}} [http://java.sun.com/j2se/1.4.2/docs/relnotes/features.html liste complète des changements]&lt;/ref&gt; sont :
** le mot-clé &lt;code&gt;assert&lt;/code&gt; (Spécifié dans [http://www.jcp.org/en/jsr/detail?id=41 JSR 41].)
** les expressions rationnelles modélisées en s’inspirant du langage Perl.
** Le chaînage d’exception permet à une exception d’encapsuler l’exception de bas niveau d’origine. (Spécifié dans {{en}} [http://www.jcp.org/en/jsr/detail?id=51 JSR 51].)
** API de journalisation (Spécifiée dans [http://www.jcp.org/en/jsr/detail?id=47 {{en}} JSR 47].)
** l’API Image I/O pour lire et écrire des images dans des formats comme JPEG et PNG.
** intégration d’un parser XML et du moteur XSLT nommé JAXP (Spécifié dans {{en}} [http://www.jcp.org/en/jsr/detail?id=5 JSR 5] et {{en}} [http://www.jcp.org/en/jsr/detail?id=63 JSR 63].)
** intégration des extensions de sécurité JCE (Java [[cryptographie|Cryptography]] [[bibliothèque logicielle|Extension]]), [[Java Secure Socket Extension|JSSE]] et [[Java Authentication and Authorization Service|JAAS]].
** [[Java Web Start]] (introduit pour la première fois en {{date||mars|2001|en informatique}} pour J2SE 1.3 - Spécifié dans {{en}} [http://www.jcp.org/en/jsr/detail?id=56 JSR 56].)

* '''J2SE 5.0''' ({{date|30|septembre|2004|en informatique}} - {{formatnum:3270}} classes et interfaces) — Nom de code {{lang|en|''Tiger''}}. (initialement numérotée 1.5, qui est toujours utilisé comme numéro de version interne&lt;ref&gt;{{en}} [http://java.sun.com/j2se/1.5.0/docs/relnotes/version-5.0.html Version 1.5.0 or 5.0?&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;). Développé par [http://www.jcp.org/en/jsr/detail?id=176 {{en}} JSR 176], {{lang|en|''Tiger''}} ajoute un nombre significatif de nouveautés&lt;ref&gt;{{en}} [http://www.sun.com/smi/Press/sunflash/2004-09/sunflash.20040930.1.html communiqué de presse]&lt;/ref&gt; au langage :
** Intégration du composant logiciel [[Java Web Start]] dans l'environnement d'exécution Java (JRE)&lt;ref&gt;[http://www.java.com/fr/download/faq/java_webstart.xml Qu'est-ce que le logiciel Java Web Start]http://www.java.com&lt;/ref&gt;
** Programmation générique — (Spécifié par [http://www.jcp.org/en/jsr/detail?id=14 {{en}} JSR 14])
** [[Annotation (Java)|Metadata]] — également appelées annotations, permet au langage de construire des classes et des méthodes étiquetées avec des données additionnelles qui peuvent être utilisées en tant que méta-données (Spécifiée dans {{en}} [http://www.jcp.org/en/jsr/detail?id=175 JSR 175].)
** Autoboxing/unboxing — conversion automatique entre des types primitifs (comme le type &lt;code&gt;int&lt;/code&gt;) et le Wrapper de classe correspondant (comme la classe Integer) (Spécifié dans {{en}} [http://www.jcp.org/en/jsr/detail?id=201 JSR 201]).
** Énumérations&lt;!-- ou alors en anglais sans aucun accent ? --&gt; — le mot-clé &lt;code&gt;enum&lt;/code&gt; permet de créer une liste ordonnée de valeurs en gardant la [[sûreté du typage]]. Auparavant, ceci pouvait seulement être réalisé par des entiers constants (Spécifié dans JSR 201).
** Varargs — la syntaxe &lt;code&gt;Object...&lt;/code&gt; utilisée dans une déclaration de méthode permet de spécifier un nombre variable d’arguments pour cette méthode. C’est un fonctionnement équivalent à la fonction « printf » en C.
** Imports statiques — Cette fonctionnalité permet d’utiliser les constantes d’une classe sans spécifier le nom de cette classe et sans passer par « l’{{lang|en|''anti-pattern Constant Interface''}} » (c’est l’expression utilisée sur le site de Sun).
** Extension du &lt;code&gt;for&lt;/code&gt; pour les boucles — la syntaxe du &lt;code&gt;for&lt;/code&gt; est étendue avec une syntaxe spéciale pour itérer sur n’importe quel objet itérable comme un tableau, ou une collection en utilisant la syntaxe :
&lt;source lang=&quot;java5&quot;&gt;
        void displayWidgets (Iterable&lt;Widget&gt; widgets) {
            for (Widget w : widgets) {
                w.display();
            }
        }
&lt;/source&gt;
:::''Cet exemple parcourt le contenu de l’objet widgets de la classe Iterable et contenant uniquement des références vers des objets de la classe Widget, assignant chacun de ces éléments à la variable w et ensuite appelle la méthode display() sur l’élément w (spécifié dans JSR 201)''.
::En plus des changements au niveau du langage, des changements plus importants ont eu lieu au fil des années qui ont conduit des quelques centaines de classes dans le JDK 1.0 à plus de {{formatnum:3000}} dans J2SE 5.0. Des API entières, comme Swing ou Java2D ont été ajoutées et beaucoup de méthodes de l’original JDK 1.0 ont été déclarées {{lang|en|''deprecated''}} (c’est-à-dire déconseillées, elles pourraient être supprimées dans une version ultérieure de Java).

* '''Java SE 6''' ({{date|11|décembre|2006|en informatique}} - {{formatnum:3777}} classes et interfaces dans plus de 20 paquetages) — Nom de code [https://mustang.dev.java.net/ ''Mustang'']&lt;ref&gt;{{en}} [http://www.jcp.org/en/jsr/detail?id=270 JSR 270]&lt;/ref&gt;. Une version bêta est sortie le 15 février 2006, une autre bêta en juin 2006, une version « {{lang|en|''release candidate''}} » en novembre 2006, et la version finale le 12 décembre 2006. Avec cette version, Sun remplace définitivement le nom J2SE par Java SE et supprime le .0 au numéro de version&lt;ref&gt;{{en}} [http://www.java.com/en/about/brand/naming.jsp Java Naming&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;.
:Cette version aura été l'objet de nombreuses failles de sécurité et leurs mises à jour correctives, conduisant à la version 1.6.0_45 par Oracle et même 1.6.0_51 pour sa version Mac OS. C'est d'ailleurs là la dernière version de Java fonctionnant pour Mac OS X 10.6 et antérieurs.
* '''Java SE 7''' ({{date|7|juillet|2011|en informatique}}) - {{formatnum:8000}}&lt;ref&gt;http://docs.oracle.com/javase/7/docs/api&lt;/ref&gt; classes et interfaces) — Nom de code {{lang|en|''Dolphin''}}. Il s’agit de la première version sous la licence [[Licence publique générale GNU|GPL]].
:Dés l'update 6 (7u6), l'édition standard Oracle de Java supportant de nouveau pleinement Mac OS X&lt;ref&gt;[http://www.lemondeinformatique.fr/actualites/lire-oracle-met-a-jour-java-se-et-javafx-pour-os-x-arm-et-linux-50072.html Oracle met à jour Java SE et JavaFX pour OS X, ARM et Linux]Le Monde Informatique&lt;/ref&gt;, les mises à jour pour cet OS ne sont plus prises en charge par Apple mais par Oracle. Toutefois cette version de Java n'est pas supportée par [[Mac OS X v10.6]] : En effet certaines API requises par Java 7 ont bien été incluses par Apple dans Mac OS X 10.7.3, mais il n'est pas prévu qu'elles soient implémentées sur les précédentes versions de Mac OS&lt;ref&gt;[http://www.java.com/fr/download/faq/java_mac.xml#java%20available Informations et configuration minimale requise pour l'installation et l'utilisation de Java 7 pour Mac]http://www.java.com&lt;/ref&gt;.
:La version la plus récente en mars 2014 est la 1.7.0_51.

* '''Java SE 8''' - Une des nouveautés majeures de cette version sera l’ajout des [[Fermeture (informatique)|{{lang|en|''closures''}}]] (en cours de spécifications)&lt;ref&gt;[http://www.infoq.com/fr/news/2013/09/everything-about-java-8 Everything about Java 8]&lt;/ref&gt;. Début mai 2013 Oracle produit une roadmap présentant sa sortie pour le 18 mars 2014&lt;ref&gt;[http://openjdk.java.net/projects/jdk8 JDK8 Schedule and status]OpenJDK&lt;/ref&gt;, des releases en cours de développement du JDK sont disponibles au téléchargement dés l'automne 2013&lt;ref&gt;[https://jdk8.java.net/download.html JDK™ 8 Early Access Releases]java.net&lt;/ref&gt;.
:La modularisation de la JVM avec le projet [[Jigsaw (serveur)|Jigsaw]], initialement prévue pour cette version, est quant à elle reportée à la version 9&lt;ref&gt;[http://www.lemondeinformatique.fr/actualites/lire-oracle-reporte-le-projet-jigsaw-systeme-de-modules-pour-java-49797.html&lt;!-- Titre généré automatiquement --&gt;]&lt;/ref&gt;, du fait notamment des failles de sécurité rencontrées par Java 6 dont Oracle a privilégié la correction par rapport aux évolutions de Java.
* '''Java SE 9''', initialement prévu pour 2015, a été reporté à 2016 suite aux retards de développement de Java 8&lt;ref&gt;[http://www.developpez.com/actu/61155/Java-Oracle-publie-la-Developer-Preview-du-JDK-8-dont-la-principale-caracteristique-est-le-support-du-projet-Lambda Java : Oracle publie la Developer Preview du JDK 8] www.developpez.com - 10/09/2013&lt;/ref&gt;; ceux-ci ont déjà conduit au report dans Java 9 du projet [[Jigsaw]], qui devait initialement améliorer la modularité de Java 8.

== Philosophie ==
Lors de la création du langage Java, il avait été décidé que ce langage devait répondre à cinq objectifs&lt;ref&gt;{{en}} [http://java.sun.com/docs/white/langenv/Intro.doc2.html Design Goals of the Java Programming Language]&lt;/ref&gt; :
# &lt;!-- Simple, Object Oriented, and Familiar --&gt; simple, orienté objet et familier ;
# &lt;!-- Robust and Secure --&gt; robuste et sûr ;
# &lt;!-- Architecture Neutral and Portable --&gt; indépendant de la machine employée pour l'exécution ;
# &lt;!-- High Performance --&gt; très performant ;
# &lt;!-- Interpreted, Threaded, and Dynamic --&gt; interprété, multi-tâches et dynamique.
&lt;!-- 
# pouvoir utiliser de manière native les réseaux informatiques ;
# pouvoir exécuter du code distant de manière sûre ;
# être facile à utiliser et posséder les points forts des langages de programmation orientés objet comme le C++.
--&gt;

=== Un langage orienté objet et familier ===
{{Article connexe|Programmation orientée objet}}
La première caractéristique, le caractère orienté objet (« OO ») et familier, fait référence à une méthode de programmation et de conception du langage et le fait qu'un programme écrit en Java ressemble assez fort à un programme écrit en [[C plus plus|C++]].

Bien qu’il existe plusieurs interprétations de l’expression '''orienté objet''', une idée phare dans ce type de développement est que les différents types de données doivent être directement associés avec les différentes opérations qu’on peut effectuer sur ces données. En conséquence, les données (appelées ''Propriétés'') et le code les manipulant (appelé ''Méthodes'') sont combinés dans une même entité appelée ''Classe'' d'objet. &lt;!-- Un objet peut être vu comme une entité unique regroupant un '''comportement''', le code, avec un certain '''état''', les données. Le principe est de séparer les choses qui changent de celles qui ne changent pas ; souvent un changement au niveau d’une structure de données va impliquer un changement dans le code servant à manipuler ces données et réciproquement. Ce découpage en entités cohérentes appelées objets permet d’avoir des fondations plus solides pour bâtir une architecture logicielle de qualité. L’objectif est de pouvoir développer des projets plus simples à gérer et de réduire le nombre de projets aboutissant à un échec. --&gt; Le code devient logiquement découpé en petites entités cohérentes et devient ainsi plus simple à maintenir et plus facilement réutilisable, étant intrinsèquement modulaire.

D’autres mécanismes tels l’''héritage'' permettent d’exploiter toutes les caractéristiques d’une ''Classe'' précédemment écrite dans ses propres programmes sans même avoir à en connaître le fonctionnement interne, on n’en voit que l’''interface'' (l'interface décrit les propriétés et les méthodes sans fournir le code associé). Java interdit la notion d'héritage depuis plusieurs classes parent sauf si elles sont des interfaces.

Dans la version 1.5 du langage ont été rajoutés les ''génériques'', un mécanisme de [[Polymorphisme (informatique)|polymorphisme]] semblable (mais différent) aux {{lang|en|''templates''}} du langage [[C plus plus|C++]] ou aux foncteurs d’[[OCaml]]. Les génériques permettent d’exprimer d’une façon plus simple et plus sûre les propriétés d’objets comme des conteneurs (listes, arbres…) : le type liste est alors considéré génériquement par rapport au type d’objet contenu dans la liste.

=== Mécanisme du ramasse-miettes ===
{{Article connexe|Ramasse-miettes (informatique){{!}}Ramasse-miettes en informatique}}
Cet élément contribue à la robustesse et à la performance des programmes, le ramasse-miettes ({{lang|en|''Garbage Collector''}}) est appelé régulièrement et automatiquement pendant l'exécution du programme. Sur les systèmes [[multi-processeurs]] et/ou [[Microprocesseur multi cœur|multi-cœurs]] celui-ci emploie même des [[Processus léger|threads]] multiples à faible priorité afin de perturber le moins possible l'exécution de programme&lt;ref name=&quot;gc&quot;&gt;Voir par exemple les détails du fonctionnement et la description des options ''-XX:+UseParallelGC'' et ''-XX:+UseConcMarkSweepGC'' de la JRE de [[Sun Microsystems|Sun]] {{en}} [http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html Java SE Virtual Machine Garbage Collection Tuning]&lt;/ref&gt;. En outre, le programmeur peut au besoin suggérer &lt;!-- à la machine virtuelle Java --&gt; de lancer le ramasse-miettes à l’aide de la méthode ''System.gc()''.

Un grief récurrent à l’encontre de langages comme C++ est la lourde tâche d’avoir à programmer manuellement la gestion de la mémoire. En C++, la mémoire allouée par le programme pour créer un objet est désallouée lors de la destruction de celui-ci (le plus souvent par un appel explicite à l'opérateur {{lang|en|''delete''}}). Si le programmeur oublie de coder la désallocation, ceci aboutit à une « [[Fuite de mémoire|fuite mémoire]] », et le programme en consomme de plus en plus. Pire encore, si par erreur un programme demande plusieurs fois une désallocation, ou emploie une zone de mémoire après avoir demandé sa désallocation, celui-ci deviendra très probablement instable et se plantera.

En Java, une grande partie de ces problèmes est évitée grâce au [[ramasse-miettes (informatique)|ramasse-miettes]]. L'espace mémoire nécessaire à chaque objet créé est alloué dans un tas de mémoire ({{en en|memory heap}}) réservé à cet usage. Le programme peut ensuite accéder à chaque objet grâce à sa référence dans le tas. Quand il n'existe plus aucune référence permettant d'atteindre un objet, le ramasse-miettes le détruit automatiquement —&amp;nbsp;puisqu'il est devenu inaccessible&amp;nbsp;— libérant la mémoire et prévenant ainsi toute fuite de mémoire.

&lt;!--

Supprimé ce paragraphe : aucun GC moderne ne se laisse berner par un cas aussi simple, il faut plutôt par exemple continuer à réfencer un tableau de X références sans utiliser tous les éléments et sans avoir passé à null les positions inutilisées pour qu'une fuite mémoire existe.

Une grande faiblesse de ce système étant que si deux objets se référencent entre eux sans que le programme les utilise, le ramasse-miettes ne remarque pas que ces objets ne sont plus liés à la fonction principale du programme et ne seront plus utilisés. C'est donc une [[fuite de mémoire]]. Ce problème simpliste est traité par tous les GC modernes (pas uniquement celui de Java) qui implémente des algorithmes de détection de cycles au niveau des références mémoire et par conséquent sont capables de libérer des objets qui se référenceraient mutuellement.

--&gt;
Le ramasse-miettes emploie un algorithme de marquage puis libération {{en en|mark and sweep}}&lt;ref name=&quot;gc&quot;/&gt; qui permet de gérer les cas complexes d'objets se référençant mutuellement ou de boucles de références (cas d'une [[Liste chaînée|liste à chaînage double]] par exemple). En pratique il subsiste des cas d'erreur de programmation où le ramasse-miettes considèrera qu'un objet est encore utile alors que le programme n'y accèdera plus, mais dans l’ensemble, le ramasse-miettes rend plus simple et plus sûre la destruction d’objets en Java (en supprimant la nécessité de placer au bon endroit du code l'appel à l'opérateur {{lang|en|''delete''}}).

=== Indépendance vis-à-vis de la plate-forme ===
{{Article connexe|Bytecode Java|Compilation à la volée}}
L’indépendance vis-à-vis de la plate-forme signifie que les programmes écrits en Java fonctionnent de manière parfaitement similaire sur différentes architectures matérielles. La licence de Sun pour Java insiste ainsi sur le fait que toutes les implémentations doivent être compatibles. On peut ainsi théoriquement effectuer le développement sur une architecture donnée et faire tourner l’application finale sur toutes les autres.

Ce résultat est obtenu par :
* des bibliothèques standard fournies pour pouvoir accéder à certains éléments de la machine hôte (le graphisme, le multithreading, la programmation réseau…) exactement de la même manière sur toutes les architectures. 
* des compilateurs Java qui compilent le code source « à moitié » afin d’obtenir un '''bytecode''' (plus précisément le '''bytecode Java''', un langage de type assembleur, proche de la machine virtuelle et spécifique à la plate-forme Java).
:Ce bytecode a ensuite vocation à être interprété sur une [[machine virtuelle]] Java (JVM en anglais), un programme écrit spécifiquement pour la machine cible qui interprète le [[bytecode]] Java et fait exécuter par la machine les [[Instruction informatique|instructions]] traduites en code natif.

Noter que même s’il y a explicitement une première phase de compilation, le bytecode Java est soit interprété, soit converti à la volée en code natif par un [[Compilation à la volée|compilateur à la volée]] ({{lang|en|''just in time''}}, JIT).
==== Types de compilations ====
Les premières implémentations du langage utilisaient une machine virtuelle interprétée pour obtenir la portabilité. Ces implémentations produisaient des programmes qui s’exécutaient plus lentement que ceux écrits en langage compilé (C, C++, etc.) si bien que le langage souffrit d’une réputation de faibles performances.

Des implémentations plus récentes de la machine virtuelle Java (JVM) produisent des programmes beaucoup plus rapides qu’auparavant, en utilisant différentes techniques:
* La première technique est de compiler directement en code natif comme un compilateur traditionnel, supprimant complètement la phase de bytecode. Des compilateurs Java tels que [[GCJ|GNU Compiler for Java]] (GCJ) compilent ainsi directement le Java en code objet natif pour la machine cible. On obtient ainsi de bonnes performances, mais aux dépens de la portabilité : le code final produit par ces compilateurs ne peut de ce fait être exécuté que sur une seule architecture.
* Une autre technique appelée [[Compilation à la volée|compilation 'juste-à-temps']], ou 'à la volée' ({{lang|en|''just in time''}}, JIT) traduit le byte code en code natif durant la phase de lancement du programme.
* Certaines machines virtuelles plus sophistiquées utilisent une '''recompilation dynamique''' durant laquelle la machine virtuelle analyse le comportement du programme et en recompile sélectivement certaines parties. La recompilation dynamique permet d’obtenir de meilleurs résultats que la compilation statique car les compilateurs dynamiques peuvent optimiser en fonction de leur connaissance de l’environnement cible et des classes qui sont utilisées.
:La compilation JIT et la recompilation dynamique permettent à Java de tirer profit de la rapidité du code natif sans perdre la portabilité.

==== Bilan de la portabilité Java ====
Après que Sun ait constaté que l’implémentation de Microsoft ne supportait pas les interfaces RMI et [[Java Native Interface|JNI]], et comportait des éléments spécifiques à certaines plates-formes par rapport à sa plate-forme initiale, Sun déposa plainte en justice contre Microsoft&lt;ref&gt;[http://www.liberation.fr/economie/0101435135-microsoft-pousse-a-parler-java Microsoft poussé à parler Java]Libération - 26/12/2002&lt;/ref&gt;, et obtint des dommages et intérêt (20&amp;nbsp;millions de dollars). Cet acte de justice renforça encore les termes de la licence de Sun. En réponse, Microsoft arrêta le support de Java sur ses plates-formes et, sur les versions récentes de Windows, Internet Explorer ne supporte pas les applets Java sans ajouter de plug-in. Cependant, Sun met à disposition gratuitement des environnements d’exécution de Java pour les différentes plates-formes Microsoft.

La portabilité est techniquement un objectif difficile à atteindre et le succès de Java en ce domaine est mitigé. Quoiqu’il soit effectivement possible d’écrire des programmes pour la plate-forme Java qui fonctionnent correctement sur beaucoup de machines cibles, le nombre important de plates-formes avec de petites erreurs et des incohérences a abouti à un détournement du slogan de Sun « {{lang|en|''Write once, run anywhere''}} » ({{citation|Écrire une fois, exécuter partout}}) en {{citation|{{lang|en|''Write once, debug everywhere''}}}} ({{citation|Écrire une fois, déboguer partout}}) !

L’indépendance de Java vis-à-vis de la plate-forme est cependant un succès avec les applications côté serveur comme les services web, les servlets et le Java Beans aussi bien que les systèmes embarqués sur OSGi, utilisant l’environnement {{lang|en|'''Embedded Java'''}}.

=== Exécution sécurisée de code distant ===
La plate-forme Java fut l’un des premiers systèmes à offrir le support de l’exécution du code à partir de sources distantes. Une [[applet]] peut fonctionner dans le [[navigateur web]] d’un utilisateur, exécutant du code téléchargé d’un serveur [[Hypertext Transfer Protocol|HTTP]]. Le code d’une applet fonctionne dans un espace très restrictif, ce qui protège l’utilisateur des codes erronés ou mal intentionnés. Cet espace est délimité par un objet appelé ''gestionnaire de sécurité''. Un tel objet existe aussi pour du code local, mais il est alors par défaut inactif.

Le gestionnaire de sécurité (la classe &lt;tt&gt;SecurityManager&lt;/tt&gt;) permet de définir un certain nombre d’autorisations d’utilisation des ressources du système local (système de fichiers, réseau, propriétés système…). Une autorisation définit :
# un code accesseur (typiquement, une applet — éventuellement signée — envoyée depuis un serveur web) ;
# une ressource locale concernée (par exemple un répertoire) ;
# un ensemble de droits (par exemple lire/écrire).

Les éditeurs d’applet peuvent demander un [[certificat électronique|certificat]] pour leur permettre de [[signature numérique|signer numériquement]] une applet comme sûre, leur donnant ainsi potentiellement (moyennant l’autorisation adéquate) la permission de sortir de l’espace restrictif et d’accéder aux ressources du système local.

== Éléments du langage ==
Voici un exemple d’un programme {{lang|en|''[[Hello world]]''}} typique écrit en Java :
&lt;source lang=&quot;java&quot;&gt;
 public class HelloWorld {
     public static void main(String[] args) {
         System.out.println(&quot;Hello world!&quot;);
     }
 }
&lt;/source&gt;

Le fichier source porte presque toujours le nom de la classe avec l'extension &quot;.java&quot; (ici &quot;HelloWorld.java&quot;, ce serait même obligatoire si la classe avait l'attribut '''public''' dans sa déclaration — la rendant alors accessible à tout autre programme). On peut compiler puis exécuter cet exemple avec les commandes suivantes (sous [[Linux]]) :
 javac HelloWorld.java
 export CLASSPATH=.
 java HelloWorld

La ligne « &lt;tt&gt;export CLASSPATH=.&lt;/tt&gt; » sert à indiquer à Java qu’il doit également chercher [[class (format de fichier)|les programmes class]] dans le répertoire courant.
Ce chemin peut également être spécifié au lancement du programme par l’option &lt;tt&gt;-classpath&lt;/tt&gt; (ou &lt;tt&gt;-cp&lt;/tt&gt; en abrégé) :
 java -cp. HelloWorld

=== Mots réservés, primitifs et littéraux ===
&lt;!--
note : le placement des mots clefs est spécialement choisi pour que &lt;code&gt; les traite convenablement, en particulier
&quot;import&quot; change l'aspect du reste de sa ligne
--&gt;
&lt;source lang=&quot;java&quot;&gt;
abstract else instanceof static try boolean false
assert (1.4) enum (5.0) interface strictfp (1.2) volatile byte true
break extends native super while char
case final new switch double
catch finally package synchronized float
class for private this int
const (*) goto (*) protected throw long
continue if public throws short
default implements return transient void null
do import
&lt;/source&gt;
Notes :
* (*) ces mots clefs sont réservés mais n'ont pas de signification pour le compilateur (il est juste interdit d'employer ce nom pour une variable par exemple) ;
* (1.2), (1.4) et (5.0) ces mots clefs ont été ajoutés avec la version indiquée du langage.

&lt;small&gt;([http://download.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html source])&lt;/small&gt;

=== Types ===

{| class=&quot;wikitable&quot;
|-
! Nom !! Taille en octets lors des calculs !! Valeur par défaut
|-
| boolean || Un seul bit suffit, mais on réserve souvent un octet pour les stocker. || false
|-
| byte || 1 || 0x00
|-
| short || 2 || 0x0000
|-
| int || 4 || 0
|-
| long || 8 || 0l
|-
| char || 2 || 'x0000'
|-
| float || 4 || 0f
|-
| double || 8 || 0.0
|-
| Object || Dépendant de la machine virtuelle || &lt;code&gt;null&lt;/code&gt;
|}

Pour instancier une variable, la syntaxe (ici la même qu'en C) est la suivante :

&lt;source lang=&quot;java&quot;&gt;
NomDuType maVariable;
&lt;/source&gt;

''maVariable'' est alors allouée sur la pile.

==== Les collections d'objets ====

Il est souvent nécessaire de stocker de nombreuses données dans des collections : liste d’achats, notes des élèves, etc.
Les collections peuvent être consultées, modifiées, on peut les trier, les recopier, les supprimer etc. Elles peuvent avoir une taille fixe ou variable.&lt;br /&gt;
Les collections à taille fixe sont moins lourdes que les collections à taille variable.

===== Collections de taille fixe =====

* Les tableaux :
:Comme en C, les indices d'un tableau de taille '''n''' vont de 0 à n-1. Un des plus grands avantages des tableaux est l’accès en temps constant O(1), à chaque case du tableau.
:Les tableaux sont des objets en Java. Pour initialiser un tableau &lt;code&gt;tab&lt;/code&gt; d’entiers de 10 cases, on peut écrire (entre autres) :
&lt;source lang=&quot;java&quot;&gt;
int[] tab = new int[10];
&lt;/source&gt;
: ou :
&lt;source lang=&quot;java&quot;&gt;
int tab[] = new int[10];
&lt;/source&gt;
: ou :
&lt;source lang=&quot;java&quot;&gt;
int tab[] = {0, 0, 0, 0, 0,
    0, 0, 0, 0, 0};
&lt;/source&gt;
:Les indices de &lt;code&gt;tab&lt;/code&gt; vont de 0 à 9, et il ne pourra pas être redimensionné.
:Chaque élément de &lt;code&gt;tab&lt;/code&gt; est initialisé à sa valeur par défaut, ici 0 car il s'agit d'un tableau d'entiers (&lt;code&gt;int&lt;/code&gt;). La valeur par défaut d'un objet est &lt;code&gt;null&lt;/code&gt;, celle d'un booléen est &lt;code&gt;false&lt;/code&gt;.

:Pour lire ou modifier l'élément de &lt;code&gt;tab&lt;/code&gt; d'indice '''i''', pour 0 ≤ i ≤ 9, on utilise ''tab[i]''.
::Exemple : Pour attribuer la valeur 2 à une case de &lt;code&gt;tab&lt;/code&gt;, on écrit : &lt;code&gt;tab[i] = 2;&lt;/code&gt;

:La propriété '''length''' (exemple : &lt;code&gt;tab.length&lt;/code&gt;) fournit le nombre d'éléments du tableau. Si on essaie de modifier un élément qui n’existe pas, par exemple avec &lt;code&gt;tab [10] = 4;&lt;/code&gt;, une exception ''IndexOutOfBoundsException'' est déclenchée (notre tableau &lt;code&gt;tab&lt;/code&gt; ne contient que 10 cases, numérotées de 0 à 9 inclus).

===== Collections de taille variable =====
La classe abstraite &lt;code&gt;AbstractList&lt;/code&gt; est fournie pour implémenter les collections à taille variable.

* ArrayList :
:Pour initialiser une ArrayList il faut importer la classe &lt;code&gt;java.util.ArrayList&lt;/code&gt; et écrire &lt;code&gt;liste = new ArrayList();&lt;/code&gt;
:Depuis le JDK 1.5, on a la possibilité d’indiquer le type des éléments contenus dans une ArrayList : Entiers, chaînes de caractères ou autres objets.
:* Cette collection est vide après l’appel du constructeur ;
:* On peut ajouter autant d’éléments que l’on veut.
:Pour ajouter un élément on écrit &lt;code&gt;liste.add(Objet);&lt;/code&gt;
:Pour accéder à un élément de l’ArrayList : &lt;code&gt;liste.get(index);&lt;/code&gt;
:Pour connaître le nombre d’éléments que contient une liste : &lt;code&gt;liste.size();&lt;/code&gt;
:Pour supprimer un élément : &lt;code&gt;liste.remove(index);&lt;/code&gt; les éléments qui suivent l’élément supprimé seront décalés à gauche.

=== Structures de contrôle ===
==== Boucles ====
Bien qu’elles aient toutes un rôle similaire, chaque boucle est pourtant adaptée à une situation :

* Structure '''tant que''' (adaptée pour effectuer des opérations tant qu’une condition est remplie) :

&lt;source lang=&quot;java&quot;&gt;
 while (&lt;expression booléenne&gt;) {
 	instruction(s)
 }
&lt;/source&gt;

* Structure '''faire … tant que''' (comme la structure '''tant que''' mais la première itération est exécutée quelle que soit la condition, pour les autres itérations la condition doit être remplie) :

&lt;source lang=&quot;java&quot;&gt;
 do {
    instruction(s)
 }
 while (&lt;expression booléenne&gt;);
&lt;/source&gt;

* Structure '''pour''' (adaptée lorsqu'une collection doit être parcourue en totalité pour traitement) :
&lt;source lang=&quot;java&quot;&gt;
 for (&lt;initialisation&gt; ; &lt;condition de poursuite&gt; ; &lt;expression d’incrémentation&gt;) {
    instruction(s)
 }
&lt;/source&gt;

* Structure '''pour chaque''' (simplification du for en for each, dans laquelle l'expression doit être un tableau ou une collection) :

&lt;source lang=&quot;java&quot;&gt;
 for (type variable : &lt;expression&gt;) {
    instruction(s)
 }
&lt;/source&gt;

* Structure '''pour''' (Java 1.5) :
&lt;source lang=&quot;java&quot;&gt;
 for (&lt;Objet récupérant l’occurrence suivante de la collection&gt; : &lt;collection d’objets&gt;) {
    instruction(s)
 }
&lt;/source&gt;

==== Structures conditionnelles ====
* Structure '''si''' : condition simple
&lt;source lang=&quot;java&quot;&gt;
 if (&lt;expression booléenne&gt;) {
    instruction(s)
 }
&lt;/source&gt;

* Structure '''si … sinon''' : condition avec alternative unique
&lt;source lang=&quot;java&quot;&gt;
 if (&lt;expression booléenne&gt;) {
     instruction(s)
 }
 else {
     instruction(s)
 }
&lt;/source&gt;

* Structure '''si … ou si … ou si …''' : condition avec alternatives multiples
&lt;source lang=&quot;java&quot;&gt;
 if (&lt;expression booléenne&gt;) {
     instruction(s)
 }
 else if (&lt;expression booléenne&gt;) {
     instruction(s)
 }
 else if (&lt;expression booléenne&gt;) {
     instruction(s)
 }
 else {
     instruction(s)
 }
&lt;/source&gt;

* Structure '''atteindre … cas x … cas y …''' : embranchement vers un bloc d’instructions énuméré.
&lt;source lang=&quot;java&quot;&gt;
 switch (&lt;expression de type numérique&gt;) {
    case &lt;constante de type numérique&gt;:
         instruction(s)
         break;
    case &lt;constante de type numérique&gt;:
        instruction(s)
        break;
    [...]
    default:
         instruction(s)
         break;
 }
&lt;/source&gt;

Remarques : Java permet également d'utiliser la structure de contrôle &lt;tt&gt;switch&lt;/tt&gt; sur une énumération ; par ailleurs le &lt;tt&gt;switch&lt;/tt&gt; ne fonctionne pas sur toutes les constantes de type numérique mais seulement sur les entiers.&lt;br /&gt;
Switch fonctionne également avec des variables de type char.

La commande &lt;tt&gt;break&lt;/tt&gt; sort immédiatement la boucle en cours (&lt;tt&gt;for&lt;/tt&gt;, &lt;tt&gt;while&lt;/tt&gt;, &lt;tt&gt;do&lt;/tt&gt;), et permet de sortir d’une clause contenue dans un &lt;tt&gt;switch&lt;/tt&gt;. Si le break est omis, l'exécution du switch se poursuit de case en case.

Une expression continue termine l’itération en cours et continue à la prochaine. Elle s’écrit comme suit : &lt;tt&gt;continue&lt;/tt&gt;, mais son usage est à proscrire puisqu'elle tend à favoriser un type de programmation non structurée (programmation spaghetti).

L’énoncé &lt;tt&gt;return&lt;/tt&gt; termine une méthode.

Avec &lt;tt&gt;return uneValeur&lt;/tt&gt;, uneValeur sera renvoyée à la méthode appelante.

Opérateur ternaire &lt;tt&gt;? :&lt;/tt&gt; : Instruction conditionnelle pouvant être employée comme une expression
&lt;source lang=&quot;java&quot;&gt;
 &lt;expression booléenne&gt; ? &lt;valeur si vrai&gt; : &lt;valeur si faux&gt;
&lt;/source&gt;

==== Traitement des exceptions ====
&lt;source lang=&quot;java&quot;&gt;
 try {
       instruction(s)
 }
 catch (&lt;type exception&gt; &lt;variable&gt;) {
       instruction(s)
 } 
 [...]
 finally {
       instruction(s)
 }
&lt;/source&gt;

Le bloc de code '''finally''' sera exécuté quel que soit le résultat lorsque le programme sortira du bloc '''try-catch'''.

Voici un exemple de capture d’une exception :
&lt;source lang=&quot;java&quot;&gt;
  
 FileOutputStream fos = null; 
 
 try {
      //Chacune de ces deux instructions peut générer une exception
      // création d'un flux pour écrire dans un fichier
      fos = new FileOutputStream(...);
      // écriture de données dans ce flux
      fos.write(...);
 }
 catch (IOException e) {
      //Gestion de l'erreur de création ou d'écriture dans le flux
      e.printStackTrace();
 }
 finally{
     //Cette section de code est toujours exécutée, qu’il y ait une exception ou pas
     // fermeture du flux s'il a été ouvert
     if(fos != null) fos.close();
 }
&lt;/source&gt;

Cet exemple permet d’illustrer le mécanisme des exceptions en Java. Dans le cas d’une erreur d’entrée/sortie dans le bloc '''try''', l’exécution reprend dans le bloc '''catch''' correspondant à cette situation (exception de type '''IOException''').

Dans ce bloc '''catch''', la variable '''e''' référence l’exception qui s’est produite. Ici, nous invoquons la méthode '''printStackTrace()''' qui affiche dans la console des informations sur l’exception qui s’est produite : nom, motif, état de la pile d’appels au moment de la levée de l’exception et, éventuellement, numéro de ligne auquel l’erreur s’est produite.

Le bloc '''finally''' est ensuite exécuté (ici pour refermer les ressources utilisées). Il ne s’agit ici que d’un exemple, l’action à mettre en œuvre lorsqu’une exception survient dépend du fonctionnement général de l’application et de la nature de l’exception.

==== Types génériques ====
Un type générique est autrement appelé un Template, il prend un ou plusieurs autres types en arguments.
Le type passé en paramètre est déterminé lors de l'instanciation.

Cela permet notamment dans le cadre des ArrayList d'éviter les transtypages

&lt;source lang=&quot;java&quot;&gt;
 public class ArrayList&lt;E&gt; {
    ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;();
 }
&lt;/source&gt;

Ces types génériques ne sont utilisés qu'à la compilation, et non directement dans le bytecode.

Différence avec le C++ : les templates en C++ dupliquent une classe pour chaque type. Java, au contraire, agit au moment de la compilation comme si on avait dupliqué les classes de ces types intrinsèques mais ne traite en réalité qu'avec une seule classe.

==== Codage du code source ====
Les spécifications du langage Java précisent qu’il est formé de caractères au format [[UTF-16]], ce qui permet l’utilisation dans le code source de tous les caractères existant dans le monde :

&lt;!-- Java语言严格区分[[字节]]和[[字符]]。字符的存储格式为[[UCS-2]]，从Java 5开始支持[[UTF-16]]字符。Java的程序遂可以使用[[Unicode]]字符进行书 -
下面就是一个合法的Java程序，里面包含了[[中文]]字符作为类的名称而不是字符串，这个程序可以在编译器中运行通过。
--&gt;
&lt;source lang=&quot;java&quot;&gt;
 public class HelloWorld {
    private String text = &quot;hello world&quot;;
 }
&lt;/source&gt;

Pour assurer la portabilité entre plates-formes, les noms de [[Classe (informatique)|classes]] devraient néanmoins être formés uniquement de caractères [[ASCII]].

== Environnements de développement ==
=== JavaStyle ===
Les JavaStyle sont des conventions de programmation en langage Java définies par Sun. Le respect de conventions strictes assure une homogénéité dans le [[code source]] d’une application développée par toute une équipe et favorise la diffusion du code source auprès d’une communauté partageant les mêmes conventions de codage.
On peut noter l'utilisation de [[CamelCase|lowerCamelCase]] pour les noms de méthodes et de variables.

Cf. [http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html Les conventions de nommage édictées par Oracle]
=== Frameworks et API ===
Sun fournit un grand nombre de {{lang|en|''[[framework]]s''}} et d’[[Application programming interface|API]] afin de permettre l’utilisation de Java pour des usages très diversifiés.
On distingue essentiellement 4 grands {{lang|en|''frameworks''}} :
* [[Java SE]] (anciennement J2SE) : Ce {{lang|en|''framework''}} est destiné aux applications pour poste de travail.
* [[Java EE]] (anciennement J2EE) : Ce {{lang|en|''framework''}} est spécialisé dans les applications serveurs. Il contient pour ce faire un grand nombre d’API et d’extensions.
* [[Java ME]] (anciennement J2ME) : Ce {{lang|en|''framework''}} est spécialisé dans les applications mobiles.
* [[Java FX]] (à ne pas confondre avec [[JavaFX]]) : Ce {{lang|en|''framework''}} est spécialisé dans les applications liées aux cartes à puces et autres SmartCards. Il recouvre notamment l'ancien [[Java Card]]

La persistance est basée sur les standards :
* [[JDBC]] ({{lang|en|''Java DataBase Connectivity''}})
* [[JDO]] ({{lang|en|''Java Data Objects''}})
* [[EJB]] ({{lang|en|''Enterprise Java Beans''}})

On trouve toutefois de nombreuses autres technologies, API et extensions optionnelles pour Java :
* {{Lien|fr=Java Media Framework|lang=en}} : [[framework multimédia]], contenant notamment les API Java2D, [[Java3D]], [[JavaSound]], [[Java advanced Imaging]]
* {{Lien|fr=Java Telephony API|lang=en}}
* {{Lien|fr=Java TV|lang=en}}
* [[JXTA]] : Système de [[peer-to-peer]] reposant sur Java
* [[Jini]]
* [[JAIN]]
* {{Lien|fr=Java Dynamic Management Kit|lang=en}} (JMDK)
* [[JavaSpeech]]
* [[JMI]]
* [[JavaSpaces]]

=== Outils de développement ===
La programmation peut se faire depuis une [[Interface en ligne de commande|invite de commande]] en lançant un compilateur Java (souvent nommé &lt;tt&gt;javac&lt;/tt&gt;), mais pour avoir plus de confort, il est préférable d’utiliser un [[environnement de développement intégré]] ou IDE, certains sont gratuits.
On peut citer :
* [[BlueJ]]
* [[CodeWarrior]]
* [[Eclipse (environnement de développement)|Eclipse]] 
* [[IntelliJ IDEA]]
* [[JBuilder]]
* [[JCreator]]
* [[jDeveloper]]
* [[NetBeans]]
* [[Xcode]]

==== Automatisation ====
Un programme Java peut être produit avec des outils qui automatisent le processus de construction (c'est-à-dire l'automatisation de certaines tâches faisant appel à un nombre potentiellement grand de dépendances comme l'utilisation de bibliothèques, la compilation, la génération d'archives, de documentation, le déploiement, etc.).
Les plus utilisés sont :
* [[Apache Ant]] (génération portable, décrite en XML) ;
* [[Apache Maven]] (génération portable, décrite en XML) ;
* [[Gradle]] (génération portable, en utilisant le langage [[Groovy (langage)|Groovy]]) ;
* [[SCons]] (génération portable de Java/C/C++). Exemple :
&lt;pre&gt;Java(target = 'classes', source = 'src')
      Jar(target = 'test.jar', source = 'classes')
&lt;/pre&gt;
Résultats :
      % scons -Q
      javac -d classes -sourcepath src src/Exemple1.java src/Exemple2.java src/Exemple3.java
      jar cf test.jar classes

== Notes et références ==
{{Références}}

== Voir aussi ==
{{Autres projets 
  | wiktionary = Java
  | wikibooks = Java
  | wikiversity = Java
  | wikidata = Q251
}}
=== Articles connexes ===
* [[Plate-forme Java]]
* [[Machine virtuelle Java]]
* [[Bytecode Java]]
* [[Java et logiciel libre]]
* [[Servlet]]
* Navigateur [[HotJava]]
* [[GNU Compiler Collection]] (inclut un compilateur de code Java vers code natif, [[GCJ]])
* [[.properties]], manière de stocker les variables de configuration
* [[Processing]]

=== Liens externes ===
* {{fr}} http://www.java.com/fr/ : Site officiel pour les utilisateurs
* {{en}} http://docs.oracle.com/javase/1.5.0/docs : Schéma de l'architecture logicielle de Java
* {{fr}} http://java.developpez.com/ : Communauté de développeurs Java
* {{fr}} http://news.humancoders.com/t/java : Actualité pour développeurs Java
* {{en}} http://www.java.net : Site collaboratif officiel avec un [[wiki]]
* {{en}} http://en.wikipedia.org/wiki/Java_version_history : Détail de l'historique des versions de Java
* {{fr}} {{dmoz|Java|http://www.dmoz.org/World/Français/Informatique/Programmation/Langages/Java/}}
&lt;!-- ATTENTION : Dans le but de limiter les liens externes puisque wikipédia n’a pas vocation à être un annuaire, les liens externes sont limités aux catégories équivalentes de DMOZ qui est un annuaire régi par un même esprit que celui de wikipédia et où vous êtes invités à enregistrer votre site - cf. www.dmoz.org - plutôt que de l’ajouter ici --&gt;

=== Bibliographie ===
* Ken Arnold, James Gosling et David Holmes, ''Le Langage Java'', 2001 {{ISBN|978-2-7117-8671-8}}
* {{en}} [[Bruce Eckel]], {{lang|en|''Thinking in Java''}}, Prentice-Hall, 2002 {{ISBN|978-0-13-100287-6}}. [http://www.mindviewinc.com/downloads/TIJ-3rd-edition4.0.zip version téléchargeable] [ftp://ftp.irisa.fr/pub/mirrors/Java/index.html version électronique en ligne] [http://penserenjava.free.fr/ traduction francophone : penser en java]
* Alexandre Brillant, ''Java 5'', 2006 {{ISBN|978-2-7460-3170-8}}
* Jean Brondeau, ''Introduction à la programmation objet en Java'', Dunod, Paris, 1999 {{ISBN|978-2-10-004106-0}}
* Annick Fron, ''Architectures réparties en Java'', 2007 {{ISBN|978-2-10-051141-9}}

{{Palette|Java (Oracle)|Langages de programmation}}
{{Portail|programmation informatique}}

[[Catégorie:Langage de programmation]]
[[Catégorie:Langage orienté objet]]
[[Catégorie:Java|*]]
[[Catégorie:Plateforme Java]]

{{Lien AdQ|ml}}
{{Lien BA|zh}}</text>
      <sha1>lvtq36bl82de4288mbmatciydehd7kc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Sizeof</title>
    <ns>0</ns>
    <id>7703217</id>
    <revision>
      <id>101229175</id>
      <parentid>100486191</parentid>
      <timestamp>2014-02-13T19:05:24Z</timestamp>
      <contributor>
        <username>SniperMaské</username>
        <id>285394</id>
      </contributor>
      <minor/>
      <comment>wikif. (REM. : d. c. mais p.-ê. pas art.)</comment>
      <text xml:space="preserve" bytes="970">{{ébauche|informatique}}
Dans les langages de programmation [[C_(langage)|C]] et [[C++]], l'[[Opération unaire|opérateur unaire]] '''sizeof''' sert à calculer la taille de n'importe quel [[Type (informatique)|type]] de données, mesurée en nombre d'[[octet]]s nécessaires pour stocker le type. Un [[octet]] dans ce contexte est de même taille qu'un « unsigned char », et peut faire plus de [[8 bits]], bien que ce soit rare.

Le résultat de sizeof est la taille du type de l'expression de son opérande (qui peut également être un nom de variable ou un spécificateur de type), et est de type entier non signé (généralement « size_t »). L'opérateur sizeof peut être appliqué à tout type de données (y compris les types primitifs comme les entiers ou les types à [[virgule flottante]]), des types de pointeurs ou des types de données composés (unions, structures ou classes C++).

{{Portail|informatique}}

[[Catégorie:Langage de programmation]]</text>
      <sha1>2ro9f4kh5umaiuhujdvnr2kz54i1k9f</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
</mediawiki>
